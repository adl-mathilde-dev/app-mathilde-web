true&&(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
}());

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var jsxRuntime = {exports: {}};

var reactJsxRuntime_production_min = {};

var react = {exports: {}};

var react_production_min = {};

/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$2=Symbol.for("react.element"),n$2=Symbol.for("react.portal"),p$4=Symbol.for("react.fragment"),q$3=Symbol.for("react.strict_mode"),r$1=Symbol.for("react.profiler"),t$1=Symbol.for("react.provider"),u=Symbol.for("react.context"),v$3=Symbol.for("react.forward_ref"),w$2=Symbol.for("react.suspense"),x$2=Symbol.for("react.memo"),y$2=Symbol.for("react.lazy"),z$3=Symbol.iterator;function A$3(a){if(null===a||"object"!==typeof a)return null;a=z$3&&a[z$3]||a["@@iterator"];return "function"===typeof a?a:null}
var B$2={isMounted:function(){return  false},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},C$2=Object.assign,D$2={};function E$2(a,b,e){this.props=a;this.context=b;this.refs=D$2;this.updater=e||B$2;}E$2.prototype.isReactComponent={};
E$2.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,a,b,"setState");};E$2.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate");};function F$1(){}F$1.prototype=E$2.prototype;function G$2(a,b,e){this.props=a;this.context=b;this.refs=D$2;this.updater=e||B$2;}var H$2=G$2.prototype=new F$1;
H$2.constructor=G$2;C$2(H$2,E$2.prototype);H$2.isPureReactComponent=true;var I$2=Array.isArray,J$1=Object.prototype.hasOwnProperty,K$2={current:null},L$2={key:true,ref:true,__self:true,__source:true};
function M$2(a,b,e){var d,c={},k=null,h=null;if(null!=b)for(d in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(k=""+b.key),b)J$1.call(b,d)&&!L$2.hasOwnProperty(d)&&(c[d]=b[d]);var g=arguments.length-2;if(1===g)c.children=e;else if(1<g){for(var f=Array(g),m=0;m<g;m++)f[m]=arguments[m+2];c.children=f;}if(a&&a.defaultProps)for(d in g=a.defaultProps,g) void 0===c[d]&&(c[d]=g[d]);return {$$typeof:l$2,type:a,key:k,ref:h,props:c,_owner:K$2.current}}
function N$2(a,b){return {$$typeof:l$2,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function O$2(a){return "object"===typeof a&&null!==a&&a.$$typeof===l$2}function escape(a){var b={"=":"=0",":":"=2"};return "$"+a.replace(/[=:]/g,function(a){return b[a]})}var P$2=/\/+/g;function Q$2(a,b){return "object"===typeof a&&null!==a&&null!=a.key?escape(""+a.key):b.toString(36)}
function R$2(a,b,e,d,c){var k=typeof a;if("undefined"===k||"boolean"===k)a=null;var h=false;if(null===a)h=true;else switch(k){case "string":case "number":h=true;break;case "object":switch(a.$$typeof){case l$2:case n$2:h=true;}}if(h)return h=a,c=c(h),a=""===d?"."+Q$2(h,0):d,I$2(c)?(e="",null!=a&&(e=a.replace(P$2,"$&/")+"/"),R$2(c,b,e,"",function(a){return a})):null!=c&&(O$2(c)&&(c=N$2(c,e+(!c.key||h&&h.key===c.key?"":(""+c.key).replace(P$2,"$&/")+"/")+a)),b.push(c)),1;h=0;d=""===d?".":d+":";if(I$2(a))for(var g=0;g<a.length;g++){k=
a[g];var f=d+Q$2(k,g);h+=R$2(k,b,e,f,c);}else if(f=A$3(a),"function"===typeof f)for(a=f.call(a),g=0;!(k=a.next()).done;)k=k.value,f=d+Q$2(k,g++),h+=R$2(k,b,e,f,c);else if("object"===k)throw b=String(a),Error("Objects are not valid as a React child (found: "+("[object Object]"===b?"object with keys {"+Object.keys(a).join(", ")+"}":b)+"). If you meant to render a collection of children, use an array instead.");return h}
function S$1(a,b,e){if(null==a)return a;var d=[],c=0;R$2(a,d,"","",function(a){return b.call(e,a,c++)});return d}function T$2(a){if(-1===a._status){var b=a._result;b=b();b.then(function(b){if(0===a._status||-1===a._status)a._status=1,a._result=b;},function(b){if(0===a._status||-1===a._status)a._status=2,a._result=b;});-1===a._status&&(a._status=0,a._result=b);}if(1===a._status)return a._result.default;throw a._result;}
var U$1={current:null},V$3={transition:null},W$1={ReactCurrentDispatcher:U$1,ReactCurrentBatchConfig:V$3,ReactCurrentOwner:K$2};function X$1(){throw Error("act(...) is not supported in production builds of React.");}
react_production_min.Children={map:S$1,forEach:function(a,b,e){S$1(a,function(){b.apply(this,arguments);},e);},count:function(a){var b=0;S$1(a,function(){b++;});return b},toArray:function(a){return S$1(a,function(a){return a})||[]},only:function(a){if(!O$2(a))throw Error("React.Children.only expected to receive a single React element child.");return a}};react_production_min.Component=E$2;react_production_min.Fragment=p$4;react_production_min.Profiler=r$1;react_production_min.PureComponent=G$2;react_production_min.StrictMode=q$3;react_production_min.Suspense=w$2;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=W$1;react_production_min.act=X$1;
react_production_min.cloneElement=function(a,b,e){if(null===a||void 0===a)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+a+".");var d=C$2({},a.props),c=a.key,k=a.ref,h=a._owner;if(null!=b){ void 0!==b.ref&&(k=b.ref,h=K$2.current);void 0!==b.key&&(c=""+b.key);if(a.type&&a.type.defaultProps)var g=a.type.defaultProps;for(f in b)J$1.call(b,f)&&!L$2.hasOwnProperty(f)&&(d[f]=void 0===b[f]&&void 0!==g?g[f]:b[f]);}var f=arguments.length-2;if(1===f)d.children=e;else if(1<f){g=Array(f);
for(var m=0;m<f;m++)g[m]=arguments[m+2];d.children=g;}return {$$typeof:l$2,type:a.type,key:c,ref:k,props:d,_owner:h}};react_production_min.createContext=function(a){a={$$typeof:u,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null};a.Provider={$$typeof:t$1,_context:a};return a.Consumer=a};react_production_min.createElement=M$2;react_production_min.createFactory=function(a){var b=M$2.bind(null,a);b.type=a;return b};react_production_min.createRef=function(){return {current:null}};
react_production_min.forwardRef=function(a){return {$$typeof:v$3,render:a}};react_production_min.isValidElement=O$2;react_production_min.lazy=function(a){return {$$typeof:y$2,_payload:{_status:-1,_result:a},_init:T$2}};react_production_min.memo=function(a,b){return {$$typeof:x$2,type:a,compare:void 0===b?null:b}};react_production_min.startTransition=function(a){var b=V$3.transition;V$3.transition={};try{a();}finally{V$3.transition=b;}};react_production_min.unstable_act=X$1;react_production_min.useCallback=function(a,b){return U$1.current.useCallback(a,b)};react_production_min.useContext=function(a){return U$1.current.useContext(a)};
react_production_min.useDebugValue=function(){};react_production_min.useDeferredValue=function(a){return U$1.current.useDeferredValue(a)};react_production_min.useEffect=function(a,b){return U$1.current.useEffect(a,b)};react_production_min.useId=function(){return U$1.current.useId()};react_production_min.useImperativeHandle=function(a,b,e){return U$1.current.useImperativeHandle(a,b,e)};react_production_min.useInsertionEffect=function(a,b){return U$1.current.useInsertionEffect(a,b)};react_production_min.useLayoutEffect=function(a,b){return U$1.current.useLayoutEffect(a,b)};
react_production_min.useMemo=function(a,b){return U$1.current.useMemo(a,b)};react_production_min.useReducer=function(a,b,e){return U$1.current.useReducer(a,b,e)};react_production_min.useRef=function(a){return U$1.current.useRef(a)};react_production_min.useState=function(a){return U$1.current.useState(a)};react_production_min.useSyncExternalStore=function(a,b,e){return U$1.current.useSyncExternalStore(a,b,e)};react_production_min.useTransition=function(){return U$1.current.useTransition()};react_production_min.version="18.3.1";

{
  react.exports = react_production_min;
}

var reactExports = react.exports;
const React$1 = /*@__PURE__*/getDefaultExportFromCjs(reactExports);

/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$2=reactExports,k$2=Symbol.for("react.element"),l$1=Symbol.for("react.fragment"),m$3=Object.prototype.hasOwnProperty,n$1=f$2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p$3={key:true,ref:true,__self:true,__source:true};
function q$2(c,a,g){var b,d={},e=null,h=null;void 0!==g&&(e=""+g);void 0!==a.key&&(e=""+a.key);void 0!==a.ref&&(h=a.ref);for(b in a)m$3.call(a,b)&&!p$3.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a) void 0===d[b]&&(d[b]=a[b]);return {$$typeof:k$2,type:c,key:e,ref:h,props:d,_owner:n$1.current}}reactJsxRuntime_production_min.Fragment=l$1;reactJsxRuntime_production_min.jsx=q$2;reactJsxRuntime_production_min.jsxs=q$2;

{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}

var jsxRuntimeExports = jsxRuntime.exports;
const _y = /*@__PURE__*/getDefaultExportFromCjs(jsxRuntimeExports);

var client = {};

var reactDom = {exports: {}};

var reactDom_production_min = {};

var scheduler = {exports: {}};

var scheduler_production_min = {};

/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

(function (exports) {
function f(a,b){var c=a.length;a.push(b);a:for(;0<c;){var d=c-1>>>1,e=a[d];if(0<g(e,b))a[d]=b,a[c]=e,c=d;else break a}}function h(a){return 0===a.length?null:a[0]}function k(a){if(0===a.length)return null;var b=a[0],c=a.pop();if(c!==b){a[0]=c;a:for(var d=0,e=a.length,w=e>>>1;d<w;){var m=2*(d+1)-1,C=a[m],n=m+1,x=a[n];if(0>g(C,c))n<e&&0>g(x,C)?(a[d]=x,a[n]=c,d=n):(a[d]=C,a[m]=c,d=m);else if(n<e&&0>g(x,c))a[d]=x,a[n]=c,d=n;else break a}}return b}
	function g(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}if("object"===typeof performance&&"function"===typeof performance.now){var l=performance;exports.unstable_now=function(){return l.now()};}else {var p=Date,q=p.now();exports.unstable_now=function(){return p.now()-q};}var r=[],t=[],u=1,v=null,y=3,z=false,A=false,B=false,D="function"===typeof setTimeout?setTimeout:null,E="function"===typeof clearTimeout?clearTimeout:null,F="undefined"!==typeof setImmediate?setImmediate:null;
	"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function G(a){for(var b=h(t);null!==b;){if(null===b.callback)k(t);else if(b.startTime<=a)k(t),b.sortIndex=b.expirationTime,f(r,b);else break;b=h(t);}}function H(a){B=false;G(a);if(!A)if(null!==h(r))A=true,I(J);else {var b=h(t);null!==b&&K(H,b.startTime-a);}}
	function J(a,b){A=false;B&&(B=false,E(L),L=-1);z=true;var c=y;try{G(b);for(v=h(r);null!==v&&(!(v.expirationTime>b)||a&&!M());){var d=v.callback;if("function"===typeof d){v.callback=null;y=v.priorityLevel;var e=d(v.expirationTime<=b);b=exports.unstable_now();"function"===typeof e?v.callback=e:v===h(r)&&k(r);G(b);}else k(r);v=h(r);}if(null!==v)var w=!0;else {var m=h(t);null!==m&&K(H,m.startTime-b);w=!1;}return w}finally{v=null,y=c,z=false;}}var N=false,O=null,L=-1,P=5,Q=-1;
	function M(){return exports.unstable_now()-Q<P?false:true}function R(){if(null!==O){var a=exports.unstable_now();Q=a;var b=true;try{b=O(!0,a);}finally{b?S():(N=false,O=null);}}else N=false;}var S;if("function"===typeof F)S=function(){F(R);};else if("undefined"!==typeof MessageChannel){var T=new MessageChannel,U=T.port2;T.port1.onmessage=R;S=function(){U.postMessage(null);};}else S=function(){D(R,0);};function I(a){O=a;N||(N=true,S());}function K(a,b){L=D(function(){a(exports.unstable_now());},b);}
	exports.unstable_IdlePriority=5;exports.unstable_ImmediatePriority=1;exports.unstable_LowPriority=4;exports.unstable_NormalPriority=3;exports.unstable_Profiling=null;exports.unstable_UserBlockingPriority=2;exports.unstable_cancelCallback=function(a){a.callback=null;};exports.unstable_continueExecution=function(){A||z||(A=true,I(J));};
	exports.unstable_forceFrameRate=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):P=0<a?Math.floor(1E3/a):5;};exports.unstable_getCurrentPriorityLevel=function(){return y};exports.unstable_getFirstCallbackNode=function(){return h(r)};exports.unstable_next=function(a){switch(y){case 1:case 2:case 3:var b=3;break;default:b=y;}var c=y;y=b;try{return a()}finally{y=c;}};exports.unstable_pauseExecution=function(){};
	exports.unstable_requestPaint=function(){};exports.unstable_runWithPriority=function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3;}var c=y;y=a;try{return b()}finally{y=c;}};
	exports.unstable_scheduleCallback=function(a,b,c){var d=exports.unstable_now();"object"===typeof c&&null!==c?(c=c.delay,c="number"===typeof c&&0<c?d+c:d):c=d;switch(a){case 1:var e=-1;break;case 2:e=250;break;case 5:e=1073741823;break;case 4:e=1E4;break;default:e=5E3;}e=c+e;a={id:u++,callback:b,priorityLevel:a,startTime:c,expirationTime:e,sortIndex:-1};c>d?(a.sortIndex=c,f(t,a),null===h(r)&&a===h(t)&&(B?(E(L),L=-1):B=true,K(H,c-d))):(a.sortIndex=e,f(r,a),A||z||(A=true,I(J)));return a};
	exports.unstable_shouldYield=M;exports.unstable_wrapCallback=function(a){var b=y;return function(){var c=y;y=b;try{return a.apply(this,arguments)}finally{y=c;}}}; 
} (scheduler_production_min));

{
  scheduler.exports = scheduler_production_min;
}

var schedulerExports = scheduler.exports;

/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa$1=reactExports,ca$1=schedulerExports;function p$2(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return "Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var da$1=new Set,ea$1={};function fa$1(a,b){ha$1(a,b);ha$1(a+"Capture",b);}
function ha$1(a,b){ea$1[a]=b;for(a=0;a<b.length;a++)da$1.add(b[a]);}
var ia$1=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),ja$1=Object.prototype.hasOwnProperty,ka$1=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,la$1=
{},ma$1={};function oa$1(a){if(ja$1.call(ma$1,a))return  true;if(ja$1.call(la$1,a))return  false;if(ka$1.test(a))return ma$1[a]=true;la$1[a]=true;return  false}function pa$1(a,b,c,d){if(null!==c&&0===c.type)return  false;switch(typeof b){case "function":case "symbol":return  true;case "boolean":if(d)return  false;if(null!==c)return !c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return "data-"!==a&&"aria-"!==a;default:return  false}}
function qa$1(a,b,c,d){if(null===b||"undefined"===typeof b||pa$1(a,b,c,d))return  true;if(d)return  false;if(null!==c)switch(c.type){case 3:return !b;case 4:return  false===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return  false}function v$2(a,b,c,d,e,f,g){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f;this.removeEmptyString=g;}var z$2={};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){z$2[a]=new v$2(a,0,false,a,null,false,false);});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];z$2[b]=new v$2(b,1,false,a[1],null,false,false);});["contentEditable","draggable","spellCheck","value"].forEach(function(a){z$2[a]=new v$2(a,2,false,a.toLowerCase(),null,false,false);});
["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){z$2[a]=new v$2(a,2,false,a,null,false,false);});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){z$2[a]=new v$2(a,3,false,a.toLowerCase(),null,false,false);});
["checked","multiple","muted","selected"].forEach(function(a){z$2[a]=new v$2(a,3,true,a,null,false,false);});["capture","download"].forEach(function(a){z$2[a]=new v$2(a,4,false,a,null,false,false);});["cols","rows","size","span"].forEach(function(a){z$2[a]=new v$2(a,6,false,a,null,false,false);});["rowSpan","start"].forEach(function(a){z$2[a]=new v$2(a,5,false,a.toLowerCase(),null,false,false);});var ra$1=/[\-:]([a-z])/g;function sa$1(a){return a[1].toUpperCase()}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=a.replace(ra$1,
sa$1);z$2[b]=new v$2(b,1,false,a,null,false,false);});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(ra$1,sa$1);z$2[b]=new v$2(b,1,false,a,"http://www.w3.org/1999/xlink",false,false);});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(ra$1,sa$1);z$2[b]=new v$2(b,1,false,a,"http://www.w3.org/XML/1998/namespace",false,false);});["tabIndex","crossOrigin"].forEach(function(a){z$2[a]=new v$2(a,1,false,a.toLowerCase(),null,false,false);});
z$2.xlinkHref=new v$2("xlinkHref",1,false,"xlink:href","http://www.w3.org/1999/xlink",true,false);["src","href","action","formAction"].forEach(function(a){z$2[a]=new v$2(a,1,false,a.toLowerCase(),null,true,true);});
function ta$1(a,b,c,d){var e=z$2.hasOwnProperty(b)?z$2[b]:null;if(null!==e?0!==e.type:d||!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1])qa$1(b,c,e,d)&&(c=null),d||null===e?oa$1(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?false:"":c:(b=e.attributeName,d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&true===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c)));}
var ua$1=aa$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,va$1=Symbol.for("react.element"),wa$1=Symbol.for("react.portal"),ya$1=Symbol.for("react.fragment"),za$1=Symbol.for("react.strict_mode"),Aa$1=Symbol.for("react.profiler"),Ba$1=Symbol.for("react.provider"),Ca$1=Symbol.for("react.context"),Da$1=Symbol.for("react.forward_ref"),Ea$1=Symbol.for("react.suspense"),Fa$1=Symbol.for("react.suspense_list"),Ga$1=Symbol.for("react.memo"),Ha$1=Symbol.for("react.lazy");var Ia$1=Symbol.for("react.offscreen");var Ja$1=Symbol.iterator;function Ka$1(a){if(null===a||"object"!==typeof a)return null;a=Ja$1&&a[Ja$1]||a["@@iterator"];return "function"===typeof a?a:null}var A$2=Object.assign,La$1;function Ma$1(a){if(void 0===La$1)try{throw Error();}catch(c){var b=c.stack.trim().match(/\n( *(at )?)/);La$1=b&&b[1]||"";}return "\n"+La$1+a}var Na$1=false;
function Oa$1(a,b){if(!a||Na$1)return "";Na$1=true;var c=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(b)if(b=function(){throw Error();},Object.defineProperty(b.prototype,"props",{set:function(){throw Error();}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(b,[]);}catch(l){var d=l;}Reflect.construct(a,[],b);}else {try{b.call();}catch(l){d=l;}a.call(b.prototype);}else {try{throw Error();}catch(l){d=l;}a();}}catch(l){if(l&&d&&"string"===typeof l.stack){for(var e=l.stack.split("\n"),
f=d.stack.split("\n"),g=e.length-1,h=f.length-1;1<=g&&0<=h&&e[g]!==f[h];)h--;for(;1<=g&&0<=h;g--,h--)if(e[g]!==f[h]){if(1!==g||1!==h){do if(g--,h--,0>h||e[g]!==f[h]){var k="\n"+e[g].replace(" at new "," at ");a.displayName&&k.includes("<anonymous>")&&(k=k.replace("<anonymous>",a.displayName));return k}while(1<=g&&0<=h)}break}}}finally{Na$1=false,Error.prepareStackTrace=c;}return (a=a?a.displayName||a.name:"")?Ma$1(a):""}
function Pa$1(a){switch(a.tag){case 5:return Ma$1(a.type);case 16:return Ma$1("Lazy");case 13:return Ma$1("Suspense");case 19:return Ma$1("SuspenseList");case 0:case 2:case 15:return a=Oa$1(a.type,false),a;case 11:return a=Oa$1(a.type.render,false),a;case 1:return a=Oa$1(a.type,true),a;default:return ""}}
function Qa$1(a){if(null==a)return null;if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case ya$1:return "Fragment";case wa$1:return "Portal";case Aa$1:return "Profiler";case za$1:return "StrictMode";case Ea$1:return "Suspense";case Fa$1:return "SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Ca$1:return (a.displayName||"Context")+".Consumer";case Ba$1:return (a._context.displayName||"Context")+".Provider";case Da$1:var b=a.render;a=a.displayName;a||(a=b.displayName||
b.name||"",a=""!==a?"ForwardRef("+a+")":"ForwardRef");return a;case Ga$1:return b=a.displayName||null,null!==b?b:Qa$1(a.type)||"Memo";case Ha$1:b=a._payload;a=a._init;try{return Qa$1(a(b))}catch(c){}}return null}
function Ra$1(a){var b=a.type;switch(a.tag){case 24:return "Cache";case 9:return (b.displayName||"Context")+".Consumer";case 10:return (b._context.displayName||"Context")+".Provider";case 18:return "DehydratedFragment";case 11:return a=b.render,a=a.displayName||a.name||"",b.displayName||(""!==a?"ForwardRef("+a+")":"ForwardRef");case 7:return "Fragment";case 5:return b;case 4:return "Portal";case 3:return "Root";case 6:return "Text";case 16:return Qa$1(b);case 8:return b===za$1?"StrictMode":"Mode";case 22:return "Offscreen";
case 12:return "Profiler";case 21:return "Scope";case 13:return "Suspense";case 19:return "SuspenseList";case 25:return "TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof b)return b.displayName||b.name||null;if("string"===typeof b)return b}return null}function Sa$1(a){switch(typeof a){case "boolean":case "number":case "string":case "undefined":return a;case "object":return a;default:return ""}}
function Ta$1(a){var b=a.type;return (a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}
function Ua$1(a){var b=Ta$1(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:true,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a);}});Object.defineProperty(a,b,{enumerable:c.enumerable});return {getValue:function(){return d},setValue:function(a){d=""+a;},stopTracking:function(){a._valueTracker=
null;delete a[b];}}}}function Va$1(a){a._valueTracker||(a._valueTracker=Ua$1(a));}function Wa$1(a){if(!a)return  false;var b=a._valueTracker;if(!b)return  true;var c=b.getValue();var d="";a&&(d=Ta$1(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),true):false}function Xa$1(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}
function Ya$1(a,b){var c=b.checked;return A$2({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=c?c:a._wrapperState.initialChecked})}function Za$1(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=Sa$1(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value};}function ab$1(a,b){b=b.checked;null!=b&&ta$1(a,"checked",b,false);}
function bb$1(a,b){ab$1(a,b);var c=Sa$1(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c;}else a.value!==""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?cb$1(a,b.type,c):b.hasOwnProperty("defaultValue")&&cb$1(a,b.type,Sa$1(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked);}
function db$1(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=b);a.defaultValue=b;}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c);}
function cb$1(a,b,c){if("number"!==b||Xa$1(a.ownerDocument)!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c);}var eb$1=Array.isArray;
function fb$1(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b["$"+c[e]]=true;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=true);}else {c=""+Sa$1(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=true;d&&(a[e].defaultSelected=true);return}null!==b||a[e].disabled||(b=a[e]);}null!==b&&(b.selected=true);}}
function gb$1(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(p$2(91));return A$2({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function hb$1(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(p$2(92));if(eb$1(c)){if(1<c.length)throw Error(p$2(93));c=c[0];}b=c;}null==b&&(b="");c=b;}a._wrapperState={initialValue:Sa$1(c)};}
function ib$1(a,b){var c=Sa$1(b.value),d=Sa$1(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d);}function jb$1(a){var b=a.textContent;b===a._wrapperState.initialValue&&""!==b&&null!==b&&(a.value=b);}function kb$1(a){switch(a){case "svg":return "http://www.w3.org/2000/svg";case "math":return "http://www.w3.org/1998/Math/MathML";default:return "http://www.w3.org/1999/xhtml"}}
function lb$1(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?kb$1(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}
var mb$1,nb$1=function(a){return "undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)});}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else {mb$1=mb$1||document.createElement("div");mb$1.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=mb$1.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild);}});
function ob$1(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b;}
var pb$1={animationIterationCount:true,aspectRatio:true,borderImageOutset:true,borderImageSlice:true,borderImageWidth:true,boxFlex:true,boxFlexGroup:true,boxOrdinalGroup:true,columnCount:true,columns:true,flex:true,flexGrow:true,flexPositive:true,flexShrink:true,flexNegative:true,flexOrder:true,gridArea:true,gridRow:true,gridRowEnd:true,gridRowSpan:true,gridRowStart:true,gridColumn:true,gridColumnEnd:true,gridColumnSpan:true,gridColumnStart:true,fontWeight:true,lineClamp:true,lineHeight:true,opacity:true,order:true,orphans:true,tabSize:true,widows:true,zIndex:true,
zoom:true,fillOpacity:true,floodOpacity:true,stopOpacity:true,strokeDasharray:true,strokeDashoffset:true,strokeMiterlimit:true,strokeOpacity:true,strokeWidth:true},qb$1=["Webkit","ms","Moz","O"];Object.keys(pb$1).forEach(function(a){qb$1.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);pb$1[b]=pb$1[a];});});function rb$1(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||pb$1.hasOwnProperty(a)&&pb$1[a]?(""+b).trim():b+"px"}
function sb$1(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=rb$1(c,b[c],d);"float"===c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e;}}var tb$1=A$2({menuitem:true},{area:true,base:true,br:true,col:true,embed:true,hr:true,img:true,input:true,keygen:true,link:true,meta:true,param:true,source:true,track:true,wbr:true});
function ub$1(a,b){if(b){if(tb$1[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(p$2(137,a));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(p$2(60));if("object"!==typeof b.dangerouslySetInnerHTML||!("__html"in b.dangerouslySetInnerHTML))throw Error(p$2(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(p$2(62));}}
function vb$1(a,b){if(-1===a.indexOf("-"))return "string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return  false;default:return  true}}var wb$1=null;function xb$1(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}var yb$1=null,zb$1=null,Ab$1=null;
function Bb$1(a){if(a=Cb$1(a)){if("function"!==typeof yb$1)throw Error(p$2(280));var b=a.stateNode;b&&(b=Db$1(b),yb$1(a.stateNode,a.type,b));}}function Eb$1(a){zb$1?Ab$1?Ab$1.push(a):Ab$1=[a]:zb$1=a;}function Fb$1(){if(zb$1){var a=zb$1,b=Ab$1;Ab$1=zb$1=null;Bb$1(a);if(b)for(a=0;a<b.length;a++)Bb$1(b[a]);}}function Gb$1(a,b){return a(b)}function Hb$1(){}var Ib$1=false;function Jb$1(a,b,c){if(Ib$1)return a(b,c);Ib$1=true;try{return Gb$1(a,b,c)}finally{if(Ib$1=false,null!==zb$1||null!==Ab$1)Hb$1(),Fb$1();}}
function Kb$1(a,b){var c=a.stateNode;if(null===c)return null;var d=Db$1(c);if(null===d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=false;}if(a)return null;if(c&&"function"!==
typeof c)throw Error(p$2(231,b,typeof c));return c}var Lb$1=false;if(ia$1)try{var Mb$1={};Object.defineProperty(Mb$1,"passive",{get:function(){Lb$1=!0;}});window.addEventListener("test",Mb$1,Mb$1);window.removeEventListener("test",Mb$1,Mb$1);}catch(a){Lb$1=false;}function Nb$1(a,b,c,d,e,f,g,h,k){var l=Array.prototype.slice.call(arguments,3);try{b.apply(c,l);}catch(m){this.onError(m);}}var Ob$1=false,Pb$1=null,Qb$1=false,Rb$1=null,Sb$1={onError:function(a){Ob$1=true;Pb$1=a;}};function Tb$1(a,b,c,d,e,f,g,h,k){Ob$1=false;Pb$1=null;Nb$1.apply(Sb$1,arguments);}
function Ub$1(a,b,c,d,e,f,g,h,k){Tb$1.apply(this,arguments);if(Ob$1){if(Ob$1){var l=Pb$1;Ob$1=false;Pb$1=null;}else throw Error(p$2(198));Qb$1||(Qb$1=true,Rb$1=l);}}function Vb$1(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else {a=b;do b=a,0!==(b.flags&4098)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Wb$1(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Xb$1(a){if(Vb$1(a)!==a)throw Error(p$2(188));}
function Yb$1(a){var b=a.alternate;if(!b){b=Vb$1(a);if(null===b)throw Error(p$2(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Xb$1(e),a;if(f===d)return Xb$1(e),b;f=f.sibling;}throw Error(p$2(188));}if(c.return!==d.return)c=e,d=f;else {for(var g=false,h=e.child;h;){if(h===c){g=true;c=e;d=f;break}if(h===d){g=true;d=e;c=f;break}h=h.sibling;}if(!g){for(h=f.child;h;){if(h===
c){g=true;c=f;d=e;break}if(h===d){g=true;d=f;c=e;break}h=h.sibling;}if(!g)throw Error(p$2(189));}}if(c.alternate!==d)throw Error(p$2(190));}if(3!==c.tag)throw Error(p$2(188));return c.stateNode.current===c?a:b}function Zb$1(a){a=Yb$1(a);return null!==a?$b$1(a):null}function $b$1(a){if(5===a.tag||6===a.tag)return a;for(a=a.child;null!==a;){var b=$b$1(a);if(null!==b)return b;a=a.sibling;}return null}
var ac=ca$1.unstable_scheduleCallback,bc$1=ca$1.unstable_cancelCallback,cc$1=ca$1.unstable_shouldYield,dc$1=ca$1.unstable_requestPaint,B$1=ca$1.unstable_now,ec$1=ca$1.unstable_getCurrentPriorityLevel,fc$1=ca$1.unstable_ImmediatePriority,gc$1=ca$1.unstable_UserBlockingPriority,hc$1=ca$1.unstable_NormalPriority,ic$1=ca$1.unstable_LowPriority,jc$1=ca$1.unstable_IdlePriority,kc$1=null,lc$1=null;function mc$1(a){if(lc$1&&"function"===typeof lc$1.onCommitFiberRoot)try{lc$1.onCommitFiberRoot(kc$1,a,void 0,128===(a.current.flags&128));}catch(b){}}
var oc$1=Math.clz32?Math.clz32:nc$1,pc$1=Math.log,qc$1=Math.LN2;function nc$1(a){a>>>=0;return 0===a?32:31-(pc$1(a)/qc$1|0)|0}var rc$1=64,sc$1=4194304;
function tc$1(a){switch(a&-a){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return a&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return a&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;
default:return a}}function uc$1(a,b){var c=a.pendingLanes;if(0===c)return 0;var d=0,e=a.suspendedLanes,f=a.pingedLanes,g=c&268435455;if(0!==g){var h=g&~e;0!==h?d=tc$1(h):(f&=g,0!==f&&(d=tc$1(f)));}else g=c&~e,0!==g?d=tc$1(g):0!==f&&(d=tc$1(f));if(0===d)return 0;if(0!==b&&b!==d&&0===(b&e)&&(e=d&-d,f=b&-b,e>=f||16===e&&0!==(f&4194240)))return b;0!==(d&4)&&(d|=c&16);b=a.entangledLanes;if(0!==b)for(a=a.entanglements,b&=d;0<b;)c=31-oc$1(b),e=1<<c,d|=a[c],b&=~e;return d}
function vc$1(a,b){switch(a){case 1:case 2:case 4:return b+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return b+5E3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return  -1;case 134217728:case 268435456:case 536870912:case 1073741824:return  -1;default:return  -1}}
function wc$1(a,b){for(var c=a.suspendedLanes,d=a.pingedLanes,e=a.expirationTimes,f=a.pendingLanes;0<f;){var g=31-oc$1(f),h=1<<g,k=e[g];if(-1===k){if(0===(h&c)||0!==(h&d))e[g]=vc$1(h,b);}else k<=b&&(a.expiredLanes|=h);f&=~h;}}function xc$1(a){a=a.pendingLanes&-1073741825;return 0!==a?a:a&1073741824?1073741824:0}function yc$1(){var a=rc$1;rc$1<<=1;0===(rc$1&4194240)&&(rc$1=64);return a}function zc$1(a){for(var b=[],c=0;31>c;c++)b.push(a);return b}
function Ac$1(a,b,c){a.pendingLanes|=b;536870912!==b&&(a.suspendedLanes=0,a.pingedLanes=0);a=a.eventTimes;b=31-oc$1(b);a[b]=c;}function Bc$1(a,b){var c=a.pendingLanes&~b;a.pendingLanes=b;a.suspendedLanes=0;a.pingedLanes=0;a.expiredLanes&=b;a.mutableReadLanes&=b;a.entangledLanes&=b;b=a.entanglements;var d=a.eventTimes;for(a=a.expirationTimes;0<c;){var e=31-oc$1(c),f=1<<e;b[e]=0;d[e]=-1;a[e]=-1;c&=~f;}}
function Cc$1(a,b){var c=a.entangledLanes|=b;for(a=a.entanglements;c;){var d=31-oc$1(c),e=1<<d;e&b|a[d]&b&&(a[d]|=b);c&=~e;}}var C$1=0;function Dc$1(a){a&=-a;return 1<a?4<a?0!==(a&268435455)?16:536870912:4:1}var Ec$1,Fc$1,Gc$1,Hc$1,Ic$1,Jc$1=false,Kc$1=[],Lc$1=null,Mc$1=null,Nc$1=null,Oc$1=new Map,Pc$1=new Map,Qc$1=[],Rc$1="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc$1(a,b){switch(a){case "focusin":case "focusout":Lc$1=null;break;case "dragenter":case "dragleave":Mc$1=null;break;case "mouseover":case "mouseout":Nc$1=null;break;case "pointerover":case "pointerout":Oc$1.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Pc$1.delete(b.pointerId);}}
function Tc$1(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a={blockedOn:b,domEventName:c,eventSystemFlags:d,nativeEvent:f,targetContainers:[e]},null!==b&&(b=Cb$1(b),null!==b&&Fc$1(b)),a;a.eventSystemFlags|=d;b=a.targetContainers;null!==e&&-1===b.indexOf(e)&&b.push(e);return a}
function Uc$1(a,b,c,d,e){switch(b){case "focusin":return Lc$1=Tc$1(Lc$1,a,b,c,d,e),true;case "dragenter":return Mc$1=Tc$1(Mc$1,a,b,c,d,e),true;case "mouseover":return Nc$1=Tc$1(Nc$1,a,b,c,d,e),true;case "pointerover":var f=e.pointerId;Oc$1.set(f,Tc$1(Oc$1.get(f)||null,a,b,c,d,e));return  true;case "gotpointercapture":return f=e.pointerId,Pc$1.set(f,Tc$1(Pc$1.get(f)||null,a,b,c,d,e)),true}return  false}
function Vc$1(a){var b=Wc$1(a.target);if(null!==b){var c=Vb$1(b);if(null!==c)if(b=c.tag,13===b){if(b=Wb$1(c),null!==b){a.blockedOn=b;Ic$1(a.priority,function(){Gc$1(c);});return}}else if(3===b&&c.stateNode.current.memoizedState.isDehydrated){a.blockedOn=3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null;}
function Xc$1(a){if(null!==a.blockedOn)return  false;for(var b=a.targetContainers;0<b.length;){var c=Yc$1(a.domEventName,a.eventSystemFlags,b[0],a.nativeEvent);if(null===c){c=a.nativeEvent;var d=new c.constructor(c.type,c);wb$1=d;c.target.dispatchEvent(d);wb$1=null;}else return b=Cb$1(c),null!==b&&Fc$1(b),a.blockedOn=c,false;b.shift();}return  true}function Zc$1(a,b,c){Xc$1(a)&&c.delete(b);}function $c$1(){Jc$1=false;null!==Lc$1&&Xc$1(Lc$1)&&(Lc$1=null);null!==Mc$1&&Xc$1(Mc$1)&&(Mc$1=null);null!==Nc$1&&Xc$1(Nc$1)&&(Nc$1=null);Oc$1.forEach(Zc$1);Pc$1.forEach(Zc$1);}
function ad$1(a,b){a.blockedOn===b&&(a.blockedOn=null,Jc$1||(Jc$1=true,ca$1.unstable_scheduleCallback(ca$1.unstable_NormalPriority,$c$1)));}
function bd$1(a){function b(b){return ad$1(b,a)}if(0<Kc$1.length){ad$1(Kc$1[0],a);for(var c=1;c<Kc$1.length;c++){var d=Kc$1[c];d.blockedOn===a&&(d.blockedOn=null);}}null!==Lc$1&&ad$1(Lc$1,a);null!==Mc$1&&ad$1(Mc$1,a);null!==Nc$1&&ad$1(Nc$1,a);Oc$1.forEach(b);Pc$1.forEach(b);for(c=0;c<Qc$1.length;c++)d=Qc$1[c],d.blockedOn===a&&(d.blockedOn=null);for(;0<Qc$1.length&&(c=Qc$1[0],null===c.blockedOn);)Vc$1(c),null===c.blockedOn&&Qc$1.shift();}var cd$1=ua$1.ReactCurrentBatchConfig,dd$1=true;
function ed$1(a,b,c,d){var e=C$1,f=cd$1.transition;cd$1.transition=null;try{C$1=1,fd$1(a,b,c,d);}finally{C$1=e,cd$1.transition=f;}}function gd$1(a,b,c,d){var e=C$1,f=cd$1.transition;cd$1.transition=null;try{C$1=4,fd$1(a,b,c,d);}finally{C$1=e,cd$1.transition=f;}}
function fd$1(a,b,c,d){if(dd$1){var e=Yc$1(a,b,c,d);if(null===e)hd$1(a,b,d,id$1,c),Sc$1(a,d);else if(Uc$1(e,a,b,c,d))d.stopPropagation();else if(Sc$1(a,d),b&4&&-1<Rc$1.indexOf(a)){for(;null!==e;){var f=Cb$1(e);null!==f&&Ec$1(f);f=Yc$1(a,b,c,d);null===f&&hd$1(a,b,d,id$1,c);if(f===e)break;e=f;}null!==e&&d.stopPropagation();}else hd$1(a,b,d,null,c);}}var id$1=null;
function Yc$1(a,b,c,d){id$1=null;a=xb$1(d);a=Wc$1(a);if(null!==a)if(b=Vb$1(a),null===b)a=null;else if(c=b.tag,13===c){a=Wb$1(b);if(null!==a)return a;a=null;}else if(3===c){if(b.stateNode.current.memoizedState.isDehydrated)return 3===b.tag?b.stateNode.containerInfo:null;a=null;}else b!==a&&(a=null);id$1=a;return null}
function jd$1(a){switch(a){case "cancel":case "click":case "close":case "contextmenu":case "copy":case "cut":case "auxclick":case "dblclick":case "dragend":case "dragstart":case "drop":case "focusin":case "focusout":case "input":case "invalid":case "keydown":case "keypress":case "keyup":case "mousedown":case "mouseup":case "paste":case "pause":case "play":case "pointercancel":case "pointerdown":case "pointerup":case "ratechange":case "reset":case "resize":case "seeked":case "submit":case "touchcancel":case "touchend":case "touchstart":case "volumechange":case "change":case "selectionchange":case "textInput":case "compositionstart":case "compositionend":case "compositionupdate":case "beforeblur":case "afterblur":case "beforeinput":case "blur":case "fullscreenchange":case "focus":case "hashchange":case "popstate":case "select":case "selectstart":return 1;case "drag":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "mousemove":case "mouseout":case "mouseover":case "pointermove":case "pointerout":case "pointerover":case "scroll":case "toggle":case "touchmove":case "wheel":case "mouseenter":case "mouseleave":case "pointerenter":case "pointerleave":return 4;
case "message":switch(ec$1()){case fc$1:return 1;case gc$1:return 4;case hc$1:case ic$1:return 16;case jc$1:return 536870912;default:return 16}default:return 16}}var kd$1=null,ld$1=null,md$1=null;function nd$1(){if(md$1)return md$1;var a,b=ld$1,c=b.length,d,e="value"in kd$1?kd$1.value:kd$1.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return md$1=e.slice(a,1<d?1-d:void 0)}
function od$1(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function pd$1(){return  true}function qd$1(){return  false}
function rd$1(a){function b(b,d,e,f,g){this._reactName=b;this._targetInst=e;this.type=d;this.nativeEvent=f;this.target=g;this.currentTarget=null;for(var c in a)a.hasOwnProperty(c)&&(b=a[c],this[c]=b?b(f):f[c]);this.isDefaultPrevented=(null!=f.defaultPrevented?f.defaultPrevented:false===f.returnValue)?pd$1:qd$1;this.isPropagationStopped=qd$1;return this}A$2(b.prototype,{preventDefault:function(){this.defaultPrevented=true;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&
(a.returnValue=false),this.isDefaultPrevented=pd$1);},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=true),this.isPropagationStopped=pd$1);},persist:function(){},isPersistent:pd$1});return b}
var sd$1={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},td$1=rd$1(sd$1),ud$1=A$2({},sd$1,{view:0,detail:0}),vd$1=rd$1(ud$1),wd$1,xd$1,yd$1,Ad$1=A$2({},ud$1,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:zd$1,button:0,buttons:0,relatedTarget:function(a){return void 0===a.relatedTarget?a.fromElement===a.srcElement?a.toElement:a.fromElement:a.relatedTarget},movementX:function(a){if("movementX"in
a)return a.movementX;a!==yd$1&&(yd$1&&"mousemove"===a.type?(wd$1=a.screenX-yd$1.screenX,xd$1=a.screenY-yd$1.screenY):xd$1=wd$1=0,yd$1=a);return wd$1},movementY:function(a){return "movementY"in a?a.movementY:xd$1}}),Bd$1=rd$1(Ad$1),Cd$1=A$2({},Ad$1,{dataTransfer:0}),Dd$1=rd$1(Cd$1),Ed$1=A$2({},ud$1,{relatedTarget:0}),Fd$1=rd$1(Ed$1),Gd$1=A$2({},sd$1,{animationName:0,elapsedTime:0,pseudoElement:0}),Hd$1=rd$1(Gd$1),Id$1=A$2({},sd$1,{clipboardData:function(a){return "clipboardData"in a?a.clipboardData:window.clipboardData}}),Jd$1=rd$1(Id$1),Kd$1=A$2({},sd$1,{data:0}),Ld=rd$1(Kd$1),Md$1={Esc:"Escape",
Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Nd$1={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",
119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Od$1={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Pd$1(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Od$1[a])?!!b[a]:false}function zd$1(){return Pd$1}
var Qd$1=A$2({},ud$1,{key:function(a){if(a.key){var b=Md$1[a.key]||a.key;if("Unidentified"!==b)return b}return "keypress"===a.type?(a=od$1(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?Nd$1[a.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:zd$1,charCode:function(a){return "keypress"===a.type?od$1(a):0},keyCode:function(a){return "keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return "keypress"===
a.type?od$1(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),Rd$1=rd$1(Qd$1),Sd$1=A$2({},Ad$1,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Td$1=rd$1(Sd$1),Ud$1=A$2({},ud$1,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:zd$1}),Vd$1=rd$1(Ud$1),Wd$1=A$2({},sd$1,{propertyName:0,elapsedTime:0,pseudoElement:0}),Xd$1=rd$1(Wd$1),Yd$1=A$2({},Ad$1,{deltaX:function(a){return "deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},
deltaY:function(a){return "deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:0,deltaMode:0}),Zd$1=rd$1(Yd$1),$d$1=[9,13,27,32],ae=ia$1&&"CompositionEvent"in window,be$1=null;ia$1&&"documentMode"in document&&(be$1=document.documentMode);var ce$1=ia$1&&"TextEvent"in window&&!be$1,de=ia$1&&(!ae||be$1&&8<be$1&&11>=be$1),ee=String.fromCharCode(32),fe=false;
function ge(a,b){switch(a){case "keyup":return  -1!==$d$1.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "focusout":return  true;default:return  false}}function he$1(a){a=a.detail;return "object"===typeof a&&"data"in a?a.data:null}var ie=false;function je(a,b){switch(a){case "compositionend":return he$1(b);case "keypress":if(32!==b.which)return null;fe=true;return ee;case "textInput":return a=b.data,a===ee&&fe?null:a;default:return null}}
function ke(a,b){if(ie)return "compositionend"===a||!ae&&ge(a,b)?(a=nd$1(),md$1=ld$1=kd$1=null,ie=false,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case "compositionend":return de&&"ko"!==b.locale?null:b.data;default:return null}}
var le={color:true,date:true,datetime:true,"datetime-local":true,email:true,month:true,number:true,password:true,range:true,search:true,tel:true,text:true,time:true,url:true,week:true};function me$1(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return "input"===b?!!le[a.type]:"textarea"===b?true:false}function ne(a,b,c,d){Eb$1(d);b=oe$1(b,"onChange");0<b.length&&(c=new td$1("onChange","change",null,c,d),a.push({event:c,listeners:b}));}var pe$1=null,qe$1=null;function re(a){se$1(a,0);}function te$1(a){var b=ue$1(a);if(Wa$1(b))return a}
function ve(a,b){if("change"===a)return b}var we=false;if(ia$1){var xe$1;if(ia$1){var ye$1="oninput"in document;if(!ye$1){var ze$1=document.createElement("div");ze$1.setAttribute("oninput","return;");ye$1="function"===typeof ze$1.oninput;}xe$1=ye$1;}else xe$1=false;we=xe$1&&(!document.documentMode||9<document.documentMode);}function Ae$1(){pe$1&&(pe$1.detachEvent("onpropertychange",Be$1),qe$1=pe$1=null);}function Be$1(a){if("value"===a.propertyName&&te$1(qe$1)){var b=[];ne(b,qe$1,a,xb$1(a));Jb$1(re,b);}}
function Ce$1(a,b,c){"focusin"===a?(Ae$1(),pe$1=b,qe$1=c,pe$1.attachEvent("onpropertychange",Be$1)):"focusout"===a&&Ae$1();}function De$1(a){if("selectionchange"===a||"keyup"===a||"keydown"===a)return te$1(qe$1)}function Ee$1(a,b){if("click"===a)return te$1(b)}function Fe(a,b){if("input"===a||"change"===a)return te$1(b)}function Ge$1(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var He$1="function"===typeof Object.is?Object.is:Ge$1;
function Ie$1(a,b){if(He$1(a,b))return  true;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return  false;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return  false;for(d=0;d<c.length;d++){var e=c[d];if(!ja$1.call(b,e)||!He$1(a[e],b[e]))return  false}return  true}function Je$1(a){for(;a&&a.firstChild;)a=a.firstChild;return a}
function Ke$1(a,b){var c=Je$1(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return {node:c,offset:b-a};a=d;}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode;}c=void 0;}c=Je$1(c);}}function Le$1(a,b){return a&&b?a===b?true:a&&3===a.nodeType?false:b&&3===b.nodeType?Le$1(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):false:false}
function Me$1(){for(var a=window,b=Xa$1();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href;}catch(d){c=false;}if(c)a=b.contentWindow;else break;b=Xa$1(a.document);}return b}function Ne$1(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}
function Oe(a){var b=Me$1(),c=a.focusedElem,d=a.selectionRange;if(b!==c&&c&&c.ownerDocument&&Le$1(c.ownerDocument.documentElement,c)){if(null!==d&&Ne$1(c))if(b=d.start,a=d.end,void 0===a&&(a=b),"selectionStart"in c)c.selectionStart=b,c.selectionEnd=Math.min(a,c.value.length);else if(a=(b=c.ownerDocument||document)&&b.defaultView||window,a.getSelection){a=a.getSelection();var e=c.textContent.length,f=Math.min(d.start,e);d=void 0===d.end?f:Math.min(d.end,e);!a.extend&&f>d&&(e=d,d=f,f=e);e=Ke$1(c,f);var g=Ke$1(c,
d);e&&g&&(1!==a.rangeCount||a.anchorNode!==e.node||a.anchorOffset!==e.offset||a.focusNode!==g.node||a.focusOffset!==g.offset)&&(b=b.createRange(),b.setStart(e.node,e.offset),a.removeAllRanges(),f>d?(a.addRange(b),a.extend(g.node,g.offset)):(b.setEnd(g.node,g.offset),a.addRange(b)));}b=[];for(a=c;a=a.parentNode;)1===a.nodeType&&b.push({element:a,left:a.scrollLeft,top:a.scrollTop});"function"===typeof c.focus&&c.focus();for(c=0;c<b.length;c++)a=b[c],a.element.scrollLeft=a.left,a.element.scrollTop=a.top;}}
var Pe$1=ia$1&&"documentMode"in document&&11>=document.documentMode,Qe$1=null,Re$1=null,Se$1=null,Te$1=false;
function Ue$1(a,b,c){var d=c.window===c?c.document:9===c.nodeType?c:c.ownerDocument;Te$1||null==Qe$1||Qe$1!==Xa$1(d)||(d=Qe$1,"selectionStart"in d&&Ne$1(d)?d={start:d.selectionStart,end:d.selectionEnd}:(d=(d.ownerDocument&&d.ownerDocument.defaultView||window).getSelection(),d={anchorNode:d.anchorNode,anchorOffset:d.anchorOffset,focusNode:d.focusNode,focusOffset:d.focusOffset}),Se$1&&Ie$1(Se$1,d)||(Se$1=d,d=oe$1(Re$1,"onSelect"),0<d.length&&(b=new td$1("onSelect","select",null,b,c),a.push({event:b,listeners:d}),b.target=Qe$1)));}
function Ve$1(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}var We$1={animationend:Ve$1("Animation","AnimationEnd"),animationiteration:Ve$1("Animation","AnimationIteration"),animationstart:Ve$1("Animation","AnimationStart"),transitionend:Ve$1("Transition","TransitionEnd")},Xe$1={},Ye={};
ia$1&&(Ye=document.createElement("div").style,"AnimationEvent"in window||(delete We$1.animationend.animation,delete We$1.animationiteration.animation,delete We$1.animationstart.animation),"TransitionEvent"in window||delete We$1.transitionend.transition);function Ze$1(a){if(Xe$1[a])return Xe$1[a];if(!We$1[a])return a;var b=We$1[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Ye)return Xe$1[a]=b[c];return a}var $e=Ze$1("animationend"),af=Ze$1("animationiteration"),bf$1=Ze$1("animationstart"),cf=Ze$1("transitionend"),df=new Map,ef="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a,b){df.set(a,b);fa$1(b,[a]);}for(var gf$1=0;gf$1<ef.length;gf$1++){var hf$1=ef[gf$1],jf$1=hf$1.toLowerCase(),kf$1=hf$1[0].toUpperCase()+hf$1.slice(1);ff(jf$1,"on"+kf$1);}ff($e,"onAnimationEnd");ff(af,"onAnimationIteration");ff(bf$1,"onAnimationStart");ff("dblclick","onDoubleClick");ff("focusin","onFocus");ff("focusout","onBlur");ff(cf,"onTransitionEnd");ha$1("onMouseEnter",["mouseout","mouseover"]);ha$1("onMouseLeave",["mouseout","mouseover"]);ha$1("onPointerEnter",["pointerout","pointerover"]);
ha$1("onPointerLeave",["pointerout","pointerover"]);fa$1("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));fa$1("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));fa$1("onBeforeInput",["compositionend","keypress","textInput","paste"]);fa$1("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));fa$1("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa$1("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var lf="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),mf$1=new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=c;Ub$1(d,b,void 0,a);a.currentTarget=null;}
function se$1(a,b){b=0!==(b&4);for(var c=0;c<a.length;c++){var d=a[c],e=d.event;d=d.listeners;a:{var f=void 0;if(b)for(var g=d.length-1;0<=g;g--){var h=d[g],k=h.instance,l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;nf(e,h,l);f=k;}else for(g=0;g<d.length;g++){h=d[g];k=h.instance;l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;nf(e,h,l);f=k;}}}if(Qb$1)throw a=Rb$1,Qb$1=false,Rb$1=null,a;}
function D$1(a,b){var c=b[of$1];void 0===c&&(c=b[of$1]=new Set);var d=a+"__bubble";c.has(d)||(pf(b,a,2,false),c.add(d));}function qf$1(a,b,c){var d=0;b&&(d|=4);pf(c,a,d,b);}var rf="_reactListening"+Math.random().toString(36).slice(2);function sf(a){if(!a[rf]){a[rf]=true;da$1.forEach(function(b){"selectionchange"!==b&&(mf$1.has(b)||qf$1(b,false,a),qf$1(b,true,a));});var b=9===a.nodeType?a:a.ownerDocument;null===b||b[rf]||(b[rf]=true,qf$1("selectionchange",false,b));}}
function pf(a,b,c,d){switch(jd$1(b)){case 1:var e=ed$1;break;case 4:e=gd$1;break;default:e=fd$1;}c=e.bind(null,b,c,a);e=void 0;!Lb$1||"touchstart"!==b&&"touchmove"!==b&&"wheel"!==b||(e=true);d?void 0!==e?a.addEventListener(b,c,{capture:true,passive:e}):a.addEventListener(b,c,true):void 0!==e?a.addEventListener(b,c,{passive:e}):a.addEventListener(b,c,false);}
function hd$1(a,b,c,d,e){var f=d;if(0===(b&1)&&0===(b&2)&&null!==d)a:for(;;){if(null===d)return;var g=d.tag;if(3===g||4===g){var h=d.stateNode.containerInfo;if(h===e||8===h.nodeType&&h.parentNode===e)break;if(4===g)for(g=d.return;null!==g;){var k=g.tag;if(3===k||4===k)if(k=g.stateNode.containerInfo,k===e||8===k.nodeType&&k.parentNode===e)return;g=g.return;}for(;null!==h;){g=Wc$1(h);if(null===g)return;k=g.tag;if(5===k||6===k){d=f=g;continue a}h=h.parentNode;}}d=d.return;}Jb$1(function(){var d=f,e=xb$1(c),g=[];
a:{var h=df.get(a);if(void 0!==h){var k=td$1,n=a;switch(a){case "keypress":if(0===od$1(c))break a;case "keydown":case "keyup":k=Rd$1;break;case "focusin":n="focus";k=Fd$1;break;case "focusout":n="blur";k=Fd$1;break;case "beforeblur":case "afterblur":k=Fd$1;break;case "click":if(2===c.button)break a;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":k=Bd$1;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":k=
Dd$1;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":k=Vd$1;break;case $e:case af:case bf$1:k=Hd$1;break;case cf:k=Xd$1;break;case "scroll":k=vd$1;break;case "wheel":k=Zd$1;break;case "copy":case "cut":case "paste":k=Jd$1;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":k=Td$1;}var t=0!==(b&4),J=!t&&"scroll"===a,x=t?null!==h?h+"Capture":null:h;t=[];for(var w=d,u;null!==
w;){u=w;var F=u.stateNode;5===u.tag&&null!==F&&(u=F,null!==x&&(F=Kb$1(w,x),null!=F&&t.push(tf(w,F,u))));if(J)break;w=w.return;}0<t.length&&(h=new k(h,n,null,c,e),g.push({event:h,listeners:t}));}}if(0===(b&7)){a:{h="mouseover"===a||"pointerover"===a;k="mouseout"===a||"pointerout"===a;if(h&&c!==wb$1&&(n=c.relatedTarget||c.fromElement)&&(Wc$1(n)||n[uf$1]))break a;if(k||h){h=e.window===e?e:(h=e.ownerDocument)?h.defaultView||h.parentWindow:window;if(k){if(n=c.relatedTarget||c.toElement,k=d,n=n?Wc$1(n):null,null!==
n&&(J=Vb$1(n),n!==J||5!==n.tag&&6!==n.tag))n=null;}else k=null,n=d;if(k!==n){t=Bd$1;F="onMouseLeave";x="onMouseEnter";w="mouse";if("pointerout"===a||"pointerover"===a)t=Td$1,F="onPointerLeave",x="onPointerEnter",w="pointer";J=null==k?h:ue$1(k);u=null==n?h:ue$1(n);h=new t(F,w+"leave",k,c,e);h.target=J;h.relatedTarget=u;F=null;Wc$1(e)===d&&(t=new t(x,w+"enter",n,c,e),t.target=u,t.relatedTarget=J,F=t);J=F;if(k&&n)b:{t=k;x=n;w=0;for(u=t;u;u=vf$1(u))w++;u=0;for(F=x;F;F=vf$1(F))u++;for(;0<w-u;)t=vf$1(t),w--;for(;0<u-w;)x=
vf$1(x),u--;for(;w--;){if(t===x||null!==x&&t===x.alternate)break b;t=vf$1(t);x=vf$1(x);}t=null;}else t=null;null!==k&&wf$1(g,h,k,t,false);null!==n&&null!==J&&wf$1(g,J,n,t,true);}}}a:{h=d?ue$1(d):window;k=h.nodeName&&h.nodeName.toLowerCase();if("select"===k||"input"===k&&"file"===h.type)var na=ve;else if(me$1(h))if(we)na=Fe;else {na=De$1;var xa=Ce$1;}else (k=h.nodeName)&&"input"===k.toLowerCase()&&("checkbox"===h.type||"radio"===h.type)&&(na=Ee$1);if(na&&(na=na(a,d))){ne(g,na,c,e);break a}xa&&xa(a,h,d);"focusout"===a&&(xa=h._wrapperState)&&
xa.controlled&&"number"===h.type&&cb$1(h,"number",h.value);}xa=d?ue$1(d):window;switch(a){case "focusin":if(me$1(xa)||"true"===xa.contentEditable)Qe$1=xa,Re$1=d,Se$1=null;break;case "focusout":Se$1=Re$1=Qe$1=null;break;case "mousedown":Te$1=true;break;case "contextmenu":case "mouseup":case "dragend":Te$1=false;Ue$1(g,c,e);break;case "selectionchange":if(Pe$1)break;case "keydown":case "keyup":Ue$1(g,c,e);}var $a;if(ae)b:{switch(a){case "compositionstart":var ba="onCompositionStart";break b;case "compositionend":ba="onCompositionEnd";
break b;case "compositionupdate":ba="onCompositionUpdate";break b}ba=void 0;}else ie?ge(a,c)&&(ba="onCompositionEnd"):"keydown"===a&&229===c.keyCode&&(ba="onCompositionStart");ba&&(de&&"ko"!==c.locale&&(ie||"onCompositionStart"!==ba?"onCompositionEnd"===ba&&ie&&($a=nd$1()):(kd$1=e,ld$1="value"in kd$1?kd$1.value:kd$1.textContent,ie=true)),xa=oe$1(d,ba),0<xa.length&&(ba=new Ld(ba,a,null,c,e),g.push({event:ba,listeners:xa}),$a?ba.data=$a:($a=he$1(c),null!==$a&&(ba.data=$a))));if($a=ce$1?je(a,c):ke(a,c))d=oe$1(d,"onBeforeInput"),
0<d.length&&(e=new Ld("onBeforeInput","beforeinput",null,c,e),g.push({event:e,listeners:d}),e.data=$a);}se$1(g,b);});}function tf(a,b,c){return {instance:a,listener:b,currentTarget:c}}function oe$1(a,b){for(var c=b+"Capture",d=[];null!==a;){var e=a,f=e.stateNode;5===e.tag&&null!==f&&(e=f,f=Kb$1(a,c),null!=f&&d.unshift(tf(a,f,e)),f=Kb$1(a,b),null!=f&&d.push(tf(a,f,e)));a=a.return;}return d}function vf$1(a){if(null===a)return null;do a=a.return;while(a&&5!==a.tag);return a?a:null}
function wf$1(a,b,c,d,e){for(var f=b._reactName,g=[];null!==c&&c!==d;){var h=c,k=h.alternate,l=h.stateNode;if(null!==k&&k===d)break;5===h.tag&&null!==l&&(h=l,e?(k=Kb$1(c,f),null!=k&&g.unshift(tf(c,k,h))):e||(k=Kb$1(c,f),null!=k&&g.push(tf(c,k,h))));c=c.return;}0!==g.length&&a.push({event:b,listeners:g});}var xf$1=/\r\n?/g,yf$1=/\u0000|\uFFFD/g;function zf$1(a){return ("string"===typeof a?a:""+a).replace(xf$1,"\n").replace(yf$1,"")}function Af$1(a,b,c){b=zf$1(b);if(zf$1(a)!==b&&c)throw Error(p$2(425));}function Bf$1(){}
var Cf$1=null,Df$1=null;function Ef$1(a,b){return "textarea"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}
var Ff$1="function"===typeof setTimeout?setTimeout:void 0,Gf$1="function"===typeof clearTimeout?clearTimeout:void 0,Hf$1="function"===typeof Promise?Promise:void 0,Jf$1="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof Hf$1?function(a){return Hf$1.resolve(null).then(a).catch(If$1)}:Ff$1;function If$1(a){setTimeout(function(){throw a;});}
function Kf$1(a,b){var c=b,d=0;do{var e=c.nextSibling;a.removeChild(c);if(e&&8===e.nodeType)if(c=e.data,"/$"===c){if(0===d){a.removeChild(e);bd$1(b);return}d--;}else "$"!==c&&"$?"!==c&&"$!"!==c||d++;c=e;}while(c);bd$1(b);}function Lf$1(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break;if(8===b){b=a.data;if("$"===b||"$!"===b||"$?"===b)break;if("/$"===b)return null}}return a}
function Mf$1(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if("$"===c||"$!"===c||"$?"===c){if(0===b)return a;b--;}else "/$"===c&&b++;}a=a.previousSibling;}return null}var Nf$1=Math.random().toString(36).slice(2),Of$1="__reactFiber$"+Nf$1,Pf$1="__reactProps$"+Nf$1,uf$1="__reactContainer$"+Nf$1,of$1="__reactEvents$"+Nf$1,Qf$1="__reactListeners$"+Nf$1,Rf$1="__reactHandles$"+Nf$1;
function Wc$1(a){var b=a[Of$1];if(b)return b;for(var c=a.parentNode;c;){if(b=c[uf$1]||c[Of$1]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=Mf$1(a);null!==a;){if(c=a[Of$1])return c;a=Mf$1(a);}return b}a=c;c=a.parentNode;}return null}function Cb$1(a){a=a[Of$1]||a[uf$1];return !a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function ue$1(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(p$2(33));}function Db$1(a){return a[Pf$1]||null}var Sf$1=[],Tf$1=-1;function Uf$1(a){return {current:a}}
function E$1(a){0>Tf$1||(a.current=Sf$1[Tf$1],Sf$1[Tf$1]=null,Tf$1--);}function G$1(a,b){Tf$1++;Sf$1[Tf$1]=a.current;a.current=b;}var Vf$1={},H$1=Uf$1(Vf$1),Wf=Uf$1(false),Xf$1=Vf$1;function Yf$1(a,b){var c=a.type.contextTypes;if(!c)return Vf$1;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}
function Zf$1(a){a=a.childContextTypes;return null!==a&&void 0!==a}function $f(){E$1(Wf);E$1(H$1);}function ag$1(a,b,c){if(H$1.current!==Vf$1)throw Error(p$2(168));G$1(H$1,b);G$1(Wf,c);}function bg$1(a,b,c){var d=a.stateNode;b=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in b))throw Error(p$2(108,Ra$1(a)||"Unknown",e));return A$2({},c,d)}
function cg$1(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Vf$1;Xf$1=H$1.current;G$1(H$1,a);G$1(Wf,Wf.current);return  true}function dg$1(a,b,c){var d=a.stateNode;if(!d)throw Error(p$2(169));c?(a=bg$1(a,b,Xf$1),d.__reactInternalMemoizedMergedChildContext=a,E$1(Wf),E$1(H$1),G$1(H$1,a)):E$1(Wf);G$1(Wf,c);}var eg$1=null,fg$1=false,gg$1=false;function hg$1(a){null===eg$1?eg$1=[a]:eg$1.push(a);}function ig$1(a){fg$1=true;hg$1(a);}
function jg$1(){if(!gg$1&&null!==eg$1){gg$1=true;var a=0,b=C$1;try{var c=eg$1;for(C$1=1;a<c.length;a++){var d=c[a];do d=d(!0);while(null!==d)}eg$1=null;fg$1=!1;}catch(e){throw null!==eg$1&&(eg$1=eg$1.slice(a+1)),ac(fc$1,jg$1),e;}finally{C$1=b,gg$1=false;}}return null}var kg$1=[],lg$1=0,mg$1=null,ng$1=0,og$1=[],pg$1=0,qg=null,rg$1=1,sg$1="";function tg$1(a,b){kg$1[lg$1++]=ng$1;kg$1[lg$1++]=mg$1;mg$1=a;ng$1=b;}
function ug$1(a,b,c){og$1[pg$1++]=rg$1;og$1[pg$1++]=sg$1;og$1[pg$1++]=qg;qg=a;var d=rg$1;a=sg$1;var e=32-oc$1(d)-1;d&=~(1<<e);c+=1;var f=32-oc$1(b)+e;if(30<f){var g=e-e%5;f=(d&(1<<g)-1).toString(32);d>>=g;e-=g;rg$1=1<<32-oc$1(b)+e|c<<e|d;sg$1=f+a;}else rg$1=1<<f|c<<e|d,sg$1=a;}function vg$1(a){null!==a.return&&(tg$1(a,1),ug$1(a,1,0));}function wg$1(a){for(;a===mg$1;)mg$1=kg$1[--lg$1],kg$1[lg$1]=null,ng$1=kg$1[--lg$1],kg$1[lg$1]=null;for(;a===qg;)qg=og$1[--pg$1],og$1[pg$1]=null,sg$1=og$1[--pg$1],og$1[pg$1]=null,rg$1=og$1[--pg$1],og$1[pg$1]=null;}var xg$1=null,yg$1=null,I$1=false,zg=null;
function Ag$1(a,b){var c=Bg$1(5,null,null,0);c.elementType="DELETED";c.stateNode=b;c.return=a;b=a.deletions;null===b?(a.deletions=[c],a.flags|=16):b.push(c);}
function Cg$1(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,xg$1=a,yg$1=Lf$1(b.firstChild),true):false;case 6:return b=""===a.pendingProps||3!==b.nodeType?null:b,null!==b?(a.stateNode=b,xg$1=a,yg$1=null,true):false;case 13:return b=8!==b.nodeType?null:b,null!==b?(c=null!==qg?{id:rg$1,overflow:sg$1}:null,a.memoizedState={dehydrated:b,treeContext:c,retryLane:1073741824},c=Bg$1(18,null,null,0),c.stateNode=b,c.return=a,a.child=c,xg$1=a,yg$1=
null,true):false;default:return  false}}function Dg$1(a){return 0!==(a.mode&1)&&0===(a.flags&128)}function Eg$1(a){if(I$1){var b=yg$1;if(b){var c=b;if(!Cg$1(a,b)){if(Dg$1(a))throw Error(p$2(418));b=Lf$1(c.nextSibling);var d=xg$1;b&&Cg$1(a,b)?Ag$1(d,c):(a.flags=a.flags&-4097|2,I$1=false,xg$1=a);}}else {if(Dg$1(a))throw Error(p$2(418));a.flags=a.flags&-4097|2;I$1=false;xg$1=a;}}}function Fg$1(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;xg$1=a;}
function Gg$1(a){if(a!==xg$1)return  false;if(!I$1)return Fg$1(a),I$1=true,false;var b;(b=3!==a.tag)&&!(b=5!==a.tag)&&(b=a.type,b="head"!==b&&"body"!==b&&!Ef$1(a.type,a.memoizedProps));if(b&&(b=yg$1)){if(Dg$1(a))throw Hg$1(),Error(p$2(418));for(;b;)Ag$1(a,b),b=Lf$1(b.nextSibling);}Fg$1(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(p$2(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if("/$"===c){if(0===b){yg$1=Lf$1(a.nextSibling);break a}b--;}else "$"!==c&&"$!"!==c&&"$?"!==c||b++;}a=a.nextSibling;}yg$1=
null;}}else yg$1=xg$1?Lf$1(a.stateNode.nextSibling):null;return  true}function Hg$1(){for(var a=yg$1;a;)a=Lf$1(a.nextSibling);}function Ig(){yg$1=xg$1=null;I$1=false;}function Jg$1(a){null===zg?zg=[a]:zg.push(a);}var Kg$1=ua$1.ReactCurrentBatchConfig;
function Lg(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(p$2(309));var d=c.stateNode;}if(!d)throw Error(p$2(147,a));var e=d,f=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===f)return b.ref;b=function(a){var b=e.refs;null===a?delete b[f]:b[f]=a;};b._stringRef=f;return b}if("string"!==typeof a)throw Error(p$2(284));if(!c._owner)throw Error(p$2(290,a));}return a}
function Mg$1(a,b){a=Object.prototype.toString.call(b);throw Error(p$2(31,"[object Object]"===a?"object with keys {"+Object.keys(b).join(", ")+"}":a));}function Ng$1(a){var b=a._init;return b(a._payload)}
function Og$1(a){function b(b,c){if(a){var d=b.deletions;null===d?(b.deletions=[c],b.flags|=16):d.push(c);}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b){a=Pg$1(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return b.flags|=1048576,c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.flags|=2,c):d;b.flags|=2;return c}function g(b){a&&
null===b.alternate&&(b.flags|=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=Qg$1(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function k(a,b,c,d){var f=c.type;if(f===ya$1)return m(a,b,c.props.children,d,c.key);if(null!==b&&(b.elementType===f||"object"===typeof f&&null!==f&&f.$$typeof===Ha$1&&Ng$1(f)===b.type))return d=e(b,c.props),d.ref=Lg(a,b,c),d.return=a,d;d=Rg$1(c.type,c.key,c.props,null,a.mode,d);d.ref=Lg(a,b,c);d.return=a;return d}function l(a,b,c,d){if(null===b||4!==b.tag||
b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=Sg$1(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function m(a,b,c,d,f){if(null===b||7!==b.tag)return b=Tg$1(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function q(a,b,c){if("string"===typeof b&&""!==b||"number"===typeof b)return b=Qg$1(""+b,a.mode,c),b.return=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case va$1:return c=Rg$1(b.type,b.key,b.props,null,a.mode,c),
c.ref=Lg(a,null,b),c.return=a,c;case wa$1:return b=Sg$1(b,a.mode,c),b.return=a,b;case Ha$1:var d=b._init;return q(a,d(b._payload),c)}if(eb$1(b)||Ka$1(b))return b=Tg$1(b,a.mode,c,null),b.return=a,b;Mg$1(a,b);}return null}function r(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c&&""!==c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case va$1:return c.key===e?k(a,b,c,d):null;case wa$1:return c.key===e?l(a,b,c,d):null;case Ha$1:return e=c._init,r(a,
b,e(c._payload),d)}if(eb$1(c)||Ka$1(c))return null!==e?null:m(a,b,c,d,null);Mg$1(a,c);}return null}function y(a,b,c,d,e){if("string"===typeof d&&""!==d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case va$1:return a=a.get(null===d.key?c:d.key)||null,k(b,a,d,e);case wa$1:return a=a.get(null===d.key?c:d.key)||null,l(b,a,d,e);case Ha$1:var f=d._init;return y(a,b,c,f(d._payload),e)}if(eb$1(d)||Ka$1(d))return a=a.get(c)||null,m(b,a,d,e,null);Mg$1(b,d);}return null}
function n(e,g,h,k){for(var l=null,m=null,u=g,w=g=0,x=null;null!==u&&w<h.length;w++){u.index>w?(x=u,u=null):x=u.sibling;var n=r(e,u,h[w],k);if(null===n){null===u&&(u=x);break}a&&u&&null===n.alternate&&b(e,u);g=f(n,g,w);null===m?l=n:m.sibling=n;m=n;u=x;}if(w===h.length)return c(e,u),I$1&&tg$1(e,w),l;if(null===u){for(;w<h.length;w++)u=q(e,h[w],k),null!==u&&(g=f(u,g,w),null===m?l=u:m.sibling=u,m=u);I$1&&tg$1(e,w);return l}for(u=d(e,u);w<h.length;w++)x=y(u,e,w,h[w],k),null!==x&&(a&&null!==x.alternate&&u.delete(null===
x.key?w:x.key),g=f(x,g,w),null===m?l=x:m.sibling=x,m=x);a&&u.forEach(function(a){return b(e,a)});I$1&&tg$1(e,w);return l}function t(e,g,h,k){var l=Ka$1(h);if("function"!==typeof l)throw Error(p$2(150));h=l.call(h);if(null==h)throw Error(p$2(151));for(var u=l=null,m=g,w=g=0,x=null,n=h.next();null!==m&&!n.done;w++,n=h.next()){m.index>w?(x=m,m=null):x=m.sibling;var t=r(e,m,n.value,k);if(null===t){null===m&&(m=x);break}a&&m&&null===t.alternate&&b(e,m);g=f(t,g,w);null===u?l=t:u.sibling=t;u=t;m=x;}if(n.done)return c(e,
m),I$1&&tg$1(e,w),l;if(null===m){for(;!n.done;w++,n=h.next())n=q(e,n.value,k),null!==n&&(g=f(n,g,w),null===u?l=n:u.sibling=n,u=n);I$1&&tg$1(e,w);return l}for(m=d(e,m);!n.done;w++,n=h.next())n=y(m,e,w,n.value,k),null!==n&&(a&&null!==n.alternate&&m.delete(null===n.key?w:n.key),g=f(n,g,w),null===u?l=n:u.sibling=n,u=n);a&&m.forEach(function(a){return b(e,a)});I$1&&tg$1(e,w);return l}function J(a,d,f,h){"object"===typeof f&&null!==f&&f.type===ya$1&&null===f.key&&(f=f.props.children);if("object"===typeof f&&null!==f){switch(f.$$typeof){case va$1:a:{for(var k=
f.key,l=d;null!==l;){if(l.key===k){k=f.type;if(k===ya$1){if(7===l.tag){c(a,l.sibling);d=e(l,f.props.children);d.return=a;a=d;break a}}else if(l.elementType===k||"object"===typeof k&&null!==k&&k.$$typeof===Ha$1&&Ng$1(k)===l.type){c(a,l.sibling);d=e(l,f.props);d.ref=Lg(a,l,f);d.return=a;a=d;break a}c(a,l);break}else b(a,l);l=l.sibling;}f.type===ya$1?(d=Tg$1(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Rg$1(f.type,f.key,f.props,null,a.mode,h),h.ref=Lg(a,d,f),h.return=a,a=h);}return g(a);case wa$1:a:{for(l=f.key;null!==
d;){if(d.key===l)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else {c(a,d);break}else b(a,d);d=d.sibling;}d=Sg$1(f,a.mode,h);d.return=a;a=d;}return g(a);case Ha$1:return l=f._init,J(a,d,l(f._payload),h)}if(eb$1(f))return n(a,d,f,h);if(Ka$1(f))return t(a,d,f,h);Mg$1(a,f);}return "string"===typeof f&&""!==f||"number"===typeof f?(f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):
(c(a,d),d=Qg$1(f,a.mode,h),d.return=a,a=d),g(a)):c(a,d)}return J}var Ug$1=Og$1(true),Vg=Og$1(false),Wg=Uf$1(null),Xg$1=null,Yg$1=null,Zg$1=null;function $g(){Zg$1=Yg$1=Xg$1=null;}function ah$1(a){var b=Wg.current;E$1(Wg);a._currentValue=b;}function bh$1(a,b,c){for(;null!==a;){var d=a.alternate;(a.childLanes&b)!==b?(a.childLanes|=b,null!==d&&(d.childLanes|=b)):null!==d&&(d.childLanes&b)!==b&&(d.childLanes|=b);if(a===c)break;a=a.return;}}
function ch$1(a,b){Xg$1=a;Zg$1=Yg$1=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(0!==(a.lanes&b)&&(dh$1=true),a.firstContext=null);}function eh$1(a){var b=a._currentValue;if(Zg$1!==a)if(a={context:a,memoizedValue:b,next:null},null===Yg$1){if(null===Xg$1)throw Error(p$2(308));Yg$1=a;Xg$1.dependencies={lanes:0,firstContext:a};}else Yg$1=Yg$1.next=a;return b}var fh$1=null;function gh$1(a){null===fh$1?fh$1=[a]:fh$1.push(a);}
function hh$1(a,b,c,d){var e=b.interleaved;null===e?(c.next=c,gh$1(b)):(c.next=e.next,e.next=c);b.interleaved=c;return ih$1(a,d)}function ih$1(a,b){a.lanes|=b;var c=a.alternate;null!==c&&(c.lanes|=b);c=a;for(a=a.return;null!==a;)a.childLanes|=b,c=a.alternate,null!==c&&(c.childLanes|=b),c=a,a=a.return;return 3===c.tag?c.stateNode:null}var jh$1=false;function kh(a){a.updateQueue={baseState:a.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null};}
function lh$1(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,firstBaseUpdate:a.firstBaseUpdate,lastBaseUpdate:a.lastBaseUpdate,shared:a.shared,effects:a.effects});}function mh$1(a,b){return {eventTime:a,lane:b,tag:0,payload:null,callback:null,next:null}}
function nh$1(a,b,c){var d=a.updateQueue;if(null===d)return null;d=d.shared;if(0!==(K$1&2)){var e=d.pending;null===e?b.next=b:(b.next=e.next,e.next=b);d.pending=b;return ih$1(a,c)}e=d.interleaved;null===e?(b.next=b,gh$1(d)):(b.next=e.next,e.next=b);d.interleaved=b;return ih$1(a,c)}function oh$1(a,b,c){b=b.updateQueue;if(null!==b&&(b=b.shared,0!==(c&4194240))){var d=b.lanes;d&=a.pendingLanes;c|=d;b.lanes=c;Cc$1(a,c);}}
function ph$1(a,b){var c=a.updateQueue,d=a.alternate;if(null!==d&&(d=d.updateQueue,c===d)){var e=null,f=null;c=c.firstBaseUpdate;if(null!==c){do{var g={eventTime:c.eventTime,lane:c.lane,tag:c.tag,payload:c.payload,callback:c.callback,next:null};null===f?e=f=g:f=f.next=g;c=c.next;}while(null!==c);null===f?e=f=b:f=f.next=b;}else e=f=b;c={baseState:d.baseState,firstBaseUpdate:e,lastBaseUpdate:f,shared:d.shared,effects:d.effects};a.updateQueue=c;return}a=c.lastBaseUpdate;null===a?c.firstBaseUpdate=b:a.next=
b;c.lastBaseUpdate=b;}
function qh$1(a,b,c,d){var e=a.updateQueue;jh$1=false;var f=e.firstBaseUpdate,g=e.lastBaseUpdate,h=e.shared.pending;if(null!==h){e.shared.pending=null;var k=h,l=k.next;k.next=null;null===g?f=l:g.next=l;g=k;var m=a.alternate;null!==m&&(m=m.updateQueue,h=m.lastBaseUpdate,h!==g&&(null===h?m.firstBaseUpdate=l:h.next=l,m.lastBaseUpdate=k));}if(null!==f){var q=e.baseState;g=0;m=l=k=null;h=f;do{var r=h.lane,y=h.eventTime;if((d&r)===r){null!==m&&(m=m.next={eventTime:y,lane:0,tag:h.tag,payload:h.payload,callback:h.callback,
next:null});a:{var n=a,t=h;r=b;y=c;switch(t.tag){case 1:n=t.payload;if("function"===typeof n){q=n.call(y,q,r);break a}q=n;break a;case 3:n.flags=n.flags&-65537|128;case 0:n=t.payload;r="function"===typeof n?n.call(y,q,r):n;if(null===r||void 0===r)break a;q=A$2({},q,r);break a;case 2:jh$1=true;}}null!==h.callback&&0!==h.lane&&(a.flags|=64,r=e.effects,null===r?e.effects=[h]:r.push(h));}else y={eventTime:y,lane:r,tag:h.tag,payload:h.payload,callback:h.callback,next:null},null===m?(l=m=y,k=q):m=m.next=y,g|=r;
h=h.next;if(null===h)if(h=e.shared.pending,null===h)break;else r=h,h=r.next,r.next=null,e.lastBaseUpdate=r,e.shared.pending=null;}while(1);null===m&&(k=q);e.baseState=k;e.firstBaseUpdate=l;e.lastBaseUpdate=m;b=e.shared.interleaved;if(null!==b){e=b;do g|=e.lane,e=e.next;while(e!==b)}else null===f&&(e.shared.lanes=0);rh$1|=g;a.lanes=g;a.memoizedState=q;}}
function sh$1(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=c;if("function"!==typeof e)throw Error(p$2(191,e));e.call(d);}}}var th$1={},uh$1=Uf$1(th$1),vh$1=Uf$1(th$1),wh=Uf$1(th$1);function xh$1(a){if(a===th$1)throw Error(p$2(174));return a}
function yh$1(a,b){G$1(wh,b);G$1(vh$1,a);G$1(uh$1,th$1);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:lb$1(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=lb$1(b,a);}E$1(uh$1);G$1(uh$1,b);}function zh$1(){E$1(uh$1);E$1(vh$1);E$1(wh);}function Ah$1(a){xh$1(wh.current);var b=xh$1(uh$1.current);var c=lb$1(b,a.type);b!==c&&(G$1(vh$1,a),G$1(uh$1,c));}function Bh$1(a){vh$1.current===a&&(E$1(uh$1),E$1(vh$1));}var L$1=Uf$1(0);
function Ch(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||"$?"===c.data||"$!"===c.data))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.flags&128))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return;}b.sibling.return=b.return;b=b.sibling;}return null}var Dh=[];
function Eh$1(){for(var a=0;a<Dh.length;a++)Dh[a]._workInProgressVersionPrimary=null;Dh.length=0;}var Fh$1=ua$1.ReactCurrentDispatcher,Gh$1=ua$1.ReactCurrentBatchConfig,Hh$1=0,M$1=null,N$1=null,O$1=null,Ih$1=false,Jh$1=false,Kh$1=0,Lh$1=0;function P$1(){throw Error(p$2(321));}function Mh(a,b){if(null===b)return  false;for(var c=0;c<b.length&&c<a.length;c++)if(!He$1(a[c],b[c]))return  false;return  true}
function Nh$1(a,b,c,d,e,f){Hh$1=f;M$1=b;b.memoizedState=null;b.updateQueue=null;b.lanes=0;Fh$1.current=null===a||null===a.memoizedState?Oh:Ph$1;a=c(d,e);if(Jh$1){f=0;do{Jh$1=false;Kh$1=0;if(25<=f)throw Error(p$2(301));f+=1;O$1=N$1=null;b.updateQueue=null;Fh$1.current=Qh$1;a=c(d,e);}while(Jh$1)}Fh$1.current=Rh$1;b=null!==N$1&&null!==N$1.next;Hh$1=0;O$1=N$1=M$1=null;Ih$1=false;if(b)throw Error(p$2(300));return a}function Sh$1(){var a=0!==Kh$1;Kh$1=0;return a}
function Th$1(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===O$1?M$1.memoizedState=O$1=a:O$1=O$1.next=a;return O$1}function Uh$1(){if(null===N$1){var a=M$1.alternate;a=null!==a?a.memoizedState:null;}else a=N$1.next;var b=null===O$1?M$1.memoizedState:O$1.next;if(null!==b)O$1=b,N$1=a;else {if(null===a)throw Error(p$2(310));N$1=a;a={memoizedState:N$1.memoizedState,baseState:N$1.baseState,baseQueue:N$1.baseQueue,queue:N$1.queue,next:null};null===O$1?M$1.memoizedState=O$1=a:O$1=O$1.next=a;}return O$1}
function Vh(a,b){return "function"===typeof b?b(a):b}
function Wh$1(a){var b=Uh$1(),c=b.queue;if(null===c)throw Error(p$2(311));c.lastRenderedReducer=a;var d=N$1,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g;}d.baseQueue=e=f;c.pending=null;}if(null!==e){f=e.next;d=d.baseState;var h=g=null,k=null,l=f;do{var m=l.lane;if((Hh$1&m)===m)null!==k&&(k=k.next={lane:0,action:l.action,hasEagerState:l.hasEagerState,eagerState:l.eagerState,next:null}),d=l.hasEagerState?l.eagerState:a(d,l.action);else {var q={lane:m,action:l.action,hasEagerState:l.hasEagerState,
eagerState:l.eagerState,next:null};null===k?(h=k=q,g=d):k=k.next=q;M$1.lanes|=m;rh$1|=m;}l=l.next;}while(null!==l&&l!==f);null===k?g=d:k.next=h;He$1(d,b.memoizedState)||(dh$1=true);b.memoizedState=d;b.baseState=g;b.baseQueue=k;c.lastRenderedState=d;}a=c.interleaved;if(null!==a){e=a;do f=e.lane,M$1.lanes|=f,rh$1|=f,e=e.next;while(e!==a)}else null===e&&(c.lanes=0);return [b.memoizedState,c.dispatch]}
function Xh$1(a){var b=Uh$1(),c=b.queue;if(null===c)throw Error(p$2(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);He$1(f,b.memoizedState)||(dh$1=true);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f;}return [f,d]}function Yh(){}
function Zh$1(a,b){var c=M$1,d=Uh$1(),e=b(),f=!He$1(d.memoizedState,e);f&&(d.memoizedState=e,dh$1=true);d=d.queue;$h$1(ai$1.bind(null,c,d,a),[a]);if(d.getSnapshot!==b||f||null!==O$1&&O$1.memoizedState.tag&1){c.flags|=2048;bi$1(9,ci$1.bind(null,c,d,e,b),void 0,null);if(null===Q$1)throw Error(p$2(349));0!==(Hh$1&30)||di$1(c,b,e);}return e}function di$1(a,b,c){a.flags|=16384;a={getSnapshot:b,value:c};b=M$1.updateQueue;null===b?(b={lastEffect:null,stores:null},M$1.updateQueue=b,b.stores=[a]):(c=b.stores,null===c?b.stores=[a]:c.push(a));}
function ci$1(a,b,c,d){b.value=c;b.getSnapshot=d;ei$1(b)&&fi$1(a);}function ai$1(a,b,c){return c(function(){ei$1(b)&&fi$1(a);})}function ei$1(a){var b=a.getSnapshot;a=a.value;try{var c=b();return !He$1(a,c)}catch(d){return  true}}function fi$1(a){var b=ih$1(a,1);null!==b&&gi$1(b,a,1,-1);}
function hi$1(a){var b=Th$1();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Vh,lastRenderedState:a};b.queue=a;a=a.dispatch=ii$1.bind(null,M$1,a);return [b.memoizedState,a]}
function bi$1(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=M$1.updateQueue;null===b?(b={lastEffect:null,stores:null},M$1.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function ji$1(){return Uh$1().memoizedState}function ki$1(a,b,c,d){var e=Th$1();M$1.flags|=a;e.memoizedState=bi$1(1|b,c,void 0,void 0===d?null:d);}
function li$1(a,b,c,d){var e=Uh$1();d=void 0===d?null:d;var f=void 0;if(null!==N$1){var g=N$1.memoizedState;f=g.destroy;if(null!==d&&Mh(d,g.deps)){e.memoizedState=bi$1(b,c,f,d);return}}M$1.flags|=a;e.memoizedState=bi$1(1|b,c,f,d);}function mi$1(a,b){return ki$1(8390656,8,a,b)}function $h$1(a,b){return li$1(2048,8,a,b)}function ni$1(a,b){return li$1(4,2,a,b)}function oi$1(a,b){return li$1(4,4,a,b)}
function pi$1(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null);};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null;}}function qi$1(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return li$1(4,4,pi$1.bind(null,b,a),c)}function ri$1(){}function si(a,b){var c=Uh$1();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Mh(b,d[1]))return d[0];c.memoizedState=[a,b];return a}
function ti$1(a,b){var c=Uh$1();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Mh(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function ui$1(a,b,c){if(0===(Hh$1&21))return a.baseState&&(a.baseState=false,dh$1=true),a.memoizedState=c;He$1(c,b)||(c=yc$1(),M$1.lanes|=c,rh$1|=c,a.baseState=true);return b}function vi$1(a,b){var c=C$1;C$1=0!==c&&4>c?c:4;a(true);var d=Gh$1.transition;Gh$1.transition={};try{a(!1),b();}finally{C$1=c,Gh$1.transition=d;}}function wi$1(){return Uh$1().memoizedState}
function xi$1(a,b,c){var d=yi$1(a);c={lane:d,action:c,hasEagerState:false,eagerState:null,next:null};if(zi$1(a))Ai$1(b,c);else if(c=hh$1(a,b,c,d),null!==c){var e=R$1();gi$1(c,a,d,e);Bi$1(c,b,d);}}
function ii$1(a,b,c){var d=yi$1(a),e={lane:d,action:c,hasEagerState:false,eagerState:null,next:null};if(zi$1(a))Ai$1(b,e);else {var f=a.alternate;if(0===a.lanes&&(null===f||0===f.lanes)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,h=f(g,c);e.hasEagerState=!0;e.eagerState=h;if(He$1(h,g)){var k=b.interleaved;null===k?(e.next=e,gh$1(b)):(e.next=k.next,k.next=e);b.interleaved=e;return}}catch(l){}finally{}c=hh$1(a,b,e,d);null!==c&&(e=R$1(),gi$1(c,a,d,e),Bi$1(c,b,d));}}
function zi$1(a){var b=a.alternate;return a===M$1||null!==b&&b===M$1}function Ai$1(a,b){Jh$1=Ih$1=true;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b;}function Bi$1(a,b,c){if(0!==(c&4194240)){var d=b.lanes;d&=a.pendingLanes;c|=d;b.lanes=c;Cc$1(a,c);}}
var Rh$1={readContext:eh$1,useCallback:P$1,useContext:P$1,useEffect:P$1,useImperativeHandle:P$1,useInsertionEffect:P$1,useLayoutEffect:P$1,useMemo:P$1,useReducer:P$1,useRef:P$1,useState:P$1,useDebugValue:P$1,useDeferredValue:P$1,useTransition:P$1,useMutableSource:P$1,useSyncExternalStore:P$1,useId:P$1,unstable_isNewReconciler:false},Oh={readContext:eh$1,useCallback:function(a,b){Th$1().memoizedState=[a,void 0===b?null:b];return a},useContext:eh$1,useEffect:mi$1,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ki$1(4194308,
4,pi$1.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ki$1(4194308,4,a,b)},useInsertionEffect:function(a,b){return ki$1(4,2,a,b)},useMemo:function(a,b){var c=Th$1();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=Th$1();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};d.queue=a;a=a.dispatch=xi$1.bind(null,M$1,a);return [d.memoizedState,a]},useRef:function(a){var b=
Th$1();a={current:a};return b.memoizedState=a},useState:hi$1,useDebugValue:ri$1,useDeferredValue:function(a){return Th$1().memoizedState=a},useTransition:function(){var a=hi$1(false),b=a[0];a=vi$1.bind(null,a[1]);Th$1().memoizedState=a;return [b,a]},useMutableSource:function(){},useSyncExternalStore:function(a,b,c){var d=M$1,e=Th$1();if(I$1){if(void 0===c)throw Error(p$2(407));c=c();}else {c=b();if(null===Q$1)throw Error(p$2(349));0!==(Hh$1&30)||di$1(d,b,c);}e.memoizedState=c;var f={value:c,getSnapshot:b};e.queue=f;mi$1(ai$1.bind(null,d,
f,a),[a]);d.flags|=2048;bi$1(9,ci$1.bind(null,d,f,c,b),void 0,null);return c},useId:function(){var a=Th$1(),b=Q$1.identifierPrefix;if(I$1){var c=sg$1;var d=rg$1;c=(d&~(1<<32-oc$1(d)-1)).toString(32)+c;b=":"+b+"R"+c;c=Kh$1++;0<c&&(b+="H"+c.toString(32));b+=":";}else c=Lh$1++,b=":"+b+"r"+c.toString(32)+":";return a.memoizedState=b},unstable_isNewReconciler:false},Ph$1={readContext:eh$1,useCallback:si,useContext:eh$1,useEffect:$h$1,useImperativeHandle:qi$1,useInsertionEffect:ni$1,useLayoutEffect:oi$1,useMemo:ti$1,useReducer:Wh$1,useRef:ji$1,useState:function(){return Wh$1(Vh)},
useDebugValue:ri$1,useDeferredValue:function(a){var b=Uh$1();return ui$1(b,N$1.memoizedState,a)},useTransition:function(){var a=Wh$1(Vh)[0],b=Uh$1().memoizedState;return [a,b]},useMutableSource:Yh,useSyncExternalStore:Zh$1,useId:wi$1,unstable_isNewReconciler:false},Qh$1={readContext:eh$1,useCallback:si,useContext:eh$1,useEffect:$h$1,useImperativeHandle:qi$1,useInsertionEffect:ni$1,useLayoutEffect:oi$1,useMemo:ti$1,useReducer:Xh$1,useRef:ji$1,useState:function(){return Xh$1(Vh)},useDebugValue:ri$1,useDeferredValue:function(a){var b=Uh$1();return null===
N$1?b.memoizedState=a:ui$1(b,N$1.memoizedState,a)},useTransition:function(){var a=Xh$1(Vh)[0],b=Uh$1().memoizedState;return [a,b]},useMutableSource:Yh,useSyncExternalStore:Zh$1,useId:wi$1,unstable_isNewReconciler:false};function Ci$1(a,b){if(a&&a.defaultProps){b=A$2({},b);a=a.defaultProps;for(var c in a) void 0===b[c]&&(b[c]=a[c]);return b}return b}function Di$1(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:A$2({},b,c);a.memoizedState=c;0===a.lanes&&(a.updateQueue.baseState=c);}
var Ei$1={isMounted:function(a){return (a=a._reactInternals)?Vb$1(a)===a:false},enqueueSetState:function(a,b,c){a=a._reactInternals;var d=R$1(),e=yi$1(a),f=mh$1(d,e);f.payload=b;void 0!==c&&null!==c&&(f.callback=c);b=nh$1(a,f,e);null!==b&&(gi$1(b,a,e,d),oh$1(b,a,e));},enqueueReplaceState:function(a,b,c){a=a._reactInternals;var d=R$1(),e=yi$1(a),f=mh$1(d,e);f.tag=1;f.payload=b;void 0!==c&&null!==c&&(f.callback=c);b=nh$1(a,f,e);null!==b&&(gi$1(b,a,e,d),oh$1(b,a,e));},enqueueForceUpdate:function(a,b){a=a._reactInternals;var c=R$1(),d=
yi$1(a),e=mh$1(c,d);e.tag=2;void 0!==b&&null!==b&&(e.callback=b);b=nh$1(a,e,d);null!==b&&(gi$1(b,a,d,c),oh$1(b,a,d));}};function Fi$1(a,b,c,d,e,f,g){a=a.stateNode;return "function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,g):b.prototype&&b.prototype.isPureReactComponent?!Ie$1(c,d)||!Ie$1(e,f):true}
function Gi$1(a,b,c){var d=false,e=Vf$1;var f=b.contextType;"object"===typeof f&&null!==f?f=eh$1(f):(e=Zf$1(b)?Xf$1:H$1.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?Yf$1(a,e):Vf$1);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Ei$1;a.stateNode=b;b._reactInternals=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}
function Hi$1(a,b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Ei$1.enqueueReplaceState(b,b.state,null);}
function Ii$1(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs={};kh(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=eh$1(f):(f=Zf$1(b)?Xf$1:H$1.current,e.context=Yf$1(a,f));e.state=a.memoizedState;f=b.getDerivedStateFromProps;"function"===typeof f&&(Di$1(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,
"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Ei$1.enqueueReplaceState(e,e.state,null),qh$1(a,c,e,d),e.state=a.memoizedState);"function"===typeof e.componentDidMount&&(a.flags|=4194308);}function Ji(a,b){try{var c="",d=b;do c+=Pa$1(d),d=d.return;while(d);var e=c;}catch(f){e="\nError generating stack: "+f.message+"\n"+f.stack;}return {value:a,source:b,stack:e,digest:null}}
function Ki$1(a,b,c){return {value:a,source:null,stack:null!=c?c:null,digest:null!=b?b:null}}function Li$1(a,b){try{console.error(b.value);}catch(c){setTimeout(function(){throw c;});}}var Mi$1="function"===typeof WeakMap?WeakMap:Map;function Ni$1(a,b,c){c=mh$1(-1,c);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){Oi$1||(Oi$1=true,Pi=d);Li$1(a,b);};return c}
function Qi$1(a,b,c){c=mh$1(-1,c);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){return d(e)};c.callback=function(){Li$1(a,b);};}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){Li$1(a,b);"function"!==typeof d&&(null===Ri$1?Ri$1=new Set([this]):Ri$1.add(this));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""});});return c}
function Si$1(a,b,c){var d=a.pingCache;if(null===d){d=a.pingCache=new Mi$1;var e=new Set;d.set(b,e);}else e=d.get(b),void 0===e&&(e=new Set,d.set(b,e));e.has(c)||(e.add(c),a=Ti$1.bind(null,a,b,c),b.then(a,a));}function Ui$1(a){do{var b;if(b=13===a.tag)b=a.memoizedState,b=null!==b?null!==b.dehydrated?true:false:true;if(b)return a;a=a.return;}while(null!==a);return null}
function Vi$1(a,b,c,d,e){if(0===(a.mode&1))return a===b?a.flags|=65536:(a.flags|=128,c.flags|=131072,c.flags&=-52805,1===c.tag&&(null===c.alternate?c.tag=17:(b=mh$1(-1,1),b.tag=2,nh$1(c,b,1))),c.lanes|=1),a;a.flags|=65536;a.lanes=e;return a}var Wi$1=ua$1.ReactCurrentOwner,dh$1=false;function Xi$1(a,b,c,d){b.child=null===a?Vg(b,null,c,d):Ug$1(b,a.child,c,d);}
function Yi$1(a,b,c,d,e){c=c.render;var f=b.ref;ch$1(b,e);d=Nh$1(a,b,c,d,f,e);c=Sh$1();if(null!==a&&!dh$1)return b.updateQueue=a.updateQueue,b.flags&=-2053,a.lanes&=~e,Zi$1(a,b,e);I$1&&c&&vg$1(b);b.flags|=1;Xi$1(a,b,d,e);return b.child}
function $i$1(a,b,c,d,e){if(null===a){var f=c.type;if("function"===typeof f&&!aj(f)&&void 0===f.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=f,bj(a,b,f,d,e);a=Rg$1(c.type,null,d,b,b.mode,e);a.ref=b.ref;a.return=b;return b.child=a}f=a.child;if(0===(a.lanes&e)){var g=f.memoizedProps;c=c.compare;c=null!==c?c:Ie$1;if(c(g,d)&&a.ref===b.ref)return Zi$1(a,b,e)}b.flags|=1;a=Pg$1(f,d);a.ref=b.ref;a.return=b;return b.child=a}
function bj(a,b,c,d,e){if(null!==a){var f=a.memoizedProps;if(Ie$1(f,d)&&a.ref===b.ref)if(dh$1=false,b.pendingProps=d=f,0!==(a.lanes&e))0!==(a.flags&131072)&&(dh$1=true);else return b.lanes=a.lanes,Zi$1(a,b,e)}return cj(a,b,c,d,e)}
function dj(a,b,c){var d=b.pendingProps,e=d.children,f=null!==a?a.memoizedState:null;if("hidden"===d.mode)if(0===(b.mode&1))b.memoizedState={baseLanes:0,cachePool:null,transitions:null},G$1(ej,fj),fj|=c;else {if(0===(c&1073741824))return a=null!==f?f.baseLanes|c:c,b.lanes=b.childLanes=1073741824,b.memoizedState={baseLanes:a,cachePool:null,transitions:null},b.updateQueue=null,G$1(ej,fj),fj|=a,null;b.memoizedState={baseLanes:0,cachePool:null,transitions:null};d=null!==f?f.baseLanes:c;G$1(ej,fj);fj|=d;}else null!==
f?(d=f.baseLanes|c,b.memoizedState=null):d=c,G$1(ej,fj),fj|=d;Xi$1(a,b,e,c);return b.child}function gj(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.flags|=512,b.flags|=2097152;}function cj(a,b,c,d,e){var f=Zf$1(c)?Xf$1:H$1.current;f=Yf$1(b,f);ch$1(b,e);c=Nh$1(a,b,c,d,f,e);d=Sh$1();if(null!==a&&!dh$1)return b.updateQueue=a.updateQueue,b.flags&=-2053,a.lanes&=~e,Zi$1(a,b,e);I$1&&d&&vg$1(b);b.flags|=1;Xi$1(a,b,c,e);return b.child}
function hj(a,b,c,d,e){if(Zf$1(c)){var f=true;cg$1(b);}else f=false;ch$1(b,e);if(null===b.stateNode)ij(a,b),Gi$1(b,c,d),Ii$1(b,c,d,e),d=true;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var k=g.context,l=c.contextType;"object"===typeof l&&null!==l?l=eh$1(l):(l=Zf$1(c)?Xf$1:H$1.current,l=Yf$1(b,l));var m=c.getDerivedStateFromProps,q="function"===typeof m||"function"===typeof g.getSnapshotBeforeUpdate;q||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||
(h!==d||k!==l)&&Hi$1(b,g,d,l);jh$1=false;var r=b.memoizedState;g.state=r;qh$1(b,d,g,e);k=b.memoizedState;h!==d||r!==k||Wf.current||jh$1?("function"===typeof m&&(Di$1(b,c,m,d),k=b.memoizedState),(h=jh$1||Fi$1(b,c,h,d,r,k,l))?(q||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.flags|=4194308)):
("function"===typeof g.componentDidMount&&(b.flags|=4194308),b.memoizedProps=d,b.memoizedState=k),g.props=d,g.state=k,g.context=l,d=h):("function"===typeof g.componentDidMount&&(b.flags|=4194308),d=false);}else {g=b.stateNode;lh$1(a,b);h=b.memoizedProps;l=b.type===b.elementType?h:Ci$1(b.type,h);g.props=l;q=b.pendingProps;r=g.context;k=c.contextType;"object"===typeof k&&null!==k?k=eh$1(k):(k=Zf$1(c)?Xf$1:H$1.current,k=Yf$1(b,k));var y=c.getDerivedStateFromProps;(m="function"===typeof y||"function"===typeof g.getSnapshotBeforeUpdate)||
"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==q||r!==k)&&Hi$1(b,g,d,k);jh$1=false;r=b.memoizedState;g.state=r;qh$1(b,d,g,e);var n=b.memoizedState;h!==q||r!==n||Wf.current||jh$1?("function"===typeof y&&(Di$1(b,c,y,d),n=b.memoizedState),(l=jh$1||Fi$1(b,c,l,d,r,n,k)||false)?(m||"function"!==typeof g.UNSAFE_componentWillUpdate&&"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,n,k),"function"===typeof g.UNSAFE_componentWillUpdate&&
g.UNSAFE_componentWillUpdate(d,n,k)),"function"===typeof g.componentDidUpdate&&(b.flags|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.flags|=1024)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=1024),b.memoizedProps=d,b.memoizedState=n),g.props=d,g.state=n,g.context=k,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&r===
a.memoizedState||(b.flags|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=1024),d=false);}return jj(a,b,c,d,f,e)}
function jj(a,b,c,d,e,f){gj(a,b);var g=0!==(b.flags&128);if(!d&&!g)return e&&dg$1(b,c,false),Zi$1(a,b,f);d=b.stateNode;Wi$1.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?null:d.render();b.flags|=1;null!==a&&g?(b.child=Ug$1(b,a.child,null,f),b.child=Ug$1(b,null,h,f)):Xi$1(a,b,h,f);b.memoizedState=d.state;e&&dg$1(b,c,true);return b.child}function kj(a){var b=a.stateNode;b.pendingContext?ag$1(a,b.pendingContext,b.pendingContext!==b.context):b.context&&ag$1(a,b.context,false);yh$1(a,b.containerInfo);}
function lj(a,b,c,d,e){Ig();Jg$1(e);b.flags|=256;Xi$1(a,b,c,d);return b.child}var mj={dehydrated:null,treeContext:null,retryLane:0};function nj(a){return {baseLanes:a,cachePool:null,transitions:null}}
function oj(a,b,c){var d=b.pendingProps,e=L$1.current,f=false,g=0!==(b.flags&128),h;(h=g)||(h=null!==a&&null===a.memoizedState?false:0!==(e&2));if(h)f=true,b.flags&=-129;else if(null===a||null!==a.memoizedState)e|=1;G$1(L$1,e&1);if(null===a){Eg$1(b);a=b.memoizedState;if(null!==a&&(a=a.dehydrated,null!==a))return 0===(b.mode&1)?b.lanes=1:"$!"===a.data?b.lanes=8:b.lanes=1073741824,null;g=d.children;a=d.fallback;return f?(d=b.mode,f=b.child,g={mode:"hidden",children:g},0===(d&1)&&null!==f?(f.childLanes=0,f.pendingProps=
g):f=pj(g,d,0,null),a=Tg$1(a,d,c,null),f.return=b,a.return=b,f.sibling=a,b.child=f,b.child.memoizedState=nj(c),b.memoizedState=mj,a):qj(b,g)}e=a.memoizedState;if(null!==e&&(h=e.dehydrated,null!==h))return rj(a,b,g,d,h,e,c);if(f){f=d.fallback;g=b.mode;e=a.child;h=e.sibling;var k={mode:"hidden",children:d.children};0===(g&1)&&b.child!==e?(d=b.child,d.childLanes=0,d.pendingProps=k,b.deletions=null):(d=Pg$1(e,k),d.subtreeFlags=e.subtreeFlags&14680064);null!==h?f=Pg$1(h,f):(f=Tg$1(f,g,c,null),f.flags|=2);f.return=
b;d.return=b;d.sibling=f;b.child=d;d=f;f=b.child;g=a.child.memoizedState;g=null===g?nj(c):{baseLanes:g.baseLanes|c,cachePool:null,transitions:g.transitions};f.memoizedState=g;f.childLanes=a.childLanes&~c;b.memoizedState=mj;return d}f=a.child;a=f.sibling;d=Pg$1(f,{mode:"visible",children:d.children});0===(b.mode&1)&&(d.lanes=c);d.return=b;d.sibling=null;null!==a&&(c=b.deletions,null===c?(b.deletions=[a],b.flags|=16):c.push(a));b.child=d;b.memoizedState=null;return d}
function qj(a,b){b=pj({mode:"visible",children:b},a.mode,0,null);b.return=a;return a.child=b}function sj(a,b,c,d){null!==d&&Jg$1(d);Ug$1(b,a.child,null,c);a=qj(b,b.pendingProps.children);a.flags|=2;b.memoizedState=null;return a}
function rj(a,b,c,d,e,f,g){if(c){if(b.flags&256)return b.flags&=-257,d=Ki$1(Error(p$2(422))),sj(a,b,g,d);if(null!==b.memoizedState)return b.child=a.child,b.flags|=128,null;f=d.fallback;e=b.mode;d=pj({mode:"visible",children:d.children},e,0,null);f=Tg$1(f,e,g,null);f.flags|=2;d.return=b;f.return=b;d.sibling=f;b.child=d;0!==(b.mode&1)&&Ug$1(b,a.child,null,g);b.child.memoizedState=nj(g);b.memoizedState=mj;return f}if(0===(b.mode&1))return sj(a,b,g,null);if("$!"===e.data){d=e.nextSibling&&e.nextSibling.dataset;
if(d)var h=d.dgst;d=h;f=Error(p$2(419));d=Ki$1(f,d,void 0);return sj(a,b,g,d)}h=0!==(g&a.childLanes);if(dh$1||h){d=Q$1;if(null!==d){switch(g&-g){case 4:e=2;break;case 16:e=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:e=32;break;case 536870912:e=268435456;break;default:e=0;}e=0!==(e&(d.suspendedLanes|g))?0:e;
0!==e&&e!==f.retryLane&&(f.retryLane=e,ih$1(a,e),gi$1(d,a,e,-1));}tj();d=Ki$1(Error(p$2(421)));return sj(a,b,g,d)}if("$?"===e.data)return b.flags|=128,b.child=a.child,b=uj.bind(null,a),e._reactRetry=b,null;a=f.treeContext;yg$1=Lf$1(e.nextSibling);xg$1=b;I$1=true;zg=null;null!==a&&(og$1[pg$1++]=rg$1,og$1[pg$1++]=sg$1,og$1[pg$1++]=qg,rg$1=a.id,sg$1=a.overflow,qg=b);b=qj(b,d.children);b.flags|=4096;return b}function vj(a,b,c){a.lanes|=b;var d=a.alternate;null!==d&&(d.lanes|=b);bh$1(a.return,b,c);}
function wj(a,b,c,d,e){var f=a.memoizedState;null===f?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailMode:e}:(f.isBackwards=b,f.rendering=null,f.renderingStartTime=0,f.last=d,f.tail=c,f.tailMode=e);}
function xj(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;Xi$1(a,b,d.children,c);d=L$1.current;if(0!==(d&2))d=d&1|2,b.flags|=128;else {if(null!==a&&0!==(a.flags&128))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&vj(a,c,b);else if(19===a.tag)vj(a,c,b);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===a.return||a.return===b)break a;a=a.return;}a.sibling.return=a.return;a=a.sibling;}d&=1;}G$1(L$1,d);if(0===(b.mode&1))b.memoizedState=
null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Ch(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);wj(b,false,e,c,f);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Ch(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a;}wj(b,true,c,null,f);break;case "together":wj(b,false,null,null,void 0);break;default:b.memoizedState=null;}return b.child}
function ij(a,b){0===(b.mode&1)&&null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2);}function Zi$1(a,b,c){null!==a&&(b.dependencies=a.dependencies);rh$1|=b.lanes;if(0===(c&b.childLanes))return null;if(null!==a&&b.child!==a.child)throw Error(p$2(153));if(null!==b.child){a=b.child;c=Pg$1(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Pg$1(a,a.pendingProps),c.return=b;c.sibling=null;}return b.child}
function yj(a,b,c){switch(b.tag){case 3:kj(b);Ig();break;case 5:Ah$1(b);break;case 1:Zf$1(b.type)&&cg$1(b);break;case 4:yh$1(b,b.stateNode.containerInfo);break;case 10:var d=b.type._context,e=b.memoizedProps.value;G$1(Wg,d._currentValue);d._currentValue=e;break;case 13:d=b.memoizedState;if(null!==d){if(null!==d.dehydrated)return G$1(L$1,L$1.current&1),b.flags|=128,null;if(0!==(c&b.child.childLanes))return oj(a,b,c);G$1(L$1,L$1.current&1);a=Zi$1(a,b,c);return null!==a?a.sibling:null}G$1(L$1,L$1.current&1);break;case 19:d=0!==(c&
b.childLanes);if(0!==(a.flags&128)){if(d)return xj(a,b,c);b.flags|=128;}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null,e.lastEffect=null);G$1(L$1,L$1.current);if(d)break;else return null;case 22:case 23:return b.lanes=0,dj(a,b,c)}return Zi$1(a,b,c)}var zj,Aj,Bj,Cj;
zj=function(a,b){for(var c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return;}c.sibling.return=c.return;c=c.sibling;}};Aj=function(){};
Bj=function(a,b,c,d){var e=a.memoizedProps;if(e!==d){a=b.stateNode;xh$1(uh$1.current);var f=null;switch(c){case "input":e=Ya$1(a,e);d=Ya$1(a,d);f=[];break;case "select":e=A$2({},e,{value:void 0});d=A$2({},d,{value:void 0});f=[];break;case "textarea":e=gb$1(a,e);d=gb$1(a,d);f=[];break;default:"function"!==typeof e.onClick&&"function"===typeof d.onClick&&(a.onclick=Bf$1);}ub$1(c,d);var g;c=null;for(l in e)if(!d.hasOwnProperty(l)&&e.hasOwnProperty(l)&&null!=e[l])if("style"===l){var h=e[l];for(g in h)h.hasOwnProperty(g)&&
(c||(c={}),c[g]="");}else "dangerouslySetInnerHTML"!==l&&"children"!==l&&"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&"autoFocus"!==l&&(ea$1.hasOwnProperty(l)?f||(f=[]):(f=f||[]).push(l,null));for(l in d){var k=d[l];h=null!=e?e[l]:void 0;if(d.hasOwnProperty(l)&&k!==h&&(null!=k||null!=h))if("style"===l)if(h){for(g in h)!h.hasOwnProperty(g)||k&&k.hasOwnProperty(g)||(c||(c={}),c[g]="");for(g in k)k.hasOwnProperty(g)&&h[g]!==k[g]&&(c||(c={}),c[g]=k[g]);}else c||(f||(f=[]),f.push(l,
c)),c=k;else "dangerouslySetInnerHTML"===l?(k=k?k.__html:void 0,h=h?h.__html:void 0,null!=k&&h!==k&&(f=f||[]).push(l,k)):"children"===l?"string"!==typeof k&&"number"!==typeof k||(f=f||[]).push(l,""+k):"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&(ea$1.hasOwnProperty(l)?(null!=k&&"onScroll"===l&&D$1("scroll",a),f||h===k||(f=[])):(f=f||[]).push(l,k));}c&&(f=f||[]).push("style",c);var l=f;if(b.updateQueue=l)b.flags|=4;}};Cj=function(a,b,c,d){c!==d&&(b.flags|=4);};
function Dj(a,b){if(!I$1)switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null;}}
function S(a){var b=null!==a.alternate&&a.alternate.child===a.child,c=0,d=0;if(b)for(var e=a.child;null!==e;)c|=e.lanes|e.childLanes,d|=e.subtreeFlags&14680064,d|=e.flags&14680064,e.return=a,e=e.sibling;else for(e=a.child;null!==e;)c|=e.lanes|e.childLanes,d|=e.subtreeFlags,d|=e.flags,e.return=a,e=e.sibling;a.subtreeFlags|=d;a.childLanes=c;return b}
function Ej(a,b,c){var d=b.pendingProps;wg$1(b);switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return S(b),null;case 1:return Zf$1(b.type)&&$f(),S(b),null;case 3:d=b.stateNode;zh$1();E$1(Wf);E$1(H$1);Eh$1();d.pendingContext&&(d.context=d.pendingContext,d.pendingContext=null);if(null===a||null===a.child)Gg$1(b)?b.flags|=4:null===a||a.memoizedState.isDehydrated&&0===(b.flags&256)||(b.flags|=1024,null!==zg&&(Fj(zg),zg=null));Aj(a,b);S(b);return null;case 5:Bh$1(b);var e=xh$1(wh.current);
c=b.type;if(null!==a&&null!=b.stateNode)Bj(a,b,c,d,e),a.ref!==b.ref&&(b.flags|=512,b.flags|=2097152);else {if(!d){if(null===b.stateNode)throw Error(p$2(166));S(b);return null}a=xh$1(uh$1.current);if(Gg$1(b)){d=b.stateNode;c=b.type;var f=b.memoizedProps;d[Of$1]=b;d[Pf$1]=f;a=0!==(b.mode&1);switch(c){case "dialog":D$1("cancel",d);D$1("close",d);break;case "iframe":case "object":case "embed":D$1("load",d);break;case "video":case "audio":for(e=0;e<lf.length;e++)D$1(lf[e],d);break;case "source":D$1("error",d);break;case "img":case "image":case "link":D$1("error",
d);D$1("load",d);break;case "details":D$1("toggle",d);break;case "input":Za$1(d,f);D$1("invalid",d);break;case "select":d._wrapperState={wasMultiple:!!f.multiple};D$1("invalid",d);break;case "textarea":hb$1(d,f),D$1("invalid",d);}ub$1(c,f);e=null;for(var g in f)if(f.hasOwnProperty(g)){var h=f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(true!==f.suppressHydrationWarning&&Af$1(d.textContent,h,a),e=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(true!==f.suppressHydrationWarning&&Af$1(d.textContent,
h,a),e=["children",""+h]):ea$1.hasOwnProperty(g)&&null!=h&&"onScroll"===g&&D$1("scroll",d);}switch(c){case "input":Va$1(d);db$1(d,f,true);break;case "textarea":Va$1(d);jb$1(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=Bf$1);}d=e;b.updateQueue=d;null!==d&&(b.flags|=4);}else {g=9===e.nodeType?e:e.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=kb$1(c));"http://www.w3.org/1999/xhtml"===a?"script"===c?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):
"string"===typeof d.is?a=g.createElement(c,{is:d.is}):(a=g.createElement(c),"select"===c&&(g=a,d.multiple?g.multiple=true:d.size&&(g.size=d.size))):a=g.createElementNS(a,c);a[Of$1]=b;a[Pf$1]=d;zj(a,b,false,false);b.stateNode=a;a:{g=vb$1(c,d);switch(c){case "dialog":D$1("cancel",a);D$1("close",a);e=d;break;case "iframe":case "object":case "embed":D$1("load",a);e=d;break;case "video":case "audio":for(e=0;e<lf.length;e++)D$1(lf[e],a);e=d;break;case "source":D$1("error",a);e=d;break;case "img":case "image":case "link":D$1("error",
a);D$1("load",a);e=d;break;case "details":D$1("toggle",a);e=d;break;case "input":Za$1(a,d);e=Ya$1(a,d);D$1("invalid",a);break;case "option":e=d;break;case "select":a._wrapperState={wasMultiple:!!d.multiple};e=A$2({},d,{value:void 0});D$1("invalid",a);break;case "textarea":hb$1(a,d);e=gb$1(a,d);D$1("invalid",a);break;default:e=d;}ub$1(c,e);h=e;for(f in h)if(h.hasOwnProperty(f)){var k=h[f];"style"===f?sb$1(a,k):"dangerouslySetInnerHTML"===f?(k=k?k.__html:void 0,null!=k&&nb$1(a,k)):"children"===f?"string"===typeof k?("textarea"!==
c||""!==k)&&ob$1(a,k):"number"===typeof k&&ob$1(a,""+k):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(ea$1.hasOwnProperty(f)?null!=k&&"onScroll"===f&&D$1("scroll",a):null!=k&&ta$1(a,f,k,g));}switch(c){case "input":Va$1(a);db$1(a,d,false);break;case "textarea":Va$1(a);jb$1(a);break;case "option":null!=d.value&&a.setAttribute("value",""+Sa$1(d.value));break;case "select":a.multiple=!!d.multiple;f=d.value;null!=f?fb$1(a,!!d.multiple,f,false):null!=d.defaultValue&&fb$1(a,!!d.multiple,d.defaultValue,
true);break;default:"function"===typeof e.onClick&&(a.onclick=Bf$1);}switch(c){case "button":case "input":case "select":case "textarea":d=!!d.autoFocus;break a;case "img":d=true;break a;default:d=false;}}d&&(b.flags|=4);}null!==b.ref&&(b.flags|=512,b.flags|=2097152);}S(b);return null;case 6:if(a&&null!=b.stateNode)Cj(a,b,a.memoizedProps,d);else {if("string"!==typeof d&&null===b.stateNode)throw Error(p$2(166));c=xh$1(wh.current);xh$1(uh$1.current);if(Gg$1(b)){d=b.stateNode;c=b.memoizedProps;d[Of$1]=b;if(f=d.nodeValue!==c)if(a=
xg$1,null!==a)switch(a.tag){case 3:Af$1(d.nodeValue,c,0!==(a.mode&1));break;case 5:true!==a.memoizedProps.suppressHydrationWarning&&Af$1(d.nodeValue,c,0!==(a.mode&1));}f&&(b.flags|=4);}else d=(9===c.nodeType?c:c.ownerDocument).createTextNode(d),d[Of$1]=b,b.stateNode=d;}S(b);return null;case 13:E$1(L$1);d=b.memoizedState;if(null===a||null!==a.memoizedState&&null!==a.memoizedState.dehydrated){if(I$1&&null!==yg$1&&0!==(b.mode&1)&&0===(b.flags&128))Hg$1(),Ig(),b.flags|=98560,f=false;else if(f=Gg$1(b),null!==d&&null!==d.dehydrated){if(null===
a){if(!f)throw Error(p$2(318));f=b.memoizedState;f=null!==f?f.dehydrated:null;if(!f)throw Error(p$2(317));f[Of$1]=b;}else Ig(),0===(b.flags&128)&&(b.memoizedState=null),b.flags|=4;S(b);f=false;}else null!==zg&&(Fj(zg),zg=null),f=true;if(!f)return b.flags&65536?b:null}if(0!==(b.flags&128))return b.lanes=c,b;d=null!==d;d!==(null!==a&&null!==a.memoizedState)&&d&&(b.child.flags|=8192,0!==(b.mode&1)&&(null===a||0!==(L$1.current&1)?0===T$1&&(T$1=3):tj()));null!==b.updateQueue&&(b.flags|=4);S(b);return null;case 4:return zh$1(),
Aj(a,b),null===a&&sf(b.stateNode.containerInfo),S(b),null;case 10:return ah$1(b.type._context),S(b),null;case 17:return Zf$1(b.type)&&$f(),S(b),null;case 19:E$1(L$1);f=b.memoizedState;if(null===f)return S(b),null;d=0!==(b.flags&128);g=f.rendering;if(null===g)if(d)Dj(f,false);else {if(0!==T$1||null!==a&&0!==(a.flags&128))for(a=b.child;null!==a;){g=Ch(a);if(null!==g){b.flags|=128;Dj(f,false);d=g.updateQueue;null!==d&&(b.updateQueue=d,b.flags|=4);b.subtreeFlags=0;d=c;for(c=b.child;null!==c;)f=c,a=d,f.flags&=14680066,
g=f.alternate,null===g?(f.childLanes=0,f.lanes=a,f.child=null,f.subtreeFlags=0,f.memoizedProps=null,f.memoizedState=null,f.updateQueue=null,f.dependencies=null,f.stateNode=null):(f.childLanes=g.childLanes,f.lanes=g.lanes,f.child=g.child,f.subtreeFlags=0,f.deletions=null,f.memoizedProps=g.memoizedProps,f.memoizedState=g.memoizedState,f.updateQueue=g.updateQueue,f.type=g.type,a=g.dependencies,f.dependencies=null===a?null:{lanes:a.lanes,firstContext:a.firstContext}),c=c.sibling;G$1(L$1,L$1.current&1|2);return b.child}a=
a.sibling;}null!==f.tail&&B$1()>Gj&&(b.flags|=128,d=true,Dj(f,false),b.lanes=4194304);}else {if(!d)if(a=Ch(g),null!==a){if(b.flags|=128,d=true,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.flags|=4),Dj(f,true),null===f.tail&&"hidden"===f.tailMode&&!g.alternate&&!I$1)return S(b),null}else 2*B$1()-f.renderingStartTime>Gj&&1073741824!==c&&(b.flags|=128,d=true,Dj(f,false),b.lanes=4194304);f.isBackwards?(g.sibling=b.child,b.child=g):(c=f.last,null!==c?c.sibling=g:b.child=g,f.last=g);}if(null!==f.tail)return b=f.tail,f.rendering=
b,f.tail=b.sibling,f.renderingStartTime=B$1(),b.sibling=null,c=L$1.current,G$1(L$1,d?c&1|2:c&1),b;S(b);return null;case 22:case 23:return Hj(),d=null!==b.memoizedState,null!==a&&null!==a.memoizedState!==d&&(b.flags|=8192),d&&0!==(b.mode&1)?0!==(fj&1073741824)&&(S(b),b.subtreeFlags&6&&(b.flags|=8192)):S(b),null;case 24:return null;case 25:return null}throw Error(p$2(156,b.tag));}
function Ij(a,b){wg$1(b);switch(b.tag){case 1:return Zf$1(b.type)&&$f(),a=b.flags,a&65536?(b.flags=a&-65537|128,b):null;case 3:return zh$1(),E$1(Wf),E$1(H$1),Eh$1(),a=b.flags,0!==(a&65536)&&0===(a&128)?(b.flags=a&-65537|128,b):null;case 5:return Bh$1(b),null;case 13:E$1(L$1);a=b.memoizedState;if(null!==a&&null!==a.dehydrated){if(null===b.alternate)throw Error(p$2(340));Ig();}a=b.flags;return a&65536?(b.flags=a&-65537|128,b):null;case 19:return E$1(L$1),null;case 4:return zh$1(),null;case 10:return ah$1(b.type._context),null;case 22:case 23:return Hj(),
null;case 24:return null;default:return null}}var Jj=false,U=false,Kj="function"===typeof WeakSet?WeakSet:Set,V$2=null;function Lj(a,b){var c=a.ref;if(null!==c)if("function"===typeof c)try{c(null);}catch(d){W(a,b,d);}else c.current=null;}function Mj(a,b,c){try{c();}catch(d){W(a,b,d);}}var Nj=false;
function Oj(a,b){Cf$1=dd$1;a=Me$1();if(Ne$1(a)){if("selectionStart"in a)var c={start:a.selectionStart,end:a.selectionEnd};else a:{c=(c=a.ownerDocument)&&c.defaultView||window;var d=c.getSelection&&c.getSelection();if(d&&0!==d.rangeCount){c=d.anchorNode;var e=d.anchorOffset,f=d.focusNode;d=d.focusOffset;try{c.nodeType,f.nodeType;}catch(F){c=null;break a}var g=0,h=-1,k=-1,l=0,m=0,q=a,r=null;b:for(;;){for(var y;;){q!==c||0!==e&&3!==q.nodeType||(h=g+e);q!==f||0!==d&&3!==q.nodeType||(k=g+d);3===q.nodeType&&(g+=
q.nodeValue.length);if(null===(y=q.firstChild))break;r=q;q=y;}for(;;){if(q===a)break b;r===c&&++l===e&&(h=g);r===f&&++m===d&&(k=g);if(null!==(y=q.nextSibling))break;q=r;r=q.parentNode;}q=y;}c=-1===h||-1===k?null:{start:h,end:k};}else c=null;}c=c||{start:0,end:0};}else c=null;Df$1={focusedElem:a,selectionRange:c};dd$1=false;for(V$2=b;null!==V$2;)if(b=V$2,a=b.child,0!==(b.subtreeFlags&1028)&&null!==a)a.return=b,V$2=a;else for(;null!==V$2;){b=V$2;try{var n=b.alternate;if(0!==(b.flags&1024))switch(b.tag){case 0:case 11:case 15:break;
case 1:if(null!==n){var t=n.memoizedProps,J=n.memoizedState,x=b.stateNode,w=x.getSnapshotBeforeUpdate(b.elementType===b.type?t:Ci$1(b.type,t),J);x.__reactInternalSnapshotBeforeUpdate=w;}break;case 3:var u=b.stateNode.containerInfo;1===u.nodeType?u.textContent="":9===u.nodeType&&u.documentElement&&u.removeChild(u.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(p$2(163));}}catch(F){W(b,b.return,F);}a=b.sibling;if(null!==a){a.return=b.return;V$2=a;break}V$2=b.return;}n=Nj;Nj=false;return n}
function Pj(a,b,c){var d=b.updateQueue;d=null!==d?d.lastEffect:null;if(null!==d){var e=d=d.next;do{if((e.tag&a)===a){var f=e.destroy;e.destroy=void 0;void 0!==f&&Mj(b,c,f);}e=e.next;}while(e!==d)}}function Qj(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d();}c=c.next;}while(c!==b)}}function Rj(a){var b=a.ref;if(null!==b){var c=a.stateNode;switch(a.tag){case 5:a=c;break;default:a=c;}"function"===typeof b?b(a):b.current=a;}}
function Sj(a){var b=a.alternate;null!==b&&(a.alternate=null,Sj(b));a.child=null;a.deletions=null;a.sibling=null;5===a.tag&&(b=a.stateNode,null!==b&&(delete b[Of$1],delete b[Pf$1],delete b[of$1],delete b[Qf$1],delete b[Rf$1]));a.stateNode=null;a.return=null;a.dependencies=null;a.memoizedProps=null;a.memoizedState=null;a.pendingProps=null;a.stateNode=null;a.updateQueue=null;}function Tj(a){return 5===a.tag||3===a.tag||4===a.tag}
function Uj(a){a:for(;;){for(;null===a.sibling;){if(null===a.return||Tj(a.return))return null;a=a.return;}a.sibling.return=a.return;for(a=a.sibling;5!==a.tag&&6!==a.tag&&18!==a.tag;){if(a.flags&2)continue a;if(null===a.child||4===a.tag)continue a;else a.child.return=a,a=a.child;}if(!(a.flags&2))return a.stateNode}}
function Vj(a,b,c){var d=a.tag;if(5===d||6===d)a=a.stateNode,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=Bf$1));else if(4!==d&&(a=a.child,null!==a))for(Vj(a,b,c),a=a.sibling;null!==a;)Vj(a,b,c),a=a.sibling;}
function Wj(a,b,c){var d=a.tag;if(5===d||6===d)a=a.stateNode,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Wj(a,b,c),a=a.sibling;null!==a;)Wj(a,b,c),a=a.sibling;}var X=null,Xj=false;function Yj(a,b,c){for(c=c.child;null!==c;)Zj(a,b,c),c=c.sibling;}
function Zj(a,b,c){if(lc$1&&"function"===typeof lc$1.onCommitFiberUnmount)try{lc$1.onCommitFiberUnmount(kc$1,c);}catch(h){}switch(c.tag){case 5:U||Lj(c,b);case 6:var d=X,e=Xj;X=null;Yj(a,b,c);X=d;Xj=e;null!==X&&(Xj?(a=X,c=c.stateNode,8===a.nodeType?a.parentNode.removeChild(c):a.removeChild(c)):X.removeChild(c.stateNode));break;case 18:null!==X&&(Xj?(a=X,c=c.stateNode,8===a.nodeType?Kf$1(a.parentNode,c):1===a.nodeType&&Kf$1(a,c),bd$1(a)):Kf$1(X,c.stateNode));break;case 4:d=X;e=Xj;X=c.stateNode.containerInfo;Xj=true;
Yj(a,b,c);X=d;Xj=e;break;case 0:case 11:case 14:case 15:if(!U&&(d=c.updateQueue,null!==d&&(d=d.lastEffect,null!==d))){e=d=d.next;do{var f=e,g=f.destroy;f=f.tag;void 0!==g&&(0!==(f&2)?Mj(c,b,g):0!==(f&4)&&Mj(c,b,g));e=e.next;}while(e!==d)}Yj(a,b,c);break;case 1:if(!U&&(Lj(c,b),d=c.stateNode,"function"===typeof d.componentWillUnmount))try{d.props=c.memoizedProps,d.state=c.memoizedState,d.componentWillUnmount();}catch(h){W(c,b,h);}Yj(a,b,c);break;case 21:Yj(a,b,c);break;case 22:c.mode&1?(U=(d=U)||null!==
c.memoizedState,Yj(a,b,c),U=d):Yj(a,b,c);break;default:Yj(a,b,c);}}function ak$1(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=new Kj);b.forEach(function(b){var d=bk$1.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d));});}}
function ck(a,b){var c=b.deletions;if(null!==c)for(var d=0;d<c.length;d++){var e=c[d];try{var f=a,g=b,h=g;a:for(;null!==h;){switch(h.tag){case 5:X=h.stateNode;Xj=!1;break a;case 3:X=h.stateNode.containerInfo;Xj=!0;break a;case 4:X=h.stateNode.containerInfo;Xj=!0;break a}h=h.return;}if(null===X)throw Error(p$2(160));Zj(f,g,e);X=null;Xj=!1;var k=e.alternate;null!==k&&(k.return=null);e.return=null;}catch(l){W(e,b,l);}}if(b.subtreeFlags&12854)for(b=b.child;null!==b;)dk(b,a),b=b.sibling;}
function dk(a,b){var c=a.alternate,d=a.flags;switch(a.tag){case 0:case 11:case 14:case 15:ck(b,a);ek(a);if(d&4){try{Pj(3,a,a.return),Qj(3,a);}catch(t){W(a,a.return,t);}try{Pj(5,a,a.return);}catch(t){W(a,a.return,t);}}break;case 1:ck(b,a);ek(a);d&512&&null!==c&&Lj(c,c.return);break;case 5:ck(b,a);ek(a);d&512&&null!==c&&Lj(c,c.return);if(a.flags&32){var e=a.stateNode;try{ob$1(e,"");}catch(t){W(a,a.return,t);}}if(d&4&&(e=a.stateNode,null!=e)){var f=a.memoizedProps,g=null!==c?c.memoizedProps:f,h=a.type,k=a.updateQueue;
a.updateQueue=null;if(null!==k)try{"input"===h&&"radio"===f.type&&null!=f.name&&ab$1(e,f);vb$1(h,g);var l=vb$1(h,f);for(g=0;g<k.length;g+=2){var m=k[g],q=k[g+1];"style"===m?sb$1(e,q):"dangerouslySetInnerHTML"===m?nb$1(e,q):"children"===m?ob$1(e,q):ta$1(e,m,q,l);}switch(h){case "input":bb$1(e,f);break;case "textarea":ib$1(e,f);break;case "select":var r=e._wrapperState.wasMultiple;e._wrapperState.wasMultiple=!!f.multiple;var y=f.value;null!=y?fb$1(e,!!f.multiple,y,!1):r!==!!f.multiple&&(null!=f.defaultValue?fb$1(e,!!f.multiple,
f.defaultValue,!0):fb$1(e,!!f.multiple,f.multiple?[]:"",!1));}e[Pf$1]=f;}catch(t){W(a,a.return,t);}}break;case 6:ck(b,a);ek(a);if(d&4){if(null===a.stateNode)throw Error(p$2(162));e=a.stateNode;f=a.memoizedProps;try{e.nodeValue=f;}catch(t){W(a,a.return,t);}}break;case 3:ck(b,a);ek(a);if(d&4&&null!==c&&c.memoizedState.isDehydrated)try{bd$1(b.containerInfo);}catch(t){W(a,a.return,t);}break;case 4:ck(b,a);ek(a);break;case 13:ck(b,a);ek(a);e=a.child;e.flags&8192&&(f=null!==e.memoizedState,e.stateNode.isHidden=f,!f||
null!==e.alternate&&null!==e.alternate.memoizedState||(fk=B$1()));d&4&&ak$1(a);break;case 22:m=null!==c&&null!==c.memoizedState;a.mode&1?(U=(l=U)||m,ck(b,a),U=l):ck(b,a);ek(a);if(d&8192){l=null!==a.memoizedState;if((a.stateNode.isHidden=l)&&!m&&0!==(a.mode&1))for(V$2=a,m=a.child;null!==m;){for(q=V$2=m;null!==V$2;){r=V$2;y=r.child;switch(r.tag){case 0:case 11:case 14:case 15:Pj(4,r,r.return);break;case 1:Lj(r,r.return);var n=r.stateNode;if("function"===typeof n.componentWillUnmount){d=r;c=r.return;try{b=d,n.props=
b.memoizedProps,n.state=b.memoizedState,n.componentWillUnmount();}catch(t){W(d,c,t);}}break;case 5:Lj(r,r.return);break;case 22:if(null!==r.memoizedState){gk(q);continue}}null!==y?(y.return=r,V$2=y):gk(q);}m=m.sibling;}a:for(m=null,q=a;;){if(5===q.tag){if(null===m){m=q;try{e=q.stateNode,l?(f=e.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(h=q.stateNode,k=q.memoizedProps.style,g=void 0!==k&&null!==k&&k.hasOwnProperty("display")?k.display:null,h.style.display=
rb$1("display",g));}catch(t){W(a,a.return,t);}}}else if(6===q.tag){if(null===m)try{q.stateNode.nodeValue=l?"":q.memoizedProps;}catch(t){W(a,a.return,t);}}else if((22!==q.tag&&23!==q.tag||null===q.memoizedState||q===a)&&null!==q.child){q.child.return=q;q=q.child;continue}if(q===a)break a;for(;null===q.sibling;){if(null===q.return||q.return===a)break a;m===q&&(m=null);q=q.return;}m===q&&(m=null);q.sibling.return=q.return;q=q.sibling;}}break;case 19:ck(b,a);ek(a);d&4&&ak$1(a);break;case 21:break;default:ck(b,
a),ek(a);}}function ek(a){var b=a.flags;if(b&2){try{a:{for(var c=a.return;null!==c;){if(Tj(c)){var d=c;break a}c=c.return;}throw Error(p$2(160));}switch(d.tag){case 5:var e=d.stateNode;d.flags&32&&(ob$1(e,""),d.flags&=-33);var f=Uj(a);Wj(a,f,e);break;case 3:case 4:var g=d.stateNode.containerInfo,h=Uj(a);Vj(a,h,g);break;default:throw Error(p$2(161));}}catch(k){W(a,a.return,k);}a.flags&=-3;}b&4096&&(a.flags&=-4097);}function hk(a,b,c){V$2=a;ik(a);}
function ik(a,b,c){for(var d=0!==(a.mode&1);null!==V$2;){var e=V$2,f=e.child;if(22===e.tag&&d){var g=null!==e.memoizedState||Jj;if(!g){var h=e.alternate,k=null!==h&&null!==h.memoizedState||U;h=Jj;var l=U;Jj=g;if((U=k)&&!l)for(V$2=e;null!==V$2;)g=V$2,k=g.child,22===g.tag&&null!==g.memoizedState?jk$1(e):null!==k?(k.return=g,V$2=k):jk$1(e);for(;null!==f;)V$2=f,ik(f),f=f.sibling;V$2=e;Jj=h;U=l;}kk$1(a);}else 0!==(e.subtreeFlags&8772)&&null!==f?(f.return=e,V$2=f):kk$1(a);}}
function kk$1(a){for(;null!==V$2;){var b=V$2;if(0!==(b.flags&8772)){var c=b.alternate;try{if(0!==(b.flags&8772))switch(b.tag){case 0:case 11:case 15:U||Qj(5,b);break;case 1:var d=b.stateNode;if(b.flags&4&&!U)if(null===c)d.componentDidMount();else {var e=b.elementType===b.type?c.memoizedProps:Ci$1(b.type,c.memoizedProps);d.componentDidUpdate(e,c.memoizedState,d.__reactInternalSnapshotBeforeUpdate);}var f=b.updateQueue;null!==f&&sh$1(b,f,d);break;case 3:var g=b.updateQueue;if(null!==g){c=null;if(null!==b.child)switch(b.child.tag){case 5:c=
b.child.stateNode;break;case 1:c=b.child.stateNode;}sh$1(b,g,c);}break;case 5:var h=b.stateNode;if(null===c&&b.flags&4){c=h;var k=b.memoizedProps;switch(b.type){case "button":case "input":case "select":case "textarea":k.autoFocus&&c.focus();break;case "img":k.src&&(c.src=k.src);}}break;case 6:break;case 4:break;case 12:break;case 13:if(null===b.memoizedState){var l=b.alternate;if(null!==l){var m=l.memoizedState;if(null!==m){var q=m.dehydrated;null!==q&&bd$1(q);}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;
default:throw Error(p$2(163));}U||b.flags&512&&Rj(b);}catch(r){W(b,b.return,r);}}if(b===a){V$2=null;break}c=b.sibling;if(null!==c){c.return=b.return;V$2=c;break}V$2=b.return;}}function gk(a){for(;null!==V$2;){var b=V$2;if(b===a){V$2=null;break}var c=b.sibling;if(null!==c){c.return=b.return;V$2=c;break}V$2=b.return;}}
function jk$1(a){for(;null!==V$2;){var b=V$2;try{switch(b.tag){case 0:case 11:case 15:var c=b.return;try{Qj(4,b);}catch(k){W(b,c,k);}break;case 1:var d=b.stateNode;if("function"===typeof d.componentDidMount){var e=b.return;try{d.componentDidMount();}catch(k){W(b,e,k);}}var f=b.return;try{Rj(b);}catch(k){W(b,f,k);}break;case 5:var g=b.return;try{Rj(b);}catch(k){W(b,g,k);}}}catch(k){W(b,b.return,k);}if(b===a){V$2=null;break}var h=b.sibling;if(null!==h){h.return=b.return;V$2=h;break}V$2=b.return;}}
var lk=Math.ceil,mk=ua$1.ReactCurrentDispatcher,nk$1=ua$1.ReactCurrentOwner,ok=ua$1.ReactCurrentBatchConfig,K$1=0,Q$1=null,Y$1=null,Z=0,fj=0,ej=Uf$1(0),T$1=0,pk=null,rh$1=0,qk$1=0,rk$1=0,sk=null,tk=null,fk=0,Gj=Infinity,uk=null,Oi$1=false,Pi=null,Ri$1=null,vk=false,wk=null,xk=0,yk$1=0,zk$1=null,Ak$1=-1,Bk$1=0;function R$1(){return 0!==(K$1&6)?B$1():-1!==Ak$1?Ak$1:Ak$1=B$1()}
function yi$1(a){if(0===(a.mode&1))return 1;if(0!==(K$1&2)&&0!==Z)return Z&-Z;if(null!==Kg$1.transition)return 0===Bk$1&&(Bk$1=yc$1()),Bk$1;a=C$1;if(0!==a)return a;a=window.event;a=void 0===a?16:jd$1(a.type);return a}function gi$1(a,b,c,d){if(50<yk$1)throw yk$1=0,zk$1=null,Error(p$2(185));Ac$1(a,c,d);if(0===(K$1&2)||a!==Q$1)a===Q$1&&(0===(K$1&2)&&(qk$1|=c),4===T$1&&Ck(a,Z)),Dk(a,d),1===c&&0===K$1&&0===(b.mode&1)&&(Gj=B$1()+500,fg$1&&jg$1());}
function Dk(a,b){var c=a.callbackNode;wc$1(a,b);var d=uc$1(a,a===Q$1?Z:0);if(0===d)null!==c&&bc$1(c),a.callbackNode=null,a.callbackPriority=0;else if(b=d&-d,a.callbackPriority!==b){null!=c&&bc$1(c);if(1===b)0===a.tag?ig$1(Ek.bind(null,a)):hg$1(Ek.bind(null,a)),Jf$1(function(){0===(K$1&6)&&jg$1();}),c=null;else {switch(Dc$1(d)){case 1:c=fc$1;break;case 4:c=gc$1;break;case 16:c=hc$1;break;case 536870912:c=jc$1;break;default:c=hc$1;}c=Fk$1(c,Gk.bind(null,a));}a.callbackPriority=b;a.callbackNode=c;}}
function Gk(a,b){Ak$1=-1;Bk$1=0;if(0!==(K$1&6))throw Error(p$2(327));var c=a.callbackNode;if(Hk$1()&&a.callbackNode!==c)return null;var d=uc$1(a,a===Q$1?Z:0);if(0===d)return null;if(0!==(d&30)||0!==(d&a.expiredLanes)||b)b=Ik$1(a,d);else {b=d;var e=K$1;K$1|=2;var f=Jk();if(Q$1!==a||Z!==b)uk=null,Gj=B$1()+500,Kk$1(a,b);do try{Lk$1();break}catch(h){Mk$1(a,h);}while(1);$g();mk.current=f;K$1=e;null!==Y$1?b=0:(Q$1=null,Z=0,b=T$1);}if(0!==b){2===b&&(e=xc$1(a),0!==e&&(d=e,b=Nk$1(a,e)));if(1===b)throw c=pk,Kk$1(a,0),Ck(a,d),Dk(a,B$1()),c;if(6===b)Ck(a,d);
else {e=a.current.alternate;if(0===(d&30)&&!Ok$1(e)&&(b=Ik$1(a,d),2===b&&(f=xc$1(a),0!==f&&(d=f,b=Nk$1(a,f))),1===b))throw c=pk,Kk$1(a,0),Ck(a,d),Dk(a,B$1()),c;a.finishedWork=e;a.finishedLanes=d;switch(b){case 0:case 1:throw Error(p$2(345));case 2:Pk(a,tk,uk);break;case 3:Ck(a,d);if((d&130023424)===d&&(b=fk+500-B$1(),10<b)){if(0!==uc$1(a,0))break;e=a.suspendedLanes;if((e&d)!==d){R$1();a.pingedLanes|=a.suspendedLanes&e;break}a.timeoutHandle=Ff$1(Pk.bind(null,a,tk,uk),b);break}Pk(a,tk,uk);break;case 4:Ck(a,d);if((d&4194240)===
d)break;b=a.eventTimes;for(e=-1;0<d;){var g=31-oc$1(d);f=1<<g;g=b[g];g>e&&(e=g);d&=~f;}d=e;d=B$1()-d;d=(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*lk(d/1960))-d;if(10<d){a.timeoutHandle=Ff$1(Pk.bind(null,a,tk,uk),d);break}Pk(a,tk,uk);break;case 5:Pk(a,tk,uk);break;default:throw Error(p$2(329));}}}Dk(a,B$1());return a.callbackNode===c?Gk.bind(null,a):null}
function Nk$1(a,b){var c=sk;a.current.memoizedState.isDehydrated&&(Kk$1(a,b).flags|=256);a=Ik$1(a,b);2!==a&&(b=tk,tk=c,null!==b&&Fj(b));return a}function Fj(a){null===tk?tk=a:tk.push.apply(tk,a);}
function Ok$1(a){for(var b=a;;){if(b.flags&16384){var c=b.updateQueue;if(null!==c&&(c=c.stores,null!==c))for(var d=0;d<c.length;d++){var e=c[d],f=e.getSnapshot;e=e.value;try{if(!He$1(f(),e))return !1}catch(g){return  false}}}c=b.child;if(b.subtreeFlags&16384&&null!==c)c.return=b,b=c;else {if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return  true;b=b.return;}b.sibling.return=b.return;b=b.sibling;}}return  true}
function Ck(a,b){b&=~rk$1;b&=~qk$1;a.suspendedLanes|=b;a.pingedLanes&=~b;for(a=a.expirationTimes;0<b;){var c=31-oc$1(b),d=1<<c;a[c]=-1;b&=~d;}}function Ek(a){if(0!==(K$1&6))throw Error(p$2(327));Hk$1();var b=uc$1(a,0);if(0===(b&1))return Dk(a,B$1()),null;var c=Ik$1(a,b);if(0!==a.tag&&2===c){var d=xc$1(a);0!==d&&(b=d,c=Nk$1(a,d));}if(1===c)throw c=pk,Kk$1(a,0),Ck(a,b),Dk(a,B$1()),c;if(6===c)throw Error(p$2(345));a.finishedWork=a.current.alternate;a.finishedLanes=b;Pk(a,tk,uk);Dk(a,B$1());return null}
function Qk$1(a,b){var c=K$1;K$1|=1;try{return a(b)}finally{K$1=c,0===K$1&&(Gj=B$1()+500,fg$1&&jg$1());}}function Rk(a){null!==wk&&0===wk.tag&&0===(K$1&6)&&Hk$1();var b=K$1;K$1|=1;var c=ok.transition,d=C$1;try{if(ok.transition=null,C$1=1,a)return a()}finally{C$1=d,ok.transition=c,K$1=b,0===(K$1&6)&&jg$1();}}function Hj(){fj=ej.current;E$1(ej);}
function Kk$1(a,b){a.finishedWork=null;a.finishedLanes=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,Gf$1(c));if(null!==Y$1)for(c=Y$1.return;null!==c;){var d=c;wg$1(d);switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&$f();break;case 3:zh$1();E$1(Wf);E$1(H$1);Eh$1();break;case 5:Bh$1(d);break;case 4:zh$1();break;case 13:E$1(L$1);break;case 19:E$1(L$1);break;case 10:ah$1(d.type._context);break;case 22:case 23:Hj();}c=c.return;}Q$1=a;Y$1=a=Pg$1(a.current,null);Z=fj=b;T$1=0;pk=null;rk$1=qk$1=rh$1=0;tk=sk=null;if(null!==fh$1){for(b=
0;b<fh$1.length;b++)if(c=fh$1[b],d=c.interleaved,null!==d){c.interleaved=null;var e=d.next,f=c.pending;if(null!==f){var g=f.next;f.next=e;d.next=g;}c.pending=d;}fh$1=null;}return a}
function Mk$1(a,b){do{var c=Y$1;try{$g();Fh$1.current=Rh$1;if(Ih$1){for(var d=M$1.memoizedState;null!==d;){var e=d.queue;null!==e&&(e.pending=null);d=d.next;}Ih$1=!1;}Hh$1=0;O$1=N$1=M$1=null;Jh$1=!1;Kh$1=0;nk$1.current=null;if(null===c||null===c.return){T$1=1;pk=b;Y$1=null;break}a:{var f=a,g=c.return,h=c,k=b;b=Z;h.flags|=32768;if(null!==k&&"object"===typeof k&&"function"===typeof k.then){var l=k,m=h,q=m.tag;if(0===(m.mode&1)&&(0===q||11===q||15===q)){var r=m.alternate;r?(m.updateQueue=r.updateQueue,m.memoizedState=r.memoizedState,
m.lanes=r.lanes):(m.updateQueue=null,m.memoizedState=null);}var y=Ui$1(g);if(null!==y){y.flags&=-257;Vi$1(y,g,h,f,b);y.mode&1&&Si$1(f,l,b);b=y;k=l;var n=b.updateQueue;if(null===n){var t=new Set;t.add(k);b.updateQueue=t;}else n.add(k);break a}else {if(0===(b&1)){Si$1(f,l,b);tj();break a}k=Error(p$2(426));}}else if(I$1&&h.mode&1){var J=Ui$1(g);if(null!==J){0===(J.flags&65536)&&(J.flags|=256);Vi$1(J,g,h,f,b);Jg$1(Ji(k,h));break a}}f=k=Ji(k,h);4!==T$1&&(T$1=2);null===sk?sk=[f]:sk.push(f);f=g;do{switch(f.tag){case 3:f.flags|=65536;
b&=-b;f.lanes|=b;var x=Ni$1(f,k,b);ph$1(f,x);break a;case 1:h=k;var w=f.type,u=f.stateNode;if(0===(f.flags&128)&&("function"===typeof w.getDerivedStateFromError||null!==u&&"function"===typeof u.componentDidCatch&&(null===Ri$1||!Ri$1.has(u)))){f.flags|=65536;b&=-b;f.lanes|=b;var F=Qi$1(f,h,b);ph$1(f,F);break a}}f=f.return;}while(null!==f)}Sk$1(c);}catch(na){b=na;Y$1===c&&null!==c&&(Y$1=c=c.return);continue}break}while(1)}function Jk(){var a=mk.current;mk.current=Rh$1;return null===a?Rh$1:a}
function tj(){if(0===T$1||3===T$1||2===T$1)T$1=4;null===Q$1||0===(rh$1&268435455)&&0===(qk$1&268435455)||Ck(Q$1,Z);}function Ik$1(a,b){var c=K$1;K$1|=2;var d=Jk();if(Q$1!==a||Z!==b)uk=null,Kk$1(a,b);do try{Tk();break}catch(e){Mk$1(a,e);}while(1);$g();K$1=c;mk.current=d;if(null!==Y$1)throw Error(p$2(261));Q$1=null;Z=0;return T$1}function Tk(){for(;null!==Y$1;)Uk$1(Y$1);}function Lk$1(){for(;null!==Y$1&&!cc$1();)Uk$1(Y$1);}function Uk$1(a){var b=Vk$1(a.alternate,a,fj);a.memoizedProps=a.pendingProps;null===b?Sk$1(a):Y$1=b;nk$1.current=null;}
function Sk$1(a){var b=a;do{var c=b.alternate;a=b.return;if(0===(b.flags&32768)){if(c=Ej(c,b,fj),null!==c){Y$1=c;return}}else {c=Ij(c,b);if(null!==c){c.flags&=32767;Y$1=c;return}if(null!==a)a.flags|=32768,a.subtreeFlags=0,a.deletions=null;else {T$1=6;Y$1=null;return}}b=b.sibling;if(null!==b){Y$1=b;return}Y$1=b=a;}while(null!==b);0===T$1&&(T$1=5);}function Pk(a,b,c){var d=C$1,e=ok.transition;try{ok.transition=null,C$1=1,Wk$1(a,b,c,d);}finally{ok.transition=e,C$1=d;}return null}
function Wk$1(a,b,c,d){do Hk$1();while(null!==wk);if(0!==(K$1&6))throw Error(p$2(327));c=a.finishedWork;var e=a.finishedLanes;if(null===c)return null;a.finishedWork=null;a.finishedLanes=0;if(c===a.current)throw Error(p$2(177));a.callbackNode=null;a.callbackPriority=0;var f=c.lanes|c.childLanes;Bc$1(a,f);a===Q$1&&(Y$1=Q$1=null,Z=0);0===(c.subtreeFlags&2064)&&0===(c.flags&2064)||vk||(vk=true,Fk$1(hc$1,function(){Hk$1();return null}));f=0!==(c.flags&15990);if(0!==(c.subtreeFlags&15990)||f){f=ok.transition;ok.transition=null;
var g=C$1;C$1=1;var h=K$1;K$1|=4;nk$1.current=null;Oj(a,c);dk(c,a);Oe(Df$1);dd$1=!!Cf$1;Df$1=Cf$1=null;a.current=c;hk(c);dc$1();K$1=h;C$1=g;ok.transition=f;}else a.current=c;vk&&(vk=false,wk=a,xk=e);f=a.pendingLanes;0===f&&(Ri$1=null);mc$1(c.stateNode);Dk(a,B$1());if(null!==b)for(d=a.onRecoverableError,c=0;c<b.length;c++)e=b[c],d(e.value,{componentStack:e.stack,digest:e.digest});if(Oi$1)throw Oi$1=false,a=Pi,Pi=null,a;0!==(xk&1)&&0!==a.tag&&Hk$1();f=a.pendingLanes;0!==(f&1)?a===zk$1?yk$1++:(yk$1=0,zk$1=a):yk$1=0;jg$1();return null}
function Hk$1(){if(null!==wk){var a=Dc$1(xk),b=ok.transition,c=C$1;try{ok.transition=null;C$1=16>a?16:a;if(null===wk)var d=!1;else {a=wk;wk=null;xk=0;if(0!==(K$1&6))throw Error(p$2(331));var e=K$1;K$1|=4;for(V$2=a.current;null!==V$2;){var f=V$2,g=f.child;if(0!==(V$2.flags&16)){var h=f.deletions;if(null!==h){for(var k=0;k<h.length;k++){var l=h[k];for(V$2=l;null!==V$2;){var m=V$2;switch(m.tag){case 0:case 11:case 15:Pj(8,m,f);}var q=m.child;if(null!==q)q.return=m,V$2=q;else for(;null!==V$2;){m=V$2;var r=m.sibling,y=m.return;Sj(m);if(m===
l){V$2=null;break}if(null!==r){r.return=y;V$2=r;break}V$2=y;}}}var n=f.alternate;if(null!==n){var t=n.child;if(null!==t){n.child=null;do{var J=t.sibling;t.sibling=null;t=J;}while(null!==t)}}V$2=f;}}if(0!==(f.subtreeFlags&2064)&&null!==g)g.return=f,V$2=g;else b:for(;null!==V$2;){f=V$2;if(0!==(f.flags&2048))switch(f.tag){case 0:case 11:case 15:Pj(9,f,f.return);}var x=f.sibling;if(null!==x){x.return=f.return;V$2=x;break b}V$2=f.return;}}var w=a.current;for(V$2=w;null!==V$2;){g=V$2;var u=g.child;if(0!==(g.subtreeFlags&2064)&&null!==
u)u.return=g,V$2=u;else b:for(g=w;null!==V$2;){h=V$2;if(0!==(h.flags&2048))try{switch(h.tag){case 0:case 11:case 15:Qj(9,h);}}catch(na){W(h,h.return,na);}if(h===g){V$2=null;break b}var F=h.sibling;if(null!==F){F.return=h.return;V$2=F;break b}V$2=h.return;}}K$1=e;jg$1();if(lc$1&&"function"===typeof lc$1.onPostCommitFiberRoot)try{lc$1.onPostCommitFiberRoot(kc$1,a);}catch(na){}d=!0;}return d}finally{C$1=c,ok.transition=b;}}return  false}function Xk$1(a,b,c){b=Ji(c,b);b=Ni$1(a,b,1);a=nh$1(a,b,1);b=R$1();null!==a&&(Ac$1(a,1,b),Dk(a,b));}
function W(a,b,c){if(3===a.tag)Xk$1(a,a,c);else for(;null!==b;){if(3===b.tag){Xk$1(b,a,c);break}else if(1===b.tag){var d=b.stateNode;if("function"===typeof b.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===Ri$1||!Ri$1.has(d))){a=Ji(c,a);a=Qi$1(b,a,1);b=nh$1(b,a,1);a=R$1();null!==b&&(Ac$1(b,1,a),Dk(b,a));break}}b=b.return;}}
function Ti$1(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);b=R$1();a.pingedLanes|=a.suspendedLanes&c;Q$1===a&&(Z&c)===c&&(4===T$1||3===T$1&&(Z&130023424)===Z&&500>B$1()-fk?Kk$1(a,0):rk$1|=c);Dk(a,b);}function Yk$1(a,b){0===b&&(0===(a.mode&1)?b=1:(b=sc$1,sc$1<<=1,0===(sc$1&130023424)&&(sc$1=4194304)));var c=R$1();a=ih$1(a,b);null!==a&&(Ac$1(a,b,c),Dk(a,c));}function uj(a){var b=a.memoizedState,c=0;null!==b&&(c=b.retryLane);Yk$1(a,c);}
function bk$1(a,b){var c=0;switch(a.tag){case 13:var d=a.stateNode;var e=a.memoizedState;null!==e&&(c=e.retryLane);break;case 19:d=a.stateNode;break;default:throw Error(p$2(314));}null!==d&&d.delete(b);Yk$1(a,c);}var Vk$1;
Vk$1=function(a,b,c){if(null!==a)if(a.memoizedProps!==b.pendingProps||Wf.current)dh$1=true;else {if(0===(a.lanes&c)&&0===(b.flags&128))return dh$1=false,yj(a,b,c);dh$1=0!==(a.flags&131072)?true:false;}else dh$1=false,I$1&&0!==(b.flags&1048576)&&ug$1(b,ng$1,b.index);b.lanes=0;switch(b.tag){case 2:var d=b.type;ij(a,b);a=b.pendingProps;var e=Yf$1(b,H$1.current);ch$1(b,c);e=Nh$1(null,b,d,a,e,c);var f=Sh$1();b.flags|=1;"object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof?(b.tag=1,b.memoizedState=null,b.updateQueue=
null,Zf$1(d)?(f=true,cg$1(b)):f=false,b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null,kh(b),e.updater=Ei$1,b.stateNode=e,e._reactInternals=b,Ii$1(b,d,a,c),b=jj(null,b,d,true,f,c)):(b.tag=0,I$1&&f&&vg$1(b),Xi$1(null,b,e,c),b=b.child);return b;case 16:d=b.elementType;a:{ij(a,b);a=b.pendingProps;e=d._init;d=e(d._payload);b.type=d;e=b.tag=Zk$1(d);a=Ci$1(d,a);switch(e){case 0:b=cj(null,b,d,a,c);break a;case 1:b=hj(null,b,d,a,c);break a;case 11:b=Yi$1(null,b,d,a,c);break a;case 14:b=$i$1(null,b,d,Ci$1(d.type,a),c);break a}throw Error(p$2(306,
d,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Ci$1(d,e),cj(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Ci$1(d,e),hj(a,b,d,e,c);case 3:a:{kj(b);if(null===a)throw Error(p$2(387));d=b.pendingProps;f=b.memoizedState;e=f.element;lh$1(a,b);qh$1(b,d,null,c);var g=b.memoizedState;d=g.element;if(f.isDehydrated)if(f={element:d,isDehydrated:false,cache:g.cache,pendingSuspenseBoundaries:g.pendingSuspenseBoundaries,transitions:g.transitions},b.updateQueue.baseState=
f,b.memoizedState=f,b.flags&256){e=Ji(Error(p$2(423)),b);b=lj(a,b,d,c,e);break a}else if(d!==e){e=Ji(Error(p$2(424)),b);b=lj(a,b,d,c,e);break a}else for(yg$1=Lf$1(b.stateNode.containerInfo.firstChild),xg$1=b,I$1=true,zg=null,c=Vg(b,null,d,c),b.child=c;c;)c.flags=c.flags&-3|4096,c=c.sibling;else {Ig();if(d===e){b=Zi$1(a,b,c);break a}Xi$1(a,b,d,c);}b=b.child;}return b;case 5:return Ah$1(b),null===a&&Eg$1(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:null,g=e.children,Ef$1(d,e)?g=null:null!==f&&Ef$1(d,f)&&(b.flags|=32),
gj(a,b),Xi$1(a,b,g,c),b.child;case 6:return null===a&&Eg$1(b),null;case 13:return oj(a,b,c);case 4:return yh$1(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=Ug$1(b,null,d,c):Xi$1(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Ci$1(d,e),Yi$1(a,b,d,e,c);case 7:return Xi$1(a,b,b.pendingProps,c),b.child;case 8:return Xi$1(a,b,b.pendingProps.children,c),b.child;case 12:return Xi$1(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;f=b.memoizedProps;
g=e.value;G$1(Wg,d._currentValue);d._currentValue=g;if(null!==f)if(He$1(f.value,g)){if(f.children===e.children&&!Wf.current){b=Zi$1(a,b,c);break a}}else for(f=b.child,null!==f&&(f.return=b);null!==f;){var h=f.dependencies;if(null!==h){g=f.child;for(var k=h.firstContext;null!==k;){if(k.context===d){if(1===f.tag){k=mh$1(-1,c&-c);k.tag=2;var l=f.updateQueue;if(null!==l){l=l.shared;var m=l.pending;null===m?k.next=k:(k.next=m.next,m.next=k);l.pending=k;}}f.lanes|=c;k=f.alternate;null!==k&&(k.lanes|=c);bh$1(f.return,
c,b);h.lanes|=c;break}k=k.next;}}else if(10===f.tag)g=f.type===b.type?null:f.child;else if(18===f.tag){g=f.return;if(null===g)throw Error(p$2(341));g.lanes|=c;h=g.alternate;null!==h&&(h.lanes|=c);bh$1(g,c,b);g=f.sibling;}else g=f.child;if(null!==g)g.return=f;else for(g=f;null!==g;){if(g===b){g=null;break}f=g.sibling;if(null!==f){f.return=g.return;g=f;break}g=g.return;}f=g;}Xi$1(a,b,e.children,c);b=b.child;}return b;case 9:return e=b.type,d=b.pendingProps.children,ch$1(b,c),e=eh$1(e),d=d(e),b.flags|=1,Xi$1(a,b,d,c),
b.child;case 14:return d=b.type,e=Ci$1(d,b.pendingProps),e=Ci$1(d.type,e),$i$1(a,b,d,e,c);case 15:return bj(a,b,b.type,b.pendingProps,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Ci$1(d,e),ij(a,b),b.tag=1,Zf$1(d)?(a=true,cg$1(b)):a=false,ch$1(b,c),Gi$1(b,d,e),Ii$1(b,d,e,c),jj(null,b,d,true,a,c);case 19:return xj(a,b,c);case 22:return dj(a,b,c)}throw Error(p$2(156,b.tag));};function Fk$1(a,b){return ac(a,b)}
function $k$1(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.subtreeFlags=this.flags=0;this.deletions=null;this.childLanes=this.lanes=0;this.alternate=null;}function Bg$1(a,b,c,d){return new $k$1(a,b,c,d)}function aj(a){a=a.prototype;return !(!a||!a.isReactComponent)}
function Zk$1(a){if("function"===typeof a)return aj(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===Da$1)return 11;if(a===Ga$1)return 14}return 2}
function Pg$1(a,b){var c=a.alternate;null===c?(c=Bg$1(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.type=a.type,c.flags=0,c.subtreeFlags=0,c.deletions=null);c.flags=a.flags&14680064;c.childLanes=a.childLanes;c.lanes=a.lanes;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{lanes:b.lanes,firstContext:b.firstContext};
c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}
function Rg$1(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)aj(a)&&(g=1);else if("string"===typeof a)g=5;else a:switch(a){case ya$1:return Tg$1(c.children,e,f,b);case za$1:g=8;e|=8;break;case Aa$1:return a=Bg$1(12,c,b,e|2),a.elementType=Aa$1,a.lanes=f,a;case Ea$1:return a=Bg$1(13,c,b,e),a.elementType=Ea$1,a.lanes=f,a;case Fa$1:return a=Bg$1(19,c,b,e),a.elementType=Fa$1,a.lanes=f,a;case Ia$1:return pj(c,e,f,b);default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Ba$1:g=10;break a;case Ca$1:g=9;break a;case Da$1:g=11;
break a;case Ga$1:g=14;break a;case Ha$1:g=16;d=null;break a}throw Error(p$2(130,null==a?a:typeof a,""));}b=Bg$1(g,c,b,e);b.elementType=a;b.type=d;b.lanes=f;return b}function Tg$1(a,b,c,d){a=Bg$1(7,a,d,b);a.lanes=c;return a}function pj(a,b,c,d){a=Bg$1(22,a,d,b);a.elementType=Ia$1;a.lanes=c;a.stateNode={isHidden:false};return a}function Qg$1(a,b,c){a=Bg$1(6,a,null,b);a.lanes=c;return a}
function Sg$1(a,b,c){b=Bg$1(4,null!==a.children?a.children:[],a.key,b);b.lanes=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}
function al$1(a,b,c,d,e){this.tag=b;this.containerInfo=a;this.finishedWork=this.pingCache=this.current=this.pendingChildren=null;this.timeoutHandle=-1;this.callbackNode=this.pendingContext=this.context=null;this.callbackPriority=0;this.eventTimes=zc$1(0);this.expirationTimes=zc$1(-1);this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0;this.entanglements=zc$1(0);this.identifierPrefix=d;this.onRecoverableError=e;this.mutableSourceEagerHydrationData=
null;}function bl(a,b,c,d,e,f,g,h,k){a=new al$1(a,b,c,h,k);1===b?(b=1,true===f&&(b|=8)):b=0;f=Bg$1(3,null,null,b);a.current=f;f.stateNode=a;f.memoizedState={element:d,isDehydrated:c,cache:null,transitions:null,pendingSuspenseBoundaries:null};kh(f);return a}function cl$1(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return {$$typeof:wa$1,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}
function dl$1(a){if(!a)return Vf$1;a=a._reactInternals;a:{if(Vb$1(a)!==a||1!==a.tag)throw Error(p$2(170));var b=a;do{switch(b.tag){case 3:b=b.stateNode.context;break a;case 1:if(Zf$1(b.type)){b=b.stateNode.__reactInternalMemoizedMergedChildContext;break a}}b=b.return;}while(null!==b);throw Error(p$2(171));}if(1===a.tag){var c=a.type;if(Zf$1(c))return bg$1(a,c,b)}return b}
function el(a,b,c,d,e,f,g,h,k){a=bl(c,d,true,a,e,f,g,h,k);a.context=dl$1(null);c=a.current;d=R$1();e=yi$1(c);f=mh$1(d,e);f.callback=void 0!==b&&null!==b?b:null;nh$1(c,f,e);a.current.lanes=e;Ac$1(a,e,d);Dk(a,d);return a}function fl$1(a,b,c,d){var e=b.current,f=R$1(),g=yi$1(e);c=dl$1(c);null===b.context?b.context=c:b.pendingContext=c;b=mh$1(f,g);b.payload={element:a};d=void 0===d?null:d;null!==d&&(b.callback=d);a=nh$1(e,b,g);null!==a&&(gi$1(a,e,g,f),oh$1(a,e,g));return g}
function gl$1(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function hl(a,b){a=a.memoizedState;if(null!==a&&null!==a.dehydrated){var c=a.retryLane;a.retryLane=0!==c&&c<b?c:b;}}function il$1(a,b){hl(a,b);(a=a.alternate)&&hl(a,b);}function jl$1(){return null}var kl$1="function"===typeof reportError?reportError:function(a){console.error(a);};function ll$1(a){this._internalRoot=a;}
ml.prototype.render=ll$1.prototype.render=function(a){var b=this._internalRoot;if(null===b)throw Error(p$2(409));fl$1(a,b,null,null);};ml.prototype.unmount=ll$1.prototype.unmount=function(){var a=this._internalRoot;if(null!==a){this._internalRoot=null;var b=a.containerInfo;Rk(function(){fl$1(null,a,null,null);});b[uf$1]=null;}};function ml(a){this._internalRoot=a;}
ml.prototype.unstable_scheduleHydration=function(a){if(a){var b=Hc$1();a={blockedOn:null,target:a,priority:b};for(var c=0;c<Qc$1.length&&0!==b&&b<Qc$1[c].priority;c++);Qc$1.splice(c,0,a);0===c&&Vc$1(a);}};function nl$1(a){return !(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType)}function ol$1(a){return !(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function pl(){}
function ql(a,b,c,d,e){if(e){if("function"===typeof d){var f=d;d=function(){var a=gl$1(g);f.call(a);};}var g=el(b,d,a,0,null,false,false,"",pl);a._reactRootContainer=g;a[uf$1]=g.current;sf(8===a.nodeType?a.parentNode:a);Rk();return g}for(;e=a.lastChild;)a.removeChild(e);if("function"===typeof d){var h=d;d=function(){var a=gl$1(k);h.call(a);};}var k=bl(a,0,false,null,null,false,false,"",pl);a._reactRootContainer=k;a[uf$1]=k.current;sf(8===a.nodeType?a.parentNode:a);Rk(function(){fl$1(b,k,c,d);});return k}
function rl$1(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f;if("function"===typeof e){var h=e;e=function(){var a=gl$1(g);h.call(a);};}fl$1(b,g,a,e);}else g=ql(c,b,a,e,d);return gl$1(g)}Ec$1=function(a){switch(a.tag){case 3:var b=a.stateNode;if(b.current.memoizedState.isDehydrated){var c=tc$1(b.pendingLanes);0!==c&&(Cc$1(b,c|1),Dk(b,B$1()),0===(K$1&6)&&(Gj=B$1()+500,jg$1()));}break;case 13:Rk(function(){var b=ih$1(a,1);if(null!==b){var c=R$1();gi$1(b,a,1,c);}}),il$1(a,1);}};
Fc$1=function(a){if(13===a.tag){var b=ih$1(a,134217728);if(null!==b){var c=R$1();gi$1(b,a,134217728,c);}il$1(a,134217728);}};Gc$1=function(a){if(13===a.tag){var b=yi$1(a),c=ih$1(a,b);if(null!==c){var d=R$1();gi$1(c,a,b,d);}il$1(a,b);}};Hc$1=function(){return C$1};Ic$1=function(a,b){var c=C$1;try{return C$1=a,b()}finally{C$1=c;}};
yb$1=function(a,b,c){switch(b){case "input":bb$1(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=Db$1(d);if(!e)throw Error(p$2(90));Wa$1(d);bb$1(d,e);}}}break;case "textarea":ib$1(a,c);break;case "select":b=c.value,null!=b&&fb$1(a,!!c.multiple,b,false);}};Gb$1=Qk$1;Hb$1=Rk;
var sl$1={usingClientEntryPoint:false,Events:[Cb$1,ue$1,Db$1,Eb$1,Fb$1,Qk$1]},tl$1={findFiberByHostInstance:Wc$1,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"};
var ul$1={bundleType:tl$1.bundleType,version:tl$1.version,rendererPackageName:tl$1.rendererPackageName,rendererConfig:tl$1.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:ua$1.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Zb$1(a);return null===a?null:a.stateNode},findFiberByHostInstance:tl$1.findFiberByHostInstance||
jl$1,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var vl$1=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!vl$1.isDisabled&&vl$1.supportsFiber)try{kc$1=vl$1.inject(ul$1),lc$1=vl$1;}catch(a){}}reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=sl$1;
reactDom_production_min.createPortal=function(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!nl$1(b))throw Error(p$2(200));return cl$1(a,b,null,c)};reactDom_production_min.createRoot=function(a,b){if(!nl$1(a))throw Error(p$2(299));var c=false,d="",e=kl$1;null!==b&&void 0!==b&&(true===b.unstable_strictMode&&(c=true),void 0!==b.identifierPrefix&&(d=b.identifierPrefix),void 0!==b.onRecoverableError&&(e=b.onRecoverableError));b=bl(a,1,false,null,null,c,false,d,e);a[uf$1]=b.current;sf(8===a.nodeType?a.parentNode:a);return new ll$1(b)};
reactDom_production_min.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternals;if(void 0===b){if("function"===typeof a.render)throw Error(p$2(188));a=Object.keys(a).join(",");throw Error(p$2(268,a));}a=Zb$1(b);a=null===a?null:a.stateNode;return a};reactDom_production_min.flushSync=function(a){return Rk(a)};reactDom_production_min.hydrate=function(a,b,c){if(!ol$1(b))throw Error(p$2(200));return rl$1(null,a,b,true,c)};
reactDom_production_min.hydrateRoot=function(a,b,c){if(!nl$1(a))throw Error(p$2(405));var d=null!=c&&c.hydratedSources||null,e=false,f="",g=kl$1;null!==c&&void 0!==c&&(true===c.unstable_strictMode&&(e=true),void 0!==c.identifierPrefix&&(f=c.identifierPrefix),void 0!==c.onRecoverableError&&(g=c.onRecoverableError));b=el(b,null,a,1,null!=c?c:null,e,false,f,g);a[uf$1]=b.current;sf(a);if(d)for(a=0;a<d.length;a++)c=d[a],e=c._getVersion,e=e(c._source),null==b.mutableSourceEagerHydrationData?b.mutableSourceEagerHydrationData=[c,e]:b.mutableSourceEagerHydrationData.push(c,
e);return new ml(b)};reactDom_production_min.render=function(a,b,c){if(!ol$1(b))throw Error(p$2(200));return rl$1(null,a,b,false,c)};reactDom_production_min.unmountComponentAtNode=function(a){if(!ol$1(a))throw Error(p$2(40));return a._reactRootContainer?(Rk(function(){rl$1(null,null,a,!1,function(){a._reactRootContainer=null;a[uf$1]=null;});}),true):false};reactDom_production_min.unstable_batchedUpdates=Qk$1;
reactDom_production_min.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!ol$1(c))throw Error(p$2(200));if(null==a||void 0===a._reactInternals)throw Error(p$2(38));return rl$1(a,b,c,false,d)};reactDom_production_min.version="18.3.1-next-f1338f8080-20240426";

function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}

var reactDomExports = reactDom.exports;

var m$2 = reactDomExports;
{
  client.createRoot = m$2.createRoot;
  client.hydrateRoot = m$2.hydrateRoot;
}

var dist = {};

Object.defineProperty(dist, "__esModule", { value: true });
dist.parse = parse$2;
dist.serialize = serialize$1;
/**
 * RegExp to match cookie-name in RFC 6265 sec 4.1.1
 * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2
 * which has been replaced by the token definition in RFC 7230 appendix B.
 *
 * cookie-name       = token
 * token             = 1*tchar
 * tchar             = "!" / "#" / "$" / "%" / "&" / "'" /
 *                     "*" / "+" / "-" / "." / "^" / "_" /
 *                     "`" / "|" / "~" / DIGIT / ALPHA
 *
 * Note: Allowing more characters - https://github.com/jshttp/cookie/issues/191
 * Allow same range as cookie value, except `=`, which delimits end of name.
 */
const cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
/**
 * RegExp to match cookie-value in RFC 6265 sec 4.1.1
 *
 * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
 * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
 *                     ; US-ASCII characters excluding CTLs,
 *                     ; whitespace DQUOTE, comma, semicolon,
 *                     ; and backslash
 *
 * Allowing more characters: https://github.com/jshttp/cookie/issues/191
 * Comma, backslash, and DQUOTE are not part of the parsing algorithm.
 */
const cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
/**
 * RegExp to match domain-value in RFC 6265 sec 4.1.1
 *
 * domain-value      = <subdomain>
 *                     ; defined in [RFC1034], Section 3.5, as
 *                     ; enhanced by [RFC1123], Section 2.1
 * <subdomain>       = <label> | <subdomain> "." <label>
 * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]
 *                     Labels must be 63 characters or less.
 *                     'let-dig' not 'letter' in the first char, per RFC1123
 * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>
 * <let-dig-hyp>     = <let-dig> | "-"
 * <let-dig>         = <letter> | <digit>
 * <letter>          = any one of the 52 alphabetic characters A through Z in
 *                     upper case and a through z in lower case
 * <digit>           = any one of the ten digits 0 through 9
 *
 * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173
 *
 * > (Note that a leading %x2E ("."), if present, is ignored even though that
 * character is not permitted, but a trailing %x2E ("."), if present, will
 * cause the user agent to ignore the attribute.)
 */
const domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
/**
 * RegExp to match path-value in RFC 6265 sec 4.1.1
 *
 * path-value        = <any CHAR except CTLs or ";">
 * CHAR              = %x01-7F
 *                     ; defined in RFC 5234 appendix B.1
 */
const pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
const __toString = Object.prototype.toString;
const NullObject = /* @__PURE__ */ (() => {
    const C = function () { };
    C.prototype = Object.create(null);
    return C;
})();
/**
 * Parse a cookie header.
 *
 * Parse the given cookie header string into an object
 * The object has the various cookies as keys(names) => values
 */
function parse$2(str, options) {
    const obj = new NullObject();
    const len = str.length;
    // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.
    if (len < 2)
        return obj;
    const dec = options?.decode || decode;
    let index = 0;
    do {
        const eqIdx = str.indexOf("=", index);
        if (eqIdx === -1)
            break; // No more cookie pairs.
        const colonIdx = str.indexOf(";", index);
        const endIdx = colonIdx === -1 ? len : colonIdx;
        if (eqIdx > endIdx) {
            // backtrack on prior semicolon
            index = str.lastIndexOf(";", eqIdx - 1) + 1;
            continue;
        }
        const keyStartIdx = startIndex(str, index, eqIdx);
        const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
        const key = str.slice(keyStartIdx, keyEndIdx);
        // only assign once
        if (obj[key] === undefined) {
            let valStartIdx = startIndex(str, eqIdx + 1, endIdx);
            let valEndIdx = endIndex(str, endIdx, valStartIdx);
            const value = dec(str.slice(valStartIdx, valEndIdx));
            obj[key] = value;
        }
        index = endIdx + 1;
    } while (index < len);
    return obj;
}
function startIndex(str, index, max) {
    do {
        const code = str.charCodeAt(index);
        if (code !== 0x20 /*   */ && code !== 0x09 /* \t */)
            return index;
    } while (++index < max);
    return max;
}
function endIndex(str, index, min) {
    while (index > min) {
        const code = str.charCodeAt(--index);
        if (code !== 0x20 /*   */ && code !== 0x09 /* \t */)
            return index + 1;
    }
    return min;
}
/**
 * Serialize data into a cookie header.
 *
 * Serialize a name value pair into a cookie string suitable for
 * http headers. An optional options object specifies cookie parameters.
 *
 * serialize('foo', 'bar', { httpOnly: true })
 *   => "foo=bar; httpOnly"
 */
function serialize$1(name, val, options) {
    const enc = options?.encode || encodeURIComponent;
    if (!cookieNameRegExp.test(name)) {
        throw new TypeError(`argument name is invalid: ${name}`);
    }
    const value = enc(val);
    if (!cookieValueRegExp.test(value)) {
        throw new TypeError(`argument val is invalid: ${val}`);
    }
    let str = name + "=" + value;
    if (!options)
        return str;
    if (options.maxAge !== undefined) {
        if (!Number.isInteger(options.maxAge)) {
            throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);
        }
        str += "; Max-Age=" + options.maxAge;
    }
    if (options.domain) {
        if (!domainValueRegExp.test(options.domain)) {
            throw new TypeError(`option domain is invalid: ${options.domain}`);
        }
        str += "; Domain=" + options.domain;
    }
    if (options.path) {
        if (!pathValueRegExp.test(options.path)) {
            throw new TypeError(`option path is invalid: ${options.path}`);
        }
        str += "; Path=" + options.path;
    }
    if (options.expires) {
        if (!isDate$3(options.expires) ||
            !Number.isFinite(options.expires.valueOf())) {
            throw new TypeError(`option expires is invalid: ${options.expires}`);
        }
        str += "; Expires=" + options.expires.toUTCString();
    }
    if (options.httpOnly) {
        str += "; HttpOnly";
    }
    if (options.secure) {
        str += "; Secure";
    }
    if (options.partitioned) {
        str += "; Partitioned";
    }
    if (options.priority) {
        const priority = typeof options.priority === "string"
            ? options.priority.toLowerCase()
            : undefined;
        switch (priority) {
            case "low":
                str += "; Priority=Low";
                break;
            case "medium":
                str += "; Priority=Medium";
                break;
            case "high":
                str += "; Priority=High";
                break;
            default:
                throw new TypeError(`option priority is invalid: ${options.priority}`);
        }
    }
    if (options.sameSite) {
        const sameSite = typeof options.sameSite === "string"
            ? options.sameSite.toLowerCase()
            : options.sameSite;
        switch (sameSite) {
            case true:
            case "strict":
                str += "; SameSite=Strict";
                break;
            case "lax":
                str += "; SameSite=Lax";
                break;
            case "none":
                str += "; SameSite=None";
                break;
            default:
                throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);
        }
    }
    return str;
}
/**
 * URL-decode string value. Optimized to skip native call when no %.
 */
function decode(str) {
    if (str.indexOf("%") === -1)
        return str;
    try {
        return decodeURIComponent(str);
    }
    catch (e) {
        return str;
    }
}
/**
 * Determine if value is a Date.
 */
function isDate$3(val) {
    return __toString.call(val) === "[object Date]";
}

var PopStateEventType = "popstate";
function createBrowserHistory(options = {}) {
  function createBrowserLocation(window2, globalHistory) {
    let { pathname, search, hash } = window2.location;
    return createLocation(
      "",
      { pathname, search, hash },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createBrowserHref(window2, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(
    createBrowserLocation,
    createBrowserHref,
    null,
    options
  );
}
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined") console.warn(message);
    try {
      throw new Error(message);
    } catch (e) {
    }
  }
}
function createKey() {
  return Math.random().toString(36).substring(2, 10);
}
function getHistoryState(location, index) {
  return {
    usr: location.state,
    key: location.key,
    idx: index
  };
}
function createLocation(current, to, state = null, key) {
  let location = {
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: "",
    ...typeof to === "string" ? parsePath(to) : to,
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  };
  return location;
}
function createPath({
  pathname = "/",
  search = "",
  hash = ""
}) {
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#")
    pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substring(hashIndex);
      path = path.substring(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substring(searchIndex);
      path = path.substring(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref2, validateLocation, options = {}) {
  let { window: window2 = document.defaultView, v5Compat = false } = options;
  let globalHistory = window2.history;
  let action = "POP";
  let listener = null;
  let index = getIndex();
  if (index == null) {
    index = 0;
    globalHistory.replaceState({ ...globalHistory.state, idx: index }, "");
  }
  function getIndex() {
    let state = globalHistory.state || { idx: null };
    return state.idx;
  }
  function handlePop() {
    action = "POP";
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index;
    index = nextIndex;
    if (listener) {
      listener({ action, location: history.location, delta });
    }
  }
  function push(to, state) {
    action = "PUSH";
    let location = createLocation(history.location, to, state);
    index = getIndex() + 1;
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      if (error instanceof DOMException && error.name === "DataCloneError") {
        throw error;
      }
      window2.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({ action, location: history.location, delta: 1 });
    }
  }
  function replace2(to, state) {
    action = "REPLACE";
    let location = createLocation(history.location, to, state);
    index = getIndex();
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({ action, location: history.location, delta: 0 });
    }
  }
  function createURL(to) {
    return createBrowserURLImpl(to);
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref2(window2, to);
    },
    createURL,
    encodeLocation(to) {
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push,
    replace: replace2,
    go(n) {
      return globalHistory.go(n);
    }
  };
  return history;
}
function createBrowserURLImpl(to, isAbsolute = false) {
  let base = "http://localhost";
  if (typeof window !== "undefined") {
    base = window.location.origin !== "null" ? window.location.origin : window.location.href;
  }
  invariant(base, "No window.location.(origin|href) available to create URL");
  let href2 = typeof to === "string" ? to : createPath(to);
  href2 = href2.replace(/ $/, "%20");
  if (!isAbsolute && href2.startsWith("//")) {
    href2 = base + href2;
  }
  return new URL(href2, base);
}
function matchRoutes(routes, locationArg, basename = "/") {
  return matchRoutesImpl(routes, locationArg, basename, false);
}
function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i) {
    let decoded = decodePath(pathname);
    matches = matchRouteBranch(
      branches[i],
      decoded,
      allowPartial
    );
  }
  return matches;
}
function flattenRoutes(routes, branches = [], parentsMeta = [], parentPath = "") {
  let flattenRoute = (route, index, relativePath) => {
    let meta = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant(
        meta.relativePath.startsWith(parentPath),
        `Absolute route path "${meta.relativePath}" nested under path "${parentPath}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`
      );
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true,
        `Index routes must not have child routes. Please remove all child routes from route path "${path}".`
      );
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index) => {
    if (route.path === "" || !route.path?.includes("?")) {
      flattenRoute(route, index);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index, exploded);
      }
    }
  });
  return branches;
}
function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0) return [];
  let [first, ...rest] = segments;
  let isOptional = first.endsWith("?");
  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  result.push(
    ...restExploded.map(
      (subpath) => subpath === "" ? required : [required, subpath].join("/")
    )
  );
  if (isOptional) {
    result.push(...restExploded);
  }
  return result.map(
    (exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded
  );
}
function rankRouteBranches(branches) {
  branches.sort(
    (a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(
      a.routesMeta.map((meta) => meta.childrenIndex),
      b.routesMeta.map((meta) => meta.childrenIndex)
    )
  );
}
var paramRe = /^:[\w-]+$/;
var dynamicSegmentValue = 3;
var indexRouteValue = 2;
var emptySegmentValue = 1;
var staticSegmentValue = 10;
var splatPenalty = -2;
var isSplat = (s) => s === "*";
function computeScore(path, index) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s) => !isSplat(s)).reduce(
    (score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue),
    initialScore
  );
}
function compareIndexes(a, b) {
  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a[a.length - 1] - b[b.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch(branch, pathname, allowPartial = false) {
  let { routesMeta } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta = routesMeta[i];
    let end = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath(
      { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },
      remainingPathname
    );
    let route = meta.route;
    if (!match && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {
      match = matchPath(
        {
          path: meta.relativePath,
          caseSensitive: meta.caseSensitive,
          end: false
        },
        remainingPathname
      );
    }
    if (!match) {
      return null;
    }
    Object.assign(matchedParams, match.params);
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(
        joinPaths([matchedPathname, match.pathnameBase])
      ),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = { path: pattern, caseSensitive: false, end: true };
  }
  let [matcher, compiledParams] = compilePath(
    pattern.path,
    pattern.caseSensitive,
    pattern.end
  );
  let match = pathname.match(matcher);
  if (!match) return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = compiledParams.reduce(
    (memo2, { paramName, isOptional }, index) => {
      if (paramName === "*") {
        let splatValue = captureGroups[index] || "";
        pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
      }
      const value = captureGroups[index];
      if (isOptional && !value) {
        memo2[paramName] = void 0;
      } else {
        memo2[paramName] = (value || "").replace(/%2F/g, "/");
      }
      return memo2;
    },
    {}
  );
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive = false, end = true) {
  warning(
    path === "*" || !path.endsWith("*") || path.endsWith("/*"),
    `Route path "${path}" will be treated as if it were "${path.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${path.replace(/\*$/, "/*")}".`
  );
  let params = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(
    /\/:([\w-]+)(\?)?/g,
    (_, paramName, isOptional) => {
      params.push({ paramName, isOptional: isOptional != null });
      return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
    }
  );
  if (path.endsWith("*")) {
    params.push({ paramName: "*" });
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else ;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, params];
}
function decodePath(value) {
  try {
    return value.split("/").map((v) => decodeURIComponent(v).replace(/\//g, "%2F")).join("/");
  } catch (error) {
    warning(
      false,
      `The URL path "${value}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${error}).`
    );
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function resolvePath(to, fromPathname = "/") {
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1) segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char, field, dest, path) {
  return `Cannot include a '${char}' character in a manually specified \`to.${field}\` field [${JSON.stringify(
    path
  )}].  Please separate it out to the \`to.${dest}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
}
function getPathContributingMatches(matches) {
  return matches.filter(
    (match, index) => index === 0 || match.route.path && match.route.path.length > 0
  );
}
function getResolveToMatches(matches) {
  let pathMatches = getPathContributingMatches(matches);
  return pathMatches.map(
    (match, idx) => idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase
  );
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative = false) {
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = { ...toArg };
    invariant(
      !to.pathname || !to.pathname.includes("?"),
      getInvalidPathError("?", "pathname", "search", to)
    );
    invariant(
      !to.pathname || !to.pathname.includes("#"),
      getInvalidPathError("#", "pathname", "hash", to)
    );
    invariant(
      !to.search || !to.search.includes("#"),
      getInvalidPathError("#", "search", "hash", to)
    );
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from;
  if (toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (!isPathRelative && toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
var joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
var normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
var normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
var normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}
var validMutationMethodsArr = [
  "POST",
  "PUT",
  "PATCH",
  "DELETE"
];
new Set(
  validMutationMethodsArr
);
var validRequestMethodsArr = [
  "GET",
  ...validMutationMethodsArr
];
new Set(validRequestMethodsArr);
var DataRouterContext = reactExports.createContext(null);
DataRouterContext.displayName = "DataRouter";
var DataRouterStateContext = reactExports.createContext(null);
DataRouterStateContext.displayName = "DataRouterState";
var ViewTransitionContext = reactExports.createContext({
  isTransitioning: false
});
ViewTransitionContext.displayName = "ViewTransition";
var FetchersContext = reactExports.createContext(
  /* @__PURE__ */ new Map()
);
FetchersContext.displayName = "Fetchers";
var AwaitContext = reactExports.createContext(null);
AwaitContext.displayName = "Await";
var NavigationContext = reactExports.createContext(
  null
);
NavigationContext.displayName = "Navigation";
var LocationContext = reactExports.createContext(
  null
);
LocationContext.displayName = "Location";
var RouteContext = reactExports.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
RouteContext.displayName = "Route";
var RouteErrorContext = reactExports.createContext(null);
RouteErrorContext.displayName = "RouteError";
function useHref(to, { relative } = {}) {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useHref() may be used only in the context of a <Router> component.`
  );
  let { basename, navigator } = reactExports.useContext(NavigationContext);
  let { hash, pathname, search } = useResolvedPath(to, { relative });
  let joinedPathname = pathname;
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator.createHref({ pathname: joinedPathname, search, hash });
}
function useInRouterContext() {
  return reactExports.useContext(LocationContext) != null;
}
function useLocation() {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useLocation() may be used only in the context of a <Router> component.`
  );
  return reactExports.useContext(LocationContext).location;
}
var navigateEffectWarning = `You should call navigate() in a React.useEffect(), not when your component is first rendered.`;
function useIsomorphicLayoutEffect$2(cb) {
  let isStatic = reactExports.useContext(NavigationContext).static;
  if (!isStatic) {
    reactExports.useLayoutEffect(cb);
  }
}
function useNavigate() {
  let { isDataRoute } = reactExports.useContext(RouteContext);
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useNavigate() may be used only in the context of a <Router> component.`
  );
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  let { basename, navigator } = reactExports.useContext(NavigationContext);
  let { matches } = reactExports.useContext(RouteContext);
  let { pathname: locationPathname } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect$2(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(
    (to, options = {}) => {
      warning(activeRef.current, navigateEffectWarning);
      if (!activeRef.current) return;
      if (typeof to === "number") {
        navigator.go(to);
        return;
      }
      let path = resolveTo(
        to,
        JSON.parse(routePathnamesJson),
        locationPathname,
        options.relative === "path"
      );
      if (dataRouterContext == null && basename !== "/") {
        path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
      }
      (!!options.replace ? navigator.replace : navigator.push)(
        path,
        options.state,
        options
      );
    },
    [
      basename,
      navigator,
      routePathnamesJson,
      locationPathname,
      dataRouterContext
    ]
  );
  return navigate;
}
reactExports.createContext(null);
function useResolvedPath(to, { relative } = {}) {
  let { matches } = reactExports.useContext(RouteContext);
  let { pathname: locationPathname } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
  return reactExports.useMemo(
    () => resolveTo(
      to,
      JSON.parse(routePathnamesJson),
      locationPathname,
      relative === "path"
    ),
    [to, routePathnamesJson, locationPathname, relative]
  );
}
function useRoutes(routes, locationArg) {
  return useRoutesImpl(routes, locationArg);
}
function useRoutesImpl(routes, locationArg, dataRouterState, future) {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useRoutes() may be used only in the context of a <Router> component.`
  );
  let { navigator, static: isStatic } = reactExports.useContext(NavigationContext);
  let { matches: parentMatches } = reactExports.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  let parentPathname = routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  let parentRoute = routeMatch && routeMatch.route;
  {
    let parentPath = parentRoute && parentRoute.path || "";
    warningOnce(
      parentPathname,
      !parentRoute || parentPath.endsWith("*") || parentPath.endsWith("*?"),
      `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${parentPathname}" (under <Route path="${parentPath}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${parentPath}"> to <Route path="${parentPath === "/" ? "*" : `${parentPath}/*`}">.`
    );
  }
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    invariant(
      parentPathnameBase === "/" || parsedLocationArg.pathname?.startsWith(parentPathnameBase),
      `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${parentPathnameBase}" but pathname "${parsedLocationArg.pathname}" was given in the \`location\` prop.`
    );
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = pathname;
  if (parentPathnameBase !== "/") {
    let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
    let segments = pathname.replace(/^\//, "").split("/");
    remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
  }
  let matches = !isStatic && dataRouterState && dataRouterState.matches && dataRouterState.matches.length > 0 ? dataRouterState.matches : matchRoutes(routes, { pathname: remainingPathname });
  {
    warning(
      parentRoute || matches != null,
      `No routes matched location "${location.pathname}${location.search}${location.hash}" `
    );
    warning(
      matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0 || matches[matches.length - 1].route.lazy !== void 0,
      `Matched leaf route at location "${location.pathname}${location.search}${location.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`
    );
  }
  let renderedMatches = _renderMatches(
    matches && matches.map(
      (match) => Object.assign({}, match, {
        params: Object.assign({}, parentParams, match.params),
        pathname: joinPaths([
          parentPathnameBase,
          // Re-encode pathnames that were decoded inside matchRoutes
          navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname
        ]),
        pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([
          parentPathnameBase,
          // Re-encode pathnames that were decoded inside matchRoutes
          navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase
        ])
      })
    ),
    parentMatches,
    dataRouterState,
    future
  );
  if (locationArg && renderedMatches) {
    return /* @__PURE__ */ reactExports.createElement(
      LocationContext.Provider,
      {
        value: {
          location: {
            pathname: "/",
            search: "",
            hash: "",
            state: null,
            key: "default",
            ...location
          },
          navigationType: "POP"
          /* Pop */
        }
      },
      renderedMatches
    );
  }
  return renderedMatches;
}
function DefaultErrorComponent() {
  let error = useRouteError();
  let message = isRouteErrorResponse(error) ? `${error.status} ${error.statusText}` : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = { padding: "0.5rem", backgroundColor: lightgrey };
  let codeStyles = { padding: "2px 4px", backgroundColor: lightgrey };
  let devInfo = null;
  {
    console.error(
      "Error handled by React Router default ErrorBoundary:",
      error
    );
    devInfo = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("p", null, "💿 Hey developer 👋"), /* @__PURE__ */ reactExports.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ reactExports.createElement("code", { style: codeStyles }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ reactExports.createElement("code", { style: codeStyles }, "errorElement"), " prop on your route."));
  }
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", { style: { fontStyle: "italic" } }, message), stack ? /* @__PURE__ */ reactExports.createElement("pre", { style: preStyles }, stack) : null, devInfo);
}
var defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
var RenderErrorBoundary = class extends reactExports.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation
      };
    }
    return {
      error: props.error !== void 0 ? props.error : state.error,
      location: state.location,
      revalidation: props.revalidation || state.revalidation
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error(
      "React Router caught the following error during render",
      error,
      errorInfo
    );
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, { value: this.props.routeContext }, /* @__PURE__ */ reactExports.createElement(
      RouteErrorContext.Provider,
      {
        value: this.state.error,
        children: this.props.component
      }
    )) : this.props.children;
  }
};
function RenderedRoute({ routeContext, match, children }) {
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
  }
  return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, { value: routeContext }, children);
}
function _renderMatches(matches, parentMatches = [], dataRouterState = null, future = null) {
  if (matches == null) {
    if (!dataRouterState) {
      return null;
    }
    if (dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else if (parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors = dataRouterState?.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex(
      (m) => m.route.id && errors?.[m.route.id] !== void 0
    );
    invariant(
      errorIndex >= 0,
      `Could not find a matching route for errors on route IDs: ${Object.keys(
        errors
      ).join(",")}`
    );
    renderedMatches = renderedMatches.slice(
      0,
      Math.min(renderedMatches.length, errorIndex + 1)
    );
  }
  let renderFallback = false;
  let fallbackIndex = -1;
  if (dataRouterState) {
    for (let i = 0; i < renderedMatches.length; i++) {
      let match = renderedMatches[i];
      if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {
        fallbackIndex = i;
      }
      if (match.route.id) {
        let { loaderData, errors: errors2 } = dataRouterState;
        let needsToRunLoader = match.route.loader && !loaderData.hasOwnProperty(match.route.id) && (!errors2 || errors2[match.route.id] === void 0);
        if (match.route.lazy || needsToRunLoader) {
          renderFallback = true;
          if (fallbackIndex >= 0) {
            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
          } else {
            renderedMatches = [renderedMatches[0]];
          }
          break;
        }
      }
    }
  }
  return renderedMatches.reduceRight((outlet, match, index) => {
    let error;
    let shouldRenderHydrateFallback = false;
    let errorElement = null;
    let hydrateFallbackElement = null;
    if (dataRouterState) {
      error = errors && match.route.id ? errors[match.route.id] : void 0;
      errorElement = match.route.errorElement || defaultErrorElement;
      if (renderFallback) {
        if (fallbackIndex < 0 && index === 0) {
          warningOnce(
            "route-fallback",
            false,
            "No `HydrateFallback` element provided to render during initial hydration"
          );
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = null;
        } else if (fallbackIndex === index) {
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = match.route.hydrateFallbackElement || null;
        }
      }
    }
    let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));
    let getChildren = () => {
      let children;
      if (error) {
        children = errorElement;
      } else if (shouldRenderHydrateFallback) {
        children = hydrateFallbackElement;
      } else if (match.route.Component) {
        children = /* @__PURE__ */ reactExports.createElement(match.route.Component, null);
      } else if (match.route.element) {
        children = match.route.element;
      } else {
        children = outlet;
      }
      return /* @__PURE__ */ reactExports.createElement(
        RenderedRoute,
        {
          match,
          routeContext: {
            outlet,
            matches: matches2,
            isDataRoute: dataRouterState != null
          },
          children
        }
      );
    };
    return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /* @__PURE__ */ reactExports.createElement(
      RenderErrorBoundary,
      {
        location: dataRouterState.location,
        revalidation: dataRouterState.revalidation,
        component: errorElement,
        error,
        children: getChildren(),
        routeContext: { outlet: null, matches: matches2, isDataRoute: true }
      }
    ) : getChildren();
  }, null);
}
function getDataRouterConsoleError(hookName) {
  return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function useDataRouterContext(hookName) {
  let ctx = reactExports.useContext(DataRouterContext);
  invariant(ctx, getDataRouterConsoleError(hookName));
  return ctx;
}
function useDataRouterState(hookName) {
  let state = reactExports.useContext(DataRouterStateContext);
  invariant(state, getDataRouterConsoleError(hookName));
  return state;
}
function useRouteContext(hookName) {
  let route = reactExports.useContext(RouteContext);
  invariant(route, getDataRouterConsoleError(hookName));
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext(hookName);
  let thisRoute = route.matches[route.matches.length - 1];
  invariant(
    thisRoute.route.id,
    `${hookName} can only be used on routes that contain a unique "id"`
  );
  return thisRoute.route.id;
}
function useRouteId() {
  return useCurrentRouteId(
    "useRouteId"
    /* UseRouteId */
  );
}
function useRouteError() {
  let error = reactExports.useContext(RouteErrorContext);
  let state = useDataRouterState(
    "useRouteError"
    /* UseRouteError */
  );
  let routeId = useCurrentRouteId(
    "useRouteError"
    /* UseRouteError */
  );
  if (error !== void 0) {
    return error;
  }
  return state.errors?.[routeId];
}
function useNavigateStable() {
  let { router } = useDataRouterContext(
    "useNavigate"
    /* UseNavigateStable */
  );
  let id = useCurrentRouteId(
    "useNavigate"
    /* UseNavigateStable */
  );
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect$2(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(
    async (to, options = {}) => {
      warning(activeRef.current, navigateEffectWarning);
      if (!activeRef.current) return;
      if (typeof to === "number") {
        router.navigate(to);
      } else {
        await router.navigate(to, { fromRouteId: id, ...options });
      }
    },
    [router, id]
  );
  return navigate;
}
var alreadyWarned = {};
function warningOnce(key, cond, message) {
  if (!cond && !alreadyWarned[key]) {
    alreadyWarned[key] = true;
    warning(false, message);
  }
}
reactExports.memo(DataRoutes);
function DataRoutes({
  routes,
  future,
  state
}) {
  return useRoutesImpl(routes, void 0, state, future);
}
function Navigate({
  to,
  replace: replace2,
  state,
  relative
}) {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of
    // the router loaded. We can help them understand how to avoid that.
    `<Navigate> may be used only in the context of a <Router> component.`
  );
  let { static: isStatic } = reactExports.useContext(NavigationContext);
  warning(
    !isStatic,
    `<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.`
  );
  let { matches } = reactExports.useContext(RouteContext);
  let { pathname: locationPathname } = useLocation();
  let navigate = useNavigate();
  let path = resolveTo(
    to,
    getResolveToMatches(matches),
    locationPathname,
    relative === "path"
  );
  let jsonPath = JSON.stringify(path);
  reactExports.useEffect(() => {
    navigate(JSON.parse(jsonPath), { replace: replace2, state, relative });
  }, [navigate, jsonPath, relative, replace2, state]);
  return null;
}
function Route(_props) {
  invariant(
    false,
    `A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.`
  );
}
function Router({
  basename: basenameProp = "/",
  children = null,
  location: locationProp,
  navigationType = "POP",
  navigator,
  static: staticProp = false
}) {
  invariant(
    !useInRouterContext(),
    `You cannot render a <Router> inside another <Router>. You should never have more than one in your app.`
  );
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = reactExports.useMemo(
    () => ({
      basename,
      navigator,
      static: staticProp,
      future: {}
    }),
    [basename, navigator, staticProp]
  );
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let locationContext = reactExports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash,
        state,
        key
      },
      navigationType
    };
  }, [basename, pathname, search, hash, state, key, navigationType]);
  warning(
    locationContext != null,
    `<Router basename="${basename}"> is not able to match the URL "${pathname}${search}${hash}" because it does not start with the basename, so the <Router> won't render anything.`
  );
  if (locationContext == null) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, { value: navigationContext }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, { children, value: locationContext }));
}
function Routes({
  children,
  location
}) {
  return useRoutes(createRoutesFromChildren(children), location);
}
function createRoutesFromChildren(children, parentPath = []) {
  let routes = [];
  reactExports.Children.forEach(children, (element, index) => {
    if (!reactExports.isValidElement(element)) {
      return;
    }
    let treePath = [...parentPath, index];
    if (element.type === reactExports.Fragment) {
      routes.push.apply(
        routes,
        createRoutesFromChildren(element.props.children, treePath)
      );
      return;
    }
    invariant(
      element.type === Route,
      `[${typeof element.type === "string" ? element.type : element.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`
    );
    invariant(
      !element.props.index || !element.props.children,
      "An index route cannot have child routes."
    );
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      Component: element.props.Component,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      hydrateFallbackElement: element.props.hydrateFallbackElement,
      HydrateFallback: element.props.HydrateFallback,
      errorElement: element.props.errorElement,
      ErrorBoundary: element.props.ErrorBoundary,
      hasErrorBoundary: element.props.hasErrorBoundary === true || element.props.ErrorBoundary != null || element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle,
      lazy: element.props.lazy
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(
        element.props.children,
        treePath
      );
    }
    routes.push(route);
  });
  return routes;
}
var defaultMethod = "get";
var defaultEncType = "application/x-www-form-urlencoded";
function isHtmlElement(object) {
  return object != null && typeof object.tagName === "string";
}
function isButtonElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
}
function isFormElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
}
function isInputElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && // Ignore everything but left clicks
  (!target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event);
}
var _formDataSupportsSubmitter = null;
function isFormDataSubmitterSupported() {
  if (_formDataSupportsSubmitter === null) {
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      );
      _formDataSupportsSubmitter = false;
    } catch (e) {
      _formDataSupportsSubmitter = true;
    }
  }
  return _formDataSupportsSubmitter;
}
var supportedFormEncTypes = /* @__PURE__ */ new Set([
  "application/x-www-form-urlencoded",
  "multipart/form-data",
  "text/plain"
]);
function getFormEncType(encType) {
  if (encType != null && !supportedFormEncTypes.has(encType)) {
    warning(
      false,
      `"${encType}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${defaultEncType}"`
    );
    return null;
  }
  return encType;
}
function getFormSubmissionInfo(target, basename) {
  let method;
  let action;
  let encType;
  let formData;
  let body;
  if (isFormElement(target)) {
    let attr = target.getAttribute("action");
    action = attr ? stripBasename(attr, basename) : null;
    method = target.getAttribute("method") || defaultMethod;
    encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;
    formData = new FormData(target);
  } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
    let form = target.form;
    if (form == null) {
      throw new Error(
        `Cannot submit a <button> or <input type="submit"> without a <form>`
      );
    }
    let attr = target.getAttribute("formaction") || form.getAttribute("action");
    action = attr ? stripBasename(attr, basename) : null;
    method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
    encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType;
    formData = new FormData(form, target);
    if (!isFormDataSubmitterSupported()) {
      let { name, type, value } = target;
      if (type === "image") {
        let prefix = name ? `${name}.` : "";
        formData.append(`${prefix}x`, "0");
        formData.append(`${prefix}y`, "0");
      } else if (name) {
        formData.append(name, value);
      }
    }
  } else if (isHtmlElement(target)) {
    throw new Error(
      `Cannot submit element that is not <form>, <button>, or <input type="submit|image">`
    );
  } else {
    method = defaultMethod;
    action = null;
    encType = defaultEncType;
    body = target;
  }
  if (formData && encType === "text/plain") {
    body = formData;
    formData = void 0;
  }
  return { action, method: method.toLowerCase(), encType, formData, body };
}
function invariant2(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
async function loadRouteModule(route, routeModulesCache) {
  if (route.id in routeModulesCache) {
    return routeModulesCache[route.id];
  }
  try {
    let routeModule = await import(
      /* @vite-ignore */
      /* webpackIgnore: true */
      route.module
    );
    routeModulesCache[route.id] = routeModule;
    return routeModule;
  } catch (error) {
    console.error(
      `Error loading route module \`${route.module}\`, reloading page...`
    );
    console.error(error);
    if (window.__reactRouterContext && window.__reactRouterContext.isSpaMode && // @ts-expect-error
    void 0) ;
    window.location.reload();
    return new Promise(() => {
    });
  }
}
function isHtmlLinkDescriptor(object) {
  if (object == null) {
    return false;
  }
  if (object.href == null) {
    return object.rel === "preload" && typeof object.imageSrcSet === "string" && typeof object.imageSizes === "string";
  }
  return typeof object.rel === "string" && typeof object.href === "string";
}
async function getKeyedPrefetchLinks(matches, manifest, routeModules) {
  let links = await Promise.all(
    matches.map(async (match) => {
      let route = manifest.routes[match.route.id];
      if (route) {
        let mod = await loadRouteModule(route, routeModules);
        return mod.links ? mod.links() : [];
      }
      return [];
    })
  );
  return dedupeLinkDescriptors(
    links.flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === "stylesheet" || link.rel === "preload").map(
      (link) => link.rel === "stylesheet" ? { ...link, rel: "prefetch", as: "style" } : { ...link, rel: "prefetch" }
    )
  );
}
function getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {
  let isNew = (match, index) => {
    if (!currentMatches[index]) return true;
    return match.route.id !== currentMatches[index].route.id;
  };
  let matchPathChanged = (match, index) => {
    return (
      // param change, /users/123 -> /users/456
      currentMatches[index].pathname !== match.pathname || // splat param changed, which is not present in match.path
      // e.g. /files/images/avatar.jpg -> files/finances.xls
      currentMatches[index].route.path?.endsWith("*") && currentMatches[index].params["*"] !== match.params["*"]
    );
  };
  if (mode === "assets") {
    return nextMatches.filter(
      (match, index) => isNew(match, index) || matchPathChanged(match, index)
    );
  }
  if (mode === "data") {
    return nextMatches.filter((match, index) => {
      let manifestRoute = manifest.routes[match.route.id];
      if (!manifestRoute || !manifestRoute.hasLoader) {
        return false;
      }
      if (isNew(match, index) || matchPathChanged(match, index)) {
        return true;
      }
      if (match.route.shouldRevalidate) {
        let routeChoice = match.route.shouldRevalidate({
          currentUrl: new URL(
            location.pathname + location.search + location.hash,
            window.origin
          ),
          currentParams: currentMatches[0]?.params || {},
          nextUrl: new URL(page, window.origin),
          nextParams: match.params,
          defaultShouldRevalidate: true
        });
        if (typeof routeChoice === "boolean") {
          return routeChoice;
        }
      }
      return true;
    });
  }
  return [];
}
function getModuleLinkHrefs(matches, manifest, { includeHydrateFallback } = {}) {
  return dedupeHrefs(
    matches.map((match) => {
      let route = manifest.routes[match.route.id];
      if (!route) return [];
      let hrefs = [route.module];
      if (route.clientActionModule) {
        hrefs = hrefs.concat(route.clientActionModule);
      }
      if (route.clientLoaderModule) {
        hrefs = hrefs.concat(route.clientLoaderModule);
      }
      if (includeHydrateFallback && route.hydrateFallbackModule) {
        hrefs = hrefs.concat(route.hydrateFallbackModule);
      }
      if (route.imports) {
        hrefs = hrefs.concat(route.imports);
      }
      return hrefs;
    }).flat(1)
  );
}
function dedupeHrefs(hrefs) {
  return [...new Set(hrefs)];
}
function sortKeys(obj) {
  let sorted = {};
  let keys = Object.keys(obj).sort();
  for (let key of keys) {
    sorted[key] = obj[key];
  }
  return sorted;
}
function dedupeLinkDescriptors(descriptors, preloads) {
  let set = /* @__PURE__ */ new Set();
  new Set(preloads);
  return descriptors.reduce((deduped, descriptor) => {
    let key = JSON.stringify(sortKeys(descriptor));
    if (!set.has(key)) {
      set.add(key);
      deduped.push({ key, link: descriptor });
    }
    return deduped;
  }, []);
}
Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
var NO_BODY_STATUS_CODES = /* @__PURE__ */ new Set([100, 101, 204, 205]);
function singleFetchUrl(reqUrl, basename) {
  let url = typeof reqUrl === "string" ? new URL(
    reqUrl,
    // This can be called during the SSR flow via PrefetchPageLinksImpl so
    // don't assume window is available
    typeof window === "undefined" ? "server://singlefetch/" : window.location.origin
  ) : reqUrl;
  if (url.pathname === "/") {
    url.pathname = "_root.data";
  } else if (basename && stripBasename(url.pathname, basename) === "/") {
    url.pathname = `${basename.replace(/\/$/, "")}/_root.data`;
  } else {
    url.pathname = `${url.pathname.replace(/\/$/, "")}.data`;
  }
  return url;
}
function useDataRouterContext2() {
  let context = reactExports.useContext(DataRouterContext);
  invariant2(
    context,
    "You must render this element inside a <DataRouterContext.Provider> element"
  );
  return context;
}
function useDataRouterStateContext() {
  let context = reactExports.useContext(DataRouterStateContext);
  invariant2(
    context,
    "You must render this element inside a <DataRouterStateContext.Provider> element"
  );
  return context;
}
var FrameworkContext = reactExports.createContext(void 0);
FrameworkContext.displayName = "FrameworkContext";
function useFrameworkContext() {
  let context = reactExports.useContext(FrameworkContext);
  invariant2(
    context,
    "You must render this element inside a <HydratedRouter> element"
  );
  return context;
}
function usePrefetchBehavior(prefetch, theirElementProps) {
  let frameworkContext = reactExports.useContext(FrameworkContext);
  let [maybePrefetch, setMaybePrefetch] = reactExports.useState(false);
  let [shouldPrefetch, setShouldPrefetch] = reactExports.useState(false);
  let { onFocus, onBlur, onMouseEnter, onMouseLeave, onTouchStart } = theirElementProps;
  let ref = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (prefetch === "render") {
      setShouldPrefetch(true);
    }
    if (prefetch === "viewport") {
      let callback = (entries) => {
        entries.forEach((entry) => {
          setShouldPrefetch(entry.isIntersecting);
        });
      };
      let observer = new IntersectionObserver(callback, { threshold: 0.5 });
      if (ref.current) observer.observe(ref.current);
      return () => {
        observer.disconnect();
      };
    }
  }, [prefetch]);
  reactExports.useEffect(() => {
    if (maybePrefetch) {
      let id = setTimeout(() => {
        setShouldPrefetch(true);
      }, 100);
      return () => {
        clearTimeout(id);
      };
    }
  }, [maybePrefetch]);
  let setIntent = () => {
    setMaybePrefetch(true);
  };
  let cancelIntent = () => {
    setMaybePrefetch(false);
    setShouldPrefetch(false);
  };
  if (!frameworkContext) {
    return [false, ref, {}];
  }
  if (prefetch !== "intent") {
    return [shouldPrefetch, ref, {}];
  }
  return [
    shouldPrefetch,
    ref,
    {
      onFocus: composeEventHandlers(onFocus, setIntent),
      onBlur: composeEventHandlers(onBlur, cancelIntent),
      onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
      onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
      onTouchStart: composeEventHandlers(onTouchStart, setIntent)
    }
  ];
}
function composeEventHandlers(theirHandler, ourHandler) {
  return (event) => {
    theirHandler && theirHandler(event);
    if (!event.defaultPrevented) {
      ourHandler(event);
    }
  };
}
function PrefetchPageLinks({
  page,
  ...dataLinkProps
}) {
  let { router } = useDataRouterContext2();
  let matches = reactExports.useMemo(
    () => matchRoutes(router.routes, page, router.basename),
    [router.routes, page, router.basename]
  );
  if (!matches) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(PrefetchPageLinksImpl, { page, matches, ...dataLinkProps });
}
function useKeyedPrefetchLinks(matches) {
  let { manifest, routeModules } = useFrameworkContext();
  let [keyedPrefetchLinks, setKeyedPrefetchLinks] = reactExports.useState([]);
  reactExports.useEffect(() => {
    let interrupted = false;
    void getKeyedPrefetchLinks(matches, manifest, routeModules).then(
      (links) => {
        if (!interrupted) {
          setKeyedPrefetchLinks(links);
        }
      }
    );
    return () => {
      interrupted = true;
    };
  }, [matches, manifest, routeModules]);
  return keyedPrefetchLinks;
}
function PrefetchPageLinksImpl({
  page,
  matches: nextMatches,
  ...linkProps
}) {
  let location = useLocation();
  let { manifest, routeModules } = useFrameworkContext();
  let { basename } = useDataRouterContext2();
  let { loaderData, matches } = useDataRouterStateContext();
  let newMatchesForData = reactExports.useMemo(
    () => getNewMatchesForLinks(
      page,
      nextMatches,
      matches,
      manifest,
      location,
      "data"
    ),
    [page, nextMatches, matches, manifest, location]
  );
  let newMatchesForAssets = reactExports.useMemo(
    () => getNewMatchesForLinks(
      page,
      nextMatches,
      matches,
      manifest,
      location,
      "assets"
    ),
    [page, nextMatches, matches, manifest, location]
  );
  let dataHrefs = reactExports.useMemo(() => {
    if (page === location.pathname + location.search + location.hash) {
      return [];
    }
    let routesParams = /* @__PURE__ */ new Set();
    let foundOptOutRoute = false;
    nextMatches.forEach((m) => {
      let manifestRoute = manifest.routes[m.route.id];
      if (!manifestRoute || !manifestRoute.hasLoader) {
        return;
      }
      if (!newMatchesForData.some((m2) => m2.route.id === m.route.id) && m.route.id in loaderData && routeModules[m.route.id]?.shouldRevalidate) {
        foundOptOutRoute = true;
      } else if (manifestRoute.hasClientLoader) {
        foundOptOutRoute = true;
      } else {
        routesParams.add(m.route.id);
      }
    });
    if (routesParams.size === 0) {
      return [];
    }
    let url = singleFetchUrl(page, basename);
    if (foundOptOutRoute && routesParams.size > 0) {
      url.searchParams.set(
        "_routes",
        nextMatches.filter((m) => routesParams.has(m.route.id)).map((m) => m.route.id).join(",")
      );
    }
    return [url.pathname + url.search];
  }, [
    basename,
    loaderData,
    location,
    manifest,
    newMatchesForData,
    nextMatches,
    page,
    routeModules
  ]);
  let moduleHrefs = reactExports.useMemo(
    () => getModuleLinkHrefs(newMatchesForAssets, manifest),
    [newMatchesForAssets, manifest]
  );
  let keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, dataHrefs.map((href2) => /* @__PURE__ */ reactExports.createElement("link", { key: href2, rel: "prefetch", as: "fetch", href: href2, ...linkProps })), moduleHrefs.map((href2) => /* @__PURE__ */ reactExports.createElement("link", { key: href2, rel: "modulepreload", href: href2, ...linkProps })), keyedPrefetchLinks.map(({ key, link }) => (
    // these don't spread `linkProps` because they are full link descriptors
    // already with their own props
    /* @__PURE__ */ reactExports.createElement("link", { key, ...link })
  )));
}
function mergeRefs(...refs) {
  return (value) => {
    refs.forEach((ref) => {
      if (typeof ref === "function") {
        ref(value);
      } else if (ref != null) {
        ref.current = value;
      }
    });
  };
}
var isBrowser$4 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
try {
  if (isBrowser$4) {
    window.__reactRouterVersion = "7.6.0";
  }
} catch (e) {
}
function BrowserRouter({
  basename,
  children,
  window: window2
}) {
  let historyRef = reactExports.useRef();
  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({ window: window2, v5Compat: true });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = reactExports.useState({
    action: history.action,
    location: history.location
  });
  let setState = reactExports.useCallback(
    (newState) => {
      reactExports.startTransition(() => setStateImpl(newState));
    },
    [setStateImpl]
  );
  reactExports.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /* @__PURE__ */ reactExports.createElement(
    Router,
    {
      basename,
      children,
      location: state.location,
      navigationType: state.action,
      navigator: history
    }
  );
}
var ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
var Link = reactExports.forwardRef(
  function LinkWithRef({
    onClick,
    discover = "render",
    prefetch = "none",
    relative,
    reloadDocument,
    replace: replace2,
    state,
    target,
    to,
    preventScrollReset,
    viewTransition,
    ...rest
  }, forwardedRef) {
    let { basename } = reactExports.useContext(NavigationContext);
    let isAbsolute = typeof to === "string" && ABSOLUTE_URL_REGEX2.test(to);
    let absoluteHref;
    let isExternal = false;
    if (typeof to === "string" && isAbsolute) {
      absoluteHref = to;
      if (isBrowser$4) {
        try {
          let currentUrl = new URL(window.location.href);
          let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
          let path = stripBasename(targetUrl.pathname, basename);
          if (targetUrl.origin === currentUrl.origin && path != null) {
            to = path + targetUrl.search + targetUrl.hash;
          } else {
            isExternal = true;
          }
        } catch (e) {
          warning(
            false,
            `<Link to="${to}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`
          );
        }
      }
    }
    let href2 = useHref(to, { relative });
    let [shouldPrefetch, prefetchRef, prefetchHandlers] = usePrefetchBehavior(
      prefetch,
      rest
    );
    let internalOnClick = useLinkClickHandler(to, {
      replace: replace2,
      state,
      target,
      preventScrollReset,
      relative,
      viewTransition
    });
    function handleClick(event) {
      if (onClick) onClick(event);
      if (!event.defaultPrevented) {
        internalOnClick(event);
      }
    }
    let link = (
      // eslint-disable-next-line jsx-a11y/anchor-has-content
      /* @__PURE__ */ reactExports.createElement(
        "a",
        {
          ...rest,
          ...prefetchHandlers,
          href: absoluteHref || href2,
          onClick: isExternal || reloadDocument ? onClick : handleClick,
          ref: mergeRefs(forwardedRef, prefetchRef),
          target,
          "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
        }
      )
    );
    return shouldPrefetch && !isAbsolute ? /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, link, /* @__PURE__ */ reactExports.createElement(PrefetchPageLinks, { page: href2 })) : link;
  }
);
Link.displayName = "Link";
var NavLink = reactExports.forwardRef(
  function NavLinkWithRef({
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end = false,
    style: styleProp,
    to,
    viewTransition,
    children,
    ...rest
  }, ref) {
    let path = useResolvedPath(to, { relative: rest.relative });
    let location = useLocation();
    let routerState = reactExports.useContext(DataRouterStateContext);
    let { navigator, basename } = reactExports.useContext(NavigationContext);
    let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useViewTransitionState(path) && viewTransition === true;
    let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;
    let locationPathname = location.pathname;
    let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
    if (!caseSensitive) {
      locationPathname = locationPathname.toLowerCase();
      nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
      toPathname = toPathname.toLowerCase();
    }
    if (nextLocationPathname && basename) {
      nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;
    }
    const endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length;
    let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/";
    let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
    let renderProps = {
      isActive,
      isPending,
      isTransitioning
    };
    let ariaCurrent = isActive ? ariaCurrentProp : void 0;
    let className;
    if (typeof classNameProp === "function") {
      className = classNameProp(renderProps);
    } else {
      className = [
        classNameProp,
        isActive ? "active" : null,
        isPending ? "pending" : null,
        isTransitioning ? "transitioning" : null
      ].filter(Boolean).join(" ");
    }
    let style = typeof styleProp === "function" ? styleProp(renderProps) : styleProp;
    return /* @__PURE__ */ reactExports.createElement(
      Link,
      {
        ...rest,
        "aria-current": ariaCurrent,
        className,
        ref,
        style,
        to,
        viewTransition
      },
      typeof children === "function" ? children(renderProps) : children
    );
  }
);
NavLink.displayName = "NavLink";
var Form$1 = reactExports.forwardRef(
  ({
    discover = "render",
    fetcherKey,
    navigate,
    reloadDocument,
    replace: replace2,
    state,
    method = defaultMethod,
    action,
    onSubmit,
    relative,
    preventScrollReset,
    viewTransition,
    ...props
  }, forwardedRef) => {
    let submit = useSubmit();
    let formAction = useFormAction(action, { relative });
    let formMethod = method.toLowerCase() === "get" ? "get" : "post";
    let isAbsolute = typeof action === "string" && ABSOLUTE_URL_REGEX2.test(action);
    let submitHandler = (event) => {
      onSubmit && onSubmit(event);
      if (event.defaultPrevented) return;
      event.preventDefault();
      let submitter = event.nativeEvent.submitter;
      let submitMethod = submitter?.getAttribute("formmethod") || method;
      submit(submitter || event.currentTarget, {
        fetcherKey,
        method: submitMethod,
        navigate,
        replace: replace2,
        state,
        relative,
        preventScrollReset,
        viewTransition
      });
    };
    return /* @__PURE__ */ reactExports.createElement(
      "form",
      {
        ref: forwardedRef,
        method: formMethod,
        action: formAction,
        onSubmit: reloadDocument ? onSubmit : submitHandler,
        ...props,
        "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
      }
    );
  }
);
Form$1.displayName = "Form";
function getDataRouterConsoleError2(hookName) {
  return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function useDataRouterContext3(hookName) {
  let ctx = reactExports.useContext(DataRouterContext);
  invariant(ctx, getDataRouterConsoleError2(hookName));
  return ctx;
}
function useLinkClickHandler(to, {
  target,
  replace: replaceProp,
  state,
  preventScrollReset,
  relative,
  viewTransition
} = {}) {
  let navigate = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to, { relative });
  return reactExports.useCallback(
    (event) => {
      if (shouldProcessLinkClick(event, target)) {
        event.preventDefault();
        let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
        navigate(to, {
          replace: replace2,
          state,
          preventScrollReset,
          relative,
          viewTransition
        });
      }
    },
    [
      location,
      navigate,
      path,
      replaceProp,
      state,
      target,
      to,
      preventScrollReset,
      relative,
      viewTransition
    ]
  );
}
var fetcherId = 0;
var getUniqueFetcherId = () => `__${String(++fetcherId)}__`;
function useSubmit() {
  let { router } = useDataRouterContext3(
    "useSubmit"
    /* UseSubmit */
  );
  let { basename } = reactExports.useContext(NavigationContext);
  let currentRouteId = useRouteId();
  return reactExports.useCallback(
    async (target, options = {}) => {
      let { action, method, encType, formData, body } = getFormSubmissionInfo(
        target,
        basename
      );
      if (options.navigate === false) {
        let key = options.fetcherKey || getUniqueFetcherId();
        await router.fetch(key, currentRouteId, options.action || action, {
          preventScrollReset: options.preventScrollReset,
          formData,
          body,
          formMethod: options.method || method,
          formEncType: options.encType || encType,
          flushSync: options.flushSync
        });
      } else {
        await router.navigate(options.action || action, {
          preventScrollReset: options.preventScrollReset,
          formData,
          body,
          formMethod: options.method || method,
          formEncType: options.encType || encType,
          replace: options.replace,
          state: options.state,
          fromRouteId: currentRouteId,
          flushSync: options.flushSync,
          viewTransition: options.viewTransition
        });
      }
    },
    [router, basename, currentRouteId]
  );
}
function useFormAction(action, { relative } = {}) {
  let { basename } = reactExports.useContext(NavigationContext);
  let routeContext = reactExports.useContext(RouteContext);
  invariant(routeContext, "useFormAction must be used inside a RouteContext");
  let [match] = routeContext.matches.slice(-1);
  let path = { ...useResolvedPath(action ? action : ".", { relative }) };
  let location = useLocation();
  if (action == null) {
    path.search = location.search;
    let params = new URLSearchParams(path.search);
    let indexValues = params.getAll("index");
    let hasNakedIndexParam = indexValues.some((v) => v === "");
    if (hasNakedIndexParam) {
      params.delete("index");
      indexValues.filter((v) => v).forEach((v) => params.append("index", v));
      let qs = params.toString();
      path.search = qs ? `?${qs}` : "";
    }
  }
  if ((!action || action === ".") && match.route.index) {
    path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
  }
  if (basename !== "/") {
    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
  }
  return createPath(path);
}
function useViewTransitionState(to, opts = {}) {
  let vtContext = reactExports.useContext(ViewTransitionContext);
  invariant(
    vtContext != null,
    "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"
  );
  let { basename } = useDataRouterContext3(
    "useViewTransitionState"
    /* useViewTransitionState */
  );
  let path = useResolvedPath(to, { relative: opts.relative });
  if (!vtContext.isTransitioning) {
    return false;
  }
  let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;
  let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;
  return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;
}
/* @__PURE__ */ new Set([
  ...NO_BODY_STATUS_CODES,
  304
]);

function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// utils is a library of generic helper functions non-specific to axios

const {toString: toString$2} = Object.prototype;
const {getPrototypeOf: getPrototypeOf$1} = Object;
const {iterator, toStringTag} = Symbol;

const kindOf = (cache => thing => {
    const str = toString$2.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));

const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type
};

const typeOfTest = type => thing => typeof thing === type;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */
const {isArray: isArray$2} = Array;

/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */
const isUndefined = typeOfTest('undefined');

/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer$1(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && isFunction$2(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
const isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  let result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */
const isString$1 = typeOfTest('string');

/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
const isFunction$2 = typeOfTest('function');

/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */
const isNumber = typeOfTest('number');

/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */
const isObject$3 = (thing) => thing !== null && typeof thing === 'object';

/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */
const isBoolean$1 = thing => thing === true || thing === false;

/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */
const isPlainObject$3 = (val) => {
  if (kindOf(val) !== 'object') {
    return false;
  }

  const prototype = getPrototypeOf$1(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(toStringTag in val) && !(iterator in val);
};

/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */
const isDate$2 = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */
const isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */
const isStream = (val) => isObject$3(val) && isFunction$2(val.pipe);

/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */
const isFormData = (thing) => {
  let kind;
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) || (
      isFunction$2(thing.append) && (
        (kind = kindOf(thing)) === 'formdata' ||
        // detect form-data instance
        (kind === 'object' && isFunction$2(thing.toString) && thing.toString() === '[object FormData]')
      )
    )
  )
};

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
const isURLSearchParams = kindOfTest('URLSearchParams');

const [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */
const trim$1 = (str) => str.trim ?
  str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */
function forEach$1(obj, fn, {allOwnKeys = false} = {}) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  let i;
  let l;

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray$2(obj)) {
    // Iterate over array values
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;

    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}

function findKey$1(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}

const _global = (() => {
  /*eslint no-undef:0*/
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : (typeof window !== 'undefined' ? window : global)
})();

const isContextDefined = (context) => !isUndefined(context) && context !== _global;

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  const {caseless} = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey$1(result, key) || key;
    if (isPlainObject$3(result[targetKey]) && isPlainObject$3(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject$3(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray$2(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };

  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach$1(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */
const extend = (a, b, thisArg, {allOwnKeys}= {}) => {
  forEach$1(b, (val, key) => {
    if (thisArg && isFunction$2(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, {allOwnKeys});
  return a;
};

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
};

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */
const inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, 'super', {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */
const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};

  destObj = destObj || {};
  // eslint-disable-next-line no-eq-null,eqeqeq
  if (sourceObj == null) return destObj;

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf$1(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
};

/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};


/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */
const toArray$1 = (thing) => {
  if (!thing) return null;
  if (isArray$2(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};

/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */
// eslint-disable-next-line func-names
const isTypedArray$1 = (TypedArray => {
  // eslint-disable-next-line func-names
  return thing => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && getPrototypeOf$1(Uint8Array));

/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[iterator];

  const _iterator = generator.call(obj);

  let result;

  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};

/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];

  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }

  return arr;
};

/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
const isHTMLForm = kindOfTest('HTMLFormElement');

const toCamelCase = str => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};

/* Creating a function that will check if an object has a property. */
const hasOwnProperty$b = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */
const isRegExp = kindOfTest('RegExp');

const reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};

  forEach$1(descriptors, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });

  Object.defineProperties(obj, reducedDescriptors);
};

/**
 * Makes all methods read-only
 * @param {Object} obj
 */

const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    // skip restricted props in strict mode
    if (isFunction$2(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
      return false;
    }

    const value = obj[name];

    if (!isFunction$2(value)) return;

    descriptor.enumerable = false;

    if ('writable' in descriptor) {
      descriptor.writable = false;
      return;
    }

    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error('Can not rewrite read-only method \'' + name + '\'');
      };
    }
  });
};

const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};

  const define = (arr) => {
    arr.forEach(value => {
      obj[value] = true;
    });
  };

  isArray$2(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

  return obj;
};

const noop$1 = () => {};

const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};

/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction$2(thing.append) && thing[toStringTag] === 'FormData' && thing[iterator]);
}

const toJSONObject = (obj) => {
  const stack = new Array(10);

  const visit = (source, i) => {

    if (isObject$3(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }

      if(!('toJSON' in source)) {
        stack[i] = source;
        const target = isArray$2(source) ? [] : {};

        forEach$1(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });

        stack[i] = undefined;

        return target;
      }
    }

    return source;
  };

  return visit(obj, 0);
};

const isAsyncFn = kindOfTest('AsyncFunction');

const isThenable = (thing) =>
  thing && (isObject$3(thing) || isFunction$2(thing)) && isFunction$2(thing.then) && isFunction$2(thing.catch);

// original code
// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34

const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }

  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({source, data}) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);

    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    }
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === 'function',
  isFunction$2(_global.postMessage)
);

const asap = typeof queueMicrotask !== 'undefined' ?
  queueMicrotask.bind(_global) : ( typeof process !== 'undefined' && process.nextTick || _setImmediate);

// *********************


const isIterable = (thing) => thing != null && isFunction$2(thing[iterator]);


const utils$1 = {
  isArray: isArray$2,
  isArrayBuffer,
  isBuffer: isBuffer$1,
  isFormData,
  isArrayBufferView,
  isString: isString$1,
  isNumber,
  isBoolean: isBoolean$1,
  isObject: isObject$3,
  isPlainObject: isPlainObject$3,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate: isDate$2,
  isFile,
  isBlob,
  isRegExp,
  isFunction: isFunction$2,
  isStream,
  isURLSearchParams,
  isTypedArray: isTypedArray$1,
  isFileList,
  forEach: forEach$1,
  merge,
  extend,
  trim: trim$1,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray: toArray$1,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty: hasOwnProperty$b,
  hasOwnProp: hasOwnProperty$b, // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop$1,
  toFiniteNumber,
  findKey: findKey$1,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
};

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */
function AxiosError$1(message, code, config, request, response) {
  Error.call(this);

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = (new Error()).stack;
  }

  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}

utils$1.inherits(AxiosError$1, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});

const prototype$1 = AxiosError$1.prototype;
const descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED',
  'ERR_NOT_SUPPORT',
  'ERR_INVALID_URL'
// eslint-disable-next-line func-names
].forEach(code => {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError$1, descriptors);
Object.defineProperty(prototype$1, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError$1.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);

  utils$1.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, prop => {
    return prop !== 'isAxiosError';
  });

  AxiosError$1.call(axiosError, error.message, code, config, request, response);

  axiosError.cause = error;

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

// eslint-disable-next-line strict
const httpAdapter = null;

/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */
function isVisitable(thing) {
  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
}

/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */
function removeBrackets(key) {
  return utils$1.endsWith(key, '[]') ? key.slice(0, -2) : key;
}

/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    // eslint-disable-next-line no-param-reassign
    token = removeBrackets(token);
    return !dots && i ? '[' + token + ']' : token;
  }).join(dots ? '.' : '');
}

/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */
function isFlatArray(arr) {
  return utils$1.isArray(arr) && !arr.some(isVisitable);
}

const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});

/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/

/**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */
function toFormData$1(obj, formData, options) {
  if (!utils$1.isObject(obj)) {
    throw new TypeError('target must be an object');
  }

  // eslint-disable-next-line no-param-reassign
  formData = formData || new (FormData)();

  // eslint-disable-next-line no-param-reassign
  options = utils$1.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    return !utils$1.isUndefined(source[option]);
  });

  const metaTokens = options.metaTokens;
  // eslint-disable-next-line no-use-before-define
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);

  if (!utils$1.isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }

  function convertValue(value) {
    if (value === null) return '';

    if (utils$1.isDate(value)) {
      return value.toISOString();
    }

    if (!useBlob && utils$1.isBlob(value)) {
      throw new AxiosError$1('Blob is not supported. Use a Buffer instead.');
    }

    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */
  function defaultVisitor(value, key, path) {
    let arr = value;

    if (value && !path && typeof value === 'object') {
      if (utils$1.endsWith(key, '{}')) {
        // eslint-disable-next-line no-param-reassign
        key = metaTokens ? key : key.slice(0, -2);
        // eslint-disable-next-line no-param-reassign
        value = JSON.stringify(value);
      } else if (
        (utils$1.isArray(value) && isFlatArray(value)) ||
        ((utils$1.isFileList(value) || utils$1.endsWith(key, '[]')) && (arr = utils$1.toArray(value))
        )) {
        // eslint-disable-next-line no-param-reassign
        key = removeBrackets(key);

        arr.forEach(function each(el, index) {
          !(utils$1.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
            convertValue(el)
          );
        });
        return false;
      }
    }

    if (isVisitable(value)) {
      return true;
    }

    formData.append(renderKey(path, key, dots), convertValue(value));

    return false;
  }

  const stack = [];

  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });

  function build(value, path) {
    if (utils$1.isUndefined(value)) return;

    if (stack.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path.join('.'));
    }

    stack.push(value);

    utils$1.forEach(value, function each(el, key) {
      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
        formData, el, utils$1.isString(key) ? key.trim() : key, path, exposedHelpers
      );

      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });

    stack.pop();
  }

  if (!utils$1.isObject(obj)) {
    throw new TypeError('data must be an object');
  }

  build(obj);

  return formData;
}

/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */
function encode$1(str) {
  const charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}

/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */
function AxiosURLSearchParams(params, options) {
  this._pairs = [];

  params && toFormData$1(params, this, options);
}

const prototype = AxiosURLSearchParams.prototype;

prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};

prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;

  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + '=' + _encode(pair[1]);
  }, '').join('&');
};

/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */
function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @param {?(object|Function)} options
 *
 * @returns {string} The formatted url
 */
function buildURL(url, params, options) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }
  
  const _encode = options && options.encode || encode;

  if (utils$1.isFunction(options)) {
    options = {
      serialize: options
    };
  } 

  const serializeFn = options && options.serialize;

  let serializedParams;

  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$1.isURLSearchParams(params) ?
      params.toString() :
      new AxiosURLSearchParams(params, options).toString(_encode);
  }

  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
}

class InterceptorManager {
  constructor() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }

  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$1.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}

const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

const URLSearchParams$1 = typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams;

const FormData$1 = typeof FormData !== 'undefined' ? FormData : null;

const Blob$1 = typeof Blob !== 'undefined' ? Blob : null;

const platform$1 = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
};

const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';

const _navigator = typeof navigator === 'object' && navigator || undefined;

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */
const hasStandardBrowserEnv = hasBrowserEnv &&
  (!_navigator || ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) < 0);

/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */
const hasStandardBrowserWebWorkerEnv = (() => {
  return (
    typeof WorkerGlobalScope !== 'undefined' &&
    // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts === 'function'
  );
})();

const origin = hasBrowserEnv && window.location.href || 'http://localhost';

const utils = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv,
  navigator: _navigator,
  origin
}, Symbol.toStringTag, { value: 'Module' }));

const platform = {
  ...utils,
  ...platform$1
};

function toURLEncodedForm(data, options) {
  return toFormData$1(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils$1.isBuffer(value)) {
        this.append(key, value.toString('base64'));
        return false;
      }

      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */
function parsePropPath(name) {
  // foo[x][y][z]
  // foo.x.y.z
  // foo-x-y-z
  // foo x y z
  return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
    return match[0] === '[]' ? '' : match[1] || match[0];
  });
}

/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}

/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];

    if (name === '__proto__') return true;

    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils$1.isArray(target) ? target.length : name;

    if (isLast) {
      if (utils$1.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }

      return !isNumericKey;
    }

    if (!target[name] || !utils$1.isObject(target[name])) {
      target[name] = [];
    }

    const result = buildPath(path, value, target[name], index);

    if (result && utils$1.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }

    return !isNumericKey;
  }

  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
    const obj = {};

    utils$1.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });

    return obj;
  }

  return null;
}

/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */
function stringifySafely(rawValue, parser, encoder) {
  if (utils$1.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$1.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

const defaults = {

  transitional: transitionalDefaults,

  adapter: ['xhr', 'http', 'fetch'],

  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || '';
    const hasJSONContentType = contentType.indexOf('application/json') > -1;
    const isObjectPayload = utils$1.isObject(data);

    if (isObjectPayload && utils$1.isHTMLForm(data)) {
      data = new FormData(data);
    }

    const isFormData = utils$1.isFormData(data);

    if (isFormData) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }

    if (utils$1.isArrayBuffer(data) ||
      utils$1.isBuffer(data) ||
      utils$1.isStream(data) ||
      utils$1.isFile(data) ||
      utils$1.isBlob(data) ||
      utils$1.isReadableStream(data)
    ) {
      return data;
    }
    if (utils$1.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$1.isURLSearchParams(data)) {
      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
      return data.toString();
    }

    let isFileList;

    if (isObjectPayload) {
      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }

      if ((isFileList = utils$1.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
        const _FormData = this.env && this.env.FormData;

        return toFormData$1(
          isFileList ? {'files[]': data} : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }

    if (isObjectPayload || hasJSONContentType ) {
      headers.setContentType('application/json', false);
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === 'json';

    if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
      return data;
    }

    if (data && utils$1.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;

      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*',
      'Content-Type': undefined
    }
  }
};

utils$1.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {
  defaults.headers[method] = {};
});

// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = utils$1.toObjectSet([
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
]);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */
const parseHeaders = rawHeaders => {
  const parsed = {};
  let key;
  let val;
  let i;

  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
    i = line.indexOf(':');
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();

    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
      return;
    }

    if (key === 'set-cookie') {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
};

const $internals = Symbol('internals');

function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}

function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }

  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
}

function parseTokens(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;

  while ((match = tokensRE.exec(str))) {
    tokens[match[1]] = match[2];
  }

  return tokens;
}

const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());

function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
  if (utils$1.isFunction(filter)) {
    return filter.call(this, value, header);
  }

  if (isHeaderNameFilter) {
    value = header;
  }

  if (!utils$1.isString(value)) return;

  if (utils$1.isString(filter)) {
    return value.indexOf(filter) !== -1;
  }

  if (utils$1.isRegExp(filter)) {
    return filter.test(value);
  }
}

function formatHeader(header) {
  return header.trim()
    .toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
}

function buildAccessors(obj, header) {
  const accessorName = utils$1.toCamelCase(' ' + header);

  ['get', 'set', 'has'].forEach(methodName => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}

let AxiosHeaders$1 = class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }

  set(header, valueOrRewrite, rewrite) {
    const self = this;

    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);

      if (!lHeader) {
        throw new Error('header name must be a non-empty string');
      }

      const key = utils$1.findKey(self, lHeader);

      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {
        self[key || _header] = normalizeValue(_value);
      }
    }

    const setHeaders = (headers, _rewrite) =>
      utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));

    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if(utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils$1.isObject(header) && utils$1.isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!utils$1.isArray(entry)) {
          throw TypeError('Object iterator must return a key-value pair');
        }

        obj[key = entry[0]] = (dest = obj[key]) ?
          (utils$1.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]]) : entry[1];
      }

      setHeaders(obj, valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }

    return this;
  }

  get(header, parser) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils$1.findKey(this, header);

      if (key) {
        const value = this[key];

        if (!parser) {
          return value;
        }

        if (parser === true) {
          return parseTokens(value);
        }

        if (utils$1.isFunction(parser)) {
          return parser.call(this, value, key);
        }

        if (utils$1.isRegExp(parser)) {
          return parser.exec(value);
        }

        throw new TypeError('parser must be boolean|regexp|function');
      }
    }
  }

  has(header, matcher) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils$1.findKey(this, header);

      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }

    return false;
  }

  delete(header, matcher) {
    const self = this;
    let deleted = false;

    function deleteHeader(_header) {
      _header = normalizeHeader(_header);

      if (_header) {
        const key = utils$1.findKey(self, _header);

        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
          delete self[key];

          deleted = true;
        }
      }
    }

    if (utils$1.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }

    return deleted;
  }

  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;

    while (i--) {
      const key = keys[i];
      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }

    return deleted;
  }

  normalize(format) {
    const self = this;
    const headers = {};

    utils$1.forEach(this, (value, header) => {
      const key = utils$1.findKey(headers, header);

      if (key) {
        self[key] = normalizeValue(value);
        delete self[header];
        return;
      }

      const normalized = format ? formatHeader(header) : String(header).trim();

      if (normalized !== header) {
        delete self[header];
      }

      self[normalized] = normalizeValue(value);

      headers[normalized] = true;
    });

    return this;
  }

  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }

  toJSON(asStrings) {
    const obj = Object.create(null);

    utils$1.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(', ') : value);
    });

    return obj;
  }

  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }

  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
  }

  getSetCookie() {
    return this.get("set-cookie") || [];
  }

  get [Symbol.toStringTag]() {
    return 'AxiosHeaders';
  }

  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }

  static concat(first, ...targets) {
    const computed = new this(first);

    targets.forEach((target) => computed.set(target));

    return computed;
  }

  static accessor(header) {
    const internals = this[$internals] = (this[$internals] = {
      accessors: {}
    });

    const accessors = internals.accessors;
    const prototype = this.prototype;

    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);

      if (!accessors[lHeader]) {
        buildAccessors(prototype, _header);
        accessors[lHeader] = true;
      }
    }

    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

    return this;
  }
};

AxiosHeaders$1.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

// reserved names hotfix
utils$1.reduceDescriptors(AxiosHeaders$1.prototype, ({value}, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  }
});

utils$1.freezeMethods(AxiosHeaders$1);

/**
 * Transform the data for a request or a response
 *
 * @param {Array|Function} fns A single function or Array of functions
 * @param {?Object} response The response object
 *
 * @returns {*} The resulting transformed data
 */
function transformData(fns, response) {
  const config = this || defaults;
  const context = response || config;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;

  utils$1.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });

  headers.normalize();

  return data;
}

function isCancel$1(value) {
  return !!(value && value.__CANCEL__);
}

/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */
function CanceledError$1(message, config, request) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  AxiosError$1.call(this, message == null ? 'canceled' : message, AxiosError$1.ERR_CANCELED, config, request);
  this.name = 'CanceledError';
}

utils$1.inherits(CanceledError$1, AxiosError$1, {
  __CANCEL__: true
});

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 *
 * @returns {object} The response.
 */
function settle(resolve, reject, response) {
  const validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError$1(
      'Request failed with status code ' + response.status,
      [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
}

/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;

  min = min !== undefined ? min : 1000;

  return function push(chunkLength) {
    const now = Date.now();

    const startedAt = timestamps[tail];

    if (!firstSampleTS) {
      firstSampleTS = now;
    }

    bytes[head] = chunkLength;
    timestamps[head] = now;

    let i = tail;
    let bytesCount = 0;

    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }

    head = (head + 1) % samplesCount;

    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }

    if (now - firstSampleTS < min) {
      return;
    }

    const passed = startedAt && now - startedAt;

    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}

/**
 * Throttle decorator
 * @param {Function} fn
 * @param {Number} freq
 * @return {Function}
 */
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1000 / freq;
  let lastArgs;
  let timer;

  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  };

  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if ( passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };

  const flush = () => lastArgs && invoke(lastArgs);

  return [throttled, flush];
}

const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);

  return throttle(e => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;

    bytesNotified = loaded;

    const data = {
      loaded,
      total,
      progress: total ? (loaded / total) : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? 'download' : 'upload']: true
    };

    listener(data);
  }, freq);
};

const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;

  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};

const asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));

const isURLSameOrigin = platform.hasStandardBrowserEnv ? ((origin, isMSIE) => (url) => {
  url = new URL(url, platform.origin);

  return (
    origin.protocol === url.protocol &&
    origin.host === url.host &&
    (isMSIE || origin.port === url.port)
  );
})(
  new URL(platform.origin),
  platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
) : () => true;

const cookies = platform.hasStandardBrowserEnv ?

  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + '=' + encodeURIComponent(value)];

      utils$1.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());

      utils$1.isString(path) && cookie.push('path=' + path);

      utils$1.isString(domain) && cookie.push('domain=' + domain);

      secure === true && cookie.push('secure');

      document.cookie = cookie.join('; ');
    },

    read(name) {
      const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return (match ? decodeURIComponent(match[3]) : null);
    },

    remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  }

  :

  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {},
    read() {
      return null;
    },
    remove() {}
  };

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 *
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 *
 * @returns {string} The combined URL
 */
function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
}

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 *
 * @returns {string} The combined full path
 */
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 *
 * @returns {Object} New object resulting from merging config2 to config1
 */
function mergeConfig$1(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  const config = {};

  function getMergedValue(target, source, prop, caseless) {
    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
      return utils$1.merge.call({caseless}, target, source);
    } else if (utils$1.isPlainObject(source)) {
      return utils$1.merge({}, source);
    } else if (utils$1.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(a, b, prop , caseless) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(a, b, prop , caseless);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(undefined, a, prop , caseless);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }

  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b , prop) => mergeDeepProperties(headersToObject(a), headersToObject(b),prop, true)
  };

  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge(config1[prop], config2[prop], prop);
    (utils$1.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
}

const resolveConfig = (config) => {
  const newConfig = mergeConfig$1({}, config);

  let {data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth} = newConfig;

  newConfig.headers = headers = AxiosHeaders$1.from(headers);

  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);

  // HTTP basic authentication
  if (auth) {
    headers.set('Authorization', 'Basic ' +
      btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : ''))
    );
  }

  let contentType;

  if (utils$1.isFormData(data)) {
    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(undefined); // Let the browser set it
    } else if ((contentType = headers.getContentType()) !== false) {
      // fix semicolon duplication issue for ReactNative FormData implementation
      const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || 'multipart/form-data', ...tokens].join('; '));
    }
  }

  // Add xsrf header
  // This is only done if running in a standard browser environment.
  // Specifically not if we're in a web worker, or react-native.

  if (platform.hasStandardBrowserEnv) {
    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));

    if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(newConfig.url))) {
      // Add xsrf header
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);

      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }

  return newConfig;
};

const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

const xhrAdapter = isXHRAdapterSupported && function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
    let {responseType, onUploadProgress, onDownloadProgress} = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;

    function done() {
      flushUpload && flushUpload(); // flush events
      flushDownload && flushDownload(); // flush events

      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);

      _config.signal && _config.signal.removeEventListener('abort', onCanceled);
    }

    let request = new XMLHttpRequest();

    request.open(_config.method.toUpperCase(), _config.url, true);

    // Set the request timeout in MS
    request.timeout = _config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      const responseHeaders = AxiosHeaders$1.from(
        'getAllResponseHeaders' in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?
        request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new AxiosError$1('Request aborted', AxiosError$1.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new AxiosError$1('Network Error', AxiosError$1.ERR_NETWORK, config, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';
      const transitional = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError$1(
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Remove Content-Type if data is undefined
    requestData === undefined && requestHeaders.setContentType(null);

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }

    // Add withCredentials to request if needed
    if (!utils$1.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = _config.responseType;
    }

    // Handle progress if needed
    if (onDownloadProgress) {
      ([downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true));
      request.addEventListener('progress', downloadThrottled);
    }

    // Not all browsers support upload events
    if (onUploadProgress && request.upload) {
      ([uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress));

      request.upload.addEventListener('progress', uploadThrottled);

      request.upload.addEventListener('loadend', flushUpload);
    }

    if (_config.cancelToken || _config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = cancel => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError$1(null, config, request) : cancel);
        request.abort();
        request = null;
      };

      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);
      }
    }

    const protocol = parseProtocol(_config.url);

    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError$1('Unsupported protocol ' + protocol + ':', AxiosError$1.ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData || null);
  });
};

const composeSignals = (signals, timeout) => {
  const {length} = (signals = signals ? signals.filter(Boolean) : []);

  if (timeout || length) {
    let controller = new AbortController();

    let aborted;

    const onabort = function (reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError$1 ? err : new CanceledError$1(err instanceof Error ? err.message : err));
      }
    };

    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError$1(`timeout ${timeout} of ms exceeded`, AxiosError$1.ETIMEDOUT));
    }, timeout);

    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach(signal => {
          signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener('abort', onabort);
        });
        signals = null;
      }
    };

    signals.forEach((signal) => signal.addEventListener('abort', onabort));

    const {signal} = controller;

    signal.unsubscribe = () => utils$1.asap(unsubscribe);

    return signal;
  }
};

const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;

  if (len < chunkSize) {
    yield chunk;
    return;
  }

  let pos = 0;
  let end;

  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};

const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};

const readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }

  const reader = stream.getReader();
  try {
    for (;;) {
      const {done, value} = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};

const trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator = readBytes(stream, chunkSize);

  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };

  return new ReadableStream({
    async pull(controller) {
      try {
        const {done, value} = await iterator.next();

        if (done) {
         _onFinish();
          controller.close();
          return;
        }

        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  })
};

const isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';

// used only inside the fetch adapter
const encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?
    ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :
    async (str) => new Uint8Array(await new Response(str).arrayBuffer())
);

const test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false
  }
};

const supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;

  const hasContentType = new Request(platform.origin, {
    body: new ReadableStream(),
    method: 'POST',
    get duplex() {
      duplexAccessed = true;
      return 'half';
    },
  }).headers.has('Content-Type');

  return duplexAccessed && !hasContentType;
});

const DEFAULT_CHUNK_SIZE = 64 * 1024;

const supportsResponseStream = isReadableStreamSupported &&
  test(() => utils$1.isReadableStream(new Response('').body));


const resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};

isFetchSupported && (((res) => {
  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {
    !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res) => res[type]() :
      (_, config) => {
        throw new AxiosError$1(`Response type '${type}' is not supported`, AxiosError$1.ERR_NOT_SUPPORT, config);
      });
  });
})(new Response));

const getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }

  if(utils$1.isBlob(body)) {
    return body.size;
  }

  if(utils$1.isSpecCompliantForm(body)) {
    const _request = new Request(platform.origin, {
      method: 'POST',
      body,
    });
    return (await _request.arrayBuffer()).byteLength;
  }

  if(utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
    return body.byteLength;
  }

  if(utils$1.isURLSearchParams(body)) {
    body = body + '';
  }

  if(utils$1.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};

const resolveBodyLength = async (headers, body) => {
  const length = utils$1.toFiniteNumber(headers.getContentLength());

  return length == null ? getBodyLength(body) : length;
};

const fetchAdapter = isFetchSupported && (async (config) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = 'same-origin',
    fetchOptions
  } = resolveConfig(config);

  responseType = responseType ? (responseType + '').toLowerCase() : 'text';

  let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);

  let request;

  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
  });

  let requestContentLength;

  try {
    if (
      onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&
      (requestContentLength = await resolveBodyLength(headers, data)) !== 0
    ) {
      let _request = new Request(url, {
        method: 'POST',
        body: data,
        duplex: "half"
      });

      let contentTypeHeader;

      if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {
        headers.setContentType(contentTypeHeader);
      }

      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );

        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }

    if (!utils$1.isString(withCredentials)) {
      withCredentials = withCredentials ? 'include' : 'omit';
    }

    // Cloudflare Workers throws when credentials are defined
    // see https://github.com/cloudflare/workerd/issues/902
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : undefined
    });

    let response = await fetch(request);

    const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');

    if (supportsResponseStream && (onDownloadProgress || (isStreamResponse && unsubscribe))) {
      const options = {};

      ['status', 'statusText', 'headers'].forEach(prop => {
        options[prop] = response[prop];
      });

      const responseContentLength = utils$1.toFiniteNumber(response.headers.get('content-length'));

      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];

      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }

    responseType = responseType || 'text';

    let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || 'text'](response, config);

    !isStreamResponse && unsubscribe && unsubscribe();

    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders$1.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      });
    })
  } catch (err) {
    unsubscribe && unsubscribe();

    if (err && err.name === 'TypeError' && /Load failed|fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError$1('Network Error', AxiosError$1.ERR_NETWORK, config, request),
        {
          cause: err.cause || err
        }
      )
    }

    throw AxiosError$1.from(err, err && err.code, config, request);
  }
});

const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};

utils$1.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, 'name', {value});
    } catch (e) {
      // eslint-disable-next-line no-empty
    }
    Object.defineProperty(fn, 'adapterName', {value});
  }
});

const renderReason = (reason) => `- ${reason}`;

const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;

const adapters = {
  getAdapter: (adapters) => {
    adapters = utils$1.isArray(adapters) ? adapters : [adapters];

    const {length} = adapters;
    let nameOrAdapter;
    let adapter;

    const rejectedReasons = {};

    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;

      adapter = nameOrAdapter;

      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];

        if (adapter === undefined) {
          throw new AxiosError$1(`Unknown adapter '${id}'`);
        }
      }

      if (adapter) {
        break;
      }

      rejectedReasons[id || '#' + i] = adapter;
    }

    if (!adapter) {

      const reasons = Object.entries(rejectedReasons)
        .map(([id, state]) => `adapter ${id} ` +
          (state === false ? 'is not supported by the environment' : 'is not available in the build')
        );

      let s = length ?
        (reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0])) :
        'as no adapter specified';

      throw new AxiosError$1(
        `There is no suitable adapter to dispatch the request ` + s,
        'ERR_NOT_SUPPORT'
      );
    }

    return adapter;
  },
  adapters: knownAdapters
};

/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new CanceledError$1(null, config);
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 *
 * @returns {Promise} The Promise to be fulfilled
 */
function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  config.headers = AxiosHeaders$1.from(config.headers);

  // Transform request data
  config.data = transformData.call(
    config,
    config.transformRequest
  );

  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
    config.headers.setContentType('application/x-www-form-urlencoded', false);
  }

  const adapter = adapters.getAdapter(config.adapter || defaults.adapter);

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );

    response.headers = AxiosHeaders$1.from(response.headers);

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel$1(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }

    return Promise.reject(reason);
  });
}

const VERSION$1 = "1.9.0";

const validators$1 = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
  validators$1[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

const deprecatedWarnings = {};

/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */
validators$1.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION$1 + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError$1(
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        AxiosError$1.ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

validators$1.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    // eslint-disable-next-line no-console
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  }
};

/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new AxiosError$1('options must be an object', AxiosError$1.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError$1('option ' + opt + ' must be ' + result, AxiosError$1.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError$1('Unknown option ' + opt, AxiosError$1.ERR_BAD_OPTION);
    }
  }
}

const validator = {
  assertOptions,
  validators: validators$1
};

const validators = validator.validators;

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */
let Axios$1 = class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};

        Error.captureStackTrace ? Error.captureStackTrace(dummy) : (dummy = new Error());

        // slice off the Error: ... line
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, '') : '';
        try {
          if (!err.stack) {
            err.stack = stack;
            // match without the 2 top stack lines
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ''))) {
            err.stack += '\n' + stack;
          }
        } catch (e) {
          // ignore the case where "stack" is an un-writable property
        }
      }

      throw err;
    }
  }

  _request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === 'string') {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }

    config = mergeConfig$1(this.defaults, config);

    const {transitional, paramsSerializer, headers} = config;

    if (transitional !== undefined) {
      validator.assertOptions(transitional, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }

    if (paramsSerializer != null) {
      if (utils$1.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }

    // Set config.allowAbsoluteUrls
    if (config.allowAbsoluteUrls !== undefined) ; else if (this.defaults.allowAbsoluteUrls !== undefined) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }

    validator.assertOptions(config, {
      baseUrl: validators.spelling('baseURL'),
      withXsrfToken: validators.spelling('withXSRFToken')
    }, true);

    // Set config.method
    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

    // Flatten headers
    let contextHeaders = headers && utils$1.merge(
      headers.common,
      headers[config.method]
    );

    headers && utils$1.forEach(
      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
      (method) => {
        delete headers[method];
      }
    );

    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);

    // filter out skipped interceptors
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
        return;
      }

      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });

    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });

    let promise;
    let i = 0;
    let len;

    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), undefined];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;

      promise = Promise.resolve(config);

      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }

      return promise;
    }

    len = requestInterceptorChain.length;

    let newConfig = config;

    i = 0;

    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }

    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }

    i = 0;
    len = responseInterceptorChain.length;

    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }

    return promise;
  }

  getUri(config) {
    config = mergeConfig$1(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};

// Provide aliases for supported request methods
utils$1.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios$1.prototype[method] = function(url, config) {
    return this.request(mergeConfig$1(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});

utils$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig$1(config || {}, {
        method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url,
        data
      }));
    };
  }

  Axios$1.prototype[method] = generateHTTPMethod();

  Axios$1.prototype[method + 'Form'] = generateHTTPMethod(true);
});

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */
let CancelToken$1 = class CancelToken {
  constructor(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    let resolvePromise;

    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });

    const token = this;

    // eslint-disable-next-line func-names
    this.promise.then(cancel => {
      if (!token._listeners) return;

      let i = token._listeners.length;

      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });

    // eslint-disable-next-line func-names
    this.promise.then = onfulfilled => {
      let _resolve;
      // eslint-disable-next-line func-names
      const promise = new Promise(resolve => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);

      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };

      return promise;
    };

    executor(function cancel(message, config, request) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new CanceledError$1(message, config, request);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }

  /**
   * Subscribe to the cancel signal
   */

  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }

    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }

  /**
   * Unsubscribe from the cancel signal
   */

  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }

  toAbortSignal() {
    const controller = new AbortController();

    const abort = (err) => {
      controller.abort(err);
    };

    this.subscribe(abort);

    controller.signal.unsubscribe = () => this.unsubscribe(abort);

    return controller.signal;
  }

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
};

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 *
 * @returns {Function}
 */
function spread$1(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 *
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
function isAxiosError$1(payload) {
  return utils$1.isObject(payload) && (payload.isAxiosError === true);
}

const HttpStatusCode$1 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
};

Object.entries(HttpStatusCode$1).forEach(([key, value]) => {
  HttpStatusCode$1[value] = key;
});

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind(Axios$1.prototype.request, context);

  // Copy axios.prototype to instance
  utils$1.extend(instance, Axios$1.prototype, context, {allOwnKeys: true});

  // Copy context to instance
  utils$1.extend(instance, context, null, {allOwnKeys: true});

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig$1(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
const axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios$1;

// Expose Cancel & CancelToken
axios.CanceledError = CanceledError$1;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel$1;
axios.VERSION = VERSION$1;
axios.toFormData = toFormData$1;

// Expose AxiosError class
axios.AxiosError = AxiosError$1;

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = spread$1;

// Expose isAxiosError
axios.isAxiosError = isAxiosError$1;

// Expose mergeConfig
axios.mergeConfig = mergeConfig$1;

axios.AxiosHeaders = AxiosHeaders$1;

axios.formToJSON = thing => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);

axios.getAdapter = adapters.getAdapter;

axios.HttpStatusCode = HttpStatusCode$1;

axios.default = axios;

// This module is intended to unwrap Axios default export as named.
// Keep top-level export same with static properties
// so that it can keep same with es module or cjs
const {
  Axios,
  AxiosError,
  CanceledError,
  isCancel,
  CancelToken,
  VERSION,
  all,
  Cancel,
  isAxiosError,
  spread,
  toFormData,
  AxiosHeaders,
  HttpStatusCode,
  formToJSON,
  getAdapter,
  mergeConfig
} = axios;

var withSelector = {exports: {}};

var useSyncExternalStoreWithSelector_production = {};

/**
 * @license React
 * use-sync-external-store-with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var React = reactExports;
function is$2(x, y) {
  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
}
var objectIs = "function" === typeof Object.is ? Object.is : is$2,
  useSyncExternalStore = React.useSyncExternalStore,
  useRef = React.useRef,
  useEffect = React.useEffect,
  useMemo = React.useMemo,
  useDebugValue = React.useDebugValue;
useSyncExternalStoreWithSelector_production.useSyncExternalStoreWithSelector = function (
  subscribe,
  getSnapshot,
  getServerSnapshot,
  selector,
  isEqual
) {
  var instRef = useRef(null);
  if (null === instRef.current) {
    var inst = { hasValue: false, value: null };
    instRef.current = inst;
  } else inst = instRef.current;
  instRef = useMemo(
    function () {
      function memoizedSelector(nextSnapshot) {
        if (!hasMemo) {
          hasMemo = true;
          memoizedSnapshot = nextSnapshot;
          nextSnapshot = selector(nextSnapshot);
          if (void 0 !== isEqual && inst.hasValue) {
            var currentSelection = inst.value;
            if (isEqual(currentSelection, nextSnapshot))
              return (memoizedSelection = currentSelection);
          }
          return (memoizedSelection = nextSnapshot);
        }
        currentSelection = memoizedSelection;
        if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
        var nextSelection = selector(nextSnapshot);
        if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
          return (memoizedSnapshot = nextSnapshot), currentSelection;
        memoizedSnapshot = nextSnapshot;
        return (memoizedSelection = nextSelection);
      }
      var hasMemo = false,
        memoizedSnapshot,
        memoizedSelection,
        maybeGetServerSnapshot =
          void 0 === getServerSnapshot ? null : getServerSnapshot;
      return [
        function () {
          return memoizedSelector(getSnapshot());
        },
        null === maybeGetServerSnapshot
          ? void 0
          : function () {
              return memoizedSelector(maybeGetServerSnapshot());
            }
      ];
    },
    [getSnapshot, getServerSnapshot, selector, isEqual]
  );
  var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
  useEffect(
    function () {
      inst.hasValue = true;
      inst.value = value;
    },
    [value]
  );
  useDebugValue(value);
  return value;
};

{
  withSelector.exports = useSyncExternalStoreWithSelector_production;
}

var withSelectorExports = withSelector.exports;

function defaultNoopBatch(callback) {
  callback();
}
function createListenerCollection() {
  let first = null;
  let last = null;
  return {
    clear() {
      first = null;
      last = null;
    },
    notify() {
      defaultNoopBatch(() => {
        let listener = first;
        while (listener) {
          listener.callback();
          listener = listener.next;
        }
      });
    },
    get() {
      const listeners = [];
      let listener = first;
      while (listener) {
        listeners.push(listener);
        listener = listener.next;
      }
      return listeners;
    },
    subscribe(callback) {
      let isSubscribed = true;
      const listener = last = {
        callback,
        next: null,
        prev: last
      };
      if (listener.prev) {
        listener.prev.next = listener;
      } else {
        first = listener;
      }
      return function unsubscribe() {
        if (!isSubscribed || first === null) return;
        isSubscribed = false;
        if (listener.next) {
          listener.next.prev = listener.prev;
        } else {
          last = listener.prev;
        }
        if (listener.prev) {
          listener.prev.next = listener.next;
        } else {
          first = listener.next;
        }
      };
    }
  };
}
var nullListeners = {
  notify() {
  },
  get: () => []
};
function createSubscription(store, parentSub) {
  let unsubscribe;
  let listeners = nullListeners;
  let subscriptionsAmount = 0;
  let selfSubscribed = false;
  function addNestedSub(listener) {
    trySubscribe();
    const cleanupListener = listeners.subscribe(listener);
    let removed = false;
    return () => {
      if (!removed) {
        removed = true;
        cleanupListener();
        tryUnsubscribe();
      }
    };
  }
  function notifyNestedSubs() {
    listeners.notify();
  }
  function handleChangeWrapper() {
    if (subscription.onStateChange) {
      subscription.onStateChange();
    }
  }
  function isSubscribed() {
    return selfSubscribed;
  }
  function trySubscribe() {
    subscriptionsAmount++;
    if (!unsubscribe) {
      unsubscribe = store.subscribe(handleChangeWrapper);
      listeners = createListenerCollection();
    }
  }
  function tryUnsubscribe() {
    subscriptionsAmount--;
    if (unsubscribe && subscriptionsAmount === 0) {
      unsubscribe();
      unsubscribe = void 0;
      listeners.clear();
      listeners = nullListeners;
    }
  }
  function trySubscribeSelf() {
    if (!selfSubscribed) {
      selfSubscribed = true;
      trySubscribe();
    }
  }
  function tryUnsubscribeSelf() {
    if (selfSubscribed) {
      selfSubscribed = false;
      tryUnsubscribe();
    }
  }
  const subscription = {
    addNestedSub,
    notifyNestedSubs,
    handleChangeWrapper,
    isSubscribed,
    trySubscribe: trySubscribeSelf,
    tryUnsubscribe: tryUnsubscribeSelf,
    getListeners: () => listeners
  };
  return subscription;
}
var canUseDOM = () => !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
var isDOM = /* @__PURE__ */ canUseDOM();
var isRunningInReactNative = () => typeof navigator !== "undefined" && navigator.product === "ReactNative";
var isReactNative = /* @__PURE__ */ isRunningInReactNative();
var getUseIsomorphicLayoutEffect = () => isDOM || isReactNative ? reactExports.useLayoutEffect : reactExports.useEffect;
var useIsomorphicLayoutEffect$1 = /* @__PURE__ */ getUseIsomorphicLayoutEffect();
var ContextKey = /* @__PURE__ */ Symbol.for(`react-redux-context`);
var gT$1 = typeof globalThis !== "undefined" ? globalThis : (
  /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
  {}
);
function getContext() {
  if (!reactExports.createContext) return {};
  const contextMap = gT$1[ContextKey] ??= /* @__PURE__ */ new Map();
  let realContext = contextMap.get(reactExports.createContext);
  if (!realContext) {
    realContext = reactExports.createContext(
      null
    );
    contextMap.set(reactExports.createContext, realContext);
  }
  return realContext;
}
var ReactReduxContext = /* @__PURE__ */ getContext();
function Provider(providerProps) {
  const { children, context, serverState, store } = providerProps;
  const contextValue = reactExports.useMemo(() => {
    const subscription = createSubscription(store);
    const baseContextValue = {
      store,
      subscription,
      getServerState: serverState ? () => serverState : void 0
    };
    {
      return baseContextValue;
    }
  }, [store, serverState]);
  const previousState = reactExports.useMemo(() => store.getState(), [store]);
  useIsomorphicLayoutEffect$1(() => {
    const { subscription } = contextValue;
    subscription.onStateChange = subscription.notifyNestedSubs;
    subscription.trySubscribe();
    if (previousState !== store.getState()) {
      subscription.notifyNestedSubs();
    }
    return () => {
      subscription.tryUnsubscribe();
      subscription.onStateChange = void 0;
    };
  }, [contextValue, previousState]);
  const Context = context || ReactReduxContext;
  return /* @__PURE__ */ reactExports.createElement(Context.Provider, { value: contextValue }, children);
}
var Provider_default = Provider;
function createReduxContextHook(context = ReactReduxContext) {
  return function useReduxContext2() {
    const contextValue = reactExports.useContext(context);
    return contextValue;
  };
}
var useReduxContext = /* @__PURE__ */ createReduxContextHook();
function createStoreHook(context = ReactReduxContext) {
  const useReduxContext2 = context === ReactReduxContext ? useReduxContext : (
    // @ts-ignore
    createReduxContextHook(context)
  );
  const useStore2 = () => {
    const { store } = useReduxContext2();
    return store;
  };
  Object.assign(useStore2, {
    withTypes: () => useStore2
  });
  return useStore2;
}
var useStore = /* @__PURE__ */ createStoreHook();
function createDispatchHook(context = ReactReduxContext) {
  const useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);
  const useDispatch2 = () => {
    const store = useStore2();
    return store.dispatch;
  };
  Object.assign(useDispatch2, {
    withTypes: () => useDispatch2
  });
  return useDispatch2;
}
var useDispatch = /* @__PURE__ */ createDispatchHook();
var refEquality = (a, b) => a === b;
function createSelectorHook(context = ReactReduxContext) {
  const useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);
  const useSelector2 = (selector, equalityFnOrOptions = {}) => {
    const { equalityFn = refEquality } = typeof equalityFnOrOptions === "function" ? { equalityFn: equalityFnOrOptions } : equalityFnOrOptions;
    const reduxContext = useReduxContext2();
    const { store, subscription, getServerState } = reduxContext;
    reactExports.useRef(true);
    const wrappedSelector = reactExports.useCallback(
      {
        [selector.name](state) {
          const selected = selector(state);
          return selected;
        }
      }[selector.name],
      [selector]
    );
    const selectedState = withSelectorExports.useSyncExternalStoreWithSelector(
      subscription.addNestedSub,
      store.getState,
      getServerState || store.getState,
      wrappedSelector,
      equalityFn
    );
    reactExports.useDebugValue(selectedState);
    return selectedState;
  };
  Object.assign(useSelector2, {
    withTypes: () => useSelector2
  });
  return useSelector2;
}
var useSelector = /* @__PURE__ */ createSelectorHook();

function formatProdErrorMessage$1(code) {
  return `Minified Redux error #${code}; visit https://redux.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
}
var $$observable = /* @__PURE__ */ (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();
var symbol_observable_default = $$observable;
var randomString = () => Math.random().toString(36).substring(7).split("").join(".");
var ActionTypes = {
  INIT: `@@redux/INIT${/* @__PURE__ */ randomString()}`,
  REPLACE: `@@redux/REPLACE${/* @__PURE__ */ randomString()}`,
  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`
};
var actionTypes_default = ActionTypes;
function isPlainObject$2(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  let proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(obj) === proto || Object.getPrototypeOf(obj) === null;
}
function createStore(reducer, preloadedState, enhancer) {
  if (typeof reducer !== "function") {
    throw new Error(formatProdErrorMessage$1(2) );
  }
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(formatProdErrorMessage$1(0) );
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(formatProdErrorMessage$1(1) );
    }
    return enhancer(createStore)(reducer, preloadedState);
  }
  let currentReducer = reducer;
  let currentState = preloadedState;
  let currentListeners = /* @__PURE__ */ new Map();
  let nextListeners = currentListeners;
  let listenerIdCounter = 0;
  let isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = /* @__PURE__ */ new Map();
      currentListeners.forEach((listener, key) => {
        nextListeners.set(key, listener);
      });
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(formatProdErrorMessage$1(3) );
    }
    return currentState;
  }
  function subscribe(listener) {
    if (typeof listener !== "function") {
      throw new Error(formatProdErrorMessage$1(4) );
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage$1(5) );
    }
    let isSubscribed = true;
    ensureCanMutateNextListeners();
    const listenerId = listenerIdCounter++;
    nextListeners.set(listenerId, listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(formatProdErrorMessage$1(6) );
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      nextListeners.delete(listenerId);
      currentListeners = null;
    };
  }
  function dispatch(action) {
    if (!isPlainObject$2(action)) {
      throw new Error(formatProdErrorMessage$1(7) );
    }
    if (typeof action.type === "undefined") {
      throw new Error(formatProdErrorMessage$1(8) );
    }
    if (typeof action.type !== "string") {
      throw new Error(formatProdErrorMessage$1(17) );
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage$1(9) );
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    const listeners = currentListeners = nextListeners;
    listeners.forEach((listener) => {
      listener();
    });
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(formatProdErrorMessage$1(10) );
    }
    currentReducer = nextReducer;
    dispatch({
      type: actionTypes_default.REPLACE
    });
  }
  function observable() {
    const outerSubscribe = subscribe;
    return {
      /**
       * The minimal observable subscription method.
       * @param observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(formatProdErrorMessage$1(11) );
        }
        function observeState() {
          const observerAsObserver = observer;
          if (observerAsObserver.next) {
            observerAsObserver.next(getState());
          }
        }
        observeState();
        const unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      },
      [symbol_observable_default]() {
        return this;
      }
    };
  }
  dispatch({
    type: actionTypes_default.INIT
  });
  const store = {
    dispatch,
    subscribe,
    getState,
    replaceReducer,
    [symbol_observable_default]: observable
  };
  return store;
}
function assertReducerShape(reducers) {
  Object.keys(reducers).forEach((key) => {
    const reducer = reducers[key];
    const initialState = reducer(void 0, {
      type: actionTypes_default.INIT
    });
    if (typeof initialState === "undefined") {
      throw new Error(formatProdErrorMessage$1(12) );
    }
    if (typeof reducer(void 0, {
      type: actionTypes_default.PROBE_UNKNOWN_ACTION()
    }) === "undefined") {
      throw new Error(formatProdErrorMessage$1(13) );
    }
  });
}
function combineReducers(reducers) {
  const reducerKeys = Object.keys(reducers);
  const finalReducers = {};
  for (let i = 0; i < reducerKeys.length; i++) {
    const key = reducerKeys[i];
    if (typeof reducers[key] === "function") {
      finalReducers[key] = reducers[key];
    }
  }
  const finalReducerKeys = Object.keys(finalReducers);
  let shapeAssertionError;
  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }
  return function combination(state = {}, action) {
    if (shapeAssertionError) {
      throw shapeAssertionError;
    }
    let hasChanged = false;
    const nextState = {};
    for (let i = 0; i < finalReducerKeys.length; i++) {
      const key = finalReducerKeys[i];
      const reducer = finalReducers[key];
      const previousStateForKey = state[key];
      const nextStateForKey = reducer(previousStateForKey, action);
      if (typeof nextStateForKey === "undefined") {
        action && action.type;
        throw new Error(formatProdErrorMessage$1(14) );
      }
      nextState[key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}
function compose(...funcs) {
  if (funcs.length === 0) {
    return (arg) => arg;
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce((a, b) => (...args) => a(b(...args)));
}
function applyMiddleware(...middlewares) {
  return (createStore2) => (reducer, preloadedState) => {
    const store = createStore2(reducer, preloadedState);
    let dispatch = () => {
      throw new Error(formatProdErrorMessage$1(15) );
    };
    const middlewareAPI = {
      getState: store.getState,
      dispatch: (action, ...args) => dispatch(action, ...args)
    };
    const chain = middlewares.map((middleware) => middleware(middlewareAPI));
    dispatch = compose(...chain)(store.dispatch);
    return {
      ...store,
      dispatch
    };
  };
}
function isAction(action) {
  return isPlainObject$2(action) && "type" in action && typeof action.type === "string";
}

var NOTHING = Symbol.for("immer-nothing");
var DRAFTABLE = Symbol.for("immer-draftable");
var DRAFT_STATE = Symbol.for("immer-state");
function die(error, ...args) {
  throw new Error(
    `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var getPrototypeOf = Object.getPrototypeOf;
function isDraft(value) {
  return !!value && !!value[DRAFT_STATE];
}
function isDraftable(value) {
  if (!value)
    return false;
  return isPlainObject$1(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor?.[DRAFTABLE] || isMap$1(value) || isSet$1(value);
}
var objectCtorString$1 = Object.prototype.constructor.toString();
function isPlainObject$1(value) {
  if (!value || typeof value !== "object")
    return false;
  const proto = getPrototypeOf(value);
  if (proto === null) {
    return true;
  }
  const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  if (Ctor === Object)
    return true;
  return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString$1;
}
function each(obj, iter) {
  if (getArchtype(obj) === 0) {
    Reflect.ownKeys(obj).forEach((key) => {
      iter(key, obj[key], obj);
    });
  } else {
    obj.forEach((entry, index) => iter(index, entry, obj));
  }
}
function getArchtype(thing) {
  const state = thing[DRAFT_STATE];
  return state ? state.type_ : Array.isArray(thing) ? 1 : isMap$1(thing) ? 2 : isSet$1(thing) ? 3 : 0;
}
function has(thing, prop) {
  return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
function set(thing, propOrOldValue, value) {
  const t = getArchtype(thing);
  if (t === 2)
    thing.set(propOrOldValue, value);
  else if (t === 3) {
    thing.add(value);
  } else
    thing[propOrOldValue] = value;
}
function is$1(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
function isMap$1(target) {
  return target instanceof Map;
}
function isSet$1(target) {
  return target instanceof Set;
}
function latest(state) {
  return state.copy_ || state.base_;
}
function shallowCopy(base, strict) {
  if (isMap$1(base)) {
    return new Map(base);
  }
  if (isSet$1(base)) {
    return new Set(base);
  }
  if (Array.isArray(base))
    return Array.prototype.slice.call(base);
  const isPlain = isPlainObject$1(base);
  if (strict === true || strict === "class_only" && !isPlain) {
    const descriptors = Object.getOwnPropertyDescriptors(base);
    delete descriptors[DRAFT_STATE];
    let keys = Reflect.ownKeys(descriptors);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const desc = descriptors[key];
      if (desc.writable === false) {
        desc.writable = true;
        desc.configurable = true;
      }
      if (desc.get || desc.set)
        descriptors[key] = {
          configurable: true,
          writable: true,
          // could live with !!desc.set as well here...
          enumerable: desc.enumerable,
          value: base[key]
        };
    }
    return Object.create(getPrototypeOf(base), descriptors);
  } else {
    const proto = getPrototypeOf(base);
    if (proto !== null && isPlain) {
      return { ...base };
    }
    const obj = Object.create(proto);
    return Object.assign(obj, base);
  }
}
function freeze(obj, deep = false) {
  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
    return obj;
  if (getArchtype(obj) > 1) {
    obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
  }
  Object.freeze(obj);
  if (deep)
    Object.entries(obj).forEach(([key, value]) => freeze(value, true));
  return obj;
}
function dontMutateFrozenCollections() {
  die(2);
}
function isFrozen(obj) {
  return Object.isFrozen(obj);
}
var plugins = {};
function getPlugin(pluginKey) {
  const plugin = plugins[pluginKey];
  if (!plugin) {
    die(0, pluginKey);
  }
  return plugin;
}
var currentScope;
function getCurrentScope() {
  return currentScope;
}
function createScope(parent_, immer_) {
  return {
    drafts_: [],
    parent_,
    immer_,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: true,
    unfinalizedDrafts_: 0
  };
}
function usePatchesInScope(scope, patchListener) {
  if (patchListener) {
    getPlugin("Patches");
    scope.patches_ = [];
    scope.inversePatches_ = [];
    scope.patchListener_ = patchListener;
  }
}
function revokeScope(scope) {
  leaveScope(scope);
  scope.drafts_.forEach(revokeDraft);
  scope.drafts_ = null;
}
function leaveScope(scope) {
  if (scope === currentScope) {
    currentScope = scope.parent_;
  }
}
function enterScope(immer2) {
  return currentScope = createScope(currentScope, immer2);
}
function revokeDraft(draft) {
  const state = draft[DRAFT_STATE];
  if (state.type_ === 0 || state.type_ === 1)
    state.revoke_();
  else
    state.revoked_ = true;
}
function processResult(result, scope) {
  scope.unfinalizedDrafts_ = scope.drafts_.length;
  const baseDraft = scope.drafts_[0];
  const isReplaced = result !== void 0 && result !== baseDraft;
  if (isReplaced) {
    if (baseDraft[DRAFT_STATE].modified_) {
      revokeScope(scope);
      die(4);
    }
    if (isDraftable(result)) {
      result = finalize(scope, result);
      if (!scope.parent_)
        maybeFreeze(scope, result);
    }
    if (scope.patches_) {
      getPlugin("Patches").generateReplacementPatches_(
        baseDraft[DRAFT_STATE].base_,
        result,
        scope.patches_,
        scope.inversePatches_
      );
    }
  } else {
    result = finalize(scope, baseDraft, []);
  }
  revokeScope(scope);
  if (scope.patches_) {
    scope.patchListener_(scope.patches_, scope.inversePatches_);
  }
  return result !== NOTHING ? result : void 0;
}
function finalize(rootScope, value, path) {
  if (isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  if (!state) {
    each(
      value,
      (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path)
    );
    return value;
  }
  if (state.scope_ !== rootScope)
    return value;
  if (!state.modified_) {
    maybeFreeze(rootScope, state.base_, true);
    return state.base_;
  }
  if (!state.finalized_) {
    state.finalized_ = true;
    state.scope_.unfinalizedDrafts_--;
    const result = state.copy_;
    let resultEach = result;
    let isSet2 = false;
    if (state.type_ === 3) {
      resultEach = new Set(result);
      result.clear();
      isSet2 = true;
    }
    each(
      resultEach,
      (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path, isSet2)
    );
    maybeFreeze(rootScope, result, false);
    if (path && rootScope.patches_) {
      getPlugin("Patches").generatePatches_(
        state,
        path,
        rootScope.patches_,
        rootScope.inversePatches_
      );
    }
  }
  return state.copy_;
}
function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
  if (isDraft(childValue)) {
    const path = rootPath && parentState && parentState.type_ !== 3 && // Set objects are atomic since they have no keys.
    !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
    const res = finalize(rootScope, childValue, path);
    set(targetObject, prop, res);
    if (isDraft(res)) {
      rootScope.canAutoFreeze_ = false;
    } else
      return;
  } else if (targetIsSet) {
    targetObject.add(childValue);
  }
  if (isDraftable(childValue) && !isFrozen(childValue)) {
    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
      return;
    }
    finalize(rootScope, childValue);
    if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && Object.prototype.propertyIsEnumerable.call(targetObject, prop))
      maybeFreeze(rootScope, childValue);
  }
}
function maybeFreeze(scope, value, deep = false) {
  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
    freeze(value, deep);
  }
}
function createProxyProxy(base, parent) {
  const isArray = Array.isArray(base);
  const state = {
    type_: isArray ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: parent ? parent.scope_ : getCurrentScope(),
    // True for both shallow and deep changes.
    modified_: false,
    // Used during finalization.
    finalized_: false,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: parent,
    // The base state.
    base_: base,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: false
  };
  let target = state;
  let traps = objectTraps;
  if (isArray) {
    target = [state];
    traps = arrayTraps;
  }
  const { revoke, proxy } = Proxy.revocable(target, traps);
  state.draft_ = proxy;
  state.revoke_ = revoke;
  return proxy;
}
var objectTraps = {
  get(state, prop) {
    if (prop === DRAFT_STATE)
      return state;
    const source = latest(state);
    if (!has(source, prop)) {
      return readPropFromProto(state, source, prop);
    }
    const value = source[prop];
    if (state.finalized_ || !isDraftable(value)) {
      return value;
    }
    if (value === peek$1(state.base_, prop)) {
      prepareCopy(state);
      return state.copy_[prop] = createProxy(value, state);
    }
    return value;
  },
  has(state, prop) {
    return prop in latest(state);
  },
  ownKeys(state) {
    return Reflect.ownKeys(latest(state));
  },
  set(state, prop, value) {
    const desc = getDescriptorFromProto(latest(state), prop);
    if (desc?.set) {
      desc.set.call(state.draft_, value);
      return true;
    }
    if (!state.modified_) {
      const current2 = peek$1(latest(state), prop);
      const currentState = current2?.[DRAFT_STATE];
      if (currentState && currentState.base_ === value) {
        state.copy_[prop] = value;
        state.assigned_[prop] = false;
        return true;
      }
      if (is$1(value, current2) && (value !== void 0 || has(state.base_, prop)))
        return true;
      prepareCopy(state);
      markChanged(state);
    }
    if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
    (value !== void 0 || prop in state.copy_) || // special case: NaN
    Number.isNaN(value) && Number.isNaN(state.copy_[prop]))
      return true;
    state.copy_[prop] = value;
    state.assigned_[prop] = true;
    return true;
  },
  deleteProperty(state, prop) {
    if (peek$1(state.base_, prop) !== void 0 || prop in state.base_) {
      state.assigned_[prop] = false;
      prepareCopy(state);
      markChanged(state);
    } else {
      delete state.assigned_[prop];
    }
    if (state.copy_) {
      delete state.copy_[prop];
    }
    return true;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(state, prop) {
    const owner = latest(state);
    const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
    if (!desc)
      return desc;
    return {
      writable: true,
      configurable: state.type_ !== 1 || prop !== "length",
      enumerable: desc.enumerable,
      value: owner[prop]
    };
  },
  defineProperty() {
    die(11);
  },
  getPrototypeOf(state) {
    return getPrototypeOf(state.base_);
  },
  setPrototypeOf() {
    die(12);
  }
};
var arrayTraps = {};
each(objectTraps, (key, fn) => {
  arrayTraps[key] = function() {
    arguments[0] = arguments[0][0];
    return fn.apply(this, arguments);
  };
});
arrayTraps.deleteProperty = function(state, prop) {
  return arrayTraps.set.call(this, state, prop, void 0);
};
arrayTraps.set = function(state, prop, value) {
  return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
function peek$1(draft, prop) {
  const state = draft[DRAFT_STATE];
  const source = state ? latest(state) : draft;
  return source[prop];
}
function readPropFromProto(state, source, prop) {
  const desc = getDescriptorFromProto(source, prop);
  return desc ? `value` in desc ? desc.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    desc.get?.call(state.draft_)
  ) : void 0;
}
function getDescriptorFromProto(source, prop) {
  if (!(prop in source))
    return void 0;
  let proto = getPrototypeOf(source);
  while (proto) {
    const desc = Object.getOwnPropertyDescriptor(proto, prop);
    if (desc)
      return desc;
    proto = getPrototypeOf(proto);
  }
  return void 0;
}
function markChanged(state) {
  if (!state.modified_) {
    state.modified_ = true;
    if (state.parent_) {
      markChanged(state.parent_);
    }
  }
}
function prepareCopy(state) {
  if (!state.copy_) {
    state.copy_ = shallowCopy(
      state.base_,
      state.scope_.immer_.useStrictShallowCopy_
    );
  }
}
var Immer2 = class {
  constructor(config) {
    this.autoFreeze_ = true;
    this.useStrictShallowCopy_ = false;
    this.produce = (base, recipe, patchListener) => {
      if (typeof base === "function" && typeof recipe !== "function") {
        const defaultBase = recipe;
        recipe = base;
        const self = this;
        return function curriedProduce(base2 = defaultBase, ...args) {
          return self.produce(base2, (draft) => recipe.call(this, draft, ...args));
        };
      }
      if (typeof recipe !== "function")
        die(6);
      if (patchListener !== void 0 && typeof patchListener !== "function")
        die(7);
      let result;
      if (isDraftable(base)) {
        const scope = enterScope(this);
        const proxy = createProxy(base, void 0);
        let hasError = true;
        try {
          result = recipe(proxy);
          hasError = false;
        } finally {
          if (hasError)
            revokeScope(scope);
          else
            leaveScope(scope);
        }
        usePatchesInScope(scope, patchListener);
        return processResult(result, scope);
      } else if (!base || typeof base !== "object") {
        result = recipe(base);
        if (result === void 0)
          result = base;
        if (result === NOTHING)
          result = void 0;
        if (this.autoFreeze_)
          freeze(result, true);
        if (patchListener) {
          const p = [];
          const ip = [];
          getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
          patchListener(p, ip);
        }
        return result;
      } else
        die(1, base);
    };
    this.produceWithPatches = (base, recipe) => {
      if (typeof base === "function") {
        return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));
      }
      let patches, inversePatches;
      const result = this.produce(base, recipe, (p, ip) => {
        patches = p;
        inversePatches = ip;
      });
      return [result, patches, inversePatches];
    };
    if (typeof config?.autoFreeze === "boolean")
      this.setAutoFreeze(config.autoFreeze);
    if (typeof config?.useStrictShallowCopy === "boolean")
      this.setUseStrictShallowCopy(config.useStrictShallowCopy);
  }
  createDraft(base) {
    if (!isDraftable(base))
      die(8);
    if (isDraft(base))
      base = current(base);
    const scope = enterScope(this);
    const proxy = createProxy(base, void 0);
    proxy[DRAFT_STATE].isManual_ = true;
    leaveScope(scope);
    return proxy;
  }
  finishDraft(draft, patchListener) {
    const state = draft && draft[DRAFT_STATE];
    if (!state || !state.isManual_)
      die(9);
    const { scope_: scope } = state;
    usePatchesInScope(scope, patchListener);
    return processResult(void 0, scope);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(value) {
    this.autoFreeze_ = value;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(value) {
    this.useStrictShallowCopy_ = value;
  }
  applyPatches(base, patches) {
    let i;
    for (i = patches.length - 1; i >= 0; i--) {
      const patch = patches[i];
      if (patch.path.length === 0 && patch.op === "replace") {
        base = patch.value;
        break;
      }
    }
    if (i > -1) {
      patches = patches.slice(i + 1);
    }
    const applyPatchesImpl = getPlugin("Patches").applyPatches_;
    if (isDraft(base)) {
      return applyPatchesImpl(base, patches);
    }
    return this.produce(
      base,
      (draft) => applyPatchesImpl(draft, patches)
    );
  }
};
function createProxy(value, parent) {
  const draft = isMap$1(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet$1(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
  const scope = parent ? parent.scope_ : getCurrentScope();
  scope.drafts_.push(draft);
  return draft;
}
function current(value) {
  if (!isDraft(value))
    die(10, value);
  return currentImpl(value);
}
function currentImpl(value) {
  if (!isDraftable(value) || isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  let copy;
  if (state) {
    if (!state.modified_)
      return state.base_;
    state.finalized_ = true;
    copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
  } else {
    copy = shallowCopy(value, true);
  }
  each(copy, (key, childValue) => {
    set(copy, key, currentImpl(childValue));
  });
  if (state) {
    state.finalized_ = false;
  }
  return copy;
}
var immer = new Immer2();
var produce = immer.produce;
immer.produceWithPatches.bind(
  immer
);
immer.setAutoFreeze.bind(immer);
immer.setUseStrictShallowCopy.bind(immer);
immer.applyPatches.bind(immer);
immer.createDraft.bind(immer);
immer.finishDraft.bind(immer);

// src/index.ts
function createThunkMiddleware(extraArgument) {
  const middleware = ({ dispatch, getState }) => (next) => (action) => {
    if (typeof action === "function") {
      return action(dispatch, getState, extraArgument);
    }
    return next(action);
  };
  return middleware;
}
var thunk = createThunkMiddleware();
var withExtraArgument = createThunkMiddleware;

var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
  if (arguments.length === 0) return void 0;
  if (typeof arguments[0] === "object") return compose;
  return compose.apply(null, arguments);
};
function createAction(type, prepareAction) {
  function actionCreator(...args) {
    if (prepareAction) {
      let prepared = prepareAction(...args);
      if (!prepared) {
        throw new Error(formatProdErrorMessage(0) );
      }
      return {
        type,
        payload: prepared.payload,
        ..."meta" in prepared && {
          meta: prepared.meta
        },
        ..."error" in prepared && {
          error: prepared.error
        }
      };
    }
    return {
      type,
      payload: args[0]
    };
  }
  actionCreator.toString = () => `${type}`;
  actionCreator.type = type;
  actionCreator.match = (action) => isAction(action) && action.type === type;
  return actionCreator;
}
var Tuple = class _Tuple extends Array {
  constructor(...items) {
    super(...items);
    Object.setPrototypeOf(this, _Tuple.prototype);
  }
  static get [Symbol.species]() {
    return _Tuple;
  }
  concat(...arr) {
    return super.concat.apply(this, arr);
  }
  prepend(...arr) {
    if (arr.length === 1 && Array.isArray(arr[0])) {
      return new _Tuple(...arr[0].concat(this));
    }
    return new _Tuple(...arr.concat(this));
  }
};
function freezeDraftable(val) {
  return isDraftable(val) ? produce(val, () => {
  }) : val;
}
function getOrInsertComputed(map, key, compute) {
  if (map.has(key)) return map.get(key);
  return map.set(key, compute(key)).get(key);
}
function isBoolean(x) {
  return typeof x === "boolean";
}
var buildGetDefaultMiddleware = () => function getDefaultMiddleware(options) {
  const {
    thunk: thunk$1 = true,
    immutableCheck = true,
    serializableCheck = true,
    actionCreatorCheck = true
  } = options ?? {};
  let middlewareArray = new Tuple();
  if (thunk$1) {
    if (isBoolean(thunk$1)) {
      middlewareArray.push(thunk);
    } else {
      middlewareArray.push(withExtraArgument(thunk$1.extraArgument));
    }
  }
  return middlewareArray;
};
var SHOULD_AUTOBATCH = "RTK_autoBatch";
var createQueueWithTimer = (timeout) => {
  return (notify) => {
    setTimeout(notify, timeout);
  };
};
var autoBatchEnhancer = (options = {
  type: "raf"
}) => (next) => (...args) => {
  const store = next(...args);
  let notifying = true;
  let shouldNotifyAtEndOfTick = false;
  let notificationQueued = false;
  const listeners = /* @__PURE__ */ new Set();
  const queueCallback = options.type === "tick" ? queueMicrotask : options.type === "raf" ? (
    // requestAnimationFrame won't exist in SSR environments. Fall back to a vague approximation just to keep from erroring.
    typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10)
  ) : options.type === "callback" ? options.queueNotification : createQueueWithTimer(options.timeout);
  const notifyListeners = () => {
    notificationQueued = false;
    if (shouldNotifyAtEndOfTick) {
      shouldNotifyAtEndOfTick = false;
      listeners.forEach((l) => l());
    }
  };
  return Object.assign({}, store, {
    // Override the base `store.subscribe` method to keep original listeners
    // from running if we're delaying notifications
    subscribe(listener2) {
      const wrappedListener = () => notifying && listener2();
      const unsubscribe = store.subscribe(wrappedListener);
      listeners.add(listener2);
      return () => {
        unsubscribe();
        listeners.delete(listener2);
      };
    },
    // Override the base `store.dispatch` method so that we can check actions
    // for the `shouldAutoBatch` flag and determine if batching is active
    dispatch(action) {
      try {
        notifying = !action?.meta?.[SHOULD_AUTOBATCH];
        shouldNotifyAtEndOfTick = !notifying;
        if (shouldNotifyAtEndOfTick) {
          if (!notificationQueued) {
            notificationQueued = true;
            queueCallback(notifyListeners);
          }
        }
        return store.dispatch(action);
      } finally {
        notifying = true;
      }
    }
  });
};
var buildGetDefaultEnhancers = (middlewareEnhancer) => function getDefaultEnhancers(options) {
  const {
    autoBatch = true
  } = options ?? {};
  let enhancerArray = new Tuple(middlewareEnhancer);
  if (autoBatch) {
    enhancerArray.push(autoBatchEnhancer(typeof autoBatch === "object" ? autoBatch : void 0));
  }
  return enhancerArray;
};
function configureStore(options) {
  const getDefaultMiddleware = buildGetDefaultMiddleware();
  const {
    reducer = void 0,
    middleware,
    devTools = true,
    preloadedState = void 0,
    enhancers = void 0
  } = options || {};
  let rootReducer;
  if (typeof reducer === "function") {
    rootReducer = reducer;
  } else if (isPlainObject$2(reducer)) {
    rootReducer = combineReducers(reducer);
  } else {
    throw new Error(formatProdErrorMessage(1) );
  }
  let finalMiddleware;
  if (typeof middleware === "function") {
    finalMiddleware = middleware(getDefaultMiddleware);
  } else {
    finalMiddleware = getDefaultMiddleware();
  }
  let finalCompose = compose;
  if (devTools) {
    finalCompose = composeWithDevTools({
      // Enable capture of stack traces for dispatched Redux actions
      trace: false,
      ...typeof devTools === "object" && devTools
    });
  }
  const middlewareEnhancer = applyMiddleware(...finalMiddleware);
  const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);
  let storeEnhancers = typeof enhancers === "function" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();
  const composedEnhancer = finalCompose(...storeEnhancers);
  return createStore(rootReducer, preloadedState, composedEnhancer);
}
function executeReducerBuilderCallback(builderCallback) {
  const actionsMap = {};
  const actionMatchers = [];
  let defaultCaseReducer;
  const builder = {
    addCase(typeOrActionCreator, reducer) {
      const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
      if (!type) {
        throw new Error(formatProdErrorMessage(28) );
      }
      if (type in actionsMap) {
        throw new Error(formatProdErrorMessage(29) );
      }
      actionsMap[type] = reducer;
      return builder;
    },
    addMatcher(matcher, reducer) {
      actionMatchers.push({
        matcher,
        reducer
      });
      return builder;
    },
    addDefaultCase(reducer) {
      defaultCaseReducer = reducer;
      return builder;
    }
  };
  builderCallback(builder);
  return [actionsMap, actionMatchers, defaultCaseReducer];
}
function isStateFunction(x) {
  return typeof x === "function";
}
function createReducer(initialState, mapOrBuilderCallback) {
  let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);
  let getInitialState;
  if (isStateFunction(initialState)) {
    getInitialState = () => freezeDraftable(initialState());
  } else {
    const frozenInitialState = freezeDraftable(initialState);
    getInitialState = () => frozenInitialState;
  }
  function reducer(state = getInitialState(), action) {
    let caseReducers = [actionsMap[action.type], ...finalActionMatchers.filter(({
      matcher
    }) => matcher(action)).map(({
      reducer: reducer2
    }) => reducer2)];
    if (caseReducers.filter((cr) => !!cr).length === 0) {
      caseReducers = [finalDefaultCaseReducer];
    }
    return caseReducers.reduce((previousState, caseReducer) => {
      if (caseReducer) {
        if (isDraft(previousState)) {
          const draft = previousState;
          const result = caseReducer(draft, action);
          if (result === void 0) {
            return previousState;
          }
          return result;
        } else if (!isDraftable(previousState)) {
          const result = caseReducer(previousState, action);
          if (result === void 0) {
            if (previousState === null) {
              return previousState;
            }
            throw Error("A case reducer on a non-draftable value must not return undefined");
          }
          return result;
        } else {
          return produce(previousState, (draft) => {
            return caseReducer(draft, action);
          });
        }
      }
      return previousState;
    }, state);
  }
  reducer.getInitialState = getInitialState;
  return reducer;
}
var asyncThunkSymbol = /* @__PURE__ */ Symbol.for("rtk-slice-createasyncthunk");
function getType(slice, actionKey) {
  return `${slice}/${actionKey}`;
}
function buildCreateSlice({
  creators
} = {}) {
  const cAT = creators?.asyncThunk?.[asyncThunkSymbol];
  return function createSlice2(options) {
    const {
      name,
      reducerPath = name
    } = options;
    if (!name) {
      throw new Error(formatProdErrorMessage(11) );
    }
    const reducers = (typeof options.reducers === "function" ? options.reducers(buildReducerCreators()) : options.reducers) || {};
    const reducerNames = Object.keys(reducers);
    const context = {
      sliceCaseReducersByName: {},
      sliceCaseReducersByType: {},
      actionCreators: {},
      sliceMatchers: []
    };
    const contextMethods = {
      addCase(typeOrActionCreator, reducer2) {
        const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
        if (!type) {
          throw new Error(formatProdErrorMessage(12) );
        }
        if (type in context.sliceCaseReducersByType) {
          throw new Error(formatProdErrorMessage(13) );
        }
        context.sliceCaseReducersByType[type] = reducer2;
        return contextMethods;
      },
      addMatcher(matcher, reducer2) {
        context.sliceMatchers.push({
          matcher,
          reducer: reducer2
        });
        return contextMethods;
      },
      exposeAction(name2, actionCreator) {
        context.actionCreators[name2] = actionCreator;
        return contextMethods;
      },
      exposeCaseReducer(name2, reducer2) {
        context.sliceCaseReducersByName[name2] = reducer2;
        return contextMethods;
      }
    };
    reducerNames.forEach((reducerName) => {
      const reducerDefinition = reducers[reducerName];
      const reducerDetails = {
        reducerName,
        type: getType(name, reducerName),
        createNotation: typeof options.reducers === "function"
      };
      if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {
        handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);
      } else {
        handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);
      }
    });
    function buildReducer() {
      const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options.extraReducers === "function" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers];
      const finalCaseReducers = {
        ...extraReducers,
        ...context.sliceCaseReducersByType
      };
      return createReducer(options.initialState, (builder) => {
        for (let key in finalCaseReducers) {
          builder.addCase(key, finalCaseReducers[key]);
        }
        for (let sM of context.sliceMatchers) {
          builder.addMatcher(sM.matcher, sM.reducer);
        }
        for (let m of actionMatchers) {
          builder.addMatcher(m.matcher, m.reducer);
        }
        if (defaultCaseReducer) {
          builder.addDefaultCase(defaultCaseReducer);
        }
      });
    }
    const selectSelf = (state) => state;
    const injectedSelectorCache = /* @__PURE__ */ new Map();
    const injectedStateCache = /* @__PURE__ */ new WeakMap();
    let _reducer;
    function reducer(state, action) {
      if (!_reducer) _reducer = buildReducer();
      return _reducer(state, action);
    }
    function getInitialState() {
      if (!_reducer) _reducer = buildReducer();
      return _reducer.getInitialState();
    }
    function makeSelectorProps(reducerPath2, injected = false) {
      function selectSlice(state) {
        let sliceState = state[reducerPath2];
        if (typeof sliceState === "undefined") {
          if (injected) {
            sliceState = getOrInsertComputed(injectedStateCache, selectSlice, getInitialState);
          }
        }
        return sliceState;
      }
      function getSelectors(selectState = selectSelf) {
        const selectorCache = getOrInsertComputed(injectedSelectorCache, injected, () => /* @__PURE__ */ new WeakMap());
        return getOrInsertComputed(selectorCache, selectState, () => {
          const map = {};
          for (const [name2, selector] of Object.entries(options.selectors ?? {})) {
            map[name2] = wrapSelector(selector, selectState, () => getOrInsertComputed(injectedStateCache, selectState, getInitialState), injected);
          }
          return map;
        });
      }
      return {
        reducerPath: reducerPath2,
        getSelectors,
        get selectors() {
          return getSelectors(selectSlice);
        },
        selectSlice
      };
    }
    const slice = {
      name,
      reducer,
      actions: context.actionCreators,
      caseReducers: context.sliceCaseReducersByName,
      getInitialState,
      ...makeSelectorProps(reducerPath),
      injectInto(injectable, {
        reducerPath: pathOpt,
        ...config
      } = {}) {
        const newReducerPath = pathOpt ?? reducerPath;
        injectable.inject({
          reducerPath: newReducerPath,
          reducer
        }, config);
        return {
          ...slice,
          ...makeSelectorProps(newReducerPath, true)
        };
      }
    };
    return slice;
  };
}
function wrapSelector(selector, selectState, getInitialState, injected) {
  function wrapper(rootState, ...args) {
    let sliceState = selectState(rootState);
    if (typeof sliceState === "undefined") {
      if (injected) {
        sliceState = getInitialState();
      }
    }
    return selector(sliceState, ...args);
  }
  wrapper.unwrapped = selector;
  return wrapper;
}
var createSlice = /* @__PURE__ */ buildCreateSlice();
function buildReducerCreators() {
  function asyncThunk(payloadCreator, config) {
    return {
      _reducerDefinitionType: "asyncThunk",
      payloadCreator,
      ...config
    };
  }
  asyncThunk.withTypes = () => asyncThunk;
  return {
    reducer(caseReducer) {
      return Object.assign({
        // hack so the wrapping function has the same name as the original
        // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original
        [caseReducer.name](...args) {
          return caseReducer(...args);
        }
      }[caseReducer.name], {
        _reducerDefinitionType: "reducer"
        /* reducer */
      });
    },
    preparedReducer(prepare, reducer) {
      return {
        _reducerDefinitionType: "reducerWithPrepare",
        prepare,
        reducer
      };
    },
    asyncThunk
  };
}
function handleNormalReducerDefinition({
  type,
  reducerName,
  createNotation
}, maybeReducerWithPrepare, context) {
  let caseReducer;
  let prepareCallback;
  if ("reducer" in maybeReducerWithPrepare) {
    if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {
      throw new Error(formatProdErrorMessage(17) );
    }
    caseReducer = maybeReducerWithPrepare.reducer;
    prepareCallback = maybeReducerWithPrepare.prepare;
  } else {
    caseReducer = maybeReducerWithPrepare;
  }
  context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));
}
function isAsyncThunkSliceReducerDefinition(reducerDefinition) {
  return reducerDefinition._reducerDefinitionType === "asyncThunk";
}
function isCaseReducerWithPrepareDefinition(reducerDefinition) {
  return reducerDefinition._reducerDefinitionType === "reducerWithPrepare";
}
function handleThunkCaseReducerDefinition({
  type,
  reducerName
}, reducerDefinition, context, cAT) {
  if (!cAT) {
    throw new Error(formatProdErrorMessage(18) );
  }
  const {
    payloadCreator,
    fulfilled,
    pending,
    rejected,
    settled,
    options
  } = reducerDefinition;
  const thunk = cAT(type, payloadCreator, options);
  context.exposeAction(reducerName, thunk);
  if (fulfilled) {
    context.addCase(thunk.fulfilled, fulfilled);
  }
  if (pending) {
    context.addCase(thunk.pending, pending);
  }
  if (rejected) {
    context.addCase(thunk.rejected, rejected);
  }
  if (settled) {
    context.addMatcher(thunk.settled, settled);
  }
  context.exposeCaseReducer(reducerName, {
    fulfilled: fulfilled || noop,
    pending: pending || noop,
    rejected: rejected || noop,
    settled: settled || noop
  });
}
function noop() {
}
function formatProdErrorMessage(code) {
  return `Minified Redux Toolkit error #${code}; visit https://redux-toolkit.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
}

const initialState = {
  isAuthenticated: false,
  user: null,
  loading: false,
  error: null
};
const authSlice = createSlice({
  name: "auth",
  initialState,
  reducers: {
    login: (state, action) => {
      state.isAuthenticated = true;
      state.user = {
        username: action.payload.name,
        email: action.payload.email
      };
    },
    logout: (state) => {
      state.isAuthenticated = false;
      state.user = null;
    },
    loginFailure(state, action) {
      state.loading = false;
      state.error = action.payload;
    }
  }
});
const { login, logout, loginFailure } = authSlice.actions;
const store = configureStore({
  reducer: {
    auth: authSlice.reducer
  },
  devTools: true
});

/*!
* sweetalert2 v11.21.0
* Released under the MIT License.
*/
function _assertClassBrand(e, t, n) {
  if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
  throw new TypeError("Private element is not present on this object");
}
function _checkPrivateRedeclaration(e, t) {
  if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _classPrivateFieldGet2(s, a) {
  return s.get(_assertClassBrand(s, a));
}
function _classPrivateFieldInitSpec(e, t, a) {
  _checkPrivateRedeclaration(e, t), t.set(e, a);
}
function _classPrivateFieldSet2(s, a, r) {
  return s.set(_assertClassBrand(s, a), r), r;
}

const RESTORE_FOCUS_TIMEOUT = 100;

/** @type {GlobalState} */
const globalState = {};
const focusPreviousActiveElement = () => {
  if (globalState.previousActiveElement instanceof HTMLElement) {
    globalState.previousActiveElement.focus();
    globalState.previousActiveElement = null;
  } else if (document.body) {
    document.body.focus();
  }
};

/**
 * Restore previous active (focused) element
 *
 * @param {boolean} returnFocus
 * @returns {Promise<void>}
 */
const restoreActiveElement = returnFocus => {
  return new Promise(resolve => {
    if (!returnFocus) {
      return resolve();
    }
    const x = window.scrollX;
    const y = window.scrollY;
    globalState.restoreFocusTimeout = setTimeout(() => {
      focusPreviousActiveElement();
      resolve();
    }, RESTORE_FOCUS_TIMEOUT); // issues/900

    window.scrollTo(x, y);
  });
};

const swalPrefix = 'swal2-';

/**
 * @typedef {Record<SwalClass, string>} SwalClasses
 */

/**
 * @typedef {'success' | 'warning' | 'info' | 'question' | 'error'} SwalIcon
 * @typedef {Record<SwalIcon, string>} SwalIcons
 */

/** @type {SwalClass[]} */
const classNames = ['container', 'shown', 'height-auto', 'iosfix', 'popup', 'modal', 'no-backdrop', 'no-transition', 'toast', 'toast-shown', 'show', 'hide', 'close', 'title', 'html-container', 'actions', 'confirm', 'deny', 'cancel', 'footer', 'icon', 'icon-content', 'image', 'input', 'file', 'range', 'select', 'radio', 'checkbox', 'label', 'textarea', 'inputerror', 'input-label', 'validation-message', 'progress-steps', 'active-progress-step', 'progress-step', 'progress-step-line', 'loader', 'loading', 'styled', 'top', 'top-start', 'top-end', 'top-left', 'top-right', 'center', 'center-start', 'center-end', 'center-left', 'center-right', 'bottom', 'bottom-start', 'bottom-end', 'bottom-left', 'bottom-right', 'grow-row', 'grow-column', 'grow-fullscreen', 'rtl', 'timer-progress-bar', 'timer-progress-bar-container', 'scrollbar-measure', 'icon-success', 'icon-warning', 'icon-info', 'icon-question', 'icon-error', 'draggable', 'dragging'];
const swalClasses = classNames.reduce((acc, className) => {
  acc[className] = swalPrefix + className;
  return acc;
}, /** @type {SwalClasses} */{});

/** @type {SwalIcon[]} */
const icons = ['success', 'warning', 'info', 'question', 'error'];
const iconTypes = icons.reduce((acc, icon) => {
  acc[icon] = swalPrefix + icon;
  return acc;
}, /** @type {SwalIcons} */{});

const consolePrefix = 'SweetAlert2:';

/**
 * Capitalize the first letter of a string
 *
 * @param {string} str
 * @returns {string}
 */
const capitalizeFirstLetter = str => str.charAt(0).toUpperCase() + str.slice(1);

/**
 * Standardize console warnings
 *
 * @param {string | string[]} message
 */
const warn = message => {
  console.warn(`${consolePrefix} ${typeof message === 'object' ? message.join(' ') : message}`);
};

/**
 * Standardize console errors
 *
 * @param {string} message
 */
const error = message => {
  console.error(`${consolePrefix} ${message}`);
};

/**
 * Private global state for `warnOnce`
 *
 * @type {string[]}
 * @private
 */
const previousWarnOnceMessages = [];

/**
 * Show a console warning, but only if it hasn't already been shown
 *
 * @param {string} message
 */
const warnOnce = message => {
  if (!previousWarnOnceMessages.includes(message)) {
    previousWarnOnceMessages.push(message);
    warn(message);
  }
};

/**
 * Show a one-time console warning about deprecated params/methods
 *
 * @param {string} deprecatedParam
 * @param {string?} useInstead
 */
const warnAboutDeprecation = function (deprecatedParam) {
  let useInstead = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  warnOnce(`"${deprecatedParam}" is deprecated and will be removed in the next major release.${useInstead ? ` Use "${useInstead}" instead.` : ''}`);
};

/**
 * If `arg` is a function, call it (with no arguments or context) and return the result.
 * Otherwise, just pass the value through
 *
 * @param {Function | any} arg
 * @returns {any}
 */
const callIfFunction = arg => typeof arg === 'function' ? arg() : arg;

/**
 * @param {any} arg
 * @returns {boolean}
 */
const hasToPromiseFn = arg => arg && typeof arg.toPromise === 'function';

/**
 * @param {any} arg
 * @returns {Promise<any>}
 */
const asPromise = arg => hasToPromiseFn(arg) ? arg.toPromise() : Promise.resolve(arg);

/**
 * @param {any} arg
 * @returns {boolean}
 */
const isPromise$1 = arg => arg && Promise.resolve(arg) === arg;

/**
 * Gets the popup container which contains the backdrop and the popup itself.
 *
 * @returns {HTMLElement | null}
 */
const getContainer = () => document.body.querySelector(`.${swalClasses.container}`);

/**
 * @param {string} selectorString
 * @returns {HTMLElement | null}
 */
const elementBySelector = selectorString => {
  const container = getContainer();
  return container ? container.querySelector(selectorString) : null;
};

/**
 * @param {string} className
 * @returns {HTMLElement | null}
 */
const elementByClass = className => {
  return elementBySelector(`.${className}`);
};

/**
 * @returns {HTMLElement | null}
 */
const getPopup = () => elementByClass(swalClasses.popup);

/**
 * @returns {HTMLElement | null}
 */
const getIcon = () => elementByClass(swalClasses.icon);

/**
 * @returns {HTMLElement | null}
 */
const getIconContent = () => elementByClass(swalClasses['icon-content']);

/**
 * @returns {HTMLElement | null}
 */
const getTitle = () => elementByClass(swalClasses.title);

/**
 * @returns {HTMLElement | null}
 */
const getHtmlContainer = () => elementByClass(swalClasses['html-container']);

/**
 * @returns {HTMLElement | null}
 */
const getImage = () => elementByClass(swalClasses.image);

/**
 * @returns {HTMLElement | null}
 */
const getProgressSteps = () => elementByClass(swalClasses['progress-steps']);

/**
 * @returns {HTMLElement | null}
 */
const getValidationMessage = () => elementByClass(swalClasses['validation-message']);

/**
 * @returns {HTMLButtonElement | null}
 */
const getConfirmButton = () => (/** @type {HTMLButtonElement} */elementBySelector(`.${swalClasses.actions} .${swalClasses.confirm}`));

/**
 * @returns {HTMLButtonElement | null}
 */
const getCancelButton = () => (/** @type {HTMLButtonElement} */elementBySelector(`.${swalClasses.actions} .${swalClasses.cancel}`));

/**
 * @returns {HTMLButtonElement | null}
 */
const getDenyButton = () => (/** @type {HTMLButtonElement} */elementBySelector(`.${swalClasses.actions} .${swalClasses.deny}`));

/**
 * @returns {HTMLElement | null}
 */
const getInputLabel = () => elementByClass(swalClasses['input-label']);

/**
 * @returns {HTMLElement | null}
 */
const getLoader = () => elementBySelector(`.${swalClasses.loader}`);

/**
 * @returns {HTMLElement | null}
 */
const getActions = () => elementByClass(swalClasses.actions);

/**
 * @returns {HTMLElement | null}
 */
const getFooter = () => elementByClass(swalClasses.footer);

/**
 * @returns {HTMLElement | null}
 */
const getTimerProgressBar = () => elementByClass(swalClasses['timer-progress-bar']);

/**
 * @returns {HTMLElement | null}
 */
const getCloseButton = () => elementByClass(swalClasses.close);

// https://github.com/jkup/focusable/blob/master/index.js
const focusable = `
  a[href],
  area[href],
  input:not([disabled]),
  select:not([disabled]),
  textarea:not([disabled]),
  button:not([disabled]),
  iframe,
  object,
  embed,
  [tabindex="0"],
  [contenteditable],
  audio[controls],
  video[controls],
  summary
`;
/**
 * @returns {HTMLElement[]}
 */
const getFocusableElements = () => {
  const popup = getPopup();
  if (!popup) {
    return [];
  }
  /** @type {NodeListOf<HTMLElement>} */
  const focusableElementsWithTabindex = popup.querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])');
  const focusableElementsWithTabindexSorted = Array.from(focusableElementsWithTabindex)
  // sort according to tabindex
  .sort((a, b) => {
    const tabindexA = parseInt(a.getAttribute('tabindex') || '0');
    const tabindexB = parseInt(b.getAttribute('tabindex') || '0');
    if (tabindexA > tabindexB) {
      return 1;
    } else if (tabindexA < tabindexB) {
      return -1;
    }
    return 0;
  });

  /** @type {NodeListOf<HTMLElement>} */
  const otherFocusableElements = popup.querySelectorAll(focusable);
  const otherFocusableElementsFiltered = Array.from(otherFocusableElements).filter(el => el.getAttribute('tabindex') !== '-1');
  return [...new Set(focusableElementsWithTabindexSorted.concat(otherFocusableElementsFiltered))].filter(el => isVisible$1(el));
};

/**
 * @returns {boolean}
 */
const isModal = () => {
  return hasClass(document.body, swalClasses.shown) && !hasClass(document.body, swalClasses['toast-shown']) && !hasClass(document.body, swalClasses['no-backdrop']);
};

/**
 * @returns {boolean}
 */
const isToast = () => {
  const popup = getPopup();
  if (!popup) {
    return false;
  }
  return hasClass(popup, swalClasses.toast);
};

/**
 * @returns {boolean}
 */
const isLoading = () => {
  const popup = getPopup();
  if (!popup) {
    return false;
  }
  return popup.hasAttribute('data-loading');
};

/**
 * Securely set innerHTML of an element
 * https://github.com/sweetalert2/sweetalert2/issues/1926
 *
 * @param {HTMLElement} elem
 * @param {string} html
 */
const setInnerHtml = (elem, html) => {
  elem.textContent = '';
  if (html) {
    const parser = new DOMParser();
    const parsed = parser.parseFromString(html, `text/html`);
    const head = parsed.querySelector('head');
    if (head) {
      Array.from(head.childNodes).forEach(child => {
        elem.appendChild(child);
      });
    }
    const body = parsed.querySelector('body');
    if (body) {
      Array.from(body.childNodes).forEach(child => {
        if (child instanceof HTMLVideoElement || child instanceof HTMLAudioElement) {
          elem.appendChild(child.cloneNode(true)); // https://github.com/sweetalert2/sweetalert2/issues/2507
        } else {
          elem.appendChild(child);
        }
      });
    }
  }
};

/**
 * @param {HTMLElement} elem
 * @param {string} className
 * @returns {boolean}
 */
const hasClass = (elem, className) => {
  if (!className) {
    return false;
  }
  const classList = className.split(/\s+/);
  for (let i = 0; i < classList.length; i++) {
    if (!elem.classList.contains(classList[i])) {
      return false;
    }
  }
  return true;
};

/**
 * @param {HTMLElement} elem
 * @param {SweetAlertOptions} params
 */
const removeCustomClasses = (elem, params) => {
  Array.from(elem.classList).forEach(className => {
    if (!Object.values(swalClasses).includes(className) && !Object.values(iconTypes).includes(className) && !Object.values(params.showClass || {}).includes(className)) {
      elem.classList.remove(className);
    }
  });
};

/**
 * @param {HTMLElement} elem
 * @param {SweetAlertOptions} params
 * @param {string} className
 */
const applyCustomClass = (elem, params, className) => {
  removeCustomClasses(elem, params);
  if (!params.customClass) {
    return;
  }
  const customClass = params.customClass[(/** @type {keyof SweetAlertCustomClass} */className)];
  if (!customClass) {
    return;
  }
  if (typeof customClass !== 'string' && !customClass.forEach) {
    warn(`Invalid type of customClass.${className}! Expected string or iterable object, got "${typeof customClass}"`);
    return;
  }
  addClass(elem, customClass);
};

/**
 * @param {HTMLElement} popup
 * @param {import('./renderers/renderInput').InputClass | SweetAlertInput} inputClass
 * @returns {HTMLInputElement | null}
 */
const getInput$1 = (popup, inputClass) => {
  if (!inputClass) {
    return null;
  }
  switch (inputClass) {
    case 'select':
    case 'textarea':
    case 'file':
      return popup.querySelector(`.${swalClasses.popup} > .${swalClasses[inputClass]}`);
    case 'checkbox':
      return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.checkbox} input`);
    case 'radio':
      return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.radio} input:checked`) || popup.querySelector(`.${swalClasses.popup} > .${swalClasses.radio} input:first-child`);
    case 'range':
      return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.range} input`);
    default:
      return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.input}`);
  }
};

/**
 * @param {HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement} input
 */
const focusInput = input => {
  input.focus();

  // place cursor at end of text in text input
  if (input.type !== 'file') {
    // http://stackoverflow.com/a/2345915
    const val = input.value;
    input.value = '';
    input.value = val;
  }
};

/**
 * @param {HTMLElement | HTMLElement[] | null} target
 * @param {string | string[] | readonly string[] | undefined} classList
 * @param {boolean} condition
 */
const toggleClass = (target, classList, condition) => {
  if (!target || !classList) {
    return;
  }
  if (typeof classList === 'string') {
    classList = classList.split(/\s+/).filter(Boolean);
  }
  classList.forEach(className => {
    if (Array.isArray(target)) {
      target.forEach(elem => {
        if (condition) {
          elem.classList.add(className);
        } else {
          elem.classList.remove(className);
        }
      });
    } else {
      if (condition) {
        target.classList.add(className);
      } else {
        target.classList.remove(className);
      }
    }
  });
};

/**
 * @param {HTMLElement | HTMLElement[] | null} target
 * @param {string | string[] | readonly string[] | undefined} classList
 */
const addClass = (target, classList) => {
  toggleClass(target, classList, true);
};

/**
 * @param {HTMLElement | HTMLElement[] | null} target
 * @param {string | string[] | readonly string[] | undefined} classList
 */
const removeClass = (target, classList) => {
  toggleClass(target, classList, false);
};

/**
 * Get direct child of an element by class name
 *
 * @param {HTMLElement} elem
 * @param {string} className
 * @returns {HTMLElement | undefined}
 */
const getDirectChildByClass = (elem, className) => {
  const children = Array.from(elem.children);
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (child instanceof HTMLElement && hasClass(child, className)) {
      return child;
    }
  }
};

/**
 * @param {HTMLElement} elem
 * @param {string} property
 * @param {*} value
 */
const applyNumericalStyle = (elem, property, value) => {
  if (value === `${parseInt(value)}`) {
    value = parseInt(value);
  }
  if (value || parseInt(value) === 0) {
    elem.style.setProperty(property, typeof value === 'number' ? `${value}px` : value);
  } else {
    elem.style.removeProperty(property);
  }
};

/**
 * @param {HTMLElement | null} elem
 * @param {string} display
 */
const show = function (elem) {
  let display = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'flex';
  if (!elem) {
    return;
  }
  elem.style.display = display;
};

/**
 * @param {HTMLElement | null} elem
 */
const hide$2 = elem => {
  if (!elem) {
    return;
  }
  elem.style.display = 'none';
};

/**
 * @param {HTMLElement | null} elem
 * @param {string} display
 */
const showWhenInnerHtmlPresent = function (elem) {
  let display = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'block';
  if (!elem) {
    return;
  }
  new MutationObserver(() => {
    toggle(elem, elem.innerHTML, display);
  }).observe(elem, {
    childList: true,
    subtree: true
  });
};

/**
 * @param {HTMLElement} parent
 * @param {string} selector
 * @param {string} property
 * @param {string} value
 */
const setStyle = (parent, selector, property, value) => {
  /** @type {HTMLElement | null} */
  const el = parent.querySelector(selector);
  if (el) {
    el.style.setProperty(property, value);
  }
};

/**
 * @param {HTMLElement} elem
 * @param {any} condition
 * @param {string} display
 */
const toggle = function (elem, condition) {
  let display = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'flex';
  if (condition) {
    show(elem, display);
  } else {
    hide$2(elem);
  }
};

/**
 * borrowed from jquery $(elem).is(':visible') implementation
 *
 * @param {HTMLElement | null} elem
 * @returns {boolean}
 */
const isVisible$1 = elem => !!(elem && (elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length));

/**
 * @returns {boolean}
 */
const allButtonsAreHidden = () => !isVisible$1(getConfirmButton()) && !isVisible$1(getDenyButton()) && !isVisible$1(getCancelButton());

/**
 * @param {HTMLElement} elem
 * @returns {boolean}
 */
const isScrollable = elem => !!(elem.scrollHeight > elem.clientHeight);

/**
 * borrowed from https://stackoverflow.com/a/46352119
 *
 * @param {HTMLElement} elem
 * @returns {boolean}
 */
const hasCssAnimation = elem => {
  const style = window.getComputedStyle(elem);
  const animDuration = parseFloat(style.getPropertyValue('animation-duration') || '0');
  const transDuration = parseFloat(style.getPropertyValue('transition-duration') || '0');
  return animDuration > 0 || transDuration > 0;
};

/**
 * @param {number} timer
 * @param {boolean} reset
 */
const animateTimerProgressBar = function (timer) {
  let reset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  const timerProgressBar = getTimerProgressBar();
  if (!timerProgressBar) {
    return;
  }
  if (isVisible$1(timerProgressBar)) {
    if (reset) {
      timerProgressBar.style.transition = 'none';
      timerProgressBar.style.width = '100%';
    }
    setTimeout(() => {
      timerProgressBar.style.transition = `width ${timer / 1000}s linear`;
      timerProgressBar.style.width = '0%';
    }, 10);
  }
};
const stopTimerProgressBar = () => {
  const timerProgressBar = getTimerProgressBar();
  if (!timerProgressBar) {
    return;
  }
  const timerProgressBarWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
  timerProgressBar.style.removeProperty('transition');
  timerProgressBar.style.width = '100%';
  const timerProgressBarFullWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
  const timerProgressBarPercent = timerProgressBarWidth / timerProgressBarFullWidth * 100;
  timerProgressBar.style.width = `${timerProgressBarPercent}%`;
};

/**
 * Detect Node env
 *
 * @returns {boolean}
 */
const isNodeEnv = () => typeof window === 'undefined' || typeof document === 'undefined';

const sweetHTML = `
 <div aria-labelledby="${swalClasses.title}" aria-describedby="${swalClasses['html-container']}" class="${swalClasses.popup}" tabindex="-1">
   <button type="button" class="${swalClasses.close}"></button>
   <ul class="${swalClasses['progress-steps']}"></ul>
   <div class="${swalClasses.icon}"></div>
   <img class="${swalClasses.image}" />
   <h2 class="${swalClasses.title}" id="${swalClasses.title}"></h2>
   <div class="${swalClasses['html-container']}" id="${swalClasses['html-container']}"></div>
   <input class="${swalClasses.input}" id="${swalClasses.input}" />
   <input type="file" class="${swalClasses.file}" />
   <div class="${swalClasses.range}">
     <input type="range" />
     <output></output>
   </div>
   <select class="${swalClasses.select}" id="${swalClasses.select}"></select>
   <div class="${swalClasses.radio}"></div>
   <label class="${swalClasses.checkbox}">
     <input type="checkbox" id="${swalClasses.checkbox}" />
     <span class="${swalClasses.label}"></span>
   </label>
   <textarea class="${swalClasses.textarea}" id="${swalClasses.textarea}"></textarea>
   <div class="${swalClasses['validation-message']}" id="${swalClasses['validation-message']}"></div>
   <div class="${swalClasses.actions}">
     <div class="${swalClasses.loader}"></div>
     <button type="button" class="${swalClasses.confirm}"></button>
     <button type="button" class="${swalClasses.deny}"></button>
     <button type="button" class="${swalClasses.cancel}"></button>
   </div>
   <div class="${swalClasses.footer}"></div>
   <div class="${swalClasses['timer-progress-bar-container']}">
     <div class="${swalClasses['timer-progress-bar']}"></div>
   </div>
 </div>
`.replace(/(^|\n)\s*/g, '');

/**
 * @returns {boolean}
 */
const resetOldContainer = () => {
  const oldContainer = getContainer();
  if (!oldContainer) {
    return false;
  }
  oldContainer.remove();
  removeClass([document.documentElement, document.body], [swalClasses['no-backdrop'], swalClasses['toast-shown'], swalClasses['has-column']]);
  return true;
};
const resetValidationMessage$1 = () => {
  globalState.currentInstance.resetValidationMessage();
};
const addInputChangeListeners = () => {
  const popup = getPopup();
  const input = getDirectChildByClass(popup, swalClasses.input);
  const file = getDirectChildByClass(popup, swalClasses.file);
  /** @type {HTMLInputElement} */
  const range = popup.querySelector(`.${swalClasses.range} input`);
  /** @type {HTMLOutputElement} */
  const rangeOutput = popup.querySelector(`.${swalClasses.range} output`);
  const select = getDirectChildByClass(popup, swalClasses.select);
  /** @type {HTMLInputElement} */
  const checkbox = popup.querySelector(`.${swalClasses.checkbox} input`);
  const textarea = getDirectChildByClass(popup, swalClasses.textarea);
  input.oninput = resetValidationMessage$1;
  file.onchange = resetValidationMessage$1;
  select.onchange = resetValidationMessage$1;
  checkbox.onchange = resetValidationMessage$1;
  textarea.oninput = resetValidationMessage$1;
  range.oninput = () => {
    resetValidationMessage$1();
    rangeOutput.value = range.value;
  };
  range.onchange = () => {
    resetValidationMessage$1();
    rangeOutput.value = range.value;
  };
};

/**
 * @param {string | HTMLElement} target
 * @returns {HTMLElement}
 */
const getTarget = target => typeof target === 'string' ? document.querySelector(target) : target;

/**
 * @param {SweetAlertOptions} params
 */
const setupAccessibility = params => {
  const popup = getPopup();
  popup.setAttribute('role', params.toast ? 'alert' : 'dialog');
  popup.setAttribute('aria-live', params.toast ? 'polite' : 'assertive');
  if (!params.toast) {
    popup.setAttribute('aria-modal', 'true');
  }
};

/**
 * @param {HTMLElement} targetElement
 */
const setupRTL = targetElement => {
  if (window.getComputedStyle(targetElement).direction === 'rtl') {
    addClass(getContainer(), swalClasses.rtl);
  }
};

/**
 * Add modal + backdrop + no-war message for Russians to DOM
 *
 * @param {SweetAlertOptions} params
 */
const init = params => {
  // Clean up the old popup container if it exists
  const oldContainerExisted = resetOldContainer();
  if (isNodeEnv()) {
    error('SweetAlert2 requires document to initialize');
    return;
  }
  const container = document.createElement('div');
  container.className = swalClasses.container;
  if (oldContainerExisted) {
    addClass(container, swalClasses['no-transition']);
  }
  setInnerHtml(container, sweetHTML);
  container.dataset['swal2Theme'] = params.theme;
  const targetElement = getTarget(params.target);
  targetElement.appendChild(container);
  if (params.topLayer) {
    container.setAttribute('popover', '');
    container.showPopover();
  }
  setupAccessibility(params);
  setupRTL(targetElement);
  addInputChangeListeners();
};

/**
 * @param {HTMLElement | object | string} param
 * @param {HTMLElement} target
 */
const parseHtmlToContainer = (param, target) => {
  // DOM element
  if (param instanceof HTMLElement) {
    target.appendChild(param);
  }

  // Object
  else if (typeof param === 'object') {
    handleObject(param, target);
  }

  // Plain string
  else if (param) {
    setInnerHtml(target, param);
  }
};

/**
 * @param {any} param
 * @param {HTMLElement} target
 */
const handleObject = (param, target) => {
  // JQuery element(s)
  if (param.jquery) {
    handleJqueryElem(target, param);
  }

  // For other objects use their string representation
  else {
    setInnerHtml(target, param.toString());
  }
};

/**
 * @param {HTMLElement} target
 * @param {any} elem
 */
const handleJqueryElem = (target, elem) => {
  target.textContent = '';
  if (0 in elem) {
    for (let i = 0; i in elem; i++) {
      target.appendChild(elem[i].cloneNode(true));
    }
  } else {
    target.appendChild(elem.cloneNode(true));
  }
};

/**
 * @param {SweetAlert} instance
 * @param {SweetAlertOptions} params
 */
const renderActions = (instance, params) => {
  const actions = getActions();
  const loader = getLoader();
  if (!actions || !loader) {
    return;
  }

  // Actions (buttons) wrapper
  if (!params.showConfirmButton && !params.showDenyButton && !params.showCancelButton) {
    hide$2(actions);
  } else {
    show(actions);
  }

  // Custom class
  applyCustomClass(actions, params, 'actions');

  // Render all the buttons
  renderButtons(actions, loader, params);

  // Loader
  setInnerHtml(loader, params.loaderHtml || '');
  applyCustomClass(loader, params, 'loader');
};

/**
 * @param {HTMLElement} actions
 * @param {HTMLElement} loader
 * @param {SweetAlertOptions} params
 */
function renderButtons(actions, loader, params) {
  const confirmButton = getConfirmButton();
  const denyButton = getDenyButton();
  const cancelButton = getCancelButton();
  if (!confirmButton || !denyButton || !cancelButton) {
    return;
  }

  // Render buttons
  renderButton(confirmButton, 'confirm', params);
  renderButton(denyButton, 'deny', params);
  renderButton(cancelButton, 'cancel', params);
  handleButtonsStyling(confirmButton, denyButton, cancelButton, params);
  if (params.reverseButtons) {
    if (params.toast) {
      actions.insertBefore(cancelButton, confirmButton);
      actions.insertBefore(denyButton, confirmButton);
    } else {
      actions.insertBefore(cancelButton, loader);
      actions.insertBefore(denyButton, loader);
      actions.insertBefore(confirmButton, loader);
    }
  }
}

/**
 * @param {HTMLElement} confirmButton
 * @param {HTMLElement} denyButton
 * @param {HTMLElement} cancelButton
 * @param {SweetAlertOptions} params
 */
function handleButtonsStyling(confirmButton, denyButton, cancelButton, params) {
  if (!params.buttonsStyling) {
    removeClass([confirmButton, denyButton, cancelButton], swalClasses.styled);
    return;
  }
  addClass([confirmButton, denyButton, cancelButton], swalClasses.styled);

  // Apply custom background colors to action buttons
  if (params.confirmButtonColor) {
    confirmButton.style.setProperty('--swal2-confirm-button-background-color', params.confirmButtonColor);
  }
  if (params.denyButtonColor) {
    denyButton.style.setProperty('--swal2-deny-button-background-color', params.denyButtonColor);
  }
  if (params.cancelButtonColor) {
    cancelButton.style.setProperty('--swal2-cancel-button-background-color', params.cancelButtonColor);
  }

  // Apply the outline color to action buttons
  applyOutlineColor(confirmButton);
  applyOutlineColor(denyButton);
  applyOutlineColor(cancelButton);
}

/**
 * @param {HTMLElement} button
 */
function applyOutlineColor(button) {
  const buttonStyle = window.getComputedStyle(button);
  const outlineColor = buttonStyle.backgroundColor.replace(/rgba?\((\d+), (\d+), (\d+).*/, 'rgba($1, $2, $3, 0.5)');
  button.style.setProperty('--swal2-action-button-outline', buttonStyle.getPropertyValue('--swal2-outline').replace(/ rgba\(.*/, ` ${outlineColor}`));
}

/**
 * @param {HTMLElement} button
 * @param {'confirm' | 'deny' | 'cancel'} buttonType
 * @param {SweetAlertOptions} params
 */
function renderButton(button, buttonType, params) {
  const buttonName = /** @type {'Confirm' | 'Deny' | 'Cancel'} */capitalizeFirstLetter(buttonType);
  toggle(button, params[`show${buttonName}Button`], 'inline-block');
  setInnerHtml(button, params[`${buttonType}ButtonText`] || ''); // Set caption text
  button.setAttribute('aria-label', params[`${buttonType}ButtonAriaLabel`] || ''); // ARIA label

  // Add buttons custom classes
  button.className = swalClasses[buttonType];
  applyCustomClass(button, params, `${buttonType}Button`);
}

/**
 * @param {SweetAlert} instance
 * @param {SweetAlertOptions} params
 */
const renderCloseButton = (instance, params) => {
  const closeButton = getCloseButton();
  if (!closeButton) {
    return;
  }
  setInnerHtml(closeButton, params.closeButtonHtml || '');

  // Custom class
  applyCustomClass(closeButton, params, 'closeButton');
  toggle(closeButton, params.showCloseButton);
  closeButton.setAttribute('aria-label', params.closeButtonAriaLabel || '');
};

/**
 * @param {SweetAlert} instance
 * @param {SweetAlertOptions} params
 */
const renderContainer = (instance, params) => {
  const container = getContainer();
  if (!container) {
    return;
  }
  handleBackdropParam(container, params.backdrop);
  handlePositionParam(container, params.position);
  handleGrowParam(container, params.grow);

  // Custom class
  applyCustomClass(container, params, 'container');
};

/**
 * @param {HTMLElement} container
 * @param {SweetAlertOptions['backdrop']} backdrop
 */
function handleBackdropParam(container, backdrop) {
  if (typeof backdrop === 'string') {
    container.style.background = backdrop;
  } else if (!backdrop) {
    addClass([document.documentElement, document.body], swalClasses['no-backdrop']);
  }
}

/**
 * @param {HTMLElement} container
 * @param {SweetAlertOptions['position']} position
 */
function handlePositionParam(container, position) {
  if (!position) {
    return;
  }
  if (position in swalClasses) {
    addClass(container, swalClasses[position]);
  } else {
    warn('The "position" parameter is not valid, defaulting to "center"');
    addClass(container, swalClasses.center);
  }
}

/**
 * @param {HTMLElement} container
 * @param {SweetAlertOptions['grow']} grow
 */
function handleGrowParam(container, grow) {
  if (!grow) {
    return;
  }
  addClass(container, swalClasses[`grow-${grow}`]);
}

/**
 * This module contains `WeakMap`s for each effectively-"private  property" that a `Swal` has.
 * For example, to set the private property "foo" of `this` to "bar", you can `privateProps.foo.set(this, 'bar')`
 * This is the approach that Babel will probably take to implement private methods/fields
 *   https://github.com/tc39/proposal-private-methods
 *   https://github.com/babel/babel/pull/7555
 * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*
 *   then we can use that language feature.
 */

var privateProps = {
  innerParams: new WeakMap(),
  domCache: new WeakMap()
};

/// <reference path="../../../../sweetalert2.d.ts"/>


/** @type {InputClass[]} */
const inputClasses = ['input', 'file', 'range', 'select', 'radio', 'checkbox', 'textarea'];

/**
 * @param {SweetAlert} instance
 * @param {SweetAlertOptions} params
 */
const renderInput = (instance, params) => {
  const popup = getPopup();
  if (!popup) {
    return;
  }
  const innerParams = privateProps.innerParams.get(instance);
  const rerender = !innerParams || params.input !== innerParams.input;
  inputClasses.forEach(inputClass => {
    const inputContainer = getDirectChildByClass(popup, swalClasses[inputClass]);
    if (!inputContainer) {
      return;
    }

    // set attributes
    setAttributes(inputClass, params.inputAttributes);

    // set class
    inputContainer.className = swalClasses[inputClass];
    if (rerender) {
      hide$2(inputContainer);
    }
  });
  if (params.input) {
    if (rerender) {
      showInput(params);
    }
    // set custom class
    setCustomClass(params);
  }
};

/**
 * @param {SweetAlertOptions} params
 */
const showInput = params => {
  if (!params.input) {
    return;
  }
  if (!renderInputType[params.input]) {
    error(`Unexpected type of input! Expected ${Object.keys(renderInputType).join(' | ')}, got "${params.input}"`);
    return;
  }
  const inputContainer = getInputContainer(params.input);
  if (!inputContainer) {
    return;
  }
  const input = renderInputType[params.input](inputContainer, params);
  show(inputContainer);

  // input autofocus
  if (params.inputAutoFocus) {
    setTimeout(() => {
      focusInput(input);
    });
  }
};

/**
 * @param {HTMLInputElement} input
 */
const removeAttributes = input => {
  for (let i = 0; i < input.attributes.length; i++) {
    const attrName = input.attributes[i].name;
    if (!['id', 'type', 'value', 'style'].includes(attrName)) {
      input.removeAttribute(attrName);
    }
  }
};

/**
 * @param {InputClass} inputClass
 * @param {SweetAlertOptions['inputAttributes']} inputAttributes
 */
const setAttributes = (inputClass, inputAttributes) => {
  const popup = getPopup();
  if (!popup) {
    return;
  }
  const input = getInput$1(popup, inputClass);
  if (!input) {
    return;
  }
  removeAttributes(input);
  for (const attr in inputAttributes) {
    input.setAttribute(attr, inputAttributes[attr]);
  }
};

/**
 * @param {SweetAlertOptions} params
 */
const setCustomClass = params => {
  if (!params.input) {
    return;
  }
  const inputContainer = getInputContainer(params.input);
  if (inputContainer) {
    applyCustomClass(inputContainer, params, 'input');
  }
};

/**
 * @param {HTMLInputElement | HTMLTextAreaElement} input
 * @param {SweetAlertOptions} params
 */
const setInputPlaceholder = (input, params) => {
  if (!input.placeholder && params.inputPlaceholder) {
    input.placeholder = params.inputPlaceholder;
  }
};

/**
 * @param {Input} input
 * @param {Input} prependTo
 * @param {SweetAlertOptions} params
 */
const setInputLabel = (input, prependTo, params) => {
  if (params.inputLabel) {
    const label = document.createElement('label');
    const labelClass = swalClasses['input-label'];
    label.setAttribute('for', input.id);
    label.className = labelClass;
    if (typeof params.customClass === 'object') {
      addClass(label, params.customClass.inputLabel);
    }
    label.innerText = params.inputLabel;
    prependTo.insertAdjacentElement('beforebegin', label);
  }
};

/**
 * @param {SweetAlertInput} inputType
 * @returns {HTMLElement | undefined}
 */
const getInputContainer = inputType => {
  const popup = getPopup();
  if (!popup) {
    return;
  }
  return getDirectChildByClass(popup, swalClasses[(/** @type {SwalClass} */inputType)] || swalClasses.input);
};

/**
 * @param {HTMLInputElement | HTMLOutputElement | HTMLTextAreaElement} input
 * @param {SweetAlertOptions['inputValue']} inputValue
 */
const checkAndSetInputValue = (input, inputValue) => {
  if (['string', 'number'].includes(typeof inputValue)) {
    input.value = `${inputValue}`;
  } else if (!isPromise$1(inputValue)) {
    warn(`Unexpected type of inputValue! Expected "string", "number" or "Promise", got "${typeof inputValue}"`);
  }
};

/** @type {Record<SweetAlertInput, (input: Input | HTMLElement, params: SweetAlertOptions) => Input>} */
const renderInputType = {};

/**
 * @param {HTMLInputElement} input
 * @param {SweetAlertOptions} params
 * @returns {HTMLInputElement}
 */
renderInputType.text = renderInputType.email = renderInputType.password = renderInputType.number = renderInputType.tel = renderInputType.url = renderInputType.search = renderInputType.date = renderInputType['datetime-local'] = renderInputType.time = renderInputType.week = renderInputType.month = /** @type {(input: Input | HTMLElement, params: SweetAlertOptions) => Input} */
(input, params) => {
  checkAndSetInputValue(input, params.inputValue);
  setInputLabel(input, input, params);
  setInputPlaceholder(input, params);
  input.type = params.input;
  return input;
};

/**
 * @param {HTMLInputElement} input
 * @param {SweetAlertOptions} params
 * @returns {HTMLInputElement}
 */
renderInputType.file = (input, params) => {
  setInputLabel(input, input, params);
  setInputPlaceholder(input, params);
  return input;
};

/**
 * @param {HTMLInputElement} range
 * @param {SweetAlertOptions} params
 * @returns {HTMLInputElement}
 */
renderInputType.range = (range, params) => {
  const rangeInput = range.querySelector('input');
  const rangeOutput = range.querySelector('output');
  checkAndSetInputValue(rangeInput, params.inputValue);
  rangeInput.type = params.input;
  checkAndSetInputValue(rangeOutput, params.inputValue);
  setInputLabel(rangeInput, range, params);
  return range;
};

/**
 * @param {HTMLSelectElement} select
 * @param {SweetAlertOptions} params
 * @returns {HTMLSelectElement}
 */
renderInputType.select = (select, params) => {
  select.textContent = '';
  if (params.inputPlaceholder) {
    const placeholder = document.createElement('option');
    setInnerHtml(placeholder, params.inputPlaceholder);
    placeholder.value = '';
    placeholder.disabled = true;
    placeholder.selected = true;
    select.appendChild(placeholder);
  }
  setInputLabel(select, select, params);
  return select;
};

/**
 * @param {HTMLInputElement} radio
 * @returns {HTMLInputElement}
 */
renderInputType.radio = radio => {
  radio.textContent = '';
  return radio;
};

/**
 * @param {HTMLLabelElement} checkboxContainer
 * @param {SweetAlertOptions} params
 * @returns {HTMLInputElement}
 */
renderInputType.checkbox = (checkboxContainer, params) => {
  const checkbox = getInput$1(getPopup(), 'checkbox');
  checkbox.value = '1';
  checkbox.checked = Boolean(params.inputValue);
  const label = checkboxContainer.querySelector('span');
  setInnerHtml(label, params.inputPlaceholder || params.inputLabel);
  return checkbox;
};

/**
 * @param {HTMLTextAreaElement} textarea
 * @param {SweetAlertOptions} params
 * @returns {HTMLTextAreaElement}
 */
renderInputType.textarea = (textarea, params) => {
  checkAndSetInputValue(textarea, params.inputValue);
  setInputPlaceholder(textarea, params);
  setInputLabel(textarea, textarea, params);

  /**
   * @param {HTMLElement} el
   * @returns {number}
   */
  const getMargin = el => parseInt(window.getComputedStyle(el).marginLeft) + parseInt(window.getComputedStyle(el).marginRight);

  // https://github.com/sweetalert2/sweetalert2/issues/2291
  setTimeout(() => {
    // https://github.com/sweetalert2/sweetalert2/issues/1699
    if ('MutationObserver' in window) {
      const initialPopupWidth = parseInt(window.getComputedStyle(getPopup()).width);
      const textareaResizeHandler = () => {
        // check if texarea is still in document (i.e. popup wasn't closed in the meantime)
        if (!document.body.contains(textarea)) {
          return;
        }
        const textareaWidth = textarea.offsetWidth + getMargin(textarea);
        if (textareaWidth > initialPopupWidth) {
          getPopup().style.width = `${textareaWidth}px`;
        } else {
          applyNumericalStyle(getPopup(), 'width', params.width);
        }
      };
      new MutationObserver(textareaResizeHandler).observe(textarea, {
        attributes: true,
        attributeFilter: ['style']
      });
    }
  });
  return textarea;
};

/**
 * @param {SweetAlert} instance
 * @param {SweetAlertOptions} params
 */
const renderContent = (instance, params) => {
  const htmlContainer = getHtmlContainer();
  if (!htmlContainer) {
    return;
  }
  showWhenInnerHtmlPresent(htmlContainer);
  applyCustomClass(htmlContainer, params, 'htmlContainer');

  // Content as HTML
  if (params.html) {
    parseHtmlToContainer(params.html, htmlContainer);
    show(htmlContainer, 'block');
  }

  // Content as plain text
  else if (params.text) {
    htmlContainer.textContent = params.text;
    show(htmlContainer, 'block');
  }

  // No content
  else {
    hide$2(htmlContainer);
  }
  renderInput(instance, params);
};

/**
 * @param {SweetAlert} instance
 * @param {SweetAlertOptions} params
 */
const renderFooter = (instance, params) => {
  const footer = getFooter();
  if (!footer) {
    return;
  }
  showWhenInnerHtmlPresent(footer);
  toggle(footer, params.footer, 'block');
  if (params.footer) {
    parseHtmlToContainer(params.footer, footer);
  }

  // Custom class
  applyCustomClass(footer, params, 'footer');
};

/**
 * @param {SweetAlert} instance
 * @param {SweetAlertOptions} params
 */
const renderIcon = (instance, params) => {
  const innerParams = privateProps.innerParams.get(instance);
  const icon = getIcon();
  if (!icon) {
    return;
  }

  // if the given icon already rendered, apply the styling without re-rendering the icon
  if (innerParams && params.icon === innerParams.icon) {
    // Custom or default content
    setContent(icon, params);
    applyStyles$2(icon, params);
    return;
  }
  if (!params.icon && !params.iconHtml) {
    hide$2(icon);
    return;
  }
  if (params.icon && Object.keys(iconTypes).indexOf(params.icon) === -1) {
    error(`Unknown icon! Expected "success", "error", "warning", "info" or "question", got "${params.icon}"`);
    hide$2(icon);
    return;
  }
  show(icon);

  // Custom or default content
  setContent(icon, params);
  applyStyles$2(icon, params);

  // Animate icon
  addClass(icon, params.showClass && params.showClass.icon);

  // Re-adjust the success icon on system theme change
  const colorSchemeQueryList = window.matchMedia('(prefers-color-scheme: dark)');
  colorSchemeQueryList.addEventListener('change', adjustSuccessIconBackgroundColor);
};

/**
 * @param {HTMLElement} icon
 * @param {SweetAlertOptions} params
 */
const applyStyles$2 = (icon, params) => {
  for (const [iconType, iconClassName] of Object.entries(iconTypes)) {
    if (params.icon !== iconType) {
      removeClass(icon, iconClassName);
    }
  }
  addClass(icon, params.icon && iconTypes[params.icon]);

  // Icon color
  setColor(icon, params);

  // Success icon background color
  adjustSuccessIconBackgroundColor();

  // Custom class
  applyCustomClass(icon, params, 'icon');
};

// Adjust success icon background color to match the popup background color
const adjustSuccessIconBackgroundColor = () => {
  const popup = getPopup();
  if (!popup) {
    return;
  }
  const popupBackgroundColor = window.getComputedStyle(popup).getPropertyValue('background-color');
  /** @type {NodeListOf<HTMLElement>} */
  const successIconParts = popup.querySelectorAll('[class^=swal2-success-circular-line], .swal2-success-fix');
  for (let i = 0; i < successIconParts.length; i++) {
    successIconParts[i].style.backgroundColor = popupBackgroundColor;
  }
};
const successIconHtml = `
  <div class="swal2-success-circular-line-left"></div>
  <span class="swal2-success-line-tip"></span> <span class="swal2-success-line-long"></span>
  <div class="swal2-success-ring"></div> <div class="swal2-success-fix"></div>
  <div class="swal2-success-circular-line-right"></div>
`;
const errorIconHtml = `
  <span class="swal2-x-mark">
    <span class="swal2-x-mark-line-left"></span>
    <span class="swal2-x-mark-line-right"></span>
  </span>
`;

/**
 * @param {HTMLElement} icon
 * @param {SweetAlertOptions} params
 */
const setContent = (icon, params) => {
  if (!params.icon && !params.iconHtml) {
    return;
  }
  let oldContent = icon.innerHTML;
  let newContent = '';
  if (params.iconHtml) {
    newContent = iconContent(params.iconHtml);
  } else if (params.icon === 'success') {
    newContent = successIconHtml;
    oldContent = oldContent.replace(/ style=".*?"/g, ''); // undo adjustSuccessIconBackgroundColor()
  } else if (params.icon === 'error') {
    newContent = errorIconHtml;
  } else if (params.icon) {
    const defaultIconHtml = {
      question: '?',
      warning: '!',
      info: 'i'
    };
    newContent = iconContent(defaultIconHtml[params.icon]);
  }
  if (oldContent.trim() !== newContent.trim()) {
    setInnerHtml(icon, newContent);
  }
};

/**
 * @param {HTMLElement} icon
 * @param {SweetAlertOptions} params
 */
const setColor = (icon, params) => {
  if (!params.iconColor) {
    return;
  }
  icon.style.color = params.iconColor;
  icon.style.borderColor = params.iconColor;
  for (const sel of ['.swal2-success-line-tip', '.swal2-success-line-long', '.swal2-x-mark-line-left', '.swal2-x-mark-line-right']) {
    setStyle(icon, sel, 'background-color', params.iconColor);
  }
  setStyle(icon, '.swal2-success-ring', 'border-color', params.iconColor);
};

/**
 * @param {string} content
 * @returns {string}
 */
const iconContent = content => `<div class="${swalClasses['icon-content']}">${content}</div>`;

/**
 * @param {SweetAlert} instance
 * @param {SweetAlertOptions} params
 */
const renderImage = (instance, params) => {
  const image = getImage();
  if (!image) {
    return;
  }
  if (!params.imageUrl) {
    hide$2(image);
    return;
  }
  show(image, '');

  // Src, alt
  image.setAttribute('src', params.imageUrl);
  image.setAttribute('alt', params.imageAlt || '');

  // Width, height
  applyNumericalStyle(image, 'width', params.imageWidth);
  applyNumericalStyle(image, 'height', params.imageHeight);

  // Class
  image.className = swalClasses.image;
  applyCustomClass(image, params, 'image');
};

let dragging = false;
let mousedownX = 0;
let mousedownY = 0;
let initialX = 0;
let initialY = 0;

/**
 * @param {HTMLElement} popup
 */
const addDraggableListeners = popup => {
  popup.addEventListener('mousedown', down);
  document.body.addEventListener('mousemove', move);
  popup.addEventListener('mouseup', up$1);
  popup.addEventListener('touchstart', down);
  document.body.addEventListener('touchmove', move);
  popup.addEventListener('touchend', up$1);
};

/**
 * @param {HTMLElement} popup
 */
const removeDraggableListeners = popup => {
  popup.removeEventListener('mousedown', down);
  document.body.removeEventListener('mousemove', move);
  popup.removeEventListener('mouseup', up$1);
  popup.removeEventListener('touchstart', down);
  document.body.removeEventListener('touchmove', move);
  popup.removeEventListener('touchend', up$1);
};

/**
 * @param {MouseEvent | TouchEvent} event
 */
const down = event => {
  const popup = getPopup();
  if (event.target === popup || getIcon().contains(/** @type {HTMLElement} */event.target)) {
    dragging = true;
    const clientXY = getClientXY(event);
    mousedownX = clientXY.clientX;
    mousedownY = clientXY.clientY;
    initialX = parseInt(popup.style.insetInlineStart) || 0;
    initialY = parseInt(popup.style.insetBlockStart) || 0;
    addClass(popup, 'swal2-dragging');
  }
};

/**
 * @param {MouseEvent | TouchEvent} event
 */
const move = event => {
  const popup = getPopup();
  if (dragging) {
    let {
      clientX,
      clientY
    } = getClientXY(event);
    popup.style.insetInlineStart = `${initialX + (clientX - mousedownX)}px`;
    popup.style.insetBlockStart = `${initialY + (clientY - mousedownY)}px`;
  }
};
const up$1 = () => {
  const popup = getPopup();
  dragging = false;
  removeClass(popup, 'swal2-dragging');
};

/**
 * @param {MouseEvent | TouchEvent} event
 * @returns {{ clientX: number, clientY: number }}
 */
const getClientXY = event => {
  let clientX = 0,
    clientY = 0;
  if (event.type.startsWith('mouse')) {
    clientX = /** @type {MouseEvent} */event.clientX;
    clientY = /** @type {MouseEvent} */event.clientY;
  } else if (event.type.startsWith('touch')) {
    clientX = /** @type {TouchEvent} */event.touches[0].clientX;
    clientY = /** @type {TouchEvent} */event.touches[0].clientY;
  }
  return {
    clientX,
    clientY
  };
};

/**
 * @param {SweetAlert} instance
 * @param {SweetAlertOptions} params
 */
const renderPopup = (instance, params) => {
  const container = getContainer();
  const popup = getPopup();
  if (!container || !popup) {
    return;
  }

  // Width
  // https://github.com/sweetalert2/sweetalert2/issues/2170
  if (params.toast) {
    applyNumericalStyle(container, 'width', params.width);
    popup.style.width = '100%';
    const loader = getLoader();
    if (loader) {
      popup.insertBefore(loader, getIcon());
    }
  } else {
    applyNumericalStyle(popup, 'width', params.width);
  }

  // Padding
  applyNumericalStyle(popup, 'padding', params.padding);

  // Color
  if (params.color) {
    popup.style.color = params.color;
  }

  // Background
  if (params.background) {
    popup.style.background = params.background;
  }
  hide$2(getValidationMessage());

  // Classes
  addClasses$1(popup, params);
  if (params.draggable && !params.toast) {
    addClass(popup, swalClasses.draggable);
    addDraggableListeners(popup);
  } else {
    removeClass(popup, swalClasses.draggable);
    removeDraggableListeners(popup);
  }
};

/**
 * @param {HTMLElement} popup
 * @param {SweetAlertOptions} params
 */
const addClasses$1 = (popup, params) => {
  const showClass = params.showClass || {};
  // Default Class + showClass when updating Swal.update({})
  popup.className = `${swalClasses.popup} ${isVisible$1(popup) ? showClass.popup : ''}`;
  if (params.toast) {
    addClass([document.documentElement, document.body], swalClasses['toast-shown']);
    addClass(popup, swalClasses.toast);
  } else {
    addClass(popup, swalClasses.modal);
  }

  // Custom class
  applyCustomClass(popup, params, 'popup');
  // TODO: remove in the next major
  if (typeof params.customClass === 'string') {
    addClass(popup, params.customClass);
  }

  // Icon class (#1842)
  if (params.icon) {
    addClass(popup, swalClasses[`icon-${params.icon}`]);
  }
};

/**
 * @param {SweetAlert} instance
 * @param {SweetAlertOptions} params
 */
const renderProgressSteps = (instance, params) => {
  const progressStepsContainer = getProgressSteps();
  if (!progressStepsContainer) {
    return;
  }
  const {
    progressSteps,
    currentProgressStep
  } = params;
  if (!progressSteps || progressSteps.length === 0 || currentProgressStep === undefined) {
    hide$2(progressStepsContainer);
    return;
  }
  show(progressStepsContainer);
  progressStepsContainer.textContent = '';
  if (currentProgressStep >= progressSteps.length) {
    warn('Invalid currentProgressStep parameter, it should be less than progressSteps.length ' + '(currentProgressStep like JS arrays starts from 0)');
  }
  progressSteps.forEach((step, index) => {
    const stepEl = createStepElement(step);
    progressStepsContainer.appendChild(stepEl);
    if (index === currentProgressStep) {
      addClass(stepEl, swalClasses['active-progress-step']);
    }
    if (index !== progressSteps.length - 1) {
      const lineEl = createLineElement(params);
      progressStepsContainer.appendChild(lineEl);
    }
  });
};

/**
 * @param {string} step
 * @returns {HTMLLIElement}
 */
const createStepElement = step => {
  const stepEl = document.createElement('li');
  addClass(stepEl, swalClasses['progress-step']);
  setInnerHtml(stepEl, step);
  return stepEl;
};

/**
 * @param {SweetAlertOptions} params
 * @returns {HTMLLIElement}
 */
const createLineElement = params => {
  const lineEl = document.createElement('li');
  addClass(lineEl, swalClasses['progress-step-line']);
  if (params.progressStepsDistance) {
    applyNumericalStyle(lineEl, 'width', params.progressStepsDistance);
  }
  return lineEl;
};

/**
 * @param {SweetAlert} instance
 * @param {SweetAlertOptions} params
 */
const renderTitle = (instance, params) => {
  const title = getTitle();
  if (!title) {
    return;
  }
  showWhenInnerHtmlPresent(title);
  toggle(title, params.title || params.titleText, 'block');
  if (params.title) {
    parseHtmlToContainer(params.title, title);
  }
  if (params.titleText) {
    title.innerText = params.titleText;
  }

  // Custom class
  applyCustomClass(title, params, 'title');
};

/**
 * @param {SweetAlert} instance
 * @param {SweetAlertOptions} params
 */
const render = (instance, params) => {
  renderPopup(instance, params);
  renderContainer(instance, params);
  renderProgressSteps(instance, params);
  renderIcon(instance, params);
  renderImage(instance, params);
  renderTitle(instance, params);
  renderCloseButton(instance, params);
  renderContent(instance, params);
  renderActions(instance, params);
  renderFooter(instance, params);
  const popup = getPopup();
  if (typeof params.didRender === 'function' && popup) {
    params.didRender(popup);
  }
  globalState.eventEmitter.emit('didRender', popup);
};

/*
 * Global function to determine if SweetAlert2 popup is shown
 */
const isVisible = () => {
  return isVisible$1(getPopup());
};

/*
 * Global function to click 'Confirm' button
 */
const clickConfirm = () => {
  var _dom$getConfirmButton;
  return (_dom$getConfirmButton = getConfirmButton()) === null || _dom$getConfirmButton === void 0 ? void 0 : _dom$getConfirmButton.click();
};

/*
 * Global function to click 'Deny' button
 */
const clickDeny = () => {
  var _dom$getDenyButton;
  return (_dom$getDenyButton = getDenyButton()) === null || _dom$getDenyButton === void 0 ? void 0 : _dom$getDenyButton.click();
};

/*
 * Global function to click 'Cancel' button
 */
const clickCancel = () => {
  var _dom$getCancelButton;
  return (_dom$getCancelButton = getCancelButton()) === null || _dom$getCancelButton === void 0 ? void 0 : _dom$getCancelButton.click();
};

/** @typedef {'cancel' | 'backdrop' | 'close' | 'esc' | 'timer'} DismissReason */

/** @type {Record<DismissReason, DismissReason>} */
const DismissReason = Object.freeze({
  cancel: 'cancel',
  backdrop: 'backdrop',
  close: 'close',
  esc: 'esc',
  timer: 'timer'
});

/**
 * @param {GlobalState} globalState
 */
const removeKeydownHandler = globalState => {
  if (globalState.keydownTarget && globalState.keydownHandlerAdded) {
    globalState.keydownTarget.removeEventListener('keydown', globalState.keydownHandler, {
      capture: globalState.keydownListenerCapture
    });
    globalState.keydownHandlerAdded = false;
  }
};

/**
 * @param {GlobalState} globalState
 * @param {SweetAlertOptions} innerParams
 * @param {*} dismissWith
 */
const addKeydownHandler = (globalState, innerParams, dismissWith) => {
  removeKeydownHandler(globalState);
  if (!innerParams.toast) {
    globalState.keydownHandler = e => keydownHandler(innerParams, e, dismissWith);
    globalState.keydownTarget = innerParams.keydownListenerCapture ? window : getPopup();
    globalState.keydownListenerCapture = innerParams.keydownListenerCapture;
    globalState.keydownTarget.addEventListener('keydown', globalState.keydownHandler, {
      capture: globalState.keydownListenerCapture
    });
    globalState.keydownHandlerAdded = true;
  }
};

/**
 * @param {number} index
 * @param {number} increment
 */
const setFocus = (index, increment) => {
  var _dom$getPopup;
  const focusableElements = getFocusableElements();
  // search for visible elements and select the next possible match
  if (focusableElements.length) {
    index = index + increment;

    // shift + tab when .swal2-popup is focused
    if (index === -2) {
      index = focusableElements.length - 1;
    }

    // rollover to first item
    if (index === focusableElements.length) {
      index = 0;

      // go to last item
    } else if (index === -1) {
      index = focusableElements.length - 1;
    }
    focusableElements[index].focus();
    return;
  }
  // no visible focusable elements, focus the popup
  (_dom$getPopup = getPopup()) === null || _dom$getPopup === void 0 || _dom$getPopup.focus();
};
const arrowKeysNextButton = ['ArrowRight', 'ArrowDown'];
const arrowKeysPreviousButton = ['ArrowLeft', 'ArrowUp'];

/**
 * @param {SweetAlertOptions} innerParams
 * @param {KeyboardEvent} event
 * @param {Function} dismissWith
 */
const keydownHandler = (innerParams, event, dismissWith) => {
  if (!innerParams) {
    return; // This instance has already been destroyed
  }

  // Ignore keydown during IME composition
  // https://developer.mozilla.org/en-US/docs/Web/API/Document/keydown_event#ignoring_keydown_during_ime_composition
  // https://github.com/sweetalert2/sweetalert2/issues/720
  // https://github.com/sweetalert2/sweetalert2/issues/2406
  if (event.isComposing || event.keyCode === 229) {
    return;
  }
  if (innerParams.stopKeydownPropagation) {
    event.stopPropagation();
  }

  // ENTER
  if (event.key === 'Enter') {
    handleEnter(event, innerParams);
  }

  // TAB
  else if (event.key === 'Tab') {
    handleTab(event);
  }

  // ARROWS - switch focus between buttons
  else if ([...arrowKeysNextButton, ...arrowKeysPreviousButton].includes(event.key)) {
    handleArrows(event.key);
  }

  // ESC
  else if (event.key === 'Escape') {
    handleEsc(event, innerParams, dismissWith);
  }
};

/**
 * @param {KeyboardEvent} event
 * @param {SweetAlertOptions} innerParams
 */
const handleEnter = (event, innerParams) => {
  // https://github.com/sweetalert2/sweetalert2/issues/2386
  if (!callIfFunction(innerParams.allowEnterKey)) {
    return;
  }
  const input = getInput$1(getPopup(), innerParams.input);
  if (event.target && input && event.target instanceof HTMLElement && event.target.outerHTML === input.outerHTML) {
    if (['textarea', 'file'].includes(innerParams.input)) {
      return; // do not submit
    }
    clickConfirm();
    event.preventDefault();
  }
};

/**
 * @param {KeyboardEvent} event
 */
const handleTab = event => {
  const targetElement = event.target;
  const focusableElements = getFocusableElements();
  let btnIndex = -1;
  for (let i = 0; i < focusableElements.length; i++) {
    if (targetElement === focusableElements[i]) {
      btnIndex = i;
      break;
    }
  }

  // Cycle to the next button
  if (!event.shiftKey) {
    setFocus(btnIndex, 1);
  }

  // Cycle to the prev button
  else {
    setFocus(btnIndex, -1);
  }
  event.stopPropagation();
  event.preventDefault();
};

/**
 * @param {string} key
 */
const handleArrows = key => {
  const actions = getActions();
  const confirmButton = getConfirmButton();
  const denyButton = getDenyButton();
  const cancelButton = getCancelButton();
  if (!actions || !confirmButton || !denyButton || !cancelButton) {
    return;
  }
  /** @type HTMLElement[] */
  const buttons = [confirmButton, denyButton, cancelButton];
  if (document.activeElement instanceof HTMLElement && !buttons.includes(document.activeElement)) {
    return;
  }
  const sibling = arrowKeysNextButton.includes(key) ? 'nextElementSibling' : 'previousElementSibling';
  let buttonToFocus = document.activeElement;
  if (!buttonToFocus) {
    return;
  }
  for (let i = 0; i < actions.children.length; i++) {
    buttonToFocus = buttonToFocus[sibling];
    if (!buttonToFocus) {
      return;
    }
    if (buttonToFocus instanceof HTMLButtonElement && isVisible$1(buttonToFocus)) {
      break;
    }
  }
  if (buttonToFocus instanceof HTMLButtonElement) {
    buttonToFocus.focus();
  }
};

/**
 * @param {KeyboardEvent} event
 * @param {SweetAlertOptions} innerParams
 * @param {Function} dismissWith
 */
const handleEsc = (event, innerParams, dismissWith) => {
  if (callIfFunction(innerParams.allowEscapeKey)) {
    event.preventDefault();
    dismissWith(DismissReason.esc);
  }
};

/**
 * This module contains `WeakMap`s for each effectively-"private  property" that a `Swal` has.
 * For example, to set the private property "foo" of `this` to "bar", you can `privateProps.foo.set(this, 'bar')`
 * This is the approach that Babel will probably take to implement private methods/fields
 *   https://github.com/tc39/proposal-private-methods
 *   https://github.com/babel/babel/pull/7555
 * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*
 *   then we can use that language feature.
 */

var privateMethods = {
  swalPromiseResolve: new WeakMap(),
  swalPromiseReject: new WeakMap()
};

// From https://developer.paciellogroup.com/blog/2018/06/the-current-state-of-modal-dialog-accessibility/
// Adding aria-hidden="true" to elements outside of the active modal dialog ensures that
// elements not within the active modal dialog will not be surfaced if a user opens a screen
// reader’s list of elements (headings, form controls, landmarks, etc.) in the document.

const setAriaHidden = () => {
  const container = getContainer();
  const bodyChildren = Array.from(document.body.children);
  bodyChildren.forEach(el => {
    if (el.contains(container)) {
      return;
    }
    if (el.hasAttribute('aria-hidden')) {
      el.setAttribute('data-previous-aria-hidden', el.getAttribute('aria-hidden') || '');
    }
    el.setAttribute('aria-hidden', 'true');
  });
};
const unsetAriaHidden = () => {
  const bodyChildren = Array.from(document.body.children);
  bodyChildren.forEach(el => {
    if (el.hasAttribute('data-previous-aria-hidden')) {
      el.setAttribute('aria-hidden', el.getAttribute('data-previous-aria-hidden') || '');
      el.removeAttribute('data-previous-aria-hidden');
    } else {
      el.removeAttribute('aria-hidden');
    }
  });
};

// @ts-ignore
const isSafariOrIOS = typeof window !== 'undefined' && !!window.GestureEvent; // true for Safari desktop + all iOS browsers https://stackoverflow.com/a/70585394

/**
 * Fix iOS scrolling
 * http://stackoverflow.com/q/39626302
 */
const iOSfix = () => {
  if (isSafariOrIOS && !hasClass(document.body, swalClasses.iosfix)) {
    const offset = document.body.scrollTop;
    document.body.style.top = `${offset * -1}px`;
    addClass(document.body, swalClasses.iosfix);
    lockBodyScroll();
  }
};

/**
 * https://github.com/sweetalert2/sweetalert2/issues/1246
 */
const lockBodyScroll = () => {
  const container = getContainer();
  if (!container) {
    return;
  }
  /** @type {boolean} */
  let preventTouchMove;
  /**
   * @param {TouchEvent} event
   */
  container.ontouchstart = event => {
    preventTouchMove = shouldPreventTouchMove(event);
  };
  /**
   * @param {TouchEvent} event
   */
  container.ontouchmove = event => {
    if (preventTouchMove) {
      event.preventDefault();
      event.stopPropagation();
    }
  };
};

/**
 * @param {TouchEvent} event
 * @returns {boolean}
 */
const shouldPreventTouchMove = event => {
  const target = event.target;
  const container = getContainer();
  const htmlContainer = getHtmlContainer();
  if (!container || !htmlContainer) {
    return false;
  }
  if (isStylus(event) || isZoom(event)) {
    return false;
  }
  if (target === container) {
    return true;
  }
  if (!isScrollable(container) && target instanceof HTMLElement && target.tagName !== 'INPUT' &&
  // #1603
  target.tagName !== 'TEXTAREA' &&
  // #2266
  !(isScrollable(htmlContainer) &&
  // #1944
  htmlContainer.contains(target))) {
    return true;
  }
  return false;
};

/**
 * https://github.com/sweetalert2/sweetalert2/issues/1786
 *
 * @param {*} event
 * @returns {boolean}
 */
const isStylus = event => {
  return event.touches && event.touches.length && event.touches[0].touchType === 'stylus';
};

/**
 * https://github.com/sweetalert2/sweetalert2/issues/1891
 *
 * @param {TouchEvent} event
 * @returns {boolean}
 */
const isZoom = event => {
  return event.touches && event.touches.length > 1;
};
const undoIOSfix = () => {
  if (hasClass(document.body, swalClasses.iosfix)) {
    const offset = parseInt(document.body.style.top, 10);
    removeClass(document.body, swalClasses.iosfix);
    document.body.style.top = '';
    document.body.scrollTop = offset * -1;
  }
};

/**
 * Measure scrollbar width for padding body during modal show/hide
 * https://github.com/twbs/bootstrap/blob/master/js/src/modal.js
 *
 * @returns {number}
 */
const measureScrollbar = () => {
  const scrollDiv = document.createElement('div');
  scrollDiv.className = swalClasses['scrollbar-measure'];
  document.body.appendChild(scrollDiv);
  const scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
  document.body.removeChild(scrollDiv);
  return scrollbarWidth;
};

/**
 * Remember state in cases where opening and handling a modal will fiddle with it.
 * @type {number | null}
 */
let previousBodyPadding = null;

/**
 * @param {string} initialBodyOverflow
 */
const replaceScrollbarWithPadding = initialBodyOverflow => {
  // for queues, do not do this more than once
  if (previousBodyPadding !== null) {
    return;
  }
  // if the body has overflow
  if (document.body.scrollHeight > window.innerHeight || initialBodyOverflow === 'scroll' // https://github.com/sweetalert2/sweetalert2/issues/2663
  ) {
    // add padding so the content doesn't shift after removal of scrollbar
    previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue('padding-right'));
    document.body.style.paddingRight = `${previousBodyPadding + measureScrollbar()}px`;
  }
};
const undoReplaceScrollbarWithPadding = () => {
  if (previousBodyPadding !== null) {
    document.body.style.paddingRight = `${previousBodyPadding}px`;
    previousBodyPadding = null;
  }
};

/**
 * @param {SweetAlert} instance
 * @param {HTMLElement} container
 * @param {boolean} returnFocus
 * @param {Function} didClose
 */
function removePopupAndResetState(instance, container, returnFocus, didClose) {
  if (isToast()) {
    triggerDidCloseAndDispose(instance, didClose);
  } else {
    restoreActiveElement(returnFocus).then(() => triggerDidCloseAndDispose(instance, didClose));
    removeKeydownHandler(globalState);
  }

  // workaround for https://github.com/sweetalert2/sweetalert2/issues/2088
  // for some reason removing the container in Safari will scroll the document to bottom
  if (isSafariOrIOS) {
    container.setAttribute('style', 'display:none !important');
    container.removeAttribute('class');
    container.innerHTML = '';
  } else {
    container.remove();
  }
  if (isModal()) {
    undoReplaceScrollbarWithPadding();
    undoIOSfix();
    unsetAriaHidden();
  }
  removeBodyClasses();
}

/**
 * Remove SweetAlert2 classes from body
 */
function removeBodyClasses() {
  removeClass([document.documentElement, document.body], [swalClasses.shown, swalClasses['height-auto'], swalClasses['no-backdrop'], swalClasses['toast-shown']]);
}

/**
 * Instance method to close sweetAlert
 *
 * @param {any} resolveValue
 */
function close(resolveValue) {
  resolveValue = prepareResolveValue(resolveValue);
  const swalPromiseResolve = privateMethods.swalPromiseResolve.get(this);
  const didClose = triggerClosePopup(this);
  if (this.isAwaitingPromise) {
    // A swal awaiting for a promise (after a click on Confirm or Deny) cannot be dismissed anymore #2335
    if (!resolveValue.isDismissed) {
      handleAwaitingPromise(this);
      swalPromiseResolve(resolveValue);
    }
  } else if (didClose) {
    // Resolve Swal promise
    swalPromiseResolve(resolveValue);
  }
}
const triggerClosePopup = instance => {
  const popup = getPopup();
  if (!popup) {
    return false;
  }
  const innerParams = privateProps.innerParams.get(instance);
  if (!innerParams || hasClass(popup, innerParams.hideClass.popup)) {
    return false;
  }
  removeClass(popup, innerParams.showClass.popup);
  addClass(popup, innerParams.hideClass.popup);
  const backdrop = getContainer();
  removeClass(backdrop, innerParams.showClass.backdrop);
  addClass(backdrop, innerParams.hideClass.backdrop);
  handlePopupAnimation(instance, popup, innerParams);
  return true;
};

/**
 * @param {any} error
 */
function rejectPromise(error) {
  const rejectPromise = privateMethods.swalPromiseReject.get(this);
  handleAwaitingPromise(this);
  if (rejectPromise) {
    // Reject Swal promise
    rejectPromise(error);
  }
}

/**
 * @param {SweetAlert} instance
 */
const handleAwaitingPromise = instance => {
  if (instance.isAwaitingPromise) {
    delete instance.isAwaitingPromise;
    // The instance might have been previously partly destroyed, we must resume the destroy process in this case #2335
    if (!privateProps.innerParams.get(instance)) {
      instance._destroy();
    }
  }
};

/**
 * @param {any} resolveValue
 * @returns {SweetAlertResult}
 */
const prepareResolveValue = resolveValue => {
  // When user calls Swal.close()
  if (typeof resolveValue === 'undefined') {
    return {
      isConfirmed: false,
      isDenied: false,
      isDismissed: true
    };
  }
  return Object.assign({
    isConfirmed: false,
    isDenied: false,
    isDismissed: false
  }, resolveValue);
};

/**
 * @param {SweetAlert} instance
 * @param {HTMLElement} popup
 * @param {SweetAlertOptions} innerParams
 */
const handlePopupAnimation = (instance, popup, innerParams) => {
  var _globalState$eventEmi;
  const container = getContainer();
  // If animation is supported, animate
  const animationIsSupported = hasCssAnimation(popup);
  if (typeof innerParams.willClose === 'function') {
    innerParams.willClose(popup);
  }
  (_globalState$eventEmi = globalState.eventEmitter) === null || _globalState$eventEmi === void 0 || _globalState$eventEmi.emit('willClose', popup);
  if (animationIsSupported) {
    animatePopup(instance, popup, container, innerParams.returnFocus, innerParams.didClose);
  } else {
    // Otherwise, remove immediately
    removePopupAndResetState(instance, container, innerParams.returnFocus, innerParams.didClose);
  }
};

/**
 * @param {SweetAlert} instance
 * @param {HTMLElement} popup
 * @param {HTMLElement} container
 * @param {boolean} returnFocus
 * @param {Function} didClose
 */
const animatePopup = (instance, popup, container, returnFocus, didClose) => {
  globalState.swalCloseEventFinishedCallback = removePopupAndResetState.bind(null, instance, container, returnFocus, didClose);
  /**
   * @param {AnimationEvent | TransitionEvent} e
   */
  const swalCloseAnimationFinished = function (e) {
    if (e.target === popup) {
      var _globalState$swalClos;
      (_globalState$swalClos = globalState.swalCloseEventFinishedCallback) === null || _globalState$swalClos === void 0 || _globalState$swalClos.call(globalState);
      delete globalState.swalCloseEventFinishedCallback;
      popup.removeEventListener('animationend', swalCloseAnimationFinished);
      popup.removeEventListener('transitionend', swalCloseAnimationFinished);
    }
  };
  popup.addEventListener('animationend', swalCloseAnimationFinished);
  popup.addEventListener('transitionend', swalCloseAnimationFinished);
};

/**
 * @param {SweetAlert} instance
 * @param {Function} didClose
 */
const triggerDidCloseAndDispose = (instance, didClose) => {
  setTimeout(() => {
    var _globalState$eventEmi2;
    if (typeof didClose === 'function') {
      didClose.bind(instance.params)();
    }
    (_globalState$eventEmi2 = globalState.eventEmitter) === null || _globalState$eventEmi2 === void 0 || _globalState$eventEmi2.emit('didClose');
    // instance might have been destroyed already
    if (instance._destroy) {
      instance._destroy();
    }
  });
};

/**
 * Shows loader (spinner), this is useful with AJAX requests.
 * By default the loader be shown instead of the "Confirm" button.
 *
 * @param {HTMLButtonElement | null} [buttonToReplace]
 */
const showLoading = buttonToReplace => {
  let popup = getPopup();
  if (!popup) {
    new Swal();
  }
  popup = getPopup();
  if (!popup) {
    return;
  }
  const loader = getLoader();
  if (isToast()) {
    hide$2(getIcon());
  } else {
    replaceButton(popup, buttonToReplace);
  }
  show(loader);
  popup.setAttribute('data-loading', 'true');
  popup.setAttribute('aria-busy', 'true');
  popup.focus();
};

/**
 * @param {HTMLElement} popup
 * @param {HTMLButtonElement | null} [buttonToReplace]
 */
const replaceButton = (popup, buttonToReplace) => {
  const actions = getActions();
  const loader = getLoader();
  if (!actions || !loader) {
    return;
  }
  if (!buttonToReplace && isVisible$1(getConfirmButton())) {
    buttonToReplace = getConfirmButton();
  }
  show(actions);
  if (buttonToReplace) {
    hide$2(buttonToReplace);
    loader.setAttribute('data-button-to-replace', buttonToReplace.className);
    actions.insertBefore(loader, buttonToReplace);
  }
  addClass([popup, actions], swalClasses.loading);
};

/**
 * @param {SweetAlert} instance
 * @param {SweetAlertOptions} params
 */
const handleInputOptionsAndValue = (instance, params) => {
  if (params.input === 'select' || params.input === 'radio') {
    handleInputOptions(instance, params);
  } else if (['text', 'email', 'number', 'tel', 'textarea'].some(i => i === params.input) && (hasToPromiseFn(params.inputValue) || isPromise$1(params.inputValue))) {
    showLoading(getConfirmButton());
    handleInputValue(instance, params);
  }
};

/**
 * @param {SweetAlert} instance
 * @param {SweetAlertOptions} innerParams
 * @returns {SweetAlertInputValue}
 */
const getInputValue = (instance, innerParams) => {
  const input = instance.getInput();
  if (!input) {
    return null;
  }
  switch (innerParams.input) {
    case 'checkbox':
      return getCheckboxValue(input);
    case 'radio':
      return getRadioValue(input);
    case 'file':
      return getFileValue(input);
    default:
      return innerParams.inputAutoTrim ? input.value.trim() : input.value;
  }
};

/**
 * @param {HTMLInputElement} input
 * @returns {number}
 */
const getCheckboxValue = input => input.checked ? 1 : 0;

/**
 * @param {HTMLInputElement} input
 * @returns {string | null}
 */
const getRadioValue = input => input.checked ? input.value : null;

/**
 * @param {HTMLInputElement} input
 * @returns {FileList | File | null}
 */
const getFileValue = input => input.files && input.files.length ? input.getAttribute('multiple') !== null ? input.files : input.files[0] : null;

/**
 * @param {SweetAlert} instance
 * @param {SweetAlertOptions} params
 */
const handleInputOptions = (instance, params) => {
  const popup = getPopup();
  if (!popup) {
    return;
  }
  /**
   * @param {Record<string, any>} inputOptions
   */
  const processInputOptions = inputOptions => {
    if (params.input === 'select') {
      populateSelectOptions(popup, formatInputOptions(inputOptions), params);
    } else if (params.input === 'radio') {
      populateRadioOptions(popup, formatInputOptions(inputOptions), params);
    }
  };
  if (hasToPromiseFn(params.inputOptions) || isPromise$1(params.inputOptions)) {
    showLoading(getConfirmButton());
    asPromise(params.inputOptions).then(inputOptions => {
      instance.hideLoading();
      processInputOptions(inputOptions);
    });
  } else if (typeof params.inputOptions === 'object') {
    processInputOptions(params.inputOptions);
  } else {
    error(`Unexpected type of inputOptions! Expected object, Map or Promise, got ${typeof params.inputOptions}`);
  }
};

/**
 * @param {SweetAlert} instance
 * @param {SweetAlertOptions} params
 */
const handleInputValue = (instance, params) => {
  const input = instance.getInput();
  if (!input) {
    return;
  }
  hide$2(input);
  asPromise(params.inputValue).then(inputValue => {
    input.value = params.input === 'number' ? `${parseFloat(inputValue) || 0}` : `${inputValue}`;
    show(input);
    input.focus();
    instance.hideLoading();
  }).catch(err => {
    error(`Error in inputValue promise: ${err}`);
    input.value = '';
    show(input);
    input.focus();
    instance.hideLoading();
  });
};

/**
 * @param {HTMLElement} popup
 * @param {InputOptionFlattened[]} inputOptions
 * @param {SweetAlertOptions} params
 */
function populateSelectOptions(popup, inputOptions, params) {
  const select = getDirectChildByClass(popup, swalClasses.select);
  if (!select) {
    return;
  }
  /**
   * @param {HTMLElement} parent
   * @param {string} optionLabel
   * @param {string} optionValue
   */
  const renderOption = (parent, optionLabel, optionValue) => {
    const option = document.createElement('option');
    option.value = optionValue;
    setInnerHtml(option, optionLabel);
    option.selected = isSelected(optionValue, params.inputValue);
    parent.appendChild(option);
  };
  inputOptions.forEach(inputOption => {
    const optionValue = inputOption[0];
    const optionLabel = inputOption[1];
    // <optgroup> spec:
    // https://www.w3.org/TR/html401/interact/forms.html#h-17.6
    // "...all OPTGROUP elements must be specified directly within a SELECT element (i.e., groups may not be nested)..."
    // check whether this is a <optgroup>
    if (Array.isArray(optionLabel)) {
      // if it is an array, then it is an <optgroup>
      const optgroup = document.createElement('optgroup');
      optgroup.label = optionValue;
      optgroup.disabled = false; // not configurable for now
      select.appendChild(optgroup);
      optionLabel.forEach(o => renderOption(optgroup, o[1], o[0]));
    } else {
      // case of <option>
      renderOption(select, optionLabel, optionValue);
    }
  });
  select.focus();
}

/**
 * @param {HTMLElement} popup
 * @param {InputOptionFlattened[]} inputOptions
 * @param {SweetAlertOptions} params
 */
function populateRadioOptions(popup, inputOptions, params) {
  const radio = getDirectChildByClass(popup, swalClasses.radio);
  if (!radio) {
    return;
  }
  inputOptions.forEach(inputOption => {
    const radioValue = inputOption[0];
    const radioLabel = inputOption[1];
    const radioInput = document.createElement('input');
    const radioLabelElement = document.createElement('label');
    radioInput.type = 'radio';
    radioInput.name = swalClasses.radio;
    radioInput.value = radioValue;
    if (isSelected(radioValue, params.inputValue)) {
      radioInput.checked = true;
    }
    const label = document.createElement('span');
    setInnerHtml(label, radioLabel);
    label.className = swalClasses.label;
    radioLabelElement.appendChild(radioInput);
    radioLabelElement.appendChild(label);
    radio.appendChild(radioLabelElement);
  });
  const radios = radio.querySelectorAll('input');
  if (radios.length) {
    radios[0].focus();
  }
}

/**
 * Converts `inputOptions` into an array of `[value, label]`s
 *
 * @param {Record<string, any>} inputOptions
 * @typedef {string[]} InputOptionFlattened
 * @returns {InputOptionFlattened[]}
 */
const formatInputOptions = inputOptions => {
  /** @type {InputOptionFlattened[]} */
  const result = [];
  if (inputOptions instanceof Map) {
    inputOptions.forEach((value, key) => {
      let valueFormatted = value;
      if (typeof valueFormatted === 'object') {
        // case of <optgroup>
        valueFormatted = formatInputOptions(valueFormatted);
      }
      result.push([key, valueFormatted]);
    });
  } else {
    Object.keys(inputOptions).forEach(key => {
      let valueFormatted = inputOptions[key];
      if (typeof valueFormatted === 'object') {
        // case of <optgroup>
        valueFormatted = formatInputOptions(valueFormatted);
      }
      result.push([key, valueFormatted]);
    });
  }
  return result;
};

/**
 * @param {string} optionValue
 * @param {SweetAlertInputValue} inputValue
 * @returns {boolean}
 */
const isSelected = (optionValue, inputValue) => {
  return !!inputValue && inputValue.toString() === optionValue.toString();
};

/**
 * @param {SweetAlert} instance
 */
const handleConfirmButtonClick = instance => {
  const innerParams = privateProps.innerParams.get(instance);
  instance.disableButtons();
  if (innerParams.input) {
    handleConfirmOrDenyWithInput(instance, 'confirm');
  } else {
    confirm(instance, true);
  }
};

/**
 * @param {SweetAlert} instance
 */
const handleDenyButtonClick = instance => {
  const innerParams = privateProps.innerParams.get(instance);
  instance.disableButtons();
  if (innerParams.returnInputValueOnDeny) {
    handleConfirmOrDenyWithInput(instance, 'deny');
  } else {
    deny(instance, false);
  }
};

/**
 * @param {SweetAlert} instance
 * @param {Function} dismissWith
 */
const handleCancelButtonClick = (instance, dismissWith) => {
  instance.disableButtons();
  dismissWith(DismissReason.cancel);
};

/**
 * @param {SweetAlert} instance
 * @param {'confirm' | 'deny'} type
 */
const handleConfirmOrDenyWithInput = (instance, type) => {
  const innerParams = privateProps.innerParams.get(instance);
  if (!innerParams.input) {
    error(`The "input" parameter is needed to be set when using returnInputValueOn${capitalizeFirstLetter(type)}`);
    return;
  }
  const input = instance.getInput();
  const inputValue = getInputValue(instance, innerParams);
  if (innerParams.inputValidator) {
    handleInputValidator(instance, inputValue, type);
  } else if (input && !input.checkValidity()) {
    instance.enableButtons();
    instance.showValidationMessage(innerParams.validationMessage || input.validationMessage);
  } else if (type === 'deny') {
    deny(instance, inputValue);
  } else {
    confirm(instance, inputValue);
  }
};

/**
 * @param {SweetAlert} instance
 * @param {SweetAlertInputValue} inputValue
 * @param {'confirm' | 'deny'} type
 */
const handleInputValidator = (instance, inputValue, type) => {
  const innerParams = privateProps.innerParams.get(instance);
  instance.disableInput();
  const validationPromise = Promise.resolve().then(() => asPromise(innerParams.inputValidator(inputValue, innerParams.validationMessage)));
  validationPromise.then(validationMessage => {
    instance.enableButtons();
    instance.enableInput();
    if (validationMessage) {
      instance.showValidationMessage(validationMessage);
    } else if (type === 'deny') {
      deny(instance, inputValue);
    } else {
      confirm(instance, inputValue);
    }
  });
};

/**
 * @param {SweetAlert} instance
 * @param {any} value
 */
const deny = (instance, value) => {
  const innerParams = privateProps.innerParams.get(instance || undefined);
  if (innerParams.showLoaderOnDeny) {
    showLoading(getDenyButton());
  }
  if (innerParams.preDeny) {
    instance.isAwaitingPromise = true; // Flagging the instance as awaiting a promise so it's own promise's reject/resolve methods doesn't get destroyed until the result from this preDeny's promise is received
    const preDenyPromise = Promise.resolve().then(() => asPromise(innerParams.preDeny(value, innerParams.validationMessage)));
    preDenyPromise.then(preDenyValue => {
      if (preDenyValue === false) {
        instance.hideLoading();
        handleAwaitingPromise(instance);
      } else {
        instance.close({
          isDenied: true,
          value: typeof preDenyValue === 'undefined' ? value : preDenyValue
        });
      }
    }).catch(error => rejectWith(instance || undefined, error));
  } else {
    instance.close({
      isDenied: true,
      value
    });
  }
};

/**
 * @param {SweetAlert} instance
 * @param {any} value
 */
const succeedWith = (instance, value) => {
  instance.close({
    isConfirmed: true,
    value
  });
};

/**
 *
 * @param {SweetAlert} instance
 * @param {string} error
 */
const rejectWith = (instance, error) => {
  instance.rejectPromise(error);
};

/**
 *
 * @param {SweetAlert} instance
 * @param {any} value
 */
const confirm = (instance, value) => {
  const innerParams = privateProps.innerParams.get(instance || undefined);
  if (innerParams.showLoaderOnConfirm) {
    showLoading();
  }
  if (innerParams.preConfirm) {
    instance.resetValidationMessage();
    instance.isAwaitingPromise = true; // Flagging the instance as awaiting a promise so it's own promise's reject/resolve methods doesn't get destroyed until the result from this preConfirm's promise is received
    const preConfirmPromise = Promise.resolve().then(() => asPromise(innerParams.preConfirm(value, innerParams.validationMessage)));
    preConfirmPromise.then(preConfirmValue => {
      if (isVisible$1(getValidationMessage()) || preConfirmValue === false) {
        instance.hideLoading();
        handleAwaitingPromise(instance);
      } else {
        succeedWith(instance, typeof preConfirmValue === 'undefined' ? value : preConfirmValue);
      }
    }).catch(error => rejectWith(instance || undefined, error));
  } else {
    succeedWith(instance, value);
  }
};

/**
 * Hides loader and shows back the button which was hidden by .showLoading()
 */
function hideLoading() {
  // do nothing if popup is closed
  const innerParams = privateProps.innerParams.get(this);
  if (!innerParams) {
    return;
  }
  const domCache = privateProps.domCache.get(this);
  hide$2(domCache.loader);
  if (isToast()) {
    if (innerParams.icon) {
      show(getIcon());
    }
  } else {
    showRelatedButton(domCache);
  }
  removeClass([domCache.popup, domCache.actions], swalClasses.loading);
  domCache.popup.removeAttribute('aria-busy');
  domCache.popup.removeAttribute('data-loading');
  domCache.confirmButton.disabled = false;
  domCache.denyButton.disabled = false;
  domCache.cancelButton.disabled = false;
}
const showRelatedButton = domCache => {
  const buttonToReplace = domCache.popup.getElementsByClassName(domCache.loader.getAttribute('data-button-to-replace'));
  if (buttonToReplace.length) {
    show(buttonToReplace[0], 'inline-block');
  } else if (allButtonsAreHidden()) {
    hide$2(domCache.actions);
  }
};

/**
 * Gets the input DOM node, this method works with input parameter.
 *
 * @returns {HTMLInputElement | null}
 */
function getInput() {
  const innerParams = privateProps.innerParams.get(this);
  const domCache = privateProps.domCache.get(this);
  if (!domCache) {
    return null;
  }
  return getInput$1(domCache.popup, innerParams.input);
}

/**
 * @param {SweetAlert} instance
 * @param {string[]} buttons
 * @param {boolean} disabled
 */
function setButtonsDisabled(instance, buttons, disabled) {
  const domCache = privateProps.domCache.get(instance);
  buttons.forEach(button => {
    domCache[button].disabled = disabled;
  });
}

/**
 * @param {HTMLInputElement | null} input
 * @param {boolean} disabled
 */
function setInputDisabled(input, disabled) {
  const popup = getPopup();
  if (!popup || !input) {
    return;
  }
  if (input.type === 'radio') {
    /** @type {NodeListOf<HTMLInputElement>} */
    const radios = popup.querySelectorAll(`[name="${swalClasses.radio}"]`);
    for (let i = 0; i < radios.length; i++) {
      radios[i].disabled = disabled;
    }
  } else {
    input.disabled = disabled;
  }
}

/**
 * Enable all the buttons
 * @this {SweetAlert}
 */
function enableButtons() {
  setButtonsDisabled(this, ['confirmButton', 'denyButton', 'cancelButton'], false);
}

/**
 * Disable all the buttons
 * @this {SweetAlert}
 */
function disableButtons() {
  setButtonsDisabled(this, ['confirmButton', 'denyButton', 'cancelButton'], true);
}

/**
 * Enable the input field
 * @this {SweetAlert}
 */
function enableInput() {
  setInputDisabled(this.getInput(), false);
}

/**
 * Disable the input field
 * @this {SweetAlert}
 */
function disableInput() {
  setInputDisabled(this.getInput(), true);
}

/**
 * Show block with validation message
 *
 * @param {string} error
 * @this {SweetAlert}
 */
function showValidationMessage(error) {
  const domCache = privateProps.domCache.get(this);
  const params = privateProps.innerParams.get(this);
  setInnerHtml(domCache.validationMessage, error);
  domCache.validationMessage.className = swalClasses['validation-message'];
  if (params.customClass && params.customClass.validationMessage) {
    addClass(domCache.validationMessage, params.customClass.validationMessage);
  }
  show(domCache.validationMessage);
  const input = this.getInput();
  if (input) {
    input.setAttribute('aria-invalid', 'true');
    input.setAttribute('aria-describedby', swalClasses['validation-message']);
    focusInput(input);
    addClass(input, swalClasses.inputerror);
  }
}

/**
 * Hide block with validation message
 *
 * @this {SweetAlert}
 */
function resetValidationMessage() {
  const domCache = privateProps.domCache.get(this);
  if (domCache.validationMessage) {
    hide$2(domCache.validationMessage);
  }
  const input = this.getInput();
  if (input) {
    input.removeAttribute('aria-invalid');
    input.removeAttribute('aria-describedby');
    removeClass(input, swalClasses.inputerror);
  }
}

const defaultParams = {
  title: '',
  titleText: '',
  text: '',
  html: '',
  footer: '',
  icon: undefined,
  iconColor: undefined,
  iconHtml: undefined,
  template: undefined,
  toast: false,
  draggable: false,
  animation: true,
  theme: 'light',
  showClass: {
    popup: 'swal2-show',
    backdrop: 'swal2-backdrop-show',
    icon: 'swal2-icon-show'
  },
  hideClass: {
    popup: 'swal2-hide',
    backdrop: 'swal2-backdrop-hide',
    icon: 'swal2-icon-hide'
  },
  customClass: {},
  target: 'body',
  color: undefined,
  backdrop: true,
  heightAuto: true,
  allowOutsideClick: true,
  allowEscapeKey: true,
  allowEnterKey: true,
  stopKeydownPropagation: true,
  keydownListenerCapture: false,
  showConfirmButton: true,
  showDenyButton: false,
  showCancelButton: false,
  preConfirm: undefined,
  preDeny: undefined,
  confirmButtonText: 'OK',
  confirmButtonAriaLabel: '',
  confirmButtonColor: undefined,
  denyButtonText: 'No',
  denyButtonAriaLabel: '',
  denyButtonColor: undefined,
  cancelButtonText: 'Cancel',
  cancelButtonAriaLabel: '',
  cancelButtonColor: undefined,
  buttonsStyling: true,
  reverseButtons: false,
  focusConfirm: true,
  focusDeny: false,
  focusCancel: false,
  returnFocus: true,
  showCloseButton: false,
  closeButtonHtml: '&times;',
  closeButtonAriaLabel: 'Close this dialog',
  loaderHtml: '',
  showLoaderOnConfirm: false,
  showLoaderOnDeny: false,
  imageUrl: undefined,
  imageWidth: undefined,
  imageHeight: undefined,
  imageAlt: '',
  timer: undefined,
  timerProgressBar: false,
  width: undefined,
  padding: undefined,
  background: undefined,
  input: undefined,
  inputPlaceholder: '',
  inputLabel: '',
  inputValue: '',
  inputOptions: {},
  inputAutoFocus: true,
  inputAutoTrim: true,
  inputAttributes: {},
  inputValidator: undefined,
  returnInputValueOnDeny: false,
  validationMessage: undefined,
  grow: false,
  position: 'center',
  progressSteps: [],
  currentProgressStep: undefined,
  progressStepsDistance: undefined,
  willOpen: undefined,
  didOpen: undefined,
  didRender: undefined,
  willClose: undefined,
  didClose: undefined,
  didDestroy: undefined,
  scrollbarPadding: true,
  topLayer: false
};
const updatableParams = ['allowEscapeKey', 'allowOutsideClick', 'background', 'buttonsStyling', 'cancelButtonAriaLabel', 'cancelButtonColor', 'cancelButtonText', 'closeButtonAriaLabel', 'closeButtonHtml', 'color', 'confirmButtonAriaLabel', 'confirmButtonColor', 'confirmButtonText', 'currentProgressStep', 'customClass', 'denyButtonAriaLabel', 'denyButtonColor', 'denyButtonText', 'didClose', 'didDestroy', 'draggable', 'footer', 'hideClass', 'html', 'icon', 'iconColor', 'iconHtml', 'imageAlt', 'imageHeight', 'imageUrl', 'imageWidth', 'preConfirm', 'preDeny', 'progressSteps', 'returnFocus', 'reverseButtons', 'showCancelButton', 'showCloseButton', 'showConfirmButton', 'showDenyButton', 'text', 'title', 'titleText', 'theme', 'willClose'];

/** @type {Record<string, string | undefined>} */
const deprecatedParams = {
  allowEnterKey: undefined
};
const toastIncompatibleParams = ['allowOutsideClick', 'allowEnterKey', 'backdrop', 'draggable', 'focusConfirm', 'focusDeny', 'focusCancel', 'returnFocus', 'heightAuto', 'keydownListenerCapture'];

/**
 * Is valid parameter
 *
 * @param {string} paramName
 * @returns {boolean}
 */
const isValidParameter = paramName => {
  return Object.prototype.hasOwnProperty.call(defaultParams, paramName);
};

/**
 * Is valid parameter for Swal.update() method
 *
 * @param {string} paramName
 * @returns {boolean}
 */
const isUpdatableParameter = paramName => {
  return updatableParams.indexOf(paramName) !== -1;
};

/**
 * Is deprecated parameter
 *
 * @param {string} paramName
 * @returns {string | undefined}
 */
const isDeprecatedParameter = paramName => {
  return deprecatedParams[paramName];
};

/**
 * @param {string} param
 */
const checkIfParamIsValid = param => {
  if (!isValidParameter(param)) {
    warn(`Unknown parameter "${param}"`);
  }
};

/**
 * @param {string} param
 */
const checkIfToastParamIsValid = param => {
  if (toastIncompatibleParams.includes(param)) {
    warn(`The parameter "${param}" is incompatible with toasts`);
  }
};

/**
 * @param {string} param
 */
const checkIfParamIsDeprecated = param => {
  const isDeprecated = isDeprecatedParameter(param);
  if (isDeprecated) {
    warnAboutDeprecation(param, isDeprecated);
  }
};

/**
 * Show relevant warnings for given params
 *
 * @param {SweetAlertOptions} params
 */
const showWarningsForParams = params => {
  if (params.backdrop === false && params.allowOutsideClick) {
    warn('"allowOutsideClick" parameter requires `backdrop` parameter to be set to `true`');
  }
  if (params.theme && !['light', 'dark', 'auto', 'minimal', 'borderless', 'embed-iframe'].includes(params.theme)) {
    warn(`Invalid theme "${params.theme}". Expected "light", "dark", "auto", "minimal", "borderless", or "embed-iframe"`);
  }
  for (const param in params) {
    checkIfParamIsValid(param);
    if (params.toast) {
      checkIfToastParamIsValid(param);
    }
    checkIfParamIsDeprecated(param);
  }
};

/**
 * Updates popup parameters.
 *
 * @param {SweetAlertOptions} params
 */
function update(params) {
  const container = getContainer();
  const popup = getPopup();
  const innerParams = privateProps.innerParams.get(this);
  if (!popup || hasClass(popup, innerParams.hideClass.popup)) {
    warn(`You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup.`);
    return;
  }
  const validUpdatableParams = filterValidParams(params);
  const updatedParams = Object.assign({}, innerParams, validUpdatableParams);
  showWarningsForParams(updatedParams);
  container.dataset['swal2Theme'] = updatedParams.theme;
  render(this, updatedParams);
  privateProps.innerParams.set(this, updatedParams);
  Object.defineProperties(this, {
    params: {
      value: Object.assign({}, this.params, params),
      writable: false,
      enumerable: true
    }
  });
}

/**
 * @param {SweetAlertOptions} params
 * @returns {SweetAlertOptions}
 */
const filterValidParams = params => {
  const validUpdatableParams = {};
  Object.keys(params).forEach(param => {
    if (isUpdatableParameter(param)) {
      validUpdatableParams[param] = params[param];
    } else {
      warn(`Invalid parameter to update: ${param}`);
    }
  });
  return validUpdatableParams;
};

/**
 * Dispose the current SweetAlert2 instance
 */
function _destroy() {
  const domCache = privateProps.domCache.get(this);
  const innerParams = privateProps.innerParams.get(this);
  if (!innerParams) {
    disposeWeakMaps(this); // The WeakMaps might have been partly destroyed, we must recall it to dispose any remaining WeakMaps #2335
    return; // This instance has already been destroyed
  }

  // Check if there is another Swal closing
  if (domCache.popup && globalState.swalCloseEventFinishedCallback) {
    globalState.swalCloseEventFinishedCallback();
    delete globalState.swalCloseEventFinishedCallback;
  }
  if (typeof innerParams.didDestroy === 'function') {
    innerParams.didDestroy();
  }
  globalState.eventEmitter.emit('didDestroy');
  disposeSwal(this);
}

/**
 * @param {SweetAlert} instance
 */
const disposeSwal = instance => {
  disposeWeakMaps(instance);
  // Unset this.params so GC will dispose it (#1569)
  delete instance.params;
  // Unset globalState props so GC will dispose globalState (#1569)
  delete globalState.keydownHandler;
  delete globalState.keydownTarget;
  // Unset currentInstance
  delete globalState.currentInstance;
};

/**
 * @param {SweetAlert} instance
 */
const disposeWeakMaps = instance => {
  // If the current instance is awaiting a promise result, we keep the privateMethods to call them once the promise result is retrieved #2335
  if (instance.isAwaitingPromise) {
    unsetWeakMaps(privateProps, instance);
    instance.isAwaitingPromise = true;
  } else {
    unsetWeakMaps(privateMethods, instance);
    unsetWeakMaps(privateProps, instance);
    delete instance.isAwaitingPromise;
    // Unset instance methods
    delete instance.disableButtons;
    delete instance.enableButtons;
    delete instance.getInput;
    delete instance.disableInput;
    delete instance.enableInput;
    delete instance.hideLoading;
    delete instance.disableLoading;
    delete instance.showValidationMessage;
    delete instance.resetValidationMessage;
    delete instance.close;
    delete instance.closePopup;
    delete instance.closeModal;
    delete instance.closeToast;
    delete instance.rejectPromise;
    delete instance.update;
    delete instance._destroy;
  }
};

/**
 * @param {object} obj
 * @param {SweetAlert} instance
 */
const unsetWeakMaps = (obj, instance) => {
  for (const i in obj) {
    obj[i].delete(instance);
  }
};

var instanceMethods = /*#__PURE__*/Object.freeze({
  __proto__: null,
  _destroy: _destroy,
  close: close,
  closeModal: close,
  closePopup: close,
  closeToast: close,
  disableButtons: disableButtons,
  disableInput: disableInput,
  disableLoading: hideLoading,
  enableButtons: enableButtons,
  enableInput: enableInput,
  getInput: getInput,
  handleAwaitingPromise: handleAwaitingPromise,
  hideLoading: hideLoading,
  rejectPromise: rejectPromise,
  resetValidationMessage: resetValidationMessage,
  showValidationMessage: showValidationMessage,
  update: update
});

/**
 * @param {SweetAlertOptions} innerParams
 * @param {DomCache} domCache
 * @param {Function} dismissWith
 */
const handlePopupClick = (innerParams, domCache, dismissWith) => {
  if (innerParams.toast) {
    handleToastClick(innerParams, domCache, dismissWith);
  } else {
    // Ignore click events that had mousedown on the popup but mouseup on the container
    // This can happen when the user drags a slider
    handleModalMousedown(domCache);

    // Ignore click events that had mousedown on the container but mouseup on the popup
    handleContainerMousedown(domCache);
    handleModalClick(innerParams, domCache, dismissWith);
  }
};

/**
 * @param {SweetAlertOptions} innerParams
 * @param {DomCache} domCache
 * @param {Function} dismissWith
 */
const handleToastClick = (innerParams, domCache, dismissWith) => {
  // Closing toast by internal click
  domCache.popup.onclick = () => {
    if (innerParams && (isAnyButtonShown(innerParams) || innerParams.timer || innerParams.input)) {
      return;
    }
    dismissWith(DismissReason.close);
  };
};

/**
 * @param {SweetAlertOptions} innerParams
 * @returns {boolean}
 */
const isAnyButtonShown = innerParams => {
  return !!(innerParams.showConfirmButton || innerParams.showDenyButton || innerParams.showCancelButton || innerParams.showCloseButton);
};
let ignoreOutsideClick = false;

/**
 * @param {DomCache} domCache
 */
const handleModalMousedown = domCache => {
  domCache.popup.onmousedown = () => {
    domCache.container.onmouseup = function (e) {
      domCache.container.onmouseup = () => {};
      // We only check if the mouseup target is the container because usually it doesn't
      // have any other direct children aside of the popup
      if (e.target === domCache.container) {
        ignoreOutsideClick = true;
      }
    };
  };
};

/**
 * @param {DomCache} domCache
 */
const handleContainerMousedown = domCache => {
  domCache.container.onmousedown = e => {
    // prevent the modal text from being selected on double click on the container (allowOutsideClick: false)
    if (e.target === domCache.container) {
      e.preventDefault();
    }
    domCache.popup.onmouseup = function (e) {
      domCache.popup.onmouseup = () => {};
      // We also need to check if the mouseup target is a child of the popup
      if (e.target === domCache.popup || e.target instanceof HTMLElement && domCache.popup.contains(e.target)) {
        ignoreOutsideClick = true;
      }
    };
  };
};

/**
 * @param {SweetAlertOptions} innerParams
 * @param {DomCache} domCache
 * @param {Function} dismissWith
 */
const handleModalClick = (innerParams, domCache, dismissWith) => {
  domCache.container.onclick = e => {
    if (ignoreOutsideClick) {
      ignoreOutsideClick = false;
      return;
    }
    if (e.target === domCache.container && callIfFunction(innerParams.allowOutsideClick)) {
      dismissWith(DismissReason.backdrop);
    }
  };
};

const isJqueryElement = elem => typeof elem === 'object' && elem.jquery;
const isElement$1 = elem => elem instanceof Element || isJqueryElement(elem);
const argsToParams = args => {
  const params = {};
  if (typeof args[0] === 'object' && !isElement$1(args[0])) {
    Object.assign(params, args[0]);
  } else {
    ['title', 'html', 'icon'].forEach((name, index) => {
      const arg = args[index];
      if (typeof arg === 'string' || isElement$1(arg)) {
        params[name] = arg;
      } else if (arg !== undefined) {
        error(`Unexpected type of ${name}! Expected "string" or "Element", got ${typeof arg}`);
      }
    });
  }
  return params;
};

/**
 * Main method to create a new SweetAlert2 popup
 *
 * @param  {...SweetAlertOptions} args
 * @returns {Promise<SweetAlertResult>}
 */
function fire() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return new this(...args);
}

/**
 * Returns an extended version of `Swal` containing `params` as defaults.
 * Useful for reusing Swal configuration.
 *
 * For example:
 *
 * Before:
 * const textPromptOptions = { input: 'text', showCancelButton: true }
 * const {value: firstName} = await Swal.fire({ ...textPromptOptions, title: 'What is your first name?' })
 * const {value: lastName} = await Swal.fire({ ...textPromptOptions, title: 'What is your last name?' })
 *
 * After:
 * const TextPrompt = Swal.mixin({ input: 'text', showCancelButton: true })
 * const {value: firstName} = await TextPrompt('What is your first name?')
 * const {value: lastName} = await TextPrompt('What is your last name?')
 *
 * @param {SweetAlertOptions} mixinParams
 * @returns {SweetAlert}
 */
function mixin(mixinParams) {
  class MixinSwal extends this {
    _main(params, priorityMixinParams) {
      return super._main(params, Object.assign({}, mixinParams, priorityMixinParams));
    }
  }
  // @ts-ignore
  return MixinSwal;
}

/**
 * If `timer` parameter is set, returns number of milliseconds of timer remained.
 * Otherwise, returns undefined.
 *
 * @returns {number | undefined}
 */
const getTimerLeft = () => {
  return globalState.timeout && globalState.timeout.getTimerLeft();
};

/**
 * Stop timer. Returns number of milliseconds of timer remained.
 * If `timer` parameter isn't set, returns undefined.
 *
 * @returns {number | undefined}
 */
const stopTimer = () => {
  if (globalState.timeout) {
    stopTimerProgressBar();
    return globalState.timeout.stop();
  }
};

/**
 * Resume timer. Returns number of milliseconds of timer remained.
 * If `timer` parameter isn't set, returns undefined.
 *
 * @returns {number | undefined}
 */
const resumeTimer = () => {
  if (globalState.timeout) {
    const remaining = globalState.timeout.start();
    animateTimerProgressBar(remaining);
    return remaining;
  }
};

/**
 * Resume timer. Returns number of milliseconds of timer remained.
 * If `timer` parameter isn't set, returns undefined.
 *
 * @returns {number | undefined}
 */
const toggleTimer = () => {
  const timer = globalState.timeout;
  return timer && (timer.running ? stopTimer() : resumeTimer());
};

/**
 * Increase timer. Returns number of milliseconds of an updated timer.
 * If `timer` parameter isn't set, returns undefined.
 *
 * @param {number} ms
 * @returns {number | undefined}
 */
const increaseTimer = ms => {
  if (globalState.timeout) {
    const remaining = globalState.timeout.increase(ms);
    animateTimerProgressBar(remaining, true);
    return remaining;
  }
};

/**
 * Check if timer is running. Returns true if timer is running
 * or false if timer is paused or stopped.
 * If `timer` parameter isn't set, returns undefined
 *
 * @returns {boolean}
 */
const isTimerRunning = () => {
  return !!(globalState.timeout && globalState.timeout.isRunning());
};

let bodyClickListenerAdded = false;
const clickHandlers = {};

/**
 * @param {string} attr
 */
function bindClickHandler() {
  let attr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'data-swal-template';
  clickHandlers[attr] = this;
  if (!bodyClickListenerAdded) {
    document.body.addEventListener('click', bodyClickListener);
    bodyClickListenerAdded = true;
  }
}
const bodyClickListener = event => {
  for (let el = event.target; el && el !== document; el = el.parentNode) {
    for (const attr in clickHandlers) {
      const template = el.getAttribute(attr);
      if (template) {
        clickHandlers[attr].fire({
          template
        });
        return;
      }
    }
  }
};

// Source: https://gist.github.com/mudge/5830382?permalink_comment_id=2691957#gistcomment-2691957

class EventEmitter {
  constructor() {
    /** @type {Events} */
    this.events = {};
  }

  /**
   * @param {string} eventName
   * @returns {EventHandlers}
   */
  _getHandlersByEventName(eventName) {
    if (typeof this.events[eventName] === 'undefined') {
      // not Set because we need to keep the FIFO order
      // https://github.com/sweetalert2/sweetalert2/pull/2763#discussion_r1748990334
      this.events[eventName] = [];
    }
    return this.events[eventName];
  }

  /**
   * @param {string} eventName
   * @param {EventHandler} eventHandler
   */
  on(eventName, eventHandler) {
    const currentHandlers = this._getHandlersByEventName(eventName);
    if (!currentHandlers.includes(eventHandler)) {
      currentHandlers.push(eventHandler);
    }
  }

  /**
   * @param {string} eventName
   * @param {EventHandler} eventHandler
   */
  once(eventName, eventHandler) {
    var _this = this;
    /**
     * @param {Array} args
     */
    const onceFn = function () {
      _this.removeListener(eventName, onceFn);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      eventHandler.apply(_this, args);
    };
    this.on(eventName, onceFn);
  }

  /**
   * @param {string} eventName
   * @param {Array} args
   */
  emit(eventName) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    this._getHandlersByEventName(eventName).forEach(
    /**
     * @param {EventHandler} eventHandler
     */
    eventHandler => {
      try {
        eventHandler.apply(this, args);
      } catch (error) {
        console.error(error);
      }
    });
  }

  /**
   * @param {string} eventName
   * @param {EventHandler} eventHandler
   */
  removeListener(eventName, eventHandler) {
    const currentHandlers = this._getHandlersByEventName(eventName);
    const index = currentHandlers.indexOf(eventHandler);
    if (index > -1) {
      currentHandlers.splice(index, 1);
    }
  }

  /**
   * @param {string} eventName
   */
  removeAllListeners(eventName) {
    if (this.events[eventName] !== undefined) {
      // https://github.com/sweetalert2/sweetalert2/pull/2763#discussion_r1749239222
      this.events[eventName].length = 0;
    }
  }
  reset() {
    this.events = {};
  }
}

globalState.eventEmitter = new EventEmitter();

/**
 * @param {string} eventName
 * @param {EventHandler} eventHandler
 */
const on$1 = (eventName, eventHandler) => {
  globalState.eventEmitter.on(eventName, eventHandler);
};

/**
 * @param {string} eventName
 * @param {EventHandler} eventHandler
 */
const once = (eventName, eventHandler) => {
  globalState.eventEmitter.once(eventName, eventHandler);
};

/**
 * @param {string} [eventName]
 * @param {EventHandler} [eventHandler]
 */
const off = (eventName, eventHandler) => {
  // Remove all handlers for all events
  if (!eventName) {
    globalState.eventEmitter.reset();
    return;
  }
  if (eventHandler) {
    // Remove a specific handler
    globalState.eventEmitter.removeListener(eventName, eventHandler);
  } else {
    // Remove all handlers for a specific event
    globalState.eventEmitter.removeAllListeners(eventName);
  }
};

var staticMethods = /*#__PURE__*/Object.freeze({
  __proto__: null,
  argsToParams: argsToParams,
  bindClickHandler: bindClickHandler,
  clickCancel: clickCancel,
  clickConfirm: clickConfirm,
  clickDeny: clickDeny,
  enableLoading: showLoading,
  fire: fire,
  getActions: getActions,
  getCancelButton: getCancelButton,
  getCloseButton: getCloseButton,
  getConfirmButton: getConfirmButton,
  getContainer: getContainer,
  getDenyButton: getDenyButton,
  getFocusableElements: getFocusableElements,
  getFooter: getFooter,
  getHtmlContainer: getHtmlContainer,
  getIcon: getIcon,
  getIconContent: getIconContent,
  getImage: getImage,
  getInputLabel: getInputLabel,
  getLoader: getLoader,
  getPopup: getPopup,
  getProgressSteps: getProgressSteps,
  getTimerLeft: getTimerLeft,
  getTimerProgressBar: getTimerProgressBar,
  getTitle: getTitle,
  getValidationMessage: getValidationMessage,
  increaseTimer: increaseTimer,
  isDeprecatedParameter: isDeprecatedParameter,
  isLoading: isLoading,
  isTimerRunning: isTimerRunning,
  isUpdatableParameter: isUpdatableParameter,
  isValidParameter: isValidParameter,
  isVisible: isVisible,
  mixin: mixin,
  off: off,
  on: on$1,
  once: once,
  resumeTimer: resumeTimer,
  showLoading: showLoading,
  stopTimer: stopTimer,
  toggleTimer: toggleTimer
});

class Timer {
  /**
   * @param {Function} callback
   * @param {number} delay
   */
  constructor(callback, delay) {
    this.callback = callback;
    this.remaining = delay;
    this.running = false;
    this.start();
  }

  /**
   * @returns {number}
   */
  start() {
    if (!this.running) {
      this.running = true;
      this.started = new Date();
      this.id = setTimeout(this.callback, this.remaining);
    }
    return this.remaining;
  }

  /**
   * @returns {number}
   */
  stop() {
    if (this.started && this.running) {
      this.running = false;
      clearTimeout(this.id);
      this.remaining -= new Date().getTime() - this.started.getTime();
    }
    return this.remaining;
  }

  /**
   * @param {number} n
   * @returns {number}
   */
  increase(n) {
    const running = this.running;
    if (running) {
      this.stop();
    }
    this.remaining += n;
    if (running) {
      this.start();
    }
    return this.remaining;
  }

  /**
   * @returns {number}
   */
  getTimerLeft() {
    if (this.running) {
      this.stop();
      this.start();
    }
    return this.remaining;
  }

  /**
   * @returns {boolean}
   */
  isRunning() {
    return this.running;
  }
}

const swalStringParams = ['swal-title', 'swal-html', 'swal-footer'];

/**
 * @param {SweetAlertOptions} params
 * @returns {SweetAlertOptions}
 */
const getTemplateParams = params => {
  const template = typeof params.template === 'string' ? (/** @type {HTMLTemplateElement} */document.querySelector(params.template)) : params.template;
  if (!template) {
    return {};
  }
  /** @type {DocumentFragment} */
  const templateContent = template.content;
  showWarningsForElements(templateContent);
  const result = Object.assign(getSwalParams(templateContent), getSwalFunctionParams(templateContent), getSwalButtons(templateContent), getSwalImage(templateContent), getSwalIcon(templateContent), getSwalInput(templateContent), getSwalStringParams(templateContent, swalStringParams));
  return result;
};

/**
 * @param {DocumentFragment} templateContent
 * @returns {Record<string, any>}
 */
const getSwalParams = templateContent => {
  /** @type {Record<string, any>} */
  const result = {};
  /** @type {HTMLElement[]} */
  const swalParams = Array.from(templateContent.querySelectorAll('swal-param'));
  swalParams.forEach(param => {
    showWarningsForAttributes(param, ['name', 'value']);
    const paramName = /** @type {keyof SweetAlertOptions} */param.getAttribute('name');
    const value = param.getAttribute('value');
    if (!paramName || !value) {
      return;
    }
    if (typeof defaultParams[paramName] === 'boolean') {
      result[paramName] = value !== 'false';
    } else if (typeof defaultParams[paramName] === 'object') {
      result[paramName] = JSON.parse(value);
    } else {
      result[paramName] = value;
    }
  });
  return result;
};

/**
 * @param {DocumentFragment} templateContent
 * @returns {Record<string, any>}
 */
const getSwalFunctionParams = templateContent => {
  /** @type {Record<string, any>} */
  const result = {};
  /** @type {HTMLElement[]} */
  const swalFunctions = Array.from(templateContent.querySelectorAll('swal-function-param'));
  swalFunctions.forEach(param => {
    const paramName = /** @type {keyof SweetAlertOptions} */param.getAttribute('name');
    const value = param.getAttribute('value');
    if (!paramName || !value) {
      return;
    }
    result[paramName] = new Function(`return ${value}`)();
  });
  return result;
};

/**
 * @param {DocumentFragment} templateContent
 * @returns {Record<string, any>}
 */
const getSwalButtons = templateContent => {
  /** @type {Record<string, any>} */
  const result = {};
  /** @type {HTMLElement[]} */
  const swalButtons = Array.from(templateContent.querySelectorAll('swal-button'));
  swalButtons.forEach(button => {
    showWarningsForAttributes(button, ['type', 'color', 'aria-label']);
    const type = button.getAttribute('type');
    if (!type || !['confirm', 'cancel', 'deny'].includes(type)) {
      return;
    }
    result[`${type}ButtonText`] = button.innerHTML;
    result[`show${capitalizeFirstLetter(type)}Button`] = true;
    if (button.hasAttribute('color')) {
      result[`${type}ButtonColor`] = button.getAttribute('color');
    }
    if (button.hasAttribute('aria-label')) {
      result[`${type}ButtonAriaLabel`] = button.getAttribute('aria-label');
    }
  });
  return result;
};

/**
 * @param {DocumentFragment} templateContent
 * @returns {Pick<SweetAlertOptions, 'imageUrl' | 'imageWidth' | 'imageHeight' | 'imageAlt'>}
 */
const getSwalImage = templateContent => {
  const result = {};
  /** @type {HTMLElement | null} */
  const image = templateContent.querySelector('swal-image');
  if (image) {
    showWarningsForAttributes(image, ['src', 'width', 'height', 'alt']);
    if (image.hasAttribute('src')) {
      result.imageUrl = image.getAttribute('src') || undefined;
    }
    if (image.hasAttribute('width')) {
      result.imageWidth = image.getAttribute('width') || undefined;
    }
    if (image.hasAttribute('height')) {
      result.imageHeight = image.getAttribute('height') || undefined;
    }
    if (image.hasAttribute('alt')) {
      result.imageAlt = image.getAttribute('alt') || undefined;
    }
  }
  return result;
};

/**
 * @param {DocumentFragment} templateContent
 * @returns {Record<string, any>}
 */
const getSwalIcon = templateContent => {
  const result = {};
  /** @type {HTMLElement | null} */
  const icon = templateContent.querySelector('swal-icon');
  if (icon) {
    showWarningsForAttributes(icon, ['type', 'color']);
    if (icon.hasAttribute('type')) {
      result.icon = icon.getAttribute('type');
    }
    if (icon.hasAttribute('color')) {
      result.iconColor = icon.getAttribute('color');
    }
    result.iconHtml = icon.innerHTML;
  }
  return result;
};

/**
 * @param {DocumentFragment} templateContent
 * @returns {Record<string, any>}
 */
const getSwalInput = templateContent => {
  /** @type {Record<string, any>} */
  const result = {};
  /** @type {HTMLElement | null} */
  const input = templateContent.querySelector('swal-input');
  if (input) {
    showWarningsForAttributes(input, ['type', 'label', 'placeholder', 'value']);
    result.input = input.getAttribute('type') || 'text';
    if (input.hasAttribute('label')) {
      result.inputLabel = input.getAttribute('label');
    }
    if (input.hasAttribute('placeholder')) {
      result.inputPlaceholder = input.getAttribute('placeholder');
    }
    if (input.hasAttribute('value')) {
      result.inputValue = input.getAttribute('value');
    }
  }
  /** @type {HTMLElement[]} */
  const inputOptions = Array.from(templateContent.querySelectorAll('swal-input-option'));
  if (inputOptions.length) {
    result.inputOptions = {};
    inputOptions.forEach(option => {
      showWarningsForAttributes(option, ['value']);
      const optionValue = option.getAttribute('value');
      if (!optionValue) {
        return;
      }
      const optionName = option.innerHTML;
      result.inputOptions[optionValue] = optionName;
    });
  }
  return result;
};

/**
 * @param {DocumentFragment} templateContent
 * @param {string[]} paramNames
 * @returns {Record<string, any>}
 */
const getSwalStringParams = (templateContent, paramNames) => {
  /** @type {Record<string, any>} */
  const result = {};
  for (const i in paramNames) {
    const paramName = paramNames[i];
    /** @type {HTMLElement | null} */
    const tag = templateContent.querySelector(paramName);
    if (tag) {
      showWarningsForAttributes(tag, []);
      result[paramName.replace(/^swal-/, '')] = tag.innerHTML.trim();
    }
  }
  return result;
};

/**
 * @param {DocumentFragment} templateContent
 */
const showWarningsForElements = templateContent => {
  const allowedElements = swalStringParams.concat(['swal-param', 'swal-function-param', 'swal-button', 'swal-image', 'swal-icon', 'swal-input', 'swal-input-option']);
  Array.from(templateContent.children).forEach(el => {
    const tagName = el.tagName.toLowerCase();
    if (!allowedElements.includes(tagName)) {
      warn(`Unrecognized element <${tagName}>`);
    }
  });
};

/**
 * @param {HTMLElement} el
 * @param {string[]} allowedAttributes
 */
const showWarningsForAttributes = (el, allowedAttributes) => {
  Array.from(el.attributes).forEach(attribute => {
    if (allowedAttributes.indexOf(attribute.name) === -1) {
      warn([`Unrecognized attribute "${attribute.name}" on <${el.tagName.toLowerCase()}>.`, `${allowedAttributes.length ? `Allowed attributes are: ${allowedAttributes.join(', ')}` : 'To set the value, use HTML within the element.'}`]);
    }
  });
};

const SHOW_CLASS_TIMEOUT = 10;

/**
 * Open popup, add necessary classes and styles, fix scrollbar
 *
 * @param {SweetAlertOptions} params
 */
const openPopup = params => {
  const container = getContainer();
  const popup = getPopup();
  if (typeof params.willOpen === 'function') {
    params.willOpen(popup);
  }
  globalState.eventEmitter.emit('willOpen', popup);
  const bodyStyles = window.getComputedStyle(document.body);
  const initialBodyOverflow = bodyStyles.overflowY;
  addClasses(container, popup, params);

  // scrolling is 'hidden' until animation is done, after that 'auto'
  setTimeout(() => {
    setScrollingVisibility(container, popup);
  }, SHOW_CLASS_TIMEOUT);
  if (isModal()) {
    fixScrollContainer(container, params.scrollbarPadding, initialBodyOverflow);
    setAriaHidden();
  }
  if (!isToast() && !globalState.previousActiveElement) {
    globalState.previousActiveElement = document.activeElement;
  }
  if (typeof params.didOpen === 'function') {
    setTimeout(() => params.didOpen(popup));
  }
  globalState.eventEmitter.emit('didOpen', popup);
  removeClass(container, swalClasses['no-transition']);
};

/**
 * @param {AnimationEvent} event
 */
const swalOpenAnimationFinished = event => {
  const popup = getPopup();
  if (event.target !== popup) {
    return;
  }
  const container = getContainer();
  popup.removeEventListener('animationend', swalOpenAnimationFinished);
  popup.removeEventListener('transitionend', swalOpenAnimationFinished);
  container.style.overflowY = 'auto';
};

/**
 * @param {HTMLElement} container
 * @param {HTMLElement} popup
 */
const setScrollingVisibility = (container, popup) => {
  if (hasCssAnimation(popup)) {
    container.style.overflowY = 'hidden';
    popup.addEventListener('animationend', swalOpenAnimationFinished);
    popup.addEventListener('transitionend', swalOpenAnimationFinished);
  } else {
    container.style.overflowY = 'auto';
  }
};

/**
 * @param {HTMLElement} container
 * @param {boolean} scrollbarPadding
 * @param {string} initialBodyOverflow
 */
const fixScrollContainer = (container, scrollbarPadding, initialBodyOverflow) => {
  iOSfix();
  if (scrollbarPadding && initialBodyOverflow !== 'hidden') {
    replaceScrollbarWithPadding(initialBodyOverflow);
  }

  // sweetalert2/issues/1247
  setTimeout(() => {
    container.scrollTop = 0;
  });
};

/**
 * @param {HTMLElement} container
 * @param {HTMLElement} popup
 * @param {SweetAlertOptions} params
 */
const addClasses = (container, popup, params) => {
  addClass(container, params.showClass.backdrop);
  if (params.animation) {
    // this workaround with opacity is needed for https://github.com/sweetalert2/sweetalert2/issues/2059
    popup.style.setProperty('opacity', '0', 'important');
    show(popup, 'grid');
    setTimeout(() => {
      // Animate popup right after showing it
      addClass(popup, params.showClass.popup);
      // and remove the opacity workaround
      popup.style.removeProperty('opacity');
    }, SHOW_CLASS_TIMEOUT); // 10ms in order to fix #2062
  } else {
    show(popup, 'grid');
  }
  addClass([document.documentElement, document.body], swalClasses.shown);
  if (params.heightAuto && params.backdrop && !params.toast) {
    addClass([document.documentElement, document.body], swalClasses['height-auto']);
  }
};

var defaultInputValidators = {
  /**
   * @param {string} string
   * @param {string} [validationMessage]
   * @returns {Promise<string | void>}
   */
  email: (string, validationMessage) => {
    return /^[a-zA-Z0-9.+_'-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]+$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || 'Invalid email address');
  },
  /**
   * @param {string} string
   * @param {string} [validationMessage]
   * @returns {Promise<string | void>}
   */
  url: (string, validationMessage) => {
    // taken from https://stackoverflow.com/a/3809435 with a small change from #1306 and #2013
    return /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || 'Invalid URL');
  }
};

/**
 * @param {SweetAlertOptions} params
 */
function setDefaultInputValidators(params) {
  // Use default `inputValidator` for supported input types if not provided
  if (params.inputValidator) {
    return;
  }
  if (params.input === 'email') {
    params.inputValidator = defaultInputValidators['email'];
  }
  if (params.input === 'url') {
    params.inputValidator = defaultInputValidators['url'];
  }
}

/**
 * @param {SweetAlertOptions} params
 */
function validateCustomTargetElement(params) {
  // Determine if the custom target element is valid
  if (!params.target || typeof params.target === 'string' && !document.querySelector(params.target) || typeof params.target !== 'string' && !params.target.appendChild) {
    warn('Target parameter is not valid, defaulting to "body"');
    params.target = 'body';
  }
}

/**
 * Set type, text and actions on popup
 *
 * @param {SweetAlertOptions} params
 */
function setParameters(params) {
  setDefaultInputValidators(params);

  // showLoaderOnConfirm && preConfirm
  if (params.showLoaderOnConfirm && !params.preConfirm) {
    warn('showLoaderOnConfirm is set to true, but preConfirm is not defined.\n' + 'showLoaderOnConfirm should be used together with preConfirm, see usage example:\n' + 'https://sweetalert2.github.io/#ajax-request');
  }
  validateCustomTargetElement(params);

  // Replace newlines with <br> in title
  if (typeof params.title === 'string') {
    params.title = params.title.split('\n').join('<br />');
  }
  init(params);
}

/** @type {SweetAlert} */
let currentInstance;
var _promise = /*#__PURE__*/new WeakMap();
class SweetAlert {
  /**
   * @param {...any} args
   * @this {SweetAlert}
   */
  constructor() {
    /**
     * @type {Promise<SweetAlertResult>}
     */
    _classPrivateFieldInitSpec(this, _promise, void 0);
    // Prevent run in Node env
    if (typeof window === 'undefined') {
      return;
    }
    currentInstance = this;

    // @ts-ignore
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    const outerParams = Object.freeze(this.constructor.argsToParams(args));

    /** @type {Readonly<SweetAlertOptions>} */
    this.params = outerParams;

    /** @type {boolean} */
    this.isAwaitingPromise = false;
    _classPrivateFieldSet2(_promise, this, this._main(currentInstance.params));
  }
  _main(userParams) {
    let mixinParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    showWarningsForParams(Object.assign({}, mixinParams, userParams));
    if (globalState.currentInstance) {
      const swalPromiseResolve = privateMethods.swalPromiseResolve.get(globalState.currentInstance);
      const {
        isAwaitingPromise
      } = globalState.currentInstance;
      globalState.currentInstance._destroy();
      if (!isAwaitingPromise) {
        swalPromiseResolve({
          isDismissed: true
        });
      }
      if (isModal()) {
        unsetAriaHidden();
      }
    }
    globalState.currentInstance = currentInstance;
    const innerParams = prepareParams(userParams, mixinParams);
    setParameters(innerParams);
    Object.freeze(innerParams);

    // clear the previous timer
    if (globalState.timeout) {
      globalState.timeout.stop();
      delete globalState.timeout;
    }

    // clear the restore focus timeout
    clearTimeout(globalState.restoreFocusTimeout);
    const domCache = populateDomCache(currentInstance);
    render(currentInstance, innerParams);
    privateProps.innerParams.set(currentInstance, innerParams);
    return swalPromise(currentInstance, domCache, innerParams);
  }

  // `catch` cannot be the name of a module export, so we define our thenable methods here instead
  then(onFulfilled) {
    return _classPrivateFieldGet2(_promise, this).then(onFulfilled);
  }
  finally(onFinally) {
    return _classPrivateFieldGet2(_promise, this).finally(onFinally);
  }
}

/**
 * @param {SweetAlert} instance
 * @param {DomCache} domCache
 * @param {SweetAlertOptions} innerParams
 * @returns {Promise}
 */
const swalPromise = (instance, domCache, innerParams) => {
  return new Promise((resolve, reject) => {
    // functions to handle all closings/dismissals
    /**
     * @param {DismissReason} dismiss
     */
    const dismissWith = dismiss => {
      instance.close({
        isDismissed: true,
        dismiss
      });
    };
    privateMethods.swalPromiseResolve.set(instance, resolve);
    privateMethods.swalPromiseReject.set(instance, reject);
    domCache.confirmButton.onclick = () => {
      handleConfirmButtonClick(instance);
    };
    domCache.denyButton.onclick = () => {
      handleDenyButtonClick(instance);
    };
    domCache.cancelButton.onclick = () => {
      handleCancelButtonClick(instance, dismissWith);
    };
    domCache.closeButton.onclick = () => {
      dismissWith(DismissReason.close);
    };
    handlePopupClick(innerParams, domCache, dismissWith);
    addKeydownHandler(globalState, innerParams, dismissWith);
    handleInputOptionsAndValue(instance, innerParams);
    openPopup(innerParams);
    setupTimer(globalState, innerParams, dismissWith);
    initFocus(domCache, innerParams);

    // Scroll container to top on open (#1247, #1946)
    setTimeout(() => {
      domCache.container.scrollTop = 0;
    });
  });
};

/**
 * @param {SweetAlertOptions} userParams
 * @param {SweetAlertOptions} mixinParams
 * @returns {SweetAlertOptions}
 */
const prepareParams = (userParams, mixinParams) => {
  const templateParams = getTemplateParams(userParams);
  const params = Object.assign({}, defaultParams, mixinParams, templateParams, userParams); // precedence is described in #2131
  params.showClass = Object.assign({}, defaultParams.showClass, params.showClass);
  params.hideClass = Object.assign({}, defaultParams.hideClass, params.hideClass);
  if (params.animation === false) {
    params.showClass = {
      backdrop: 'swal2-noanimation'
    };
    params.hideClass = {};
  }
  return params;
};

/**
 * @param {SweetAlert} instance
 * @returns {DomCache}
 */
const populateDomCache = instance => {
  const domCache = {
    popup: getPopup(),
    container: getContainer(),
    actions: getActions(),
    confirmButton: getConfirmButton(),
    denyButton: getDenyButton(),
    cancelButton: getCancelButton(),
    loader: getLoader(),
    closeButton: getCloseButton(),
    validationMessage: getValidationMessage(),
    progressSteps: getProgressSteps()
  };
  privateProps.domCache.set(instance, domCache);
  return domCache;
};

/**
 * @param {GlobalState} globalState
 * @param {SweetAlertOptions} innerParams
 * @param {Function} dismissWith
 */
const setupTimer = (globalState, innerParams, dismissWith) => {
  const timerProgressBar = getTimerProgressBar();
  hide$2(timerProgressBar);
  if (innerParams.timer) {
    globalState.timeout = new Timer(() => {
      dismissWith('timer');
      delete globalState.timeout;
    }, innerParams.timer);
    if (innerParams.timerProgressBar) {
      show(timerProgressBar);
      applyCustomClass(timerProgressBar, innerParams, 'timerProgressBar');
      setTimeout(() => {
        if (globalState.timeout && globalState.timeout.running) {
          // timer can be already stopped or unset at this point
          animateTimerProgressBar(innerParams.timer);
        }
      });
    }
  }
};

/**
 * Initialize focus in the popup:
 *
 * 1. If `toast` is `true`, don't steal focus from the document.
 * 2. Else if there is an [autofocus] element, focus it.
 * 3. Else if `focusConfirm` is `true` and confirm button is visible, focus it.
 * 4. Else if `focusDeny` is `true` and deny button is visible, focus it.
 * 5. Else if `focusCancel` is `true` and cancel button is visible, focus it.
 * 6. Else focus the first focusable element in a popup (if any).
 *
 * @param {DomCache} domCache
 * @param {SweetAlertOptions} innerParams
 */
const initFocus = (domCache, innerParams) => {
  if (innerParams.toast) {
    return;
  }
  // TODO: this is dumb, remove `allowEnterKey` param in the next major version
  if (!callIfFunction(innerParams.allowEnterKey)) {
    warnAboutDeprecation('allowEnterKey');
    blurActiveElement();
    return;
  }
  if (focusAutofocus(domCache)) {
    return;
  }
  if (focusButton(domCache, innerParams)) {
    return;
  }
  setFocus(-1, 1);
};

/**
 * @param {DomCache} domCache
 * @returns {boolean}
 */
const focusAutofocus = domCache => {
  const autofocusElements = Array.from(domCache.popup.querySelectorAll('[autofocus]'));
  for (const autofocusElement of autofocusElements) {
    if (autofocusElement instanceof HTMLElement && isVisible$1(autofocusElement)) {
      autofocusElement.focus();
      return true;
    }
  }
  return false;
};

/**
 * @param {DomCache} domCache
 * @param {SweetAlertOptions} innerParams
 * @returns {boolean}
 */
const focusButton = (domCache, innerParams) => {
  if (innerParams.focusDeny && isVisible$1(domCache.denyButton)) {
    domCache.denyButton.focus();
    return true;
  }
  if (innerParams.focusCancel && isVisible$1(domCache.cancelButton)) {
    domCache.cancelButton.focus();
    return true;
  }
  if (innerParams.focusConfirm && isVisible$1(domCache.confirmButton)) {
    domCache.confirmButton.focus();
    return true;
  }
  return false;
};
const blurActiveElement = () => {
  if (document.activeElement instanceof HTMLElement && typeof document.activeElement.blur === 'function') {
    document.activeElement.blur();
  }
};

// Dear russian users visiting russian sites. Let's have fun.
if (typeof window !== 'undefined' && /^ru\b/.test(navigator.language) && location.host.match(/\.(ru|su|by|xn--p1ai)$/)) {
  const now = new Date();
  const initiationDate = localStorage.getItem('swal-initiation');
  if (!initiationDate) {
    localStorage.setItem('swal-initiation', `${now}`);
  } else if ((now.getTime() - Date.parse(initiationDate)) / (1000 * 60 * 60 * 24) > 3) {
    setTimeout(() => {
      document.body.style.pointerEvents = 'none';
      const ukrainianAnthem = document.createElement('audio');
      ukrainianAnthem.src = 'https://flag-gimn.ru/wp-content/uploads/2021/09/Ukraina.mp3';
      ukrainianAnthem.loop = true;
      document.body.appendChild(ukrainianAnthem);
      setTimeout(() => {
        ukrainianAnthem.play().catch(() => {
          // ignore
        });
      }, 2500);
    }, 500);
  }
}

// Assign instance methods from src/instanceMethods/*.js to prototype
SweetAlert.prototype.disableButtons = disableButtons;
SweetAlert.prototype.enableButtons = enableButtons;
SweetAlert.prototype.getInput = getInput;
SweetAlert.prototype.disableInput = disableInput;
SweetAlert.prototype.enableInput = enableInput;
SweetAlert.prototype.hideLoading = hideLoading;
SweetAlert.prototype.disableLoading = hideLoading;
SweetAlert.prototype.showValidationMessage = showValidationMessage;
SweetAlert.prototype.resetValidationMessage = resetValidationMessage;
SweetAlert.prototype.close = close;
SweetAlert.prototype.closePopup = close;
SweetAlert.prototype.closeModal = close;
SweetAlert.prototype.closeToast = close;
SweetAlert.prototype.rejectPromise = rejectPromise;
SweetAlert.prototype.update = update;
SweetAlert.prototype._destroy = _destroy;

// Assign static methods from src/staticMethods/*.js to constructor
Object.assign(SweetAlert, staticMethods);

// Proxy to instance methods to constructor, for now, for backwards compatibility
Object.keys(instanceMethods).forEach(key => {
  /**
   * @param {...any} args
   * @returns {any | undefined}
   */
  SweetAlert[key] = function () {
    if (currentInstance && currentInstance[key]) {
      return currentInstance[key](...arguments);
    }
    return null;
  };
});
SweetAlert.DismissReason = DismissReason;
SweetAlert.version = '11.21.0';

const Swal = SweetAlert;
// @ts-ignore
Swal.default = Swal;
"undefined"!=typeof document&&function(e,t){var n=e.createElement("style");if(e.getElementsByTagName("head")[0].appendChild(n),n.styleSheet)n.styleSheet.disabled||(n.styleSheet.cssText=t);else try{n.innerHTML=t;}catch(e){n.innerText=t;}}(document,":root{--swal2-outline: 0 0 0 3px rgba(100, 150, 200, 0.5);--swal2-container-padding: 0.625em;--swal2-backdrop: rgba(0, 0, 0, 0.4);--swal2-backdrop-transition: background-color 0.1s;--swal2-width: 32em;--swal2-padding: 0 0 1.25em;--swal2-border: none;--swal2-border-radius: 0.3125rem;--swal2-background: white;--swal2-color: #545454;--swal2-footer-border-color: #eee;--swal2-show-animation: swal2-show 0.3s;--swal2-hide-animation: swal2-hide 0.15s forwards;--swal2-icon-zoom: 1;--swal2-icon-animations: true;--swal2-title-padding: 0.8em 1em 0;--swal2-html-container-padding: 1em 1.6em 0.3em;--swal2-input-border-radius: 0.1875em;--swal2-input-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.06), 0 0 0 3px transparent;--swal2-input-background: transparent;--swal2-input-transition: border-color 0.1s, box-shadow 0.1s;--swal2-progress-step-background: #add8e6;--swal2-validation-message-background: #f0f0f0;--swal2-validation-message-color: #666;--swal2-close-button-position: initial;--swal2-close-button-inset: auto;--swal2-close-button-font-size: 2.5em;--swal2-close-button-color: #ccc;--swal2-close-button-transition: color 0.1s, box-shadow 0.1s;--swal2-close-button-outline: initial;--swal2-close-button-box-shadow: inset 0 0 0 3px transparent;--swal2-close-button-focus-box-shadow: inset var(--swal2-outline);--swal2-close-button-hover-transform: none;--swal2-button-darken-hover: rgba(0, 0, 0, 0.1);--swal2-button-darken-active: rgba(0, 0, 0, 0.2);--swal2-button-transition: box-shadow 0.1s;--swal2-confirm-button-border: 0;--swal2-confirm-button-border-radius: 0.25em;--swal2-confirm-button-background-color: #7066e0;--swal2-deny-button-border: 0;--swal2-deny-button-border-radius: 0.25em;--swal2-deny-button-background-color: #dc3741;--swal2-cancel-button-border: 0;--swal2-cancel-button-border-radius: 0.25em;--swal2-cancel-button-background-color: #6e7881;--swal2-toast-show-animation: swal2-toast-show 0.5s;--swal2-toast-hide-animation: swal2-toast-hide 0.1s forwards;--swal2-toast-border: none;--swal2-toast-box-shadow: 0 0 1px hsl(0deg 0% 0% / 0.075), 0 1px 2px hsl(0deg 0% 0% / 0.075), 1px 2px 4px hsl(0deg 0% 0% / 0.075), 1px 3px 8px hsl(0deg 0% 0% / 0.075), 2px 4px 16px hsl(0deg 0% 0% / 0.075)}[data-swal2-theme=dark]{--swal2-dark-theme-black: #19191a;--swal2-dark-theme-white: #e1e1e1;--swal2-background: var(--swal2-dark-theme-black);--swal2-color: var(--swal2-dark-theme-white);--swal2-footer-border-color: #555;--swal2-input-background: color-mix(in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10%);--swal2-validation-message-background: color-mix( in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10% );--swal2-validation-message-color: var(--swal2-dark-theme-white)}@media(prefers-color-scheme: dark){[data-swal2-theme=auto]{--swal2-dark-theme-black: #19191a;--swal2-dark-theme-white: #e1e1e1;--swal2-background: var(--swal2-dark-theme-black);--swal2-color: var(--swal2-dark-theme-white);--swal2-footer-border-color: #555;--swal2-input-background: color-mix(in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10%);--swal2-validation-message-background: color-mix( in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10% );--swal2-validation-message-color: var(--swal2-dark-theme-white)}}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown){overflow:hidden}body.swal2-height-auto{height:auto !important}body.swal2-no-backdrop .swal2-container{background-color:rgba(0,0,0,0) !important;pointer-events:none}body.swal2-no-backdrop .swal2-container .swal2-popup{pointer-events:all}body.swal2-no-backdrop .swal2-container .swal2-modal{box-shadow:0 0 10px var(--swal2-backdrop)}body.swal2-toast-shown .swal2-container{box-sizing:border-box;width:360px;max-width:100%;background-color:rgba(0,0,0,0);pointer-events:none}body.swal2-toast-shown .swal2-container.swal2-top{inset:0 auto auto 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-top-end,body.swal2-toast-shown .swal2-container.swal2-top-right{inset:0 0 auto auto}body.swal2-toast-shown .swal2-container.swal2-top-start,body.swal2-toast-shown .swal2-container.swal2-top-left{inset:0 auto auto 0}body.swal2-toast-shown .swal2-container.swal2-center-start,body.swal2-toast-shown .swal2-container.swal2-center-left{inset:50% auto auto 0;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-center{inset:50% auto auto 50%;transform:translate(-50%, -50%)}body.swal2-toast-shown .swal2-container.swal2-center-end,body.swal2-toast-shown .swal2-container.swal2-center-right{inset:50% 0 auto auto;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-start,body.swal2-toast-shown .swal2-container.swal2-bottom-left{inset:auto auto 0 0}body.swal2-toast-shown .swal2-container.swal2-bottom{inset:auto auto 0 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-end,body.swal2-toast-shown .swal2-container.swal2-bottom-right{inset:auto 0 0 auto}@media print{body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown){overflow-y:scroll !important}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown)>[aria-hidden=true]{display:none}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown) .swal2-container{position:static !important}}div:where(.swal2-container){display:grid;position:fixed;z-index:1060;inset:0;box-sizing:border-box;grid-template-areas:\"top-start     top            top-end\" \"center-start  center         center-end\" \"bottom-start  bottom-center  bottom-end\";grid-template-rows:minmax(min-content, auto) minmax(min-content, auto) minmax(min-content, auto);height:100%;padding:var(--swal2-container-padding);overflow-x:hidden;transition:var(--swal2-backdrop-transition);-webkit-overflow-scrolling:touch}div:where(.swal2-container).swal2-backdrop-show,div:where(.swal2-container).swal2-noanimation{background:var(--swal2-backdrop)}div:where(.swal2-container).swal2-backdrop-hide{background:rgba(0,0,0,0) !important}div:where(.swal2-container).swal2-top-start,div:where(.swal2-container).swal2-center-start,div:where(.swal2-container).swal2-bottom-start{grid-template-columns:minmax(0, 1fr) auto auto}div:where(.swal2-container).swal2-top,div:where(.swal2-container).swal2-center,div:where(.swal2-container).swal2-bottom{grid-template-columns:auto minmax(0, 1fr) auto}div:where(.swal2-container).swal2-top-end,div:where(.swal2-container).swal2-center-end,div:where(.swal2-container).swal2-bottom-end{grid-template-columns:auto auto minmax(0, 1fr)}div:where(.swal2-container).swal2-top-start>.swal2-popup{align-self:start}div:where(.swal2-container).swal2-top>.swal2-popup{grid-column:2;place-self:start center}div:where(.swal2-container).swal2-top-end>.swal2-popup,div:where(.swal2-container).swal2-top-right>.swal2-popup{grid-column:3;place-self:start end}div:where(.swal2-container).swal2-center-start>.swal2-popup,div:where(.swal2-container).swal2-center-left>.swal2-popup{grid-row:2;align-self:center}div:where(.swal2-container).swal2-center>.swal2-popup{grid-column:2;grid-row:2;place-self:center center}div:where(.swal2-container).swal2-center-end>.swal2-popup,div:where(.swal2-container).swal2-center-right>.swal2-popup{grid-column:3;grid-row:2;place-self:center end}div:where(.swal2-container).swal2-bottom-start>.swal2-popup,div:where(.swal2-container).swal2-bottom-left>.swal2-popup{grid-column:1;grid-row:3;align-self:end}div:where(.swal2-container).swal2-bottom>.swal2-popup{grid-column:2;grid-row:3;place-self:end center}div:where(.swal2-container).swal2-bottom-end>.swal2-popup,div:where(.swal2-container).swal2-bottom-right>.swal2-popup{grid-column:3;grid-row:3;place-self:end end}div:where(.swal2-container).swal2-grow-row>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-column:1/4;width:100%}div:where(.swal2-container).swal2-grow-column>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-row:1/4;align-self:stretch}div:where(.swal2-container).swal2-no-transition{transition:none !important}div:where(.swal2-container)[popover]{width:auto;border:0}div:where(.swal2-container) div:where(.swal2-popup){display:none;position:relative;box-sizing:border-box;grid-template-columns:minmax(0, 100%);width:var(--swal2-width);max-width:100%;padding:var(--swal2-padding);border:var(--swal2-border);border-radius:var(--swal2-border-radius);background:var(--swal2-background);color:var(--swal2-color);font-family:inherit;font-size:1rem;container-name:swal2-popup}div:where(.swal2-container) div:where(.swal2-popup):focus{outline:none}div:where(.swal2-container) div:where(.swal2-popup).swal2-loading{overflow-y:hidden}div:where(.swal2-container) div:where(.swal2-popup).swal2-draggable{cursor:grab}div:where(.swal2-container) div:where(.swal2-popup).swal2-draggable div:where(.swal2-icon){cursor:grab}div:where(.swal2-container) div:where(.swal2-popup).swal2-dragging{cursor:grabbing}div:where(.swal2-container) div:where(.swal2-popup).swal2-dragging div:where(.swal2-icon){cursor:grabbing}div:where(.swal2-container) h2:where(.swal2-title){position:relative;max-width:100%;margin:0;padding:var(--swal2-title-padding);color:inherit;font-size:1.875em;font-weight:600;text-align:center;text-transform:none;word-wrap:break-word;cursor:initial}div:where(.swal2-container) div:where(.swal2-actions){display:flex;z-index:1;box-sizing:border-box;flex-wrap:wrap;align-items:center;justify-content:center;width:auto;margin:1.25em auto 0;padding:0}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled[disabled]{opacity:.4}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled:hover{background-image:linear-gradient(var(--swal2-button-darken-hover), var(--swal2-button-darken-hover))}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled:active{background-image:linear-gradient(var(--swal2-button-darken-active), var(--swal2-button-darken-active))}div:where(.swal2-container) div:where(.swal2-loader){display:none;align-items:center;justify-content:center;width:2.2em;height:2.2em;margin:0 1.875em;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;border-width:.25em;border-style:solid;border-radius:100%;border-color:#2778c4 rgba(0,0,0,0) #2778c4 rgba(0,0,0,0)}div:where(.swal2-container) button:where(.swal2-styled){margin:.3125em;padding:.625em 1.1em;transition:var(--swal2-button-transition);box-shadow:0 0 0 3px rgba(0,0,0,0);font-weight:500}div:where(.swal2-container) button:where(.swal2-styled):not([disabled]){cursor:pointer}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-confirm){border:var(--swal2-confirm-button-border);border-radius:var(--swal2-confirm-button-border-radius);background:initial;background-color:var(--swal2-confirm-button-background-color);color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-deny){border:var(--swal2-deny-button-border);border-radius:var(--swal2-deny-button-border-radius);background:initial;background-color:var(--swal2-deny-button-background-color);color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-cancel){border:var(--swal2-cancel-button-border);border-radius:var(--swal2-cancel-button-border-radius);background:initial;background-color:var(--swal2-cancel-button-background-color);color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):focus-visible{outline:none;box-shadow:var(--swal2-action-button-outline)}div:where(.swal2-container) button:where(.swal2-styled)::-moz-focus-inner{border:0}div:where(.swal2-container) div:where(.swal2-footer){margin:1em 0 0;padding:1em 1em 0;border-top:1px solid var(--swal2-footer-border-color);color:inherit;font-size:1em;text-align:center;cursor:initial}div:where(.swal2-container) .swal2-timer-progress-bar-container{position:absolute;right:0;bottom:0;left:0;grid-column:auto !important;overflow:hidden;border-bottom-right-radius:var(--swal2-border-radius);border-bottom-left-radius:var(--swal2-border-radius)}div:where(.swal2-container) div:where(.swal2-timer-progress-bar){width:100%;height:.25em;background:rgba(0,0,0,.2)}div:where(.swal2-container) img:where(.swal2-image){max-width:100%;margin:2em auto 1em;cursor:initial}div:where(.swal2-container) button:where(.swal2-close){position:var(--swal2-close-button-position);inset:var(--swal2-close-button-inset);z-index:2;align-items:center;justify-content:center;width:1.2em;height:1.2em;margin-top:0;margin-right:0;margin-bottom:-1.2em;padding:0;overflow:hidden;transition:var(--swal2-close-button-transition);border:none;border-radius:var(--swal2-border-radius);outline:var(--swal2-close-button-outline);background:rgba(0,0,0,0);color:var(--swal2-close-button-color);font-family:monospace;font-size:var(--swal2-close-button-font-size);cursor:pointer;justify-self:end}div:where(.swal2-container) button:where(.swal2-close):hover{transform:var(--swal2-close-button-hover-transform);background:rgba(0,0,0,0);color:#f27474}div:where(.swal2-container) button:where(.swal2-close):focus-visible{outline:none;box-shadow:var(--swal2-close-button-focus-box-shadow)}div:where(.swal2-container) button:where(.swal2-close)::-moz-focus-inner{border:0}div:where(.swal2-container) div:where(.swal2-html-container){z-index:1;justify-content:center;margin:0;padding:var(--swal2-html-container-padding);overflow:auto;color:inherit;font-size:1.125em;font-weight:normal;line-height:normal;text-align:center;word-wrap:break-word;word-break:break-word;cursor:initial}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea),div:where(.swal2-container) select:where(.swal2-select),div:where(.swal2-container) div:where(.swal2-radio),div:where(.swal2-container) label:where(.swal2-checkbox){margin:1em 2em 3px}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea){box-sizing:border-box;width:auto;transition:var(--swal2-input-transition);border:1px solid #d9d9d9;border-radius:var(--swal2-input-border-radius);background:var(--swal2-input-background);box-shadow:var(--swal2-input-box-shadow);color:inherit;font-size:1.125em}div:where(.swal2-container) input:where(.swal2-input).swal2-inputerror,div:where(.swal2-container) input:where(.swal2-file).swal2-inputerror,div:where(.swal2-container) textarea:where(.swal2-textarea).swal2-inputerror{border-color:#f27474 !important;box-shadow:0 0 2px #f27474 !important}div:where(.swal2-container) input:where(.swal2-input):focus,div:where(.swal2-container) input:where(.swal2-file):focus,div:where(.swal2-container) textarea:where(.swal2-textarea):focus{border:1px solid #b4dbed;outline:none;box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px rgba(100,150,200,.5)}div:where(.swal2-container) input:where(.swal2-input)::placeholder,div:where(.swal2-container) input:where(.swal2-file)::placeholder,div:where(.swal2-container) textarea:where(.swal2-textarea)::placeholder{color:#ccc}div:where(.swal2-container) .swal2-range{margin:1em 2em 3px;background:var(--swal2-background)}div:where(.swal2-container) .swal2-range input{width:80%}div:where(.swal2-container) .swal2-range output{width:20%;color:inherit;font-weight:600;text-align:center}div:where(.swal2-container) .swal2-range input,div:where(.swal2-container) .swal2-range output{height:2.625em;padding:0;font-size:1.125em;line-height:2.625em}div:where(.swal2-container) .swal2-input{height:2.625em;padding:0 .75em}div:where(.swal2-container) .swal2-file{width:75%;margin-right:auto;margin-left:auto;background:var(--swal2-input-background);font-size:1.125em}div:where(.swal2-container) .swal2-textarea{height:6.75em;padding:.75em}div:where(.swal2-container) .swal2-select{min-width:50%;max-width:100%;padding:.375em .625em;background:var(--swal2-input-background);color:inherit;font-size:1.125em}div:where(.swal2-container) .swal2-radio,div:where(.swal2-container) .swal2-checkbox{align-items:center;justify-content:center;background:var(--swal2-background);color:inherit}div:where(.swal2-container) .swal2-radio label,div:where(.swal2-container) .swal2-checkbox label{margin:0 .6em;font-size:1.125em}div:where(.swal2-container) .swal2-radio input,div:where(.swal2-container) .swal2-checkbox input{flex-shrink:0;margin:0 .4em}div:where(.swal2-container) label:where(.swal2-input-label){display:flex;justify-content:center;margin:1em auto 0}div:where(.swal2-container) div:where(.swal2-validation-message){align-items:center;justify-content:center;margin:1em 0 0;padding:.625em;overflow:hidden;background:var(--swal2-validation-message-background);color:var(--swal2-validation-message-color);font-size:1em;font-weight:300}div:where(.swal2-container) div:where(.swal2-validation-message)::before{content:\"!\";display:inline-block;width:1.5em;min-width:1.5em;height:1.5em;margin:0 .625em;border-radius:50%;background-color:#f27474;color:#fff;font-weight:600;line-height:1.5em;text-align:center}div:where(.swal2-container) .swal2-progress-steps{flex-wrap:wrap;align-items:center;max-width:100%;margin:1.25em auto;padding:0;background:rgba(0,0,0,0);font-weight:600}div:where(.swal2-container) .swal2-progress-steps li{display:inline-block;position:relative}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step{z-index:20;flex-shrink:0;width:2em;height:2em;border-radius:2em;background:#2778c4;color:#fff;line-height:2em;text-align:center}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step{background:#2778c4}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step{background:var(--swal2-progress-step-background);color:#fff}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step-line{background:var(--swal2-progress-step-background)}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step-line{z-index:10;flex-shrink:0;width:2.5em;height:.4em;margin:0 -1px;background:#2778c4}div:where(.swal2-icon){position:relative;box-sizing:content-box;justify-content:center;width:5em;height:5em;margin:2.5em auto .6em;zoom:var(--swal2-icon-zoom);border:.25em solid rgba(0,0,0,0);border-radius:50%;border-color:#000;font-family:inherit;line-height:5em;cursor:default;user-select:none}div:where(.swal2-icon) .swal2-icon-content{display:flex;align-items:center;font-size:3.75em}div:where(.swal2-icon).swal2-error{border-color:#f27474;color:#f27474}div:where(.swal2-icon).swal2-error .swal2-x-mark{position:relative;flex-grow:1}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line]{display:block;position:absolute;top:2.3125em;width:2.9375em;height:.3125em;border-radius:.125em;background-color:#f27474}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=left]{left:1.0625em;transform:rotate(45deg)}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=right]{right:1em;transform:rotate(-45deg)}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-error.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-error.swal2-icon-show .swal2-x-mark{animation:swal2-animate-error-x-mark .5s}}div:where(.swal2-icon).swal2-warning{border-color:#f8bb86;color:#f8bb86}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-warning.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-warning.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .5s}}div:where(.swal2-icon).swal2-info{border-color:#3fc3ee;color:#3fc3ee}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-info.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-info.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .8s}}div:where(.swal2-icon).swal2-question{border-color:#87adbd;color:#87adbd}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-question.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-question.swal2-icon-show .swal2-icon-content{animation:swal2-animate-question-mark .8s}}div:where(.swal2-icon).swal2-success{border-color:#a5dc86;color:#a5dc86}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line]{position:absolute;width:3.75em;height:7.5em;border-radius:50%}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.4375em;left:-2.0635em;transform:rotate(-45deg);transform-origin:3.75em 3.75em;border-radius:7.5em 0 0 7.5em}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.6875em;left:1.875em;transform:rotate(-45deg);transform-origin:0 3.75em;border-radius:0 7.5em 7.5em 0}div:where(.swal2-icon).swal2-success .swal2-success-ring{position:absolute;z-index:2;top:-0.25em;left:-0.25em;box-sizing:content-box;width:100%;height:100%;border:.25em solid rgba(165,220,134,.3);border-radius:50%}div:where(.swal2-icon).swal2-success .swal2-success-fix{position:absolute;z-index:1;top:.5em;left:1.625em;width:.4375em;height:5.625em;transform:rotate(-45deg)}div:where(.swal2-icon).swal2-success [class^=swal2-success-line]{display:block;position:absolute;z-index:2;height:.3125em;border-radius:.125em;background-color:#a5dc86}div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=tip]{top:2.875em;left:.8125em;width:1.5625em;transform:rotate(45deg)}div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=long]{top:2.375em;right:.5em;width:2.9375em;transform:rotate(-45deg)}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-animate-success-line-tip .75s}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-animate-success-line-long .75s}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-circular-line-right{animation:swal2-rotate-success-circular-line 4.25s ease-in}}[class^=swal2]{-webkit-tap-highlight-color:rgba(0,0,0,0)}.swal2-show{animation:var(--swal2-show-animation)}.swal2-hide{animation:var(--swal2-hide-animation)}.swal2-noanimation{transition:none}.swal2-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.swal2-rtl .swal2-close{margin-right:initial;margin-left:0}.swal2-rtl .swal2-timer-progress-bar{right:0;left:auto}.swal2-toast{box-sizing:border-box;grid-column:1/4 !important;grid-row:1/4 !important;grid-template-columns:min-content auto min-content;padding:1em;overflow-y:hidden;border:var(--swal2-toast-border);background:var(--swal2-background);box-shadow:var(--swal2-toast-box-shadow);pointer-events:all}.swal2-toast>*{grid-column:2}.swal2-toast h2:where(.swal2-title){margin:.5em 1em;padding:0;font-size:1em;text-align:initial}.swal2-toast .swal2-loading{justify-content:center}.swal2-toast input:where(.swal2-input){height:2em;margin:.5em;font-size:1em}.swal2-toast .swal2-validation-message{font-size:1em}.swal2-toast div:where(.swal2-footer){margin:.5em 0 0;padding:.5em 0 0;font-size:.8em}.swal2-toast button:where(.swal2-close){grid-column:3/3;grid-row:1/99;align-self:center;width:.8em;height:.8em;margin:0;font-size:2em}.swal2-toast div:where(.swal2-html-container){margin:.5em 1em;padding:0;overflow:initial;font-size:1em;text-align:initial}.swal2-toast div:where(.swal2-html-container):empty{padding:0}.swal2-toast .swal2-loader{grid-column:1;grid-row:1/99;align-self:center;width:2em;height:2em;margin:.25em}.swal2-toast .swal2-icon{grid-column:1;grid-row:1/99;align-self:center;width:2em;min-width:2em;height:2em;margin:0 .5em 0 0}.swal2-toast .swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:1.8em;font-weight:bold}.swal2-toast .swal2-icon.swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line]{top:.875em;width:1.375em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:.3125em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:.3125em}.swal2-toast div:where(.swal2-actions){justify-content:flex-start;height:auto;margin:0;margin-top:.5em;padding:0 .5em}.swal2-toast button:where(.swal2-styled){margin:.25em .5em;padding:.4em .6em;font-size:1em}.swal2-toast .swal2-success{border-color:#a5dc86}.swal2-toast .swal2-success [class^=swal2-success-circular-line]{position:absolute;width:1.6em;height:3em;border-radius:50%}.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.8em;left:-0.5em;transform:rotate(-45deg);transform-origin:2em 2em;border-radius:4em 0 0 4em}.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.25em;left:.9375em;transform-origin:0 1.5em;border-radius:0 4em 4em 0}.swal2-toast .swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-toast .swal2-success .swal2-success-fix{top:0;left:.4375em;width:.4375em;height:2.6875em}.swal2-toast .swal2-success [class^=swal2-success-line]{height:.3125em}.swal2-toast .swal2-success [class^=swal2-success-line][class$=tip]{top:1.125em;left:.1875em;width:.75em}.swal2-toast .swal2-success [class^=swal2-success-line][class$=long]{top:.9375em;right:.1875em;width:1.375em}@container swal2-popup style(--swal2-icon-animations:true){.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-toast-animate-success-line-tip .75s}.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-toast-animate-success-line-long .75s}}.swal2-toast.swal2-show{animation:var(--swal2-toast-show-animation)}.swal2-toast.swal2-hide{animation:var(--swal2-toast-hide-animation)}@keyframes swal2-show{0%{transform:scale(0.7)}45%{transform:scale(1.05)}80%{transform:scale(0.95)}100%{transform:scale(1)}}@keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(0.5);opacity:0}}@keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-0.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(0.4);opacity:0}50%{margin-top:1.625em;transform:scale(0.4);opacity:0}80%{margin-top:-0.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0deg);opacity:1}}@keyframes swal2-rotate-loading{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes swal2-animate-question-mark{0%{transform:rotateY(-360deg)}100%{transform:rotateY(0)}}@keyframes swal2-animate-i-mark{0%{transform:rotateZ(45deg);opacity:0}25%{transform:rotateZ(-25deg);opacity:.4}50%{transform:rotateZ(15deg);opacity:.8}75%{transform:rotateZ(-5deg);opacity:1}100%{transform:rotateX(0);opacity:1}}@keyframes swal2-toast-show{0%{transform:translateY(-0.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(0.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0deg)}}@keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-0.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}");

class AuthorizationService {
  static BASE_URL = "https://ygskuqceol.execute-api.us-east-2.amazonaws.com/dev/mathilde-ads";
  /**
   * Realiza la autenticación y obtiene el token de autorización
   * @param recaptchaToken Token de reCAPTCHA para verificación
   * @returns Promise con la respuesta de autenticación
   */
  static async authenticate(recaptchaToken) {
    try {
      if (false) ;
      const response = await axios.post(
        `${this.BASE_URL}/autorizacion`,
        {
          "auth": {
            "token": recaptchaToken
          }
        },
        {
          headers: {
            "Content-Type": "application/json",
            "X-API-Key": `${"f4PyQKMBo43pGVmwViNBl54HZoyVh0iV2evi3gNY"}`
          }
        }
      );
      return {
        token: response.data.cognito_token
      };
    } catch (error) {
      console.error("Error durante la autenticación:", error);
      return {
        error: "Error al realizar la autenticación"
      };
    }
  }
  /**
   * Almacena el token de autorización de forma segura
   * @param token Token a almacenar
   */
  static setToken(token) {
    document.cookie = `auth_token=${token}; Secure; SameSite=Strict; HttpOnly; Path=/`;
  }
  /**
   * Obtiene el token almacenado
   * @returns Token de autorización o null si no existe
   */
  static getStoredToken() {
    const cookie = document.cookie.split("; ").find((row) => row.startsWith("auth_token="));
    return cookie ? cookie.split("=")[1] : null;
  }
  /**
   * Elimina el token almacenado
   */
  static removeToken() {
    document.cookie = "auth_token=; Max-Age=0; Path=/";
  }
}

const AuthContext = reactExports.createContext(void 0);
const AuthProvider = ({ children }) => {
  const [error, setError] = reactExports.useState(null);
  const dispatch = useDispatch();
  const navigate = useNavigate();
  const getInitialUser = () => {
    const storedUser = localStorage.getItem("user");
    if (storedUser) {
      try {
        const parsedUser = JSON.parse(storedUser);
        if (parsedUser.expiresAt && parsedUser.expiresAt > Date.now()) {
          dispatch(login({ email: parsedUser.username, name: parsedUser.username }));
          return { username: parsedUser.username, expiresAt: parsedUser.expiresAt };
        } else {
          localStorage.removeItem("user");
          dispatch(logout());
        }
      } catch (error2) {
        localStorage.removeItem("user");
        dispatch(logout());
      }
    }
    return null;
  };
  const [user, setUserState] = reactExports.useState(getInitialUser);
  reactExports.useEffect(() => {
    const checkSession = () => {
      const currentUser = getInitialUser();
      if (!currentUser) {
        handleLogout();
      }
    };
    const interval = setInterval(checkSession, 6e4);
    return () => clearInterval(interval);
  }, []);
  const handleLogin = async (username, password, recaptchaToken) => {
    try {
      console.log("recaptchaToken", recaptchaToken);
      const authResponse = await AuthorizationService.authenticate(recaptchaToken);
      if (authResponse.error) {
        throw new Error(authResponse.error);
      }
      if (!authResponse.token) {
        throw new Error("No se pudo obtener el token de autorización");
      }
      console.log("Token obtenido:", authResponse.token);
      sessionStorage.setItem("tokCog", authResponse.token);
      const response = await axios.post(
        // 'https://ygskuqceol.execute-api.us-east-2.amazonaws.com/dev/mathilde-ads/servicios',
        "https://mthmocks.pruebasmathilde.com/castlemock/mock/rest/project/nIVSsr/application/YPlsJX/login",
        { username, password, "action": "login" },
        {
          headers: {
            "Content-Type": "application/json"
            // 'Authorization': `Bearer ${authResponse.token}`
          }
        }
      );
      console.log("Respuesta del servicio de login:", response.data);
      if (response.data) {
        const session = {
          username,
          ClientName: response.data.ClientName,
          expiresAt: Date.now() + 1e3 * 60 * 60 * 24
          // 24 horas
        };
        console.log("Datos de sesión creados:", session);
        setUserState({ username: response.data.ClientName, expiresAt: session.expiresAt });
        localStorage.setItem("user", JSON.stringify(session));
        dispatch(login({ email: username, name: response.data.ClientName }));
        navigate("/dashboard");
        setError(null);
      } else {
        throw new Error(response.data.detail);
      }
    } catch (error2) {
      console.error("Error completo:", error2);
      if (axios.isAxiosError(error2)) {
        console.error("Detalles del error:", {
          status: error2.response?.status,
          data: error2.response?.data,
          message: error2.message
        });
        dispatch(loginFailure(error2.message));
        if (error2.response) {
          setError(`Error: ${error2.response.status} - ${error2.response.data}`);
        } else if (error2.request) {
          setError("No se recibió respuesta del servidor.");
        } else {
          setError(`Error de configuración: ${error2.message}`);
        }
      } else {
        dispatch(loginFailure("Error de inicio de sesión. Verifica tus credenciales."));
        setError("Error de inicio de sesión. Verifica tus credenciales.");
      }
      Swal.fire({
        title: "Error de inicio de sesión",
        text: error2 instanceof Error ? error2.message : "Por favor verifica tus credenciales.",
        icon: "error",
        confirmButtonText: "Aceptar"
      });
    }
  };
  const handleLogout = () => {
    dispatch(logout());
    setUserState(null);
    localStorage.removeItem("user");
    sessionStorage.removeItem("campaignDataResumen");
    navigate("/");
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AuthContext.Provider, { value: { user, handleLogin, handleLogout, error }, children });
};
const useAuth = () => {
  const context = reactExports.useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth debe ser usado dentro de un AuthProvider");
  }
  return context;
};

const RouterLogueado = ({ children }) => {
  const isAuthenticated = useSelector((state) => state.auth.isAuthenticated);
  return isAuthenticated ? children : /* @__PURE__ */ jsxRuntimeExports.jsx(Navigate, { to: "/", replace: true });
};

var wy = Object.defineProperty;
var ky = (t6, e, r) => e in t6 ? wy(t6, e, { enumerable: true, configurable: true, writable: true, value: r }) : t6[e] = r;
var K = (t6, e, r) => ky(t6, typeof e != "symbol" ? e + "" : e, r);
const Cy = "button-module__mth-btn-default__cda3k", Ey = "button-module__mth-btn-border__-pdSm", Ty = "button-module__mth-btn__LkrNk", Py = "button-module__mth-btn-full__7QycJ", Ri = {
  "mth-btn-default": "button-module__mth-btn-default__cda3k",
  mthBtnDefault: Cy,
  "mth-btn-border": "button-module__mth-btn-border__-pdSm",
  mthBtnBorder: Ey,
  "mth-btn": "button-module__mth-btn__LkrNk",
  mthBtn: Ty,
  "mth-btn-full": "button-module__mth-btn-full__7QycJ",
  mthBtnFull: Py
}, FN = ({
  txtBtn: t6,
  typeButton: e,
  full: r,
  onClick: n,
  disabled: a,
  type: i,
  leftIcon: s,
  rightIcon: o,
  iconSize: l = 20
}) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${r ? Ri["mth-btn-full"] : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "button",
  {
    type: i,
    className: `${Ri["mth-btn"]} ${Ri[`mth-btn-${e}`]} ${r ? Ri["mth-btn-full"] : ""} flex items-center justify-center gap-2`,
    onClick: n,
    disabled: a,
    children: [
      s && /* @__PURE__ */ jsxRuntimeExports.jsx(s, { size: l }),
      t6,
      o && /* @__PURE__ */ jsxRuntimeExports.jsx(o, { size: l })
    ]
  }
) }), Ry = "checkbox-module__checkmark__pC-qY", ps = {
  "checkbox-container": "checkbox-module__checkbox-container__jLidj",
  checkmark: Ry
}, Cn = ({
  src: t6,
  alt: e,
  width: r,
  height: n,
  classIm: a
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "img",
  {
    className: a,
    src: t6,
    alt: e,
    width: r,
    height: n
  }
), Ny = reactExports.forwardRef(
  ({
    placeholder: t6,
    label: e,
    error: r,
    type: n,
    classInclude: a,
    maxLength: i,
    onChange: s,
    ...o
  }, l) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-5", children: [
    e && /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: " mb-1 block font-semibold", children: e }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        ref: l,
        type: n,
        placeholder: t6,
        className: `w-full border p-2 ${a || ""}`,
        maxLength: i,
        onChange: s,
        ...o
      }
    ),
    r && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1 text-sm text-red-500", children: r })
  ] })
);
Ny.displayName = "InputForm";
var qh = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
}, Wd = React$1.createContext && /* @__PURE__ */ React$1.createContext(qh), Iy = ["attr", "size", "title"];
function Ay(t6, e) {
  if (t6 == null) return {};
  var r = Fy(t6, e), n, a;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t6);
    for (a = 0; a < i.length; a++)
      n = i[a], !(e.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(t6, n) && (r[n] = t6[n]);
  }
  return r;
}
function Fy(t6, e) {
  if (t6 == null) return {};
  var r = {}, n = Object.keys(t6), a, i;
  for (i = 0; i < n.length; i++)
    a = n[i], !(e.indexOf(a) >= 0) && (r[a] = t6[a]);
  return r;
}
function bs() {
  return bs = Object.assign ? Object.assign.bind() : function(t6) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (t6[n] = r[n]);
    }
    return t6;
  }, bs.apply(this, arguments);
}
function $d(t6, e) {
  var r = Object.keys(t6);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t6);
    e && (n = n.filter(function(a) {
      return Object.getOwnPropertyDescriptor(t6, a).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function ys(t6) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? $d(Object(r), true).forEach(function(n) {
      Ly(t6, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t6, Object.getOwnPropertyDescriptors(r)) : $d(Object(r)).forEach(function(n) {
      Object.defineProperty(t6, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return t6;
}
function Ly(t6, e, r) {
  return e = Wy(e), e in t6 ? Object.defineProperty(t6, e, { value: r, enumerable: true, configurable: true, writable: true }) : t6[e] = r, t6;
}
function Wy(t6) {
  var e = $y(t6, "string");
  return typeof e == "symbol" ? e : String(e);
}
function $y(t6, e) {
  if (typeof t6 != "object" || t6 === null) return t6;
  var r = t6[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(t6, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t6);
}
function Uh(t6) {
  return t6 && t6.map((e, r) => /* @__PURE__ */ React$1.createElement(e.tag, ys({
    key: r
  }, e.attr), Uh(e.child)));
}
function We(t6) {
  return (e) => /* @__PURE__ */ React$1.createElement(zy, bs({
    attr: ys({}, t6.attr)
  }, e), Uh(t6.child));
}
function zy(t6) {
  var e = (r) => {
    var {
      attr: n,
      size: a,
      title: i
    } = t6, s = Ay(t6, Iy), o = a || r.size || "1em", l;
    return r.className && (l = r.className), t6.className && (l = (l ? l + " " : "") + t6.className), /* @__PURE__ */ React$1.createElement("svg", bs({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, r.attr, n, s, {
      className: l,
      style: ys(ys({
        color: t6.color || r.color
      }, r.style), t6.style),
      height: o,
      width: o,
      xmlns: "http://www.w3.org/2000/svg"
    }), i && /* @__PURE__ */ React$1.createElement("title", null, i), t6.children);
  };
  return Wd !== void 0 ? /* @__PURE__ */ React$1.createElement(Wd.Consumer, null, (r) => e(r)) : e(qh);
}
function jy(t6) {
  return We({ attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z" }, child: [] }] })(t6);
}
function Hy(t6) {
  return We({ attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M207.029 381.476L12.686 187.132c-9.373-9.373-9.373-24.569 0-33.941l22.667-22.667c9.357-9.357 24.522-9.375 33.901-.04L224 284.505l154.745-154.021c9.379-9.335 24.544-9.317 33.901.04l22.667 22.667c9.373 9.373 9.373 24.569 0 33.941L240.971 381.476c-9.373 9.372-24.569 9.372-33.942 0z" }, child: [] }] })(t6);
}
function By(t6) {
  return We({ attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M240.971 130.524l194.343 194.343c9.373 9.373 9.373 24.569 0 33.941l-22.667 22.667c-9.357 9.357-24.522 9.375-33.901.04L224 227.495 69.255 381.516c-9.379 9.335-24.544 9.317-33.901-.04l-22.667-22.667c-9.373-9.373-9.373-24.569 0-33.941L207.03 130.525c9.372-9.373 24.568-9.373 33.941-.001z" }, child: [] }] })(t6);
}
function Yy(t6) {
  return We({ attr: { viewBox: "0 0 640 512" }, child: [{ tag: "path", attr: { d: "M320 400c-75.85 0-137.25-58.71-142.9-133.11L72.2 185.82c-13.79 17.3-26.48 35.59-36.72 55.59a32.35 32.35 0 0 0 0 29.19C89.71 376.41 197.07 448 320 448c26.91 0 52.87-4 77.89-10.46L346 397.39a144.13 144.13 0 0 1-26 2.61zm313.82 58.1l-110.55-85.44a331.25 331.25 0 0 0 81.25-102.07 32.35 32.35 0 0 0 0-29.19C550.29 135.59 442.93 64 320 64a308.15 308.15 0 0 0-147.32 37.7L45.46 3.37A16 16 0 0 0 23 6.18L3.37 31.45A16 16 0 0 0 6.18 53.9l588.36 454.73a16 16 0 0 0 22.46-2.81l19.64-25.27a16 16 0 0 0-2.82-22.45zm-183.72-142l-39.3-30.38A94.75 94.75 0 0 0 416 256a94.76 94.76 0 0 0-121.31-92.21A47.65 47.65 0 0 1 304 192a46.64 46.64 0 0 1-1.54 10l-73.61-56.89A142.31 142.31 0 0 1 320 112a143.92 143.92 0 0 1 144 144c0 21.63-5.29 41.79-13.9 60.11z" }, child: [] }] })(t6);
}
function Vy(t6) {
  return We({ attr: { viewBox: "0 0 576 512" }, child: [{ tag: "path", attr: { d: "M572.52 241.4C518.29 135.59 410.93 64 288 64S57.68 135.64 3.48 241.41a32.35 32.35 0 0 0 0 29.19C57.71 376.41 165.07 448 288 448s230.32-71.64 284.52-177.41a32.35 32.35 0 0 0 0-29.19zM288 400a144 144 0 1 1 144-144 143.93 143.93 0 0 1-144 144zm0-240a95.31 95.31 0 0 0-25.31 3.79 47.85 47.85 0 0 1-66.9 66.9A95.78 95.78 0 1 0 288 160z" }, child: [] }] })(t6);
}
const qy = {
  "mth-password": "passwordInput-module__mth-password__R6DoN"
}, zd = ({
  placeholder: t6,
  onChange: e,
  value: r,
  ...n
}) => {
  const [a, i] = reactExports.useState(false), s = () => {
    i(!a);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-5", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative inline-block w-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        type: a ? "text" : "password",
        value: r,
        className: "w-full border p-2 pr-10",
        onChange: e,
        placeholder: t6,
        ...n
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        type: "button",
        onClick: s,
        className: qy["mth-password"],
        children: a ? /* @__PURE__ */ jsxRuntimeExports.jsx(Yy, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(Vy, {})
      }
    )
  ] }) });
}, jd = {
  "progress-check": "progressBar-module__progress-check__TVlHq",
  "progress-no-check": "progressBar-module__progress-no-check__YeVq1"
}, Uy = ({
  start: t6,
  end: e,
  current: r
}) => {
  const n = (r - t6) / (e - t6) * 100;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative h-4 w-full overflow-hidden rounded-full bg-gray-200", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: `absolute left-0 top-0 h-full rounded-full ${n < 50 ? jd["progress-no-check"] : jd["progress-check"]}`,
        style: { width: `${Math.min(n, 100)}%` }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 flex items-center px-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "z-10 text-sm font-medium text-gray-900", children: [
      r.toFixed(2),
      "%"
    ] }) })
  ] });
}, Xy = reactExports.forwardRef(
  ({ options: t6, label: e, error: r, value: n, onChange: a, ...i }, s) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-5", children: [
    e && /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "mb-1 block font-semibold", children: e }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "select",
      {
        ref: s,
        className: "w-full rounded border p-2",
        value: n,
        onChange: a,
        ...i,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("option", { disabled: true, value: "", children: "Seleccione una opción" }),
          t6 == null ? void 0 : t6.map((o) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: o.value, children: o.label }, o.value))
        ]
      }
    ),
    r && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1 text-sm text-red-500", children: r })
  ] })
);
Xy.displayName = "SelectForm";
const Gy = {
  conversiones: "https://ftp.mathilde-ads.com/151-a05ae956a2c7caeb6f6d8952cac41a24.svg",
  click: "https://ftp.mathilde-ads.com/151-81ace0b5242dabee10930b76df01d43b.svg",
  impresiones: "https://ftp.mathilde-ads.com/151-b50587f350bafb8f19a9308325b45467.svg",
  porcentaje: "https://ftp.mathilde-ads.com/151-846076c2407128d25fffa4f35342d415.svg",
  vistas: "https://ftp.mathilde-ads.com/151-2b68ef020e57a0986c576b16607d85dd.svg"
}, WN = ({
  logo: t6,
  number: e,
  title: r,
  start: n,
  end: a,
  current: i
}) => {
  const s = (o) => new Intl.NumberFormat("es-ES", {
    maximumFractionDigits: 2,
    minimumFractionDigits: 0
  }).format(o);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col border bg-white px-3.5 py-7", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Cn,
      {
        src: Gy[t6] || "",
        alt: "Icon",
        width: 30,
        height: 30
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "my-3 font-bold", children: r }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("small", { className: "text-3xl", children: s(e) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-2 w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Uy, { start: n, end: a, current: i }) })
  ] });
};
/*!
 * @kurkle/color v0.3.4
 * https://github.com/kurkle/color#readme
 * (c) 2024 Jukka Kurkela
 * Released under the MIT License
 */
function gi(t6) {
  return t6 + 0.5 | 0;
}
const Yr = (t6, e, r) => Math.max(Math.min(t6, r), e);
function La(t6) {
  return Yr(gi(t6 * 2.55), 0, 255);
}
function qr(t6) {
  return Yr(gi(t6 * 255), 0, 255);
}
function Mr(t6) {
  return Yr(gi(t6 / 2.55) / 100, 0, 1);
}
function Hd(t6) {
  return Yr(gi(t6 * 100), 0, 100);
}
const $t = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, Dl = [..."0123456789ABCDEF"], Ky = (t6) => Dl[t6 & 15], Qy = (t6) => Dl[(t6 & 240) >> 4] + Dl[t6 & 15], Ni = (t6) => (t6 & 240) >> 4 === (t6 & 15), Jy = (t6) => Ni(t6.r) && Ni(t6.g) && Ni(t6.b) && Ni(t6.a);
function Zy(t6) {
  var e = t6.length, r;
  return t6[0] === "#" && (e === 4 || e === 5 ? r = {
    r: 255 & $t[t6[1]] * 17,
    g: 255 & $t[t6[2]] * 17,
    b: 255 & $t[t6[3]] * 17,
    a: e === 5 ? $t[t6[4]] * 17 : 255
  } : (e === 7 || e === 9) && (r = {
    r: $t[t6[1]] << 4 | $t[t6[2]],
    g: $t[t6[3]] << 4 | $t[t6[4]],
    b: $t[t6[5]] << 4 | $t[t6[6]],
    a: e === 9 ? $t[t6[7]] << 4 | $t[t6[8]] : 255
  })), r;
}
const ev = (t6, e) => t6 < 255 ? e(t6) : "";
function tv(t6) {
  var e = Jy(t6) ? Ky : Qy;
  return t6 ? "#" + e(t6.r) + e(t6.g) + e(t6.b) + ev(t6.a, e) : void 0;
}
const rv = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function Xh(t6, e, r) {
  const n = e * Math.min(r, 1 - r), a = (i, s = (i + t6 / 30) % 12) => r - n * Math.max(Math.min(s - 3, 9 - s, 1), -1);
  return [a(0), a(8), a(4)];
}
function nv(t6, e, r) {
  const n = (a, i = (a + t6 / 60) % 6) => r - r * e * Math.max(Math.min(i, 4 - i, 1), 0);
  return [n(5), n(3), n(1)];
}
function av(t6, e, r) {
  const n = Xh(t6, 1, 0.5);
  let a;
  for (e + r > 1 && (a = 1 / (e + r), e *= a, r *= a), a = 0; a < 3; a++)
    n[a] *= 1 - e - r, n[a] += e;
  return n;
}
function iv(t6, e, r, n, a) {
  return t6 === a ? (e - r) / n + (e < r ? 6 : 0) : e === a ? (r - t6) / n + 2 : (t6 - e) / n + 4;
}
function ic(t6) {
  const r = t6.r / 255, n = t6.g / 255, a = t6.b / 255, i = Math.max(r, n, a), s = Math.min(r, n, a), o = (i + s) / 2;
  let l, c, d;
  return i !== s && (d = i - s, c = o > 0.5 ? d / (2 - i - s) : d / (i + s), l = iv(r, n, a, d, i), l = l * 60 + 0.5), [l | 0, c || 0, o];
}
function sc(t6, e, r, n) {
  return (Array.isArray(e) ? t6(e[0], e[1], e[2]) : t6(e, r, n)).map(qr);
}
function oc(t6, e, r) {
  return sc(Xh, t6, e, r);
}
function sv(t6, e, r) {
  return sc(av, t6, e, r);
}
function ov(t6, e, r) {
  return sc(nv, t6, e, r);
}
function Gh(t6) {
  return (t6 % 360 + 360) % 360;
}
function lv(t6) {
  const e = rv.exec(t6);
  let r = 255, n;
  if (!e)
    return;
  e[5] !== n && (r = e[6] ? La(+e[5]) : qr(+e[5]));
  const a = Gh(+e[2]), i = +e[3] / 100, s = +e[4] / 100;
  return e[1] === "hwb" ? n = sv(a, i, s) : e[1] === "hsv" ? n = ov(a, i, s) : n = oc(a, i, s), {
    r: n[0],
    g: n[1],
    b: n[2],
    a: r
  };
}
function cv(t6, e) {
  var r = ic(t6);
  r[0] = Gh(r[0] + e), r = oc(r), t6.r = r[0], t6.g = r[1], t6.b = r[2];
}
function dv(t6) {
  if (!t6)
    return;
  const e = ic(t6), r = e[0], n = Hd(e[1]), a = Hd(e[2]);
  return t6.a < 255 ? `hsla(${r}, ${n}%, ${a}%, ${Mr(t6.a)})` : `hsl(${r}, ${n}%, ${a}%)`;
}
const Bd = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
}, Yd = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function uv() {
  const t6 = {}, e = Object.keys(Yd), r = Object.keys(Bd);
  let n, a, i, s, o;
  for (n = 0; n < e.length; n++) {
    for (s = o = e[n], a = 0; a < r.length; a++)
      i = r[a], o = o.replace(i, Bd[i]);
    i = parseInt(Yd[s], 16), t6[o] = [i >> 16 & 255, i >> 8 & 255, i & 255];
  }
  return t6;
}
let Ii;
function fv(t6) {
  Ii || (Ii = uv(), Ii.transparent = [0, 0, 0, 0]);
  const e = Ii[t6.toLowerCase()];
  return e && {
    r: e[0],
    g: e[1],
    b: e[2],
    a: e.length === 4 ? e[3] : 255
  };
}
const hv = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function gv(t6) {
  const e = hv.exec(t6);
  let r = 255, n, a, i;
  if (e) {
    if (e[7] !== n) {
      const s = +e[7];
      r = e[8] ? La(s) : Yr(s * 255, 0, 255);
    }
    return n = +e[1], a = +e[3], i = +e[5], n = 255 & (e[2] ? La(n) : Yr(n, 0, 255)), a = 255 & (e[4] ? La(a) : Yr(a, 0, 255)), i = 255 & (e[6] ? La(i) : Yr(i, 0, 255)), {
      r: n,
      g: a,
      b: i,
      a: r
    };
  }
}
function mv(t6) {
  return t6 && (t6.a < 255 ? `rgba(${t6.r}, ${t6.g}, ${t6.b}, ${Mr(t6.a)})` : `rgb(${t6.r}, ${t6.g}, ${t6.b})`);
}
const Yo = (t6) => t6 <= 31308e-7 ? t6 * 12.92 : Math.pow(t6, 1 / 2.4) * 1.055 - 0.055, $n = (t6) => t6 <= 0.04045 ? t6 / 12.92 : Math.pow((t6 + 0.055) / 1.055, 2.4);
function pv(t6, e, r) {
  const n = $n(Mr(t6.r)), a = $n(Mr(t6.g)), i = $n(Mr(t6.b));
  return {
    r: qr(Yo(n + r * ($n(Mr(e.r)) - n))),
    g: qr(Yo(a + r * ($n(Mr(e.g)) - a))),
    b: qr(Yo(i + r * ($n(Mr(e.b)) - i))),
    a: t6.a + r * (e.a - t6.a)
  };
}
function Ai(t6, e, r) {
  if (t6) {
    let n = ic(t6);
    n[e] = Math.max(0, Math.min(n[e] + n[e] * r, e === 0 ? 360 : 1)), n = oc(n), t6.r = n[0], t6.g = n[1], t6.b = n[2];
  }
}
function Kh(t6, e) {
  return t6 && Object.assign(e || {}, t6);
}
function Vd(t6) {
  var e = { r: 0, g: 0, b: 0, a: 255 };
  return Array.isArray(t6) ? t6.length >= 3 && (e = { r: t6[0], g: t6[1], b: t6[2], a: 255 }, t6.length > 3 && (e.a = qr(t6[3]))) : (e = Kh(t6, { r: 0, g: 0, b: 0, a: 1 }), e.a = qr(e.a)), e;
}
function bv(t6) {
  return t6.charAt(0) === "r" ? gv(t6) : lv(t6);
}
class ei {
  constructor(e) {
    if (e instanceof ei)
      return e;
    const r = typeof e;
    let n;
    r === "object" ? n = Vd(e) : r === "string" && (n = Zy(e) || fv(e) || bv(e)), this._rgb = n, this._valid = !!n;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var e = Kh(this._rgb);
    return e && (e.a = Mr(e.a)), e;
  }
  set rgb(e) {
    this._rgb = Vd(e);
  }
  rgbString() {
    return this._valid ? mv(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? tv(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? dv(this._rgb) : void 0;
  }
  mix(e, r) {
    if (e) {
      const n = this.rgb, a = e.rgb;
      let i;
      const s = r === i ? 0.5 : r, o = 2 * s - 1, l = n.a - a.a, c = ((o * l === -1 ? o : (o + l) / (1 + o * l)) + 1) / 2;
      i = 1 - c, n.r = 255 & c * n.r + i * a.r + 0.5, n.g = 255 & c * n.g + i * a.g + 0.5, n.b = 255 & c * n.b + i * a.b + 0.5, n.a = s * n.a + (1 - s) * a.a, this.rgb = n;
    }
    return this;
  }
  interpolate(e, r) {
    return e && (this._rgb = pv(this._rgb, e._rgb, r)), this;
  }
  clone() {
    return new ei(this.rgb);
  }
  alpha(e) {
    return this._rgb.a = qr(e), this;
  }
  clearer(e) {
    const r = this._rgb;
    return r.a *= 1 - e, this;
  }
  greyscale() {
    const e = this._rgb, r = gi(e.r * 0.3 + e.g * 0.59 + e.b * 0.11);
    return e.r = e.g = e.b = r, this;
  }
  opaquer(e) {
    const r = this._rgb;
    return r.a *= 1 + e, this;
  }
  negate() {
    const e = this._rgb;
    return e.r = 255 - e.r, e.g = 255 - e.g, e.b = 255 - e.b, this;
  }
  lighten(e) {
    return Ai(this._rgb, 2, e), this;
  }
  darken(e) {
    return Ai(this._rgb, 2, -e), this;
  }
  saturate(e) {
    return Ai(this._rgb, 1, e), this;
  }
  desaturate(e) {
    return Ai(this._rgb, 1, -e), this;
  }
  rotate(e) {
    return cv(this._rgb, e), this;
  }
}
/*!
 * Chart.js v4.4.8
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */
function xr() {
}
const yv = /* @__PURE__ */ (() => {
  let t6 = 0;
  return () => t6++;
})();
function mt(t6) {
  return t6 == null;
}
function ct(t6) {
  if (Array.isArray && Array.isArray(t6))
    return true;
  const e = Object.prototype.toString.call(t6);
  return e.slice(0, 7) === "[object" && e.slice(-6) === "Array]";
}
function pe(t6) {
  return t6 !== null && Object.prototype.toString.call(t6) === "[object Object]";
}
function Er(t6) {
  return (typeof t6 == "number" || t6 instanceof Number) && isFinite(+t6);
}
function er(t6, e) {
  return Er(t6) ? t6 : e;
}
function De(t6, e) {
  return typeof t6 > "u" ? e : t6;
}
const vv = (t6, e) => typeof t6 == "string" && t6.endsWith("%") ? parseFloat(t6) / 100 : +t6 / e, Qh = (t6, e) => typeof t6 == "string" && t6.endsWith("%") ? parseFloat(t6) / 100 * e : +t6;
function Ae(t6, e, r) {
  if (t6 && typeof t6.call == "function")
    return t6.apply(r, e);
}
function Se(t6, e, r, n) {
  let a, i, s;
  if (ct(t6))
    for (i = t6.length, a = 0; a < i; a++)
      e.call(r, t6[a], a);
  else if (pe(t6))
    for (s = Object.keys(t6), i = s.length, a = 0; a < i; a++)
      e.call(r, t6[s[a]], s[a]);
}
function vs(t6, e) {
  let r, n, a, i;
  if (!t6 || !e || t6.length !== e.length)
    return false;
  for (r = 0, n = t6.length; r < n; ++r)
    if (a = t6[r], i = e[r], a.datasetIndex !== i.datasetIndex || a.index !== i.index)
      return false;
  return true;
}
function xs(t6) {
  if (ct(t6))
    return t6.map(xs);
  if (pe(t6)) {
    const e = /* @__PURE__ */ Object.create(null), r = Object.keys(t6), n = r.length;
    let a = 0;
    for (; a < n; ++a)
      e[r[a]] = xs(t6[r[a]]);
    return e;
  }
  return t6;
}
function Jh(t6) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(t6) === -1;
}
function xv(t6, e, r, n) {
  if (!Jh(t6))
    return;
  const a = e[t6], i = r[t6];
  pe(a) && pe(i) ? ti(a, i, n) : e[t6] = xs(i);
}
function ti(t6, e, r) {
  const n = ct(e) ? e : [
    e
  ], a = n.length;
  if (!pe(t6))
    return t6;
  r = r || {};
  const i = r.merger || xv;
  let s;
  for (let o = 0; o < a; ++o) {
    if (s = n[o], !pe(s))
      continue;
    const l = Object.keys(s);
    for (let c = 0, d = l.length; c < d; ++c)
      i(l[c], t6, s, r);
  }
  return t6;
}
function Ba(t6, e) {
  return ti(t6, e, {
    merger: wv
  });
}
function wv(t6, e, r) {
  if (!Jh(t6))
    return;
  const n = e[t6], a = r[t6];
  pe(n) && pe(a) ? Ba(n, a) : Object.prototype.hasOwnProperty.call(e, t6) || (e[t6] = xs(a));
}
const qd = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (t6) => t6,
  // default resolvers
  x: (t6) => t6.x,
  y: (t6) => t6.y
};
function kv(t6) {
  const e = t6.split("."), r = [];
  let n = "";
  for (const a of e)
    n += a, n.endsWith("\\") ? n = n.slice(0, -1) + "." : (r.push(n), n = "");
  return r;
}
function _v(t6) {
  const e = kv(t6);
  return (r) => {
    for (const n of e) {
      if (n === "")
        break;
      r = r && r[n];
    }
    return r;
  };
}
function ri(t6, e) {
  return (qd[e] || (qd[e] = _v(e)))(t6);
}
function lc(t6) {
  return t6.charAt(0).toUpperCase() + t6.slice(1);
}
const ws = (t6) => typeof t6 < "u", Xr = (t6) => typeof t6 == "function", Ud = (t6, e) => {
  if (t6.size !== e.size)
    return false;
  for (const r of t6)
    if (!e.has(r))
      return false;
  return true;
};
function Ov(t6) {
  return t6.type === "mouseup" || t6.type === "click" || t6.type === "contextmenu";
}
const at = Math.PI, Qe = 2 * at, ks = Number.POSITIVE_INFINITY, Sv = at / 180, tt = at / 2, an = at / 4, Xd = at * 2 / 3, Gd = Math.sign;
function Dv(t6) {
  const e = [], r = Math.sqrt(t6);
  let n;
  for (n = 1; n < r; n++)
    t6 % n === 0 && (e.push(n), e.push(t6 / n));
  return r === (r | 0) && e.push(r), e.sort((a, i) => a - i).pop(), e;
}
function Mv(t6) {
  return typeof t6 == "symbol" || typeof t6 == "object" && t6 !== null && !(Symbol.toPrimitive in t6 || "toString" in t6 || "valueOf" in t6);
}
function _s(t6) {
  return !Mv(t6) && !isNaN(parseFloat(t6)) && isFinite(t6);
}
function xn(t6) {
  return t6 * (at / 180);
}
function Cv(t6) {
  return t6 * (180 / at);
}
function Zh(t6, e) {
  const r = e.x - t6.x, n = e.y - t6.y, a = Math.sqrt(r * r + n * n);
  let i = Math.atan2(n, r);
  return i < -0.5 * at && (i += Qe), {
    angle: i,
    distance: a
  };
}
function Ev(t6, e) {
  return Math.sqrt(Math.pow(e.x - t6.x, 2) + Math.pow(e.y - t6.y, 2));
}
function sn(t6) {
  return (t6 % Qe + Qe) % Qe;
}
function Os(t6, e, r, n) {
  const a = sn(t6), i = sn(e), s = sn(r), o = sn(i - a), l = sn(s - a), c = sn(a - i), d = sn(a - s);
  return a === i || a === s || n && i === s || o > l && c < d;
}
function jt(t6, e, r) {
  return Math.max(e, Math.min(r, t6));
}
function Tv(t6) {
  return jt(t6, -32768, 32767);
}
function Wa(t6, e, r, n = 1e-6) {
  return t6 >= Math.min(e, r) - n && t6 <= Math.max(e, r) + n;
}
function cc(t6, e, r) {
  r = r || ((s) => t6[s] < e);
  let n = t6.length - 1, a = 0, i;
  for (; n - a > 1; )
    i = a + n >> 1, r(i) ? a = i : n = i;
  return {
    lo: a,
    hi: n
  };
}
const Ml = (t6, e, r, n) => cc(t6, r, n ? (a) => {
  const i = t6[a][e];
  return i < r || i === r && t6[a + 1][e] === r;
} : (a) => t6[a][e] < r), Pv = (t6, e, r) => cc(t6, r, (n) => t6[n][e] >= r);
function Rv(t6, e, r) {
  let n = 0, a = t6.length;
  for (; n < a && t6[n] < e; )
    n++;
  for (; a > n && t6[a - 1] > r; )
    a--;
  return n > 0 || a < t6.length ? t6.slice(n, a) : t6;
}
const eg = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function Nv(t6, e) {
  if (t6._chartjs) {
    t6._chartjs.listeners.push(e);
    return;
  }
  Object.defineProperty(t6, "_chartjs", {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [
        e
      ]
    }
  }), eg.forEach((r) => {
    const n = "_onData" + lc(r), a = t6[r];
    Object.defineProperty(t6, r, {
      configurable: true,
      enumerable: false,
      value(...i) {
        const s = a.apply(this, i);
        return t6._chartjs.listeners.forEach((o) => {
          typeof o[n] == "function" && o[n](...i);
        }), s;
      }
    });
  });
}
function Kd(t6, e) {
  const r = t6._chartjs;
  if (!r)
    return;
  const n = r.listeners, a = n.indexOf(e);
  a !== -1 && n.splice(a, 1), !(n.length > 0) && (eg.forEach((i) => {
    delete t6[i];
  }), delete t6._chartjs);
}
function Iv(t6) {
  const e = new Set(t6);
  return e.size === t6.length ? t6 : Array.from(e);
}
const tg = function() {
  return typeof window > "u" ? function(t6) {
    return t6();
  } : window.requestAnimationFrame;
}();
function rg(t6, e) {
  let r = [], n = false;
  return function(...a) {
    r = a, n || (n = true, tg.call(window, () => {
      n = false, t6.apply(e, r);
    }));
  };
}
function Av(t6, e) {
  let r;
  return function(...n) {
    return e ? (clearTimeout(r), r = setTimeout(t6, e, n)) : t6.apply(this, n), e;
  };
}
const ng = (t6) => t6 === "start" ? "left" : t6 === "end" ? "right" : "center", It = (t6, e, r) => t6 === "start" ? e : t6 === "end" ? r : (e + r) / 2, Fv = (t6, e, r, n) => t6 === (n ? "left" : "right") ? r : t6 === "center" ? (e + r) / 2 : e, Fi = (t6) => t6 === 0 || t6 === 1, Qd = (t6, e, r) => -(Math.pow(2, 10 * (t6 -= 1)) * Math.sin((t6 - e) * Qe / r)), Jd = (t6, e, r) => Math.pow(2, -10 * t6) * Math.sin((t6 - e) * Qe / r) + 1, Ya = {
  linear: (t6) => t6,
  easeInQuad: (t6) => t6 * t6,
  easeOutQuad: (t6) => -t6 * (t6 - 2),
  easeInOutQuad: (t6) => (t6 /= 0.5) < 1 ? 0.5 * t6 * t6 : -0.5 * (--t6 * (t6 - 2) - 1),
  easeInCubic: (t6) => t6 * t6 * t6,
  easeOutCubic: (t6) => (t6 -= 1) * t6 * t6 + 1,
  easeInOutCubic: (t6) => (t6 /= 0.5) < 1 ? 0.5 * t6 * t6 * t6 : 0.5 * ((t6 -= 2) * t6 * t6 + 2),
  easeInQuart: (t6) => t6 * t6 * t6 * t6,
  easeOutQuart: (t6) => -((t6 -= 1) * t6 * t6 * t6 - 1),
  easeInOutQuart: (t6) => (t6 /= 0.5) < 1 ? 0.5 * t6 * t6 * t6 * t6 : -0.5 * ((t6 -= 2) * t6 * t6 * t6 - 2),
  easeInQuint: (t6) => t6 * t6 * t6 * t6 * t6,
  easeOutQuint: (t6) => (t6 -= 1) * t6 * t6 * t6 * t6 + 1,
  easeInOutQuint: (t6) => (t6 /= 0.5) < 1 ? 0.5 * t6 * t6 * t6 * t6 * t6 : 0.5 * ((t6 -= 2) * t6 * t6 * t6 * t6 + 2),
  easeInSine: (t6) => -Math.cos(t6 * tt) + 1,
  easeOutSine: (t6) => Math.sin(t6 * tt),
  easeInOutSine: (t6) => -0.5 * (Math.cos(at * t6) - 1),
  easeInExpo: (t6) => t6 === 0 ? 0 : Math.pow(2, 10 * (t6 - 1)),
  easeOutExpo: (t6) => t6 === 1 ? 1 : -Math.pow(2, -10 * t6) + 1,
  easeInOutExpo: (t6) => Fi(t6) ? t6 : t6 < 0.5 ? 0.5 * Math.pow(2, 10 * (t6 * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t6 * 2 - 1)) + 2),
  easeInCirc: (t6) => t6 >= 1 ? t6 : -(Math.sqrt(1 - t6 * t6) - 1),
  easeOutCirc: (t6) => Math.sqrt(1 - (t6 -= 1) * t6),
  easeInOutCirc: (t6) => (t6 /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t6 * t6) - 1) : 0.5 * (Math.sqrt(1 - (t6 -= 2) * t6) + 1),
  easeInElastic: (t6) => Fi(t6) ? t6 : Qd(t6, 0.075, 0.3),
  easeOutElastic: (t6) => Fi(t6) ? t6 : Jd(t6, 0.075, 0.3),
  easeInOutElastic(t6) {
    return Fi(t6) ? t6 : t6 < 0.5 ? 0.5 * Qd(t6 * 2, 0.1125, 0.45) : 0.5 + 0.5 * Jd(t6 * 2 - 1, 0.1125, 0.45);
  },
  easeInBack(t6) {
    return t6 * t6 * ((1.70158 + 1) * t6 - 1.70158);
  },
  easeOutBack(t6) {
    return (t6 -= 1) * t6 * ((1.70158 + 1) * t6 + 1.70158) + 1;
  },
  easeInOutBack(t6) {
    let e = 1.70158;
    return (t6 /= 0.5) < 1 ? 0.5 * (t6 * t6 * (((e *= 1.525) + 1) * t6 - e)) : 0.5 * ((t6 -= 2) * t6 * (((e *= 1.525) + 1) * t6 + e) + 2);
  },
  easeInBounce: (t6) => 1 - Ya.easeOutBounce(1 - t6),
  easeOutBounce(t6) {
    return t6 < 1 / 2.75 ? 7.5625 * t6 * t6 : t6 < 2 / 2.75 ? 7.5625 * (t6 -= 1.5 / 2.75) * t6 + 0.75 : t6 < 2.5 / 2.75 ? 7.5625 * (t6 -= 2.25 / 2.75) * t6 + 0.9375 : 7.5625 * (t6 -= 2.625 / 2.75) * t6 + 0.984375;
  },
  easeInOutBounce: (t6) => t6 < 0.5 ? Ya.easeInBounce(t6 * 2) * 0.5 : Ya.easeOutBounce(t6 * 2 - 1) * 0.5 + 0.5
};
function ag(t6) {
  if (t6 && typeof t6 == "object") {
    const e = t6.toString();
    return e === "[object CanvasPattern]" || e === "[object CanvasGradient]";
  }
  return false;
}
function Zd(t6) {
  return ag(t6) ? t6 : new ei(t6);
}
function Vo(t6) {
  return ag(t6) ? t6 : new ei(t6).saturate(0.5).darken(0.1).hexString();
}
const Lv = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
], Wv = [
  "color",
  "borderColor",
  "backgroundColor"
];
function $v(t6) {
  t6.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  }), t6.describe("animation", {
    _fallback: false,
    _indexable: false,
    _scriptable: (e) => e !== "onProgress" && e !== "onComplete" && e !== "fn"
  }), t6.set("animations", {
    colors: {
      type: "color",
      properties: Wv
    },
    numbers: {
      type: "number",
      properties: Lv
    }
  }), t6.describe("animations", {
    _fallback: "animation"
  }), t6.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (e) => e | 0
        }
      }
    }
  });
}
function zv(t6) {
  t6.set("layout", {
    autoPadding: true,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
const eu = /* @__PURE__ */ new Map();
function jv(t6, e) {
  e = e || {};
  const r = t6 + JSON.stringify(e);
  let n = eu.get(r);
  return n || (n = new Intl.NumberFormat(t6, e), eu.set(r, n)), n;
}
function Hv(t6, e, r) {
  return jv(e, r).format(t6);
}
const Bv = {
  values(t6) {
    return ct(t6) ? t6 : "" + t6;
  }
};
var Yv = {
  formatters: Bv
};
function Vv(t6) {
  t6.set("scale", {
    display: true,
    offset: false,
    reverse: false,
    beginAtZero: false,
    bounds: "ticks",
    clip: true,
    grace: 0,
    grid: {
      display: true,
      lineWidth: 1,
      drawOnChartArea: true,
      drawTicks: true,
      tickLength: 8,
      tickWidth: (e, r) => r.lineWidth,
      tickColor: (e, r) => r.color,
      offset: false
    },
    border: {
      display: true,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: false,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: false,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: true,
      autoSkip: true,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Yv.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: false,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  }), t6.route("scale.ticks", "color", "", "color"), t6.route("scale.grid", "color", "", "borderColor"), t6.route("scale.border", "color", "", "borderColor"), t6.route("scale.title", "color", "", "color"), t6.describe("scale", {
    _fallback: false,
    _scriptable: (e) => !e.startsWith("before") && !e.startsWith("after") && e !== "callback" && e !== "parser",
    _indexable: (e) => e !== "borderDash" && e !== "tickBorderDash" && e !== "dash"
  }), t6.describe("scales", {
    _fallback: "scale"
  }), t6.describe("scale.ticks", {
    _scriptable: (e) => e !== "backdropPadding" && e !== "callback",
    _indexable: (e) => e !== "backdropPadding"
  });
}
const En = /* @__PURE__ */ Object.create(null), Cl = /* @__PURE__ */ Object.create(null);
function Va(t6, e) {
  if (!e)
    return t6;
  const r = e.split(".");
  for (let n = 0, a = r.length; n < a; ++n) {
    const i = r[n];
    t6 = t6[i] || (t6[i] = /* @__PURE__ */ Object.create(null));
  }
  return t6;
}
function qo(t6, e, r) {
  return typeof e == "string" ? ti(Va(t6, e), r) : ti(Va(t6, ""), e);
}
class qv {
  constructor(e, r) {
    this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = (n) => n.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ], this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    }, this.hover = {}, this.hoverBackgroundColor = (n, a) => Vo(a.backgroundColor), this.hoverBorderColor = (n, a) => Vo(a.borderColor), this.hoverColor = (n, a) => Vo(a.color), this.indexAxis = "x", this.interaction = {
      mode: "nearest",
      intersect: true,
      includeInvisible: false
    }, this.maintainAspectRatio = true, this.onHover = null, this.onClick = null, this.parsing = true, this.plugins = {}, this.responsive = true, this.scale = void 0, this.scales = {}, this.showLine = true, this.drawActiveElementsOnTop = true, this.describe(e), this.apply(r);
  }
  set(e, r) {
    return qo(this, e, r);
  }
  get(e) {
    return Va(this, e);
  }
  describe(e, r) {
    return qo(Cl, e, r);
  }
  override(e, r) {
    return qo(En, e, r);
  }
  route(e, r, n, a) {
    const i = Va(this, e), s = Va(this, n), o = "_" + r;
    Object.defineProperties(i, {
      [o]: {
        value: i[r],
        writable: true
      },
      [r]: {
        enumerable: true,
        get() {
          const l = this[o], c = s[a];
          return pe(l) ? Object.assign({}, c, l) : De(l, c);
        },
        set(l) {
          this[o] = l;
        }
      }
    });
  }
  apply(e) {
    e.forEach((r) => r(this));
  }
}
var Ve = /* @__PURE__ */ new qv({
  _scriptable: (t6) => !t6.startsWith("on"),
  _indexable: (t6) => t6 !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: false,
    _indexable: false
  }
}, [
  $v,
  zv,
  Vv
]);
function Uv(t6) {
  return !t6 || mt(t6.size) || mt(t6.family) ? null : (t6.style ? t6.style + " " : "") + (t6.weight ? t6.weight + " " : "") + t6.size + "px " + t6.family;
}
function tu(t6, e, r, n, a) {
  let i = e[a];
  return i || (i = e[a] = t6.measureText(a).width, r.push(a)), i > n && (n = i), n;
}
function on(t6, e, r) {
  const n = t6.currentDevicePixelRatio, a = r !== 0 ? Math.max(r / 2, 0.5) : 0;
  return Math.round((e - a) * n) / n + a;
}
function ru(t6, e) {
  !e && !t6 || (e = e || t6.getContext("2d"), e.save(), e.resetTransform(), e.clearRect(0, 0, t6.width, t6.height), e.restore());
}
function nu(t6, e, r, n) {
  ig(t6, e, r, n, null);
}
function ig(t6, e, r, n, a) {
  let i, s, o, l, c, d, u, f;
  const h = e.pointStyle, g = e.rotation, m = e.radius;
  let p = (g || 0) * Sv;
  if (h && typeof h == "object" && (i = h.toString(), i === "[object HTMLImageElement]" || i === "[object HTMLCanvasElement]")) {
    t6.save(), t6.translate(r, n), t6.rotate(p), t6.drawImage(h, -h.width / 2, -h.height / 2, h.width, h.height), t6.restore();
    return;
  }
  if (!(isNaN(m) || m <= 0)) {
    switch (t6.beginPath(), h) {
      default:
        a ? t6.ellipse(r, n, a / 2, m, 0, 0, Qe) : t6.arc(r, n, m, 0, Qe), t6.closePath();
        break;
      case "triangle":
        d = a ? a / 2 : m, t6.moveTo(r + Math.sin(p) * d, n - Math.cos(p) * m), p += Xd, t6.lineTo(r + Math.sin(p) * d, n - Math.cos(p) * m), p += Xd, t6.lineTo(r + Math.sin(p) * d, n - Math.cos(p) * m), t6.closePath();
        break;
      case "rectRounded":
        c = m * 0.516, l = m - c, s = Math.cos(p + an) * l, u = Math.cos(p + an) * (a ? a / 2 - c : l), o = Math.sin(p + an) * l, f = Math.sin(p + an) * (a ? a / 2 - c : l), t6.arc(r - u, n - o, c, p - at, p - tt), t6.arc(r + f, n - s, c, p - tt, p), t6.arc(r + u, n + o, c, p, p + tt), t6.arc(r - f, n + s, c, p + tt, p + at), t6.closePath();
        break;
      case "rect":
        if (!g) {
          l = Math.SQRT1_2 * m, d = a ? a / 2 : l, t6.rect(r - d, n - l, 2 * d, 2 * l);
          break;
        }
        p += an;
      case "rectRot":
        u = Math.cos(p) * (a ? a / 2 : m), s = Math.cos(p) * m, o = Math.sin(p) * m, f = Math.sin(p) * (a ? a / 2 : m), t6.moveTo(r - u, n - o), t6.lineTo(r + f, n - s), t6.lineTo(r + u, n + o), t6.lineTo(r - f, n + s), t6.closePath();
        break;
      case "crossRot":
        p += an;
      case "cross":
        u = Math.cos(p) * (a ? a / 2 : m), s = Math.cos(p) * m, o = Math.sin(p) * m, f = Math.sin(p) * (a ? a / 2 : m), t6.moveTo(r - u, n - o), t6.lineTo(r + u, n + o), t6.moveTo(r + f, n - s), t6.lineTo(r - f, n + s);
        break;
      case "star":
        u = Math.cos(p) * (a ? a / 2 : m), s = Math.cos(p) * m, o = Math.sin(p) * m, f = Math.sin(p) * (a ? a / 2 : m), t6.moveTo(r - u, n - o), t6.lineTo(r + u, n + o), t6.moveTo(r + f, n - s), t6.lineTo(r - f, n + s), p += an, u = Math.cos(p) * (a ? a / 2 : m), s = Math.cos(p) * m, o = Math.sin(p) * m, f = Math.sin(p) * (a ? a / 2 : m), t6.moveTo(r - u, n - o), t6.lineTo(r + u, n + o), t6.moveTo(r + f, n - s), t6.lineTo(r - f, n + s);
        break;
      case "line":
        s = a ? a / 2 : Math.cos(p) * m, o = Math.sin(p) * m, t6.moveTo(r - s, n - o), t6.lineTo(r + s, n + o);
        break;
      case "dash":
        t6.moveTo(r, n), t6.lineTo(r + Math.cos(p) * (a ? a / 2 : m), n + Math.sin(p) * m);
        break;
      case false:
        t6.closePath();
        break;
    }
    t6.fill(), e.borderWidth > 0 && t6.stroke();
  }
}
function sg(t6, e, r) {
  return r = r || 0.5, !e || t6 && t6.x > e.left - r && t6.x < e.right + r && t6.y > e.top - r && t6.y < e.bottom + r;
}
function dc(t6, e) {
  t6.save(), t6.beginPath(), t6.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t6.clip();
}
function uc(t6) {
  t6.restore();
}
function Xv(t6, e) {
  e.translation && t6.translate(e.translation[0], e.translation[1]), mt(e.rotation) || t6.rotate(e.rotation), e.color && (t6.fillStyle = e.color), e.textAlign && (t6.textAlign = e.textAlign), e.textBaseline && (t6.textBaseline = e.textBaseline);
}
function Gv(t6, e, r, n, a) {
  if (a.strikethrough || a.underline) {
    const i = t6.measureText(n), s = e - i.actualBoundingBoxLeft, o = e + i.actualBoundingBoxRight, l = r - i.actualBoundingBoxAscent, c = r + i.actualBoundingBoxDescent, d = a.strikethrough ? (l + c) / 2 : c;
    t6.strokeStyle = t6.fillStyle, t6.beginPath(), t6.lineWidth = a.decorationWidth || 2, t6.moveTo(s, d), t6.lineTo(o, d), t6.stroke();
  }
}
function Kv(t6, e) {
  const r = t6.fillStyle;
  t6.fillStyle = e.color, t6.fillRect(e.left, e.top, e.width, e.height), t6.fillStyle = r;
}
function Ss(t6, e, r, n, a, i = {}) {
  const s = ct(e) ? e : [
    e
  ], o = i.strokeWidth > 0 && i.strokeColor !== "";
  let l, c;
  for (t6.save(), t6.font = a.string, Xv(t6, i), l = 0; l < s.length; ++l)
    c = s[l], i.backdrop && Kv(t6, i.backdrop), o && (i.strokeColor && (t6.strokeStyle = i.strokeColor), mt(i.strokeWidth) || (t6.lineWidth = i.strokeWidth), t6.strokeText(c, r, n, i.maxWidth)), t6.fillText(c, r, n, i.maxWidth), Gv(t6, r, n, c, i), n += Number(a.lineHeight);
  t6.restore();
}
function El(t6, e) {
  const { x: r, y: n, w: a, h: i, radius: s } = e;
  t6.arc(r + s.topLeft, n + s.topLeft, s.topLeft, 1.5 * at, at, true), t6.lineTo(r, n + i - s.bottomLeft), t6.arc(r + s.bottomLeft, n + i - s.bottomLeft, s.bottomLeft, at, tt, true), t6.lineTo(r + a - s.bottomRight, n + i), t6.arc(r + a - s.bottomRight, n + i - s.bottomRight, s.bottomRight, tt, 0, true), t6.lineTo(r + a, n + s.topRight), t6.arc(r + a - s.topRight, n + s.topRight, s.topRight, 0, -tt, true), t6.lineTo(r + s.topLeft, n);
}
const Qv = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, Jv = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function Zv(t6, e) {
  const r = ("" + t6).match(Qv);
  if (!r || r[1] === "normal")
    return e * 1.2;
  switch (t6 = +r[2], r[3]) {
    case "px":
      return t6;
    case "%":
      t6 /= 100;
      break;
  }
  return e * t6;
}
const ex = (t6) => +t6 || 0;
function fc(t6, e) {
  const r = {}, n = pe(e), a = n ? Object.keys(e) : e, i = pe(t6) ? n ? (s) => De(t6[s], t6[e[s]]) : (s) => t6[s] : () => t6;
  for (const s of a)
    r[s] = ex(i(s));
  return r;
}
function tx(t6) {
  return fc(t6, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function qa(t6) {
  return fc(t6, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function Kt(t6) {
  const e = tx(t6);
  return e.width = e.left + e.right, e.height = e.top + e.bottom, e;
}
function _t(t6, e) {
  t6 = t6 || {}, e = e || Ve.font;
  let r = De(t6.size, e.size);
  typeof r == "string" && (r = parseInt(r, 10));
  let n = De(t6.style, e.style);
  n && !("" + n).match(Jv) && (console.warn('Invalid font style specified: "' + n + '"'), n = void 0);
  const a = {
    family: De(t6.family, e.family),
    lineHeight: Zv(De(t6.lineHeight, e.lineHeight), r),
    size: r,
    style: n,
    weight: De(t6.weight, e.weight),
    string: ""
  };
  return a.string = Uv(a), a;
}
function Li(t6, e, r, n) {
  let a, i, s;
  for (a = 0, i = t6.length; a < i; ++a)
    if (s = t6[a], s !== void 0 && s !== void 0)
      return s;
}
function rx(t6, e, r) {
  const { min: n, max: a } = t6, i = Qh(e, (a - n) / 2), s = (o, l) => r && o === 0 ? 0 : o + l;
  return {
    min: s(n, -Math.abs(i)),
    max: s(a, i)
  };
}
function ha(t6, e) {
  return Object.assign(Object.create(t6), e);
}
function hc(t6, e = [
  ""
], r, n, a = () => t6[0]) {
  const i = r || t6;
  typeof n > "u" && (n = dg("_fallback", t6));
  const s = {
    [Symbol.toStringTag]: "Object",
    _cacheable: true,
    _scopes: t6,
    _rootScopes: i,
    _fallback: n,
    _getTarget: a,
    override: (o) => hc([
      o,
      ...t6
    ], e, i, n)
  };
  return new Proxy(s, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(o, l) {
      return delete o[l], delete o._keys, delete t6[0][l], true;
    },
    /**
    * A trap for getting property values.
    */
    get(o, l) {
      return lg(o, l, () => dx(l, e, t6, o));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(o, l) {
      return Reflect.getOwnPropertyDescriptor(o._scopes[0], l);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(t6[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(o, l) {
      return iu(o).includes(l);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(o) {
      return iu(o);
    },
    /**
    * A trap for setting property values.
    */
    set(o, l, c) {
      const d = o._storage || (o._storage = a());
      return o[l] = d[l] = c, delete o._keys, true;
    }
  });
}
function ra(t6, e, r, n) {
  const a = {
    _cacheable: false,
    _proxy: t6,
    _context: e,
    _subProxy: r,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: og(t6, n),
    setContext: (i) => ra(t6, i, r, n),
    override: (i) => ra(t6.override(i), e, r, n)
  };
  return new Proxy(a, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(i, s) {
      return delete i[s], delete t6[s], true;
    },
    /**
    * A trap for getting property values.
    */
    get(i, s, o) {
      return lg(i, s, () => ax(i, s, o));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(i, s) {
      return i._descriptors.allKeys ? Reflect.has(t6, s) ? {
        enumerable: true,
        configurable: true
      } : void 0 : Reflect.getOwnPropertyDescriptor(t6, s);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(t6);
    },
    /**
    * A trap for the in operator.
    */
    has(i, s) {
      return Reflect.has(t6, s);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(t6);
    },
    /**
    * A trap for setting property values.
    */
    set(i, s, o) {
      return t6[s] = o, delete i[s], true;
    }
  });
}
function og(t6, e = {
  scriptable: true,
  indexable: true
}) {
  const { _scriptable: r = e.scriptable, _indexable: n = e.indexable, _allKeys: a = e.allKeys } = t6;
  return {
    allKeys: a,
    scriptable: r,
    indexable: n,
    isScriptable: Xr(r) ? r : () => r,
    isIndexable: Xr(n) ? n : () => n
  };
}
const nx = (t6, e) => t6 ? t6 + lc(e) : e, gc = (t6, e) => pe(e) && t6 !== "adapters" && (Object.getPrototypeOf(e) === null || e.constructor === Object);
function lg(t6, e, r) {
  if (Object.prototype.hasOwnProperty.call(t6, e) || e === "constructor")
    return t6[e];
  const n = r();
  return t6[e] = n, n;
}
function ax(t6, e, r) {
  const { _proxy: n, _context: a, _subProxy: i, _descriptors: s } = t6;
  let o = n[e];
  return Xr(o) && s.isScriptable(e) && (o = ix(e, o, t6, r)), ct(o) && o.length && (o = sx(e, o, t6, s.isIndexable)), gc(e, o) && (o = ra(o, a, i && i[e], s)), o;
}
function ix(t6, e, r, n) {
  const { _proxy: a, _context: i, _subProxy: s, _stack: o } = r;
  if (o.has(t6))
    throw new Error("Recursion detected: " + Array.from(o).join("->") + "->" + t6);
  o.add(t6);
  let l = e(i, s || n);
  return o.delete(t6), gc(t6, l) && (l = mc(a._scopes, a, t6, l)), l;
}
function sx(t6, e, r, n) {
  const { _proxy: a, _context: i, _subProxy: s, _descriptors: o } = r;
  if (typeof i.index < "u" && n(t6))
    return e[i.index % e.length];
  if (pe(e[0])) {
    const l = e, c = a._scopes.filter((d) => d !== l);
    e = [];
    for (const d of l) {
      const u = mc(c, a, t6, d);
      e.push(ra(u, i, s && s[t6], o));
    }
  }
  return e;
}
function cg(t6, e, r) {
  return Xr(t6) ? t6(e, r) : t6;
}
const ox = (t6, e) => t6 === true ? e : typeof t6 == "string" ? ri(e, t6) : void 0;
function lx(t6, e, r, n, a) {
  for (const i of e) {
    const s = ox(r, i);
    if (s) {
      t6.add(s);
      const o = cg(s._fallback, r, a);
      if (typeof o < "u" && o !== r && o !== n)
        return o;
    } else if (s === false && typeof n < "u" && r !== n)
      return null;
  }
  return false;
}
function mc(t6, e, r, n) {
  const a = e._rootScopes, i = cg(e._fallback, r, n), s = [
    ...t6,
    ...a
  ], o = /* @__PURE__ */ new Set();
  o.add(n);
  let l = au(o, s, r, i || r, n);
  return l === null || typeof i < "u" && i !== r && (l = au(o, s, i, l, n), l === null) ? false : hc(Array.from(o), [
    ""
  ], a, i, () => cx(e, r, n));
}
function au(t6, e, r, n, a) {
  for (; r; )
    r = lx(t6, e, r, n, a);
  return r;
}
function cx(t6, e, r) {
  const n = t6._getTarget();
  e in n || (n[e] = {});
  const a = n[e];
  return ct(a) && pe(r) ? r : a || {};
}
function dx(t6, e, r, n) {
  let a;
  for (const i of e)
    if (a = dg(nx(i, t6), r), typeof a < "u")
      return gc(t6, a) ? mc(r, n, t6, a) : a;
}
function dg(t6, e) {
  for (const r of e) {
    if (!r)
      continue;
    const n = r[t6];
    if (typeof n < "u")
      return n;
  }
}
function iu(t6) {
  let e = t6._keys;
  return e || (e = t6._keys = ux(t6._scopes)), e;
}
function ux(t6) {
  const e = /* @__PURE__ */ new Set();
  for (const r of t6)
    for (const n of Object.keys(r).filter((a) => !a.startsWith("_")))
      e.add(n);
  return Array.from(e);
}
function pc() {
  return typeof window < "u" && typeof document < "u";
}
function bc(t6) {
  let e = t6.parentNode;
  return e && e.toString() === "[object ShadowRoot]" && (e = e.host), e;
}
function Ds(t6, e, r) {
  let n;
  return typeof t6 == "string" ? (n = parseInt(t6, 10), t6.indexOf("%") !== -1 && (n = n / 100 * e.parentNode[r])) : n = t6, n;
}
const ao = (t6) => t6.ownerDocument.defaultView.getComputedStyle(t6, null);
function fx(t6, e) {
  return ao(t6).getPropertyValue(e);
}
const hx = [
  "top",
  "right",
  "bottom",
  "left"
];
function _n(t6, e, r) {
  const n = {};
  r = r ? "-" + r : "";
  for (let a = 0; a < 4; a++) {
    const i = hx[a];
    n[i] = parseFloat(t6[e + "-" + i + r]) || 0;
  }
  return n.width = n.left + n.right, n.height = n.top + n.bottom, n;
}
const gx = (t6, e, r) => (t6 > 0 || e > 0) && (!r || !r.shadowRoot);
function mx(t6, e) {
  const r = t6.touches, n = r && r.length ? r[0] : t6, { offsetX: a, offsetY: i } = n;
  let s = false, o, l;
  if (gx(a, i, t6.target))
    o = a, l = i;
  else {
    const c = e.getBoundingClientRect();
    o = n.clientX - c.left, l = n.clientY - c.top, s = true;
  }
  return {
    x: o,
    y: l,
    box: s
  };
}
function gn(t6, e) {
  if ("native" in t6)
    return t6;
  const { canvas: r, currentDevicePixelRatio: n } = e, a = ao(r), i = a.boxSizing === "border-box", s = _n(a, "padding"), o = _n(a, "border", "width"), { x: l, y: c, box: d } = mx(t6, r), u = s.left + (d && o.left), f = s.top + (d && o.top);
  let { width: h, height: g } = e;
  return i && (h -= s.width + o.width, g -= s.height + o.height), {
    x: Math.round((l - u) / h * r.width / n),
    y: Math.round((c - f) / g * r.height / n)
  };
}
function px(t6, e, r) {
  let n, a;
  if (e === void 0 || r === void 0) {
    const i = t6 && bc(t6);
    if (!i)
      e = t6.clientWidth, r = t6.clientHeight;
    else {
      const s = i.getBoundingClientRect(), o = ao(i), l = _n(o, "border", "width"), c = _n(o, "padding");
      e = s.width - c.width - l.width, r = s.height - c.height - l.height, n = Ds(o.maxWidth, i, "clientWidth"), a = Ds(o.maxHeight, i, "clientHeight");
    }
  }
  return {
    width: e,
    height: r,
    maxWidth: n || ks,
    maxHeight: a || ks
  };
}
const Wi = (t6) => Math.round(t6 * 10) / 10;
function bx(t6, e, r, n) {
  const a = ao(t6), i = _n(a, "margin"), s = Ds(a.maxWidth, t6, "clientWidth") || ks, o = Ds(a.maxHeight, t6, "clientHeight") || ks, l = px(t6, e, r);
  let { width: c, height: d } = l;
  if (a.boxSizing === "content-box") {
    const f = _n(a, "border", "width"), h = _n(a, "padding");
    c -= h.width + f.width, d -= h.height + f.height;
  }
  return c = Math.max(0, c - i.width), d = Math.max(0, n ? c / n : d - i.height), c = Wi(Math.min(c, s, l.maxWidth)), d = Wi(Math.min(d, o, l.maxHeight)), c && !d && (d = Wi(c / 2)), (e !== void 0 || r !== void 0) && n && l.height && d > l.height && (d = l.height, c = Wi(Math.floor(d * n))), {
    width: c,
    height: d
  };
}
function su(t6, e, r) {
  const n = e || 1, a = Math.floor(t6.height * n), i = Math.floor(t6.width * n);
  t6.height = Math.floor(t6.height), t6.width = Math.floor(t6.width);
  const s = t6.canvas;
  return s.style && (r || !s.style.height && !s.style.width) && (s.style.height = `${t6.height}px`, s.style.width = `${t6.width}px`), t6.currentDevicePixelRatio !== n || s.height !== a || s.width !== i ? (t6.currentDevicePixelRatio = n, s.height = a, s.width = i, t6.ctx.setTransform(n, 0, 0, n, 0, 0), true) : false;
}
const yx = function() {
  let t6 = false;
  try {
    const e = {
      get passive() {
        return t6 = true, false;
      }
    };
    pc() && (window.addEventListener("test", null, e), window.removeEventListener("test", null, e));
  } catch {
  }
  return t6;
}();
function ou(t6, e) {
  const r = fx(t6, e), n = r && r.match(/^(\d+)(\.\d+)?px$/);
  return n ? +n[1] : void 0;
}
const vx = function(t6, e) {
  return {
    x(r) {
      return t6 + t6 + e - r;
    },
    setWidth(r) {
      e = r;
    },
    textAlign(r) {
      return r === "center" ? r : r === "right" ? "left" : "right";
    },
    xPlus(r, n) {
      return r - n;
    },
    leftForLtr(r, n) {
      return r - n;
    }
  };
}, xx = function() {
  return {
    x(t6) {
      return t6;
    },
    setWidth(t6) {
    },
    textAlign(t6) {
      return t6;
    },
    xPlus(t6, e) {
      return t6 + e;
    },
    leftForLtr(t6, e) {
      return t6;
    }
  };
};
function Jn(t6, e, r) {
  return t6 ? vx(e, r) : xx();
}
function ug(t6, e) {
  let r, n;
  (e === "ltr" || e === "rtl") && (r = t6.canvas.style, n = [
    r.getPropertyValue("direction"),
    r.getPropertyPriority("direction")
  ], r.setProperty("direction", e, "important"), t6.prevTextDirection = n);
}
function fg(t6, e) {
  e !== void 0 && (delete t6.prevTextDirection, t6.canvas.style.setProperty("direction", e[0], e[1]));
}
/*!
 * Chart.js v4.4.8
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */
class wx {
  constructor() {
    this._request = null, this._charts = /* @__PURE__ */ new Map(), this._running = false, this._lastDate = void 0;
  }
  _notify(e, r, n, a) {
    const i = r.listeners[a], s = r.duration;
    i.forEach((o) => o({
      chart: e,
      initial: r.initial,
      numSteps: s,
      currentStep: Math.min(n - r.start, s)
    }));
  }
  _refresh() {
    this._request || (this._running = true, this._request = tg.call(window, () => {
      this._update(), this._request = null, this._running && this._refresh();
    }));
  }
  _update(e = Date.now()) {
    let r = 0;
    this._charts.forEach((n, a) => {
      if (!n.running || !n.items.length)
        return;
      const i = n.items;
      let s = i.length - 1, o = false, l;
      for (; s >= 0; --s)
        l = i[s], l._active ? (l._total > n.duration && (n.duration = l._total), l.tick(e), o = true) : (i[s] = i[i.length - 1], i.pop());
      o && (a.draw(), this._notify(a, n, e, "progress")), i.length || (n.running = false, this._notify(a, n, e, "complete"), n.initial = false), r += i.length;
    }), this._lastDate = e, r === 0 && (this._running = false);
  }
  _getAnims(e) {
    const r = this._charts;
    let n = r.get(e);
    return n || (n = {
      running: false,
      initial: true,
      items: [],
      listeners: {
        complete: [],
        progress: []
      }
    }, r.set(e, n)), n;
  }
  listen(e, r, n) {
    this._getAnims(e).listeners[r].push(n);
  }
  add(e, r) {
    !r || !r.length || this._getAnims(e).items.push(...r);
  }
  has(e) {
    return this._getAnims(e).items.length > 0;
  }
  start(e) {
    const r = this._charts.get(e);
    r && (r.running = true, r.start = Date.now(), r.duration = r.items.reduce((n, a) => Math.max(n, a._duration), 0), this._refresh());
  }
  running(e) {
    if (!this._running)
      return false;
    const r = this._charts.get(e);
    return !(!r || !r.running || !r.items.length);
  }
  stop(e) {
    const r = this._charts.get(e);
    if (!r || !r.items.length)
      return;
    const n = r.items;
    let a = n.length - 1;
    for (; a >= 0; --a)
      n[a].cancel();
    r.items = [], this._notify(e, r, Date.now(), "complete");
  }
  remove(e) {
    return this._charts.delete(e);
  }
}
var Or = /* @__PURE__ */ new wx();
const lu = "transparent", kx = {
  boolean(t6, e, r) {
    return r > 0.5 ? e : t6;
  },
  color(t6, e, r) {
    const n = Zd(t6 || lu), a = n.valid && Zd(e || lu);
    return a && a.valid ? a.mix(n, r).hexString() : e;
  },
  number(t6, e, r) {
    return t6 + (e - t6) * r;
  }
};
class _x {
  constructor(e, r, n, a) {
    const i = r[n];
    a = Li([
      e.to,
      a,
      i,
      e.from
    ]);
    const s = Li([
      e.from,
      i,
      a
    ]);
    this._active = true, this._fn = e.fn || kx[e.type || typeof s], this._easing = Ya[e.easing] || Ya.linear, this._start = Math.floor(Date.now() + (e.delay || 0)), this._duration = this._total = Math.floor(e.duration), this._loop = !!e.loop, this._target = r, this._prop = n, this._from = s, this._to = a, this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(e, r, n) {
    if (this._active) {
      this._notify(false);
      const a = this._target[this._prop], i = n - this._start, s = this._duration - i;
      this._start = n, this._duration = Math.floor(Math.max(s, e.duration)), this._total += i, this._loop = !!e.loop, this._to = Li([
        e.to,
        r,
        a,
        e.from
      ]), this._from = Li([
        e.from,
        a,
        r
      ]);
    }
  }
  cancel() {
    this._active && (this.tick(Date.now()), this._active = false, this._notify(false));
  }
  tick(e) {
    const r = e - this._start, n = this._duration, a = this._prop, i = this._from, s = this._loop, o = this._to;
    let l;
    if (this._active = i !== o && (s || r < n), !this._active) {
      this._target[a] = o, this._notify(true);
      return;
    }
    if (r < 0) {
      this._target[a] = i;
      return;
    }
    l = r / n % 2, l = s && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[a] = this._fn(i, o, l);
  }
  wait() {
    const e = this._promises || (this._promises = []);
    return new Promise((r, n) => {
      e.push({
        res: r,
        rej: n
      });
    });
  }
  _notify(e) {
    const r = e ? "res" : "rej", n = this._promises || [];
    for (let a = 0; a < n.length; a++)
      n[a][r]();
  }
}
class hg {
  constructor(e, r) {
    this._chart = e, this._properties = /* @__PURE__ */ new Map(), this.configure(r);
  }
  configure(e) {
    if (!pe(e))
      return;
    const r = Object.keys(Ve.animation), n = this._properties;
    Object.getOwnPropertyNames(e).forEach((a) => {
      const i = e[a];
      if (!pe(i))
        return;
      const s = {};
      for (const o of r)
        s[o] = i[o];
      (ct(i.properties) && i.properties || [
        a
      ]).forEach((o) => {
        (o === a || !n.has(o)) && n.set(o, s);
      });
    });
  }
  _animateOptions(e, r) {
    const n = r.options, a = Sx(e, n);
    if (!a)
      return [];
    const i = this._createAnimations(a, n);
    return n.$shared && Ox(e.options.$animations, n).then(() => {
      e.options = n;
    }, () => {
    }), i;
  }
  _createAnimations(e, r) {
    const n = this._properties, a = [], i = e.$animations || (e.$animations = {}), s = Object.keys(r), o = Date.now();
    let l;
    for (l = s.length - 1; l >= 0; --l) {
      const c = s[l];
      if (c.charAt(0) === "$")
        continue;
      if (c === "options") {
        a.push(...this._animateOptions(e, r));
        continue;
      }
      const d = r[c];
      let u = i[c];
      const f = n.get(c);
      if (u)
        if (f && u.active()) {
          u.update(f, d, o);
          continue;
        } else
          u.cancel();
      if (!f || !f.duration) {
        e[c] = d;
        continue;
      }
      i[c] = u = new _x(f, e, c, d), a.push(u);
    }
    return a;
  }
  update(e, r) {
    if (this._properties.size === 0) {
      Object.assign(e, r);
      return;
    }
    const n = this._createAnimations(e, r);
    if (n.length)
      return Or.add(this._chart, n), true;
  }
}
function Ox(t6, e) {
  const r = [], n = Object.keys(e);
  for (let a = 0; a < n.length; a++) {
    const i = t6[n[a]];
    i && i.active() && r.push(i.wait());
  }
  return Promise.all(r);
}
function Sx(t6, e) {
  if (!e)
    return;
  let r = t6.options;
  if (!r) {
    t6.options = e;
    return;
  }
  return r.$shared && (t6.options = r = Object.assign({}, r, {
    $shared: false,
    $animations: {}
  })), r;
}
function cu(t6, e) {
  const r = t6 && t6.options || {}, n = r.reverse, a = r.min === void 0 ? e : 0, i = r.max === void 0 ? e : 0;
  return {
    start: n ? i : a,
    end: n ? a : i
  };
}
function Dx(t6, e, r) {
  if (r === false)
    return false;
  const n = cu(t6, r), a = cu(e, r);
  return {
    top: a.end,
    right: n.end,
    bottom: a.start,
    left: n.start
  };
}
function Mx(t6) {
  let e, r, n, a;
  return pe(t6) ? (e = t6.top, r = t6.right, n = t6.bottom, a = t6.left) : e = r = n = a = t6, {
    top: e,
    right: r,
    bottom: n,
    left: a,
    disabled: t6 === false
  };
}
function gg(t6, e) {
  const r = [], n = t6._getSortedDatasetMetas(e);
  let a, i;
  for (a = 0, i = n.length; a < i; ++a)
    r.push(n[a].index);
  return r;
}
function du(t6, e, r, n = {}) {
  const a = t6.keys, i = n.mode === "single";
  let s, o, l, c;
  if (e === null)
    return;
  let d = false;
  for (s = 0, o = a.length; s < o; ++s) {
    if (l = +a[s], l === r) {
      if (d = true, n.all)
        continue;
      break;
    }
    c = t6.values[l], Er(c) && (i || e === 0 || Gd(e) === Gd(c)) && (e += c);
  }
  return !d && !n.all ? 0 : e;
}
function Cx(t6, e) {
  const { iScale: r, vScale: n } = e, a = r.axis === "x" ? "x" : "y", i = n.axis === "x" ? "x" : "y", s = Object.keys(t6), o = new Array(s.length);
  let l, c, d;
  for (l = 0, c = s.length; l < c; ++l)
    d = s[l], o[l] = {
      [a]: d,
      [i]: t6[d]
    };
  return o;
}
function Uo(t6, e) {
  const r = t6 && t6.options.stacked;
  return r || r === void 0 && e.stack !== void 0;
}
function Ex(t6, e, r) {
  return `${t6.id}.${e.id}.${r.stack || r.type}`;
}
function Tx(t6) {
  const { min: e, max: r, minDefined: n, maxDefined: a } = t6.getUserBounds();
  return {
    min: n ? e : Number.NEGATIVE_INFINITY,
    max: a ? r : Number.POSITIVE_INFINITY
  };
}
function Px(t6, e, r) {
  const n = t6[e] || (t6[e] = {});
  return n[r] || (n[r] = {});
}
function uu(t6, e, r, n) {
  for (const a of e.getMatchingVisibleMetas(n).reverse()) {
    const i = t6[a.index];
    if (r && i > 0 || !r && i < 0)
      return a.index;
  }
  return null;
}
function fu(t6, e) {
  const { chart: r, _cachedMeta: n } = t6, a = r._stacks || (r._stacks = {}), { iScale: i, vScale: s, index: o } = n, l = i.axis, c = s.axis, d = Ex(i, s, n), u = e.length;
  let f;
  for (let h = 0; h < u; ++h) {
    const g = e[h], { [l]: m, [c]: p } = g, w = g._stacks || (g._stacks = {});
    f = w[c] = Px(a, d, m), f[o] = p, f._top = uu(f, s, true, n.type), f._bottom = uu(f, s, false, n.type);
    const b = f._visualValues || (f._visualValues = {});
    b[o] = p;
  }
}
function Xo(t6, e) {
  const r = t6.scales;
  return Object.keys(r).filter((n) => r[n].axis === e).shift();
}
function Rx(t6, e) {
  return ha(t6, {
    active: false,
    dataset: void 0,
    datasetIndex: e,
    index: e,
    mode: "default",
    type: "dataset"
  });
}
function Nx(t6, e, r) {
  return ha(t6, {
    active: false,
    dataIndex: e,
    parsed: void 0,
    raw: void 0,
    element: r,
    index: e,
    mode: "default",
    type: "data"
  });
}
function wa(t6, e) {
  const r = t6.controller.index, n = t6.vScale && t6.vScale.axis;
  if (n) {
    e = e || t6._parsed;
    for (const a of e) {
      const i = a._stacks;
      if (!i || i[n] === void 0 || i[n][r] === void 0)
        return;
      delete i[n][r], i[n]._visualValues !== void 0 && i[n]._visualValues[r] !== void 0 && delete i[n]._visualValues[r];
    }
  }
}
const Go = (t6) => t6 === "reset" || t6 === "none", hu = (t6, e) => e ? t6 : Object.assign({}, t6), Ix = (t6, e, r) => t6 && !e.hidden && e._stacked && {
  keys: gg(r, true),
  values: null
};
class Ua {
  constructor(e, r) {
    this.chart = e, this._ctx = e.ctx, this.index = r, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = false, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = false, this.supportsDecimation = false, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize();
  }
  initialize() {
    const e = this._cachedMeta;
    this.configure(), this.linkScales(), e._stacked = Uo(e.vScale, e), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
  }
  updateIndex(e) {
    this.index !== e && wa(this._cachedMeta), this.index = e;
  }
  linkScales() {
    const e = this.chart, r = this._cachedMeta, n = this.getDataset(), a = (u, f, h, g) => u === "x" ? f : u === "r" ? g : h, i = r.xAxisID = De(n.xAxisID, Xo(e, "x")), s = r.yAxisID = De(n.yAxisID, Xo(e, "y")), o = r.rAxisID = De(n.rAxisID, Xo(e, "r")), l = r.indexAxis, c = r.iAxisID = a(l, i, s, o), d = r.vAxisID = a(l, s, i, o);
    r.xScale = this.getScaleForId(i), r.yScale = this.getScaleForId(s), r.rScale = this.getScaleForId(o), r.iScale = this.getScaleForId(c), r.vScale = this.getScaleForId(d);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(e) {
    return this.chart.scales[e];
  }
  _getOtherScale(e) {
    const r = this._cachedMeta;
    return e === r.iScale ? r.vScale : r.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const e = this._cachedMeta;
    this._data && Kd(this._data, this), e._stacked && wa(e);
  }
  _dataCheck() {
    const e = this.getDataset(), r = e.data || (e.data = []), n = this._data;
    if (pe(r)) {
      const a = this._cachedMeta;
      this._data = Cx(r, a);
    } else if (n !== r) {
      if (n) {
        Kd(n, this);
        const a = this._cachedMeta;
        wa(a), a._parsed = [];
      }
      r && Object.isExtensible(r) && Nv(r, this), this._syncList = [], this._data = r;
    }
  }
  addElements() {
    const e = this._cachedMeta;
    this._dataCheck(), this.datasetElementType && (e.dataset = new this.datasetElementType());
  }
  buildOrUpdateElements(e) {
    const r = this._cachedMeta, n = this.getDataset();
    let a = false;
    this._dataCheck();
    const i = r._stacked;
    r._stacked = Uo(r.vScale, r), r.stack !== n.stack && (a = true, wa(r), r.stack = n.stack), this._resyncElements(e), (a || i !== r._stacked) && (fu(this, r._parsed), r._stacked = Uo(r.vScale, r));
  }
  configure() {
    const e = this.chart.config, r = e.datasetScopeKeys(this._type), n = e.getOptionScopes(this.getDataset(), r, true);
    this.options = e.createResolver(n, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};
  }
  parse(e, r) {
    const { _cachedMeta: n, _data: a } = this, { iScale: i, _stacked: s } = n, o = i.axis;
    let l = e === 0 && r === a.length ? true : n._sorted, c = e > 0 && n._parsed[e - 1], d, u, f;
    if (this._parsing === false)
      n._parsed = a, n._sorted = true, f = a;
    else {
      ct(a[e]) ? f = this.parseArrayData(n, a, e, r) : pe(a[e]) ? f = this.parseObjectData(n, a, e, r) : f = this.parsePrimitiveData(n, a, e, r);
      const h = () => u[o] === null || c && u[o] < c[o];
      for (d = 0; d < r; ++d)
        n._parsed[d + e] = u = f[d], l && (h() && (l = false), c = u);
      n._sorted = l;
    }
    s && fu(this, f);
  }
  parsePrimitiveData(e, r, n, a) {
    const { iScale: i, vScale: s } = e, o = i.axis, l = s.axis, c = i.getLabels(), d = i === s, u = new Array(a);
    let f, h, g;
    for (f = 0, h = a; f < h; ++f)
      g = f + n, u[f] = {
        [o]: d || i.parse(c[g], g),
        [l]: s.parse(r[g], g)
      };
    return u;
  }
  parseArrayData(e, r, n, a) {
    const { xScale: i, yScale: s } = e, o = new Array(a);
    let l, c, d, u;
    for (l = 0, c = a; l < c; ++l)
      d = l + n, u = r[d], o[l] = {
        x: i.parse(u[0], d),
        y: s.parse(u[1], d)
      };
    return o;
  }
  parseObjectData(e, r, n, a) {
    const { xScale: i, yScale: s } = e, { xAxisKey: o = "x", yAxisKey: l = "y" } = this._parsing, c = new Array(a);
    let d, u, f, h;
    for (d = 0, u = a; d < u; ++d)
      f = d + n, h = r[f], c[d] = {
        x: i.parse(ri(h, o), f),
        y: s.parse(ri(h, l), f)
      };
    return c;
  }
  getParsed(e) {
    return this._cachedMeta._parsed[e];
  }
  getDataElement(e) {
    return this._cachedMeta.data[e];
  }
  applyStack(e, r, n) {
    const a = this.chart, i = this._cachedMeta, s = r[e.axis], o = {
      keys: gg(a, true),
      values: r._stacks[e.axis]._visualValues
    };
    return du(o, s, i.index, {
      mode: n
    });
  }
  updateRangeFromParsed(e, r, n, a) {
    const i = n[r.axis];
    let s = i === null ? NaN : i;
    const o = a && n._stacks[r.axis];
    a && o && (a.values = o, s = du(a, i, this._cachedMeta.index)), e.min = Math.min(e.min, s), e.max = Math.max(e.max, s);
  }
  getMinMax(e, r) {
    const n = this._cachedMeta, a = n._parsed, i = n._sorted && e === n.iScale, s = a.length, o = this._getOtherScale(e), l = Ix(r, n, this.chart), c = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    }, { min: d, max: u } = Tx(o);
    let f, h;
    function g() {
      h = a[f];
      const m = h[o.axis];
      return !Er(h[e.axis]) || d > m || u < m;
    }
    for (f = 0; f < s && !(!g() && (this.updateRangeFromParsed(c, e, h, l), i)); ++f)
      ;
    if (i) {
      for (f = s - 1; f >= 0; --f)
        if (!g()) {
          this.updateRangeFromParsed(c, e, h, l);
          break;
        }
    }
    return c;
  }
  getAllParsedValues(e) {
    const r = this._cachedMeta._parsed, n = [];
    let a, i, s;
    for (a = 0, i = r.length; a < i; ++a)
      s = r[a][e.axis], Er(s) && n.push(s);
    return n;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(e) {
    const r = this._cachedMeta, n = r.iScale, a = r.vScale, i = this.getParsed(e);
    return {
      label: n ? "" + n.getLabelForValue(i[n.axis]) : "",
      value: a ? "" + a.getLabelForValue(i[a.axis]) : ""
    };
  }
  _update(e) {
    const r = this._cachedMeta;
    this.update(e || "default"), r._clip = Mx(De(this.options.clip, Dx(r.xScale, r.yScale, this.getMaxOverflow())));
  }
  update(e) {
  }
  draw() {
    const e = this._ctx, r = this.chart, n = this._cachedMeta, a = n.data || [], i = r.chartArea, s = [], o = this._drawStart || 0, l = this._drawCount || a.length - o, c = this.options.drawActiveElementsOnTop;
    let d;
    for (n.dataset && n.dataset.draw(e, i, o, l), d = o; d < o + l; ++d) {
      const u = a[d];
      u.hidden || (u.active && c ? s.push(u) : u.draw(e, i));
    }
    for (d = 0; d < s.length; ++d)
      s[d].draw(e, i);
  }
  getStyle(e, r) {
    const n = r ? "active" : "default";
    return e === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(n) : this.resolveDataElementOptions(e || 0, n);
  }
  getContext(e, r, n) {
    const a = this.getDataset();
    let i;
    if (e >= 0 && e < this._cachedMeta.data.length) {
      const s = this._cachedMeta.data[e];
      i = s.$context || (s.$context = Nx(this.getContext(), e, s)), i.parsed = this.getParsed(e), i.raw = a.data[e], i.index = i.dataIndex = e;
    } else
      i = this.$context || (this.$context = Rx(this.chart.getContext(), this.index)), i.dataset = a, i.index = i.datasetIndex = this.index;
    return i.active = !!r, i.mode = n, i;
  }
  resolveDatasetElementOptions(e) {
    return this._resolveElementOptions(this.datasetElementType.id, e);
  }
  resolveDataElementOptions(e, r) {
    return this._resolveElementOptions(this.dataElementType.id, r, e);
  }
  _resolveElementOptions(e, r = "default", n) {
    const a = r === "active", i = this._cachedDataOpts, s = e + "-" + r, o = i[s], l = this.enableOptionSharing && ws(n);
    if (o)
      return hu(o, l);
    const c = this.chart.config, d = c.datasetElementScopeKeys(this._type, e), u = a ? [
      `${e}Hover`,
      "hover",
      e,
      ""
    ] : [
      e,
      ""
    ], f = c.getOptionScopes(this.getDataset(), d), h = Object.keys(Ve.elements[e]), g = () => this.getContext(n, a, r), m = c.resolveNamedOptions(f, h, g, u);
    return m.$shared && (m.$shared = l, i[s] = Object.freeze(hu(m, l))), m;
  }
  _resolveAnimations(e, r, n) {
    const a = this.chart, i = this._cachedDataOpts, s = `animation-${r}`, o = i[s];
    if (o)
      return o;
    let l;
    if (a.options.animation !== false) {
      const d = this.chart.config, u = d.datasetAnimationScopeKeys(this._type, r), f = d.getOptionScopes(this.getDataset(), u);
      l = d.createResolver(f, this.getContext(e, n, r));
    }
    const c = new hg(a, l && l.animations);
    return l && l._cacheable && (i[s] = Object.freeze(c)), c;
  }
  getSharedOptions(e) {
    if (e.$shared)
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, e));
  }
  includeOptions(e, r) {
    return !r || Go(e) || this.chart._animationsDisabled;
  }
  _getSharedOptions(e, r) {
    const n = this.resolveDataElementOptions(e, r), a = this._sharedOptions, i = this.getSharedOptions(n), s = this.includeOptions(r, i) || i !== a;
    return this.updateSharedOptions(i, r, n), {
      sharedOptions: i,
      includeOptions: s
    };
  }
  updateElement(e, r, n, a) {
    Go(a) ? Object.assign(e, n) : this._resolveAnimations(r, a).update(e, n);
  }
  updateSharedOptions(e, r, n) {
    e && !Go(r) && this._resolveAnimations(void 0, r).update(e, n);
  }
  _setStyle(e, r, n, a) {
    e.active = a;
    const i = this.getStyle(r, a);
    this._resolveAnimations(r, n, a).update(e, {
      options: !a && this.getSharedOptions(i) || i
    });
  }
  removeHoverStyle(e, r, n) {
    this._setStyle(e, n, "active", false);
  }
  setHoverStyle(e, r, n) {
    this._setStyle(e, n, "active", true);
  }
  _removeDatasetHoverStyle() {
    const e = this._cachedMeta.dataset;
    e && this._setStyle(e, void 0, "active", false);
  }
  _setDatasetHoverStyle() {
    const e = this._cachedMeta.dataset;
    e && this._setStyle(e, void 0, "active", true);
  }
  _resyncElements(e) {
    const r = this._data, n = this._cachedMeta.data;
    for (const [o, l, c] of this._syncList)
      this[o](l, c);
    this._syncList = [];
    const a = n.length, i = r.length, s = Math.min(i, a);
    s && this.parse(0, s), i > a ? this._insertElements(a, i - a, e) : i < a && this._removeElements(i, a - i);
  }
  _insertElements(e, r, n = true) {
    const a = this._cachedMeta, i = a.data, s = e + r;
    let o;
    const l = (c) => {
      for (c.length += r, o = c.length - 1; o >= s; o--)
        c[o] = c[o - r];
    };
    for (l(i), o = e; o < s; ++o)
      i[o] = new this.dataElementType();
    this._parsing && l(a._parsed), this.parse(e, r), n && this.updateElements(i, e, r, "reset");
  }
  updateElements(e, r, n, a) {
  }
  _removeElements(e, r) {
    const n = this._cachedMeta;
    if (this._parsing) {
      const a = n._parsed.splice(e, r);
      n._stacked && wa(n, a);
    }
    n.data.splice(e, r);
  }
  _sync(e) {
    if (this._parsing)
      this._syncList.push(e);
    else {
      const [r, n, a] = e;
      this[r](n, a);
    }
    this.chart._dataChanges.push([
      this.index,
      ...e
    ]);
  }
  _onDataPush() {
    const e = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - e,
      e
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(e, r) {
    r && this._sync([
      "_removeElements",
      e,
      r
    ]);
    const n = arguments.length - 2;
    n && this._sync([
      "_insertElements",
      e,
      n
    ]);
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
}
K(Ua, "defaults", {}), K(Ua, "datasetElementType", null), K(Ua, "dataElementType", null);
function Ax(t6, e, r) {
  let n = 1, a = 1, i = 0, s = 0;
  if (e < Qe) {
    const o = t6, l = o + e, c = Math.cos(o), d = Math.sin(o), u = Math.cos(l), f = Math.sin(l), h = (k, v, x) => Os(k, o, l, true) ? 1 : Math.max(v, v * r, x, x * r), g = (k, v, x) => Os(k, o, l, true) ? -1 : Math.min(v, v * r, x, x * r), m = h(0, c, u), p = h(tt, d, f), w = g(at, c, u), b = g(at + tt, d, f);
    n = (m - w) / 2, a = (p - b) / 2, i = -(m + w) / 2, s = -(p + b) / 2;
  }
  return {
    ratioX: n,
    ratioY: a,
    offsetX: i,
    offsetY: s
  };
}
class $a extends Ua {
  constructor(e, r) {
    super(e, r), this.enableOptionSharing = true, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(e, r) {
    const n = this.getDataset().data, a = this._cachedMeta;
    if (this._parsing === false)
      a._parsed = n;
    else {
      let i = (l) => +n[l];
      if (pe(n[e])) {
        const { key: l = "value" } = this._parsing;
        i = (c) => +ri(n[c], l);
      }
      let s, o;
      for (s = e, o = e + r; s < o; ++s)
        a._parsed[s] = i(s);
    }
  }
  _getRotation() {
    return xn(this.options.rotation - 90);
  }
  _getCircumference() {
    return xn(this.options.circumference);
  }
  _getRotationExtents() {
    let e = Qe, r = -Qe;
    for (let n = 0; n < this.chart.data.datasets.length; ++n)
      if (this.chart.isDatasetVisible(n) && this.chart.getDatasetMeta(n).type === this._type) {
        const a = this.chart.getDatasetMeta(n).controller, i = a._getRotation(), s = a._getCircumference();
        e = Math.min(e, i), r = Math.max(r, i + s);
      }
    return {
      rotation: e,
      circumference: r - e
    };
  }
  update(e) {
    const r = this.chart, { chartArea: n } = r, a = this._cachedMeta, i = a.data, s = this.getMaxBorderWidth() + this.getMaxOffset(i) + this.options.spacing, o = Math.max((Math.min(n.width, n.height) - s) / 2, 0), l = Math.min(vv(this.options.cutout, o), 1), c = this._getRingWeight(this.index), { circumference: d, rotation: u } = this._getRotationExtents(), { ratioX: f, ratioY: h, offsetX: g, offsetY: m } = Ax(u, d, l), p = (n.width - s) / f, w = (n.height - s) / h, b = Math.max(Math.min(p, w) / 2, 0), k = Qh(this.options.radius, b), v = Math.max(k * l, 0), x = (k - v) / this._getVisibleDatasetWeightTotal();
    this.offsetX = g * k, this.offsetY = m * k, a.total = this.calculateTotal(), this.outerRadius = k - x * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - x * c, 0), this.updateElements(i, 0, i.length, e);
  }
  _circumference(e, r) {
    const n = this.options, a = this._cachedMeta, i = this._getCircumference();
    return r && n.animation.animateRotate || !this.chart.getDataVisibility(e) || a._parsed[e] === null || a.data[e].hidden ? 0 : this.calculateCircumference(a._parsed[e] * i / Qe);
  }
  updateElements(e, r, n, a) {
    const i = a === "reset", s = this.chart, o = s.chartArea, c = s.options.animation, d = (o.left + o.right) / 2, u = (o.top + o.bottom) / 2, f = i && c.animateScale, h = f ? 0 : this.innerRadius, g = f ? 0 : this.outerRadius, { sharedOptions: m, includeOptions: p } = this._getSharedOptions(r, a);
    let w = this._getRotation(), b;
    for (b = 0; b < r; ++b)
      w += this._circumference(b, i);
    for (b = r; b < r + n; ++b) {
      const k = this._circumference(b, i), v = e[b], x = {
        x: d + this.offsetX,
        y: u + this.offsetY,
        startAngle: w,
        endAngle: w + k,
        circumference: k,
        outerRadius: g,
        innerRadius: h
      };
      p && (x.options = m || this.resolveDataElementOptions(b, v.active ? "active" : a)), w += k, this.updateElement(v, b, x, a);
    }
  }
  calculateTotal() {
    const e = this._cachedMeta, r = e.data;
    let n = 0, a;
    for (a = 0; a < r.length; a++) {
      const i = e._parsed[a];
      i !== null && !isNaN(i) && this.chart.getDataVisibility(a) && !r[a].hidden && (n += Math.abs(i));
    }
    return n;
  }
  calculateCircumference(e) {
    const r = this._cachedMeta.total;
    return r > 0 && !isNaN(e) ? Qe * (Math.abs(e) / r) : 0;
  }
  getLabelAndValue(e) {
    const r = this._cachedMeta, n = this.chart, a = n.data.labels || [], i = Hv(r._parsed[e], n.options.locale);
    return {
      label: a[e] || "",
      value: i
    };
  }
  getMaxBorderWidth(e) {
    let r = 0;
    const n = this.chart;
    let a, i, s, o, l;
    if (!e) {
      for (a = 0, i = n.data.datasets.length; a < i; ++a)
        if (n.isDatasetVisible(a)) {
          s = n.getDatasetMeta(a), e = s.data, o = s.controller;
          break;
        }
    }
    if (!e)
      return 0;
    for (a = 0, i = e.length; a < i; ++a)
      l = o.resolveDataElementOptions(a), l.borderAlign !== "inner" && (r = Math.max(r, l.borderWidth || 0, l.hoverBorderWidth || 0));
    return r;
  }
  getMaxOffset(e) {
    let r = 0;
    for (let n = 0, a = e.length; n < a; ++n) {
      const i = this.resolveDataElementOptions(n);
      r = Math.max(r, i.offset || 0, i.hoverOffset || 0);
    }
    return r;
  }
  _getRingWeightOffset(e) {
    let r = 0;
    for (let n = 0; n < e; ++n)
      this.chart.isDatasetVisible(n) && (r += this._getRingWeight(n));
    return r;
  }
  _getRingWeight(e) {
    return Math.max(De(this.chart.data.datasets[e].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
}
K($a, "id", "doughnut"), K($a, "defaults", {
  datasetElementType: false,
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: false
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "circumference",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "startAngle",
        "x",
        "y",
        "offset",
        "borderWidth",
        "spacing"
      ]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
}), K($a, "descriptors", {
  _scriptable: (e) => e !== "spacing",
  _indexable: (e) => e !== "spacing" && !e.startsWith("borderDash") && !e.startsWith("hoverBorderDash")
}), K($a, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(e) {
          const r = e.data;
          if (r.labels.length && r.datasets.length) {
            const { labels: { pointStyle: n, color: a } } = e.legend.options;
            return r.labels.map((i, s) => {
              const l = e.getDatasetMeta(0).controller.getStyle(s);
              return {
                text: i,
                fillStyle: l.backgroundColor,
                strokeStyle: l.borderColor,
                fontColor: a,
                lineWidth: l.borderWidth,
                pointStyle: n,
                hidden: !e.getDataVisibility(s),
                index: s
              };
            });
          }
          return [];
        }
      },
      onClick(e, r, n) {
        n.chart.toggleDataVisibility(r.index), n.chart.update();
      }
    }
  }
});
function ln() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
class yc {
  constructor(e) {
    K(this, "options");
    this.options = e || {};
  }
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(e) {
    Object.assign(yc.prototype, e);
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return ln();
  }
  parse() {
    return ln();
  }
  format() {
    return ln();
  }
  add() {
    return ln();
  }
  diff() {
    return ln();
  }
  startOf() {
    return ln();
  }
  endOf() {
    return ln();
  }
}
var Fx = {
  _date: yc
};
function Lx(t6, e, r, n) {
  const { controller: a, data: i, _sorted: s } = t6, o = a._cachedMeta.iScale, l = t6.dataset && t6.dataset.options ? t6.dataset.options.spanGaps : null;
  if (o && e === o.axis && e !== "r" && s && i.length) {
    const c = o._reversePixels ? Pv : Ml;
    if (n) {
      if (a._sharedOptions) {
        const d = i[0], u = typeof d.getRange == "function" && d.getRange(e);
        if (u) {
          const f = c(i, e, r - u), h = c(i, e, r + u);
          return {
            lo: f.lo,
            hi: h.hi
          };
        }
      }
    } else {
      const d = c(i, e, r);
      if (l) {
        const { vScale: u } = a._cachedMeta, { _parsed: f } = t6, h = f.slice(0, d.lo + 1).reverse().findIndex((m) => !mt(m[u.axis]));
        d.lo -= Math.max(0, h);
        const g = f.slice(d.hi).findIndex((m) => !mt(m[u.axis]));
        d.hi += Math.max(0, g);
      }
      return d;
    }
  }
  return {
    lo: 0,
    hi: i.length - 1
  };
}
function io(t6, e, r, n, a) {
  const i = t6.getSortedVisibleDatasetMetas(), s = r[e];
  for (let o = 0, l = i.length; o < l; ++o) {
    const { index: c, data: d } = i[o], { lo: u, hi: f } = Lx(i[o], e, s, a);
    for (let h = u; h <= f; ++h) {
      const g = d[h];
      g.skip || n(g, c, h);
    }
  }
}
function Wx(t6) {
  const e = t6.indexOf("x") !== -1, r = t6.indexOf("y") !== -1;
  return function(n, a) {
    const i = e ? Math.abs(n.x - a.x) : 0, s = r ? Math.abs(n.y - a.y) : 0;
    return Math.sqrt(Math.pow(i, 2) + Math.pow(s, 2));
  };
}
function Ko(t6, e, r, n, a) {
  const i = [];
  return !a && !t6.isPointInArea(e) || io(t6, r, e, function(o, l, c) {
    !a && !sg(o, t6.chartArea, 0) || o.inRange(e.x, e.y, n) && i.push({
      element: o,
      datasetIndex: l,
      index: c
    });
  }, true), i;
}
function $x(t6, e, r, n) {
  let a = [];
  function i(s, o, l) {
    const { startAngle: c, endAngle: d } = s.getProps([
      "startAngle",
      "endAngle"
    ], n), { angle: u } = Zh(s, {
      x: e.x,
      y: e.y
    });
    Os(u, c, d) && a.push({
      element: s,
      datasetIndex: o,
      index: l
    });
  }
  return io(t6, r, e, i), a;
}
function zx(t6, e, r, n, a, i) {
  let s = [];
  const o = Wx(r);
  let l = Number.POSITIVE_INFINITY;
  function c(d, u, f) {
    const h = d.inRange(e.x, e.y, a);
    if (n && !h)
      return;
    const g = d.getCenterPoint(a);
    if (!(!!i || t6.isPointInArea(g)) && !h)
      return;
    const p = o(e, g);
    p < l ? (s = [
      {
        element: d,
        datasetIndex: u,
        index: f
      }
    ], l = p) : p === l && s.push({
      element: d,
      datasetIndex: u,
      index: f
    });
  }
  return io(t6, r, e, c), s;
}
function Qo(t6, e, r, n, a, i) {
  return !i && !t6.isPointInArea(e) ? [] : r === "r" && !n ? $x(t6, e, r, a) : zx(t6, e, r, n, a, i);
}
function gu(t6, e, r, n, a) {
  const i = [], s = r === "x" ? "inXRange" : "inYRange";
  let o = false;
  return io(t6, r, e, (l, c, d) => {
    l[s] && l[s](e[r], a) && (i.push({
      element: l,
      datasetIndex: c,
      index: d
    }), o = o || l.inRange(e.x, e.y, a));
  }), n && !o ? [] : i;
}
var jx = {
  modes: {
    index(t6, e, r, n) {
      const a = gn(e, t6), i = r.axis || "x", s = r.includeInvisible || false, o = r.intersect ? Ko(t6, a, i, n, s) : Qo(t6, a, i, false, n, s), l = [];
      return o.length ? (t6.getSortedVisibleDatasetMetas().forEach((c) => {
        const d = o[0].index, u = c.data[d];
        u && !u.skip && l.push({
          element: u,
          datasetIndex: c.index,
          index: d
        });
      }), l) : [];
    },
    dataset(t6, e, r, n) {
      const a = gn(e, t6), i = r.axis || "xy", s = r.includeInvisible || false;
      let o = r.intersect ? Ko(t6, a, i, n, s) : Qo(t6, a, i, false, n, s);
      if (o.length > 0) {
        const l = o[0].datasetIndex, c = t6.getDatasetMeta(l).data;
        o = [];
        for (let d = 0; d < c.length; ++d)
          o.push({
            element: c[d],
            datasetIndex: l,
            index: d
          });
      }
      return o;
    },
    point(t6, e, r, n) {
      const a = gn(e, t6), i = r.axis || "xy", s = r.includeInvisible || false;
      return Ko(t6, a, i, n, s);
    },
    nearest(t6, e, r, n) {
      const a = gn(e, t6), i = r.axis || "xy", s = r.includeInvisible || false;
      return Qo(t6, a, i, r.intersect, n, s);
    },
    x(t6, e, r, n) {
      const a = gn(e, t6);
      return gu(t6, a, "x", r.intersect, n);
    },
    y(t6, e, r, n) {
      const a = gn(e, t6);
      return gu(t6, a, "y", r.intersect, n);
    }
  }
};
const mg = [
  "left",
  "top",
  "right",
  "bottom"
];
function ka(t6, e) {
  return t6.filter((r) => r.pos === e);
}
function mu(t6, e) {
  return t6.filter((r) => mg.indexOf(r.pos) === -1 && r.box.axis === e);
}
function _a(t6, e) {
  return t6.sort((r, n) => {
    const a = e ? n : r, i = e ? r : n;
    return a.weight === i.weight ? a.index - i.index : a.weight - i.weight;
  });
}
function Hx(t6) {
  const e = [];
  let r, n, a, i, s, o;
  for (r = 0, n = (t6 || []).length; r < n; ++r)
    a = t6[r], { position: i, options: { stack: s, stackWeight: o = 1 } } = a, e.push({
      index: r,
      box: a,
      pos: i,
      horizontal: a.isHorizontal(),
      weight: a.weight,
      stack: s && i + s,
      stackWeight: o
    });
  return e;
}
function Bx(t6) {
  const e = {};
  for (const r of t6) {
    const { stack: n, pos: a, stackWeight: i } = r;
    if (!n || !mg.includes(a))
      continue;
    const s = e[n] || (e[n] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    s.count++, s.weight += i;
  }
  return e;
}
function Yx(t6, e) {
  const r = Bx(t6), { vBoxMaxWidth: n, hBoxMaxHeight: a } = e;
  let i, s, o;
  for (i = 0, s = t6.length; i < s; ++i) {
    o = t6[i];
    const { fullSize: l } = o.box, c = r[o.stack], d = c && o.stackWeight / c.weight;
    o.horizontal ? (o.width = d ? d * n : l && e.availableWidth, o.height = a) : (o.width = n, o.height = d ? d * a : l && e.availableHeight);
  }
  return r;
}
function Vx(t6) {
  const e = Hx(t6), r = _a(e.filter((c) => c.box.fullSize), true), n = _a(ka(e, "left"), true), a = _a(ka(e, "right")), i = _a(ka(e, "top"), true), s = _a(ka(e, "bottom")), o = mu(e, "x"), l = mu(e, "y");
  return {
    fullSize: r,
    leftAndTop: n.concat(i),
    rightAndBottom: a.concat(l).concat(s).concat(o),
    chartArea: ka(e, "chartArea"),
    vertical: n.concat(a).concat(l),
    horizontal: i.concat(s).concat(o)
  };
}
function pu(t6, e, r, n) {
  return Math.max(t6[r], e[r]) + Math.max(t6[n], e[n]);
}
function pg(t6, e) {
  t6.top = Math.max(t6.top, e.top), t6.left = Math.max(t6.left, e.left), t6.bottom = Math.max(t6.bottom, e.bottom), t6.right = Math.max(t6.right, e.right);
}
function qx(t6, e, r, n) {
  const { pos: a, box: i } = r, s = t6.maxPadding;
  if (!pe(a)) {
    r.size && (t6[a] -= r.size);
    const u = n[r.stack] || {
      size: 0,
      count: 1
    };
    u.size = Math.max(u.size, r.horizontal ? i.height : i.width), r.size = u.size / u.count, t6[a] += r.size;
  }
  i.getPadding && pg(s, i.getPadding());
  const o = Math.max(0, e.outerWidth - pu(s, t6, "left", "right")), l = Math.max(0, e.outerHeight - pu(s, t6, "top", "bottom")), c = o !== t6.w, d = l !== t6.h;
  return t6.w = o, t6.h = l, r.horizontal ? {
    same: c,
    other: d
  } : {
    same: d,
    other: c
  };
}
function Ux(t6) {
  const e = t6.maxPadding;
  function r(n) {
    const a = Math.max(e[n] - t6[n], 0);
    return t6[n] += a, a;
  }
  t6.y += r("top"), t6.x += r("left"), r("right"), r("bottom");
}
function Xx(t6, e) {
  const r = e.maxPadding;
  function n(a) {
    const i = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    return a.forEach((s) => {
      i[s] = Math.max(e[s], r[s]);
    }), i;
  }
  return n(t6 ? [
    "left",
    "right"
  ] : [
    "top",
    "bottom"
  ]);
}
function za(t6, e, r, n) {
  const a = [];
  let i, s, o, l, c, d;
  for (i = 0, s = t6.length, c = 0; i < s; ++i) {
    o = t6[i], l = o.box, l.update(o.width || e.w, o.height || e.h, Xx(o.horizontal, e));
    const { same: u, other: f } = qx(e, r, o, n);
    c |= u && a.length, d = d || f, l.fullSize || a.push(o);
  }
  return c && za(a, e, r, n) || d;
}
function $i(t6, e, r, n, a) {
  t6.top = r, t6.left = e, t6.right = e + n, t6.bottom = r + a, t6.width = n, t6.height = a;
}
function bu(t6, e, r, n) {
  const a = r.padding;
  let { x: i, y: s } = e;
  for (const o of t6) {
    const l = o.box, c = n[o.stack] || {
      placed: 0,
      weight: 1
    }, d = o.stackWeight / c.weight || 1;
    if (o.horizontal) {
      const u = e.w * d, f = c.size || l.height;
      ws(c.start) && (s = c.start), l.fullSize ? $i(l, a.left, s, r.outerWidth - a.right - a.left, f) : $i(l, e.left + c.placed, s, u, f), c.start = s, c.placed += u, s = l.bottom;
    } else {
      const u = e.h * d, f = c.size || l.width;
      ws(c.start) && (i = c.start), l.fullSize ? $i(l, i, a.top, f, r.outerHeight - a.bottom - a.top) : $i(l, i, e.top + c.placed, f, u), c.start = i, c.placed += u, i = l.right;
    }
  }
  e.x = i, e.y = s;
}
var Vr = {
  addBox(t6, e) {
    t6.boxes || (t6.boxes = []), e.fullSize = e.fullSize || false, e.position = e.position || "top", e.weight = e.weight || 0, e._layers = e._layers || function() {
      return [
        {
          z: 0,
          draw(r) {
            e.draw(r);
          }
        }
      ];
    }, t6.boxes.push(e);
  },
  removeBox(t6, e) {
    const r = t6.boxes ? t6.boxes.indexOf(e) : -1;
    r !== -1 && t6.boxes.splice(r, 1);
  },
  configure(t6, e, r) {
    e.fullSize = r.fullSize, e.position = r.position, e.weight = r.weight;
  },
  update(t6, e, r, n) {
    if (!t6)
      return;
    const a = Kt(t6.options.layout.padding), i = Math.max(e - a.width, 0), s = Math.max(r - a.height, 0), o = Vx(t6.boxes), l = o.vertical, c = o.horizontal;
    Se(t6.boxes, (m) => {
      typeof m.beforeLayout == "function" && m.beforeLayout();
    });
    const d = l.reduce((m, p) => p.box.options && p.box.options.display === false ? m : m + 1, 0) || 1, u = Object.freeze({
      outerWidth: e,
      outerHeight: r,
      padding: a,
      availableWidth: i,
      availableHeight: s,
      vBoxMaxWidth: i / 2 / d,
      hBoxMaxHeight: s / 2
    }), f = Object.assign({}, a);
    pg(f, Kt(n));
    const h = Object.assign({
      maxPadding: f,
      w: i,
      h: s,
      x: a.left,
      y: a.top
    }, a), g = Yx(l.concat(c), u);
    za(o.fullSize, h, u, g), za(l, h, u, g), za(c, h, u, g) && za(l, h, u, g), Ux(h), bu(o.leftAndTop, h, u, g), h.x += h.w, h.y += h.h, bu(o.rightAndBottom, h, u, g), t6.chartArea = {
      left: h.left,
      top: h.top,
      right: h.left + h.w,
      bottom: h.top + h.h,
      height: h.h,
      width: h.w
    }, Se(o.chartArea, (m) => {
      const p = m.box;
      Object.assign(p, t6.chartArea), p.update(h.w, h.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
class bg {
  acquireContext(e, r) {
  }
  releaseContext(e) {
    return false;
  }
  addEventListener(e, r, n) {
  }
  removeEventListener(e, r, n) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(e, r, n, a) {
    return r = Math.max(0, r || e.width), n = n || e.height, {
      width: r,
      height: Math.max(0, a ? Math.floor(r / a) : n)
    };
  }
  isAttached(e) {
    return true;
  }
  updateConfig(e) {
  }
}
class Gx extends bg {
  acquireContext(e) {
    return e && e.getContext && e.getContext("2d") || null;
  }
  updateConfig(e) {
    e.options.animation = false;
  }
}
const ss = "$chartjs", Kx = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
}, yu = (t6) => t6 === null || t6 === "";
function Qx(t6, e) {
  const r = t6.style, n = t6.getAttribute("height"), a = t6.getAttribute("width");
  if (t6[ss] = {
    initial: {
      height: n,
      width: a,
      style: {
        display: r.display,
        height: r.height,
        width: r.width
      }
    }
  }, r.display = r.display || "block", r.boxSizing = r.boxSizing || "border-box", yu(a)) {
    const i = ou(t6, "width");
    i !== void 0 && (t6.width = i);
  }
  if (yu(n))
    if (t6.style.height === "")
      t6.height = t6.width / (e || 2);
    else {
      const i = ou(t6, "height");
      i !== void 0 && (t6.height = i);
    }
  return t6;
}
const yg = yx ? {
  passive: true
} : false;
function Jx(t6, e, r) {
  t6 && t6.addEventListener(e, r, yg);
}
function Zx(t6, e, r) {
  t6 && t6.canvas && t6.canvas.removeEventListener(e, r, yg);
}
function ew(t6, e) {
  const r = Kx[t6.type] || t6.type, { x: n, y: a } = gn(t6, e);
  return {
    type: r,
    chart: e,
    native: t6,
    x: n !== void 0 ? n : null,
    y: a !== void 0 ? a : null
  };
}
function Ms(t6, e) {
  for (const r of t6)
    if (r === e || r.contains(e))
      return true;
}
function tw(t6, e, r) {
  const n = t6.canvas, a = new MutationObserver((i) => {
    let s = false;
    for (const o of i)
      s = s || Ms(o.addedNodes, n), s = s && !Ms(o.removedNodes, n);
    s && r();
  });
  return a.observe(document, {
    childList: true,
    subtree: true
  }), a;
}
function rw(t6, e, r) {
  const n = t6.canvas, a = new MutationObserver((i) => {
    let s = false;
    for (const o of i)
      s = s || Ms(o.removedNodes, n), s = s && !Ms(o.addedNodes, n);
    s && r();
  });
  return a.observe(document, {
    childList: true,
    subtree: true
  }), a;
}
const ni = /* @__PURE__ */ new Map();
let vu = 0;
function vg() {
  const t6 = window.devicePixelRatio;
  t6 !== vu && (vu = t6, ni.forEach((e, r) => {
    r.currentDevicePixelRatio !== t6 && e();
  }));
}
function nw(t6, e) {
  ni.size || window.addEventListener("resize", vg), ni.set(t6, e);
}
function aw(t6) {
  ni.delete(t6), ni.size || window.removeEventListener("resize", vg);
}
function iw(t6, e, r) {
  const n = t6.canvas, a = n && bc(n);
  if (!a)
    return;
  const i = rg((o, l) => {
    const c = a.clientWidth;
    r(o, l), c < a.clientWidth && r();
  }, window), s = new ResizeObserver((o) => {
    const l = o[0], c = l.contentRect.width, d = l.contentRect.height;
    c === 0 && d === 0 || i(c, d);
  });
  return s.observe(a), nw(t6, i), s;
}
function Jo(t6, e, r) {
  r && r.disconnect(), e === "resize" && aw(t6);
}
function sw(t6, e, r) {
  const n = t6.canvas, a = rg((i) => {
    t6.ctx !== null && r(ew(i, t6));
  }, t6);
  return Jx(n, e, a), a;
}
class ow extends bg {
  acquireContext(e, r) {
    const n = e && e.getContext && e.getContext("2d");
    return n && n.canvas === e ? (Qx(e, r), n) : null;
  }
  releaseContext(e) {
    const r = e.canvas;
    if (!r[ss])
      return false;
    const n = r[ss].initial;
    [
      "height",
      "width"
    ].forEach((i) => {
      const s = n[i];
      mt(s) ? r.removeAttribute(i) : r.setAttribute(i, s);
    });
    const a = n.style || {};
    return Object.keys(a).forEach((i) => {
      r.style[i] = a[i];
    }), r.width = r.width, delete r[ss], true;
  }
  addEventListener(e, r, n) {
    this.removeEventListener(e, r);
    const a = e.$proxies || (e.$proxies = {}), s = {
      attach: tw,
      detach: rw,
      resize: iw
    }[r] || sw;
    a[r] = s(e, r, n);
  }
  removeEventListener(e, r) {
    const n = e.$proxies || (e.$proxies = {}), a = n[r];
    if (!a)
      return;
    (({
      attach: Jo,
      detach: Jo,
      resize: Jo
    })[r] || Zx)(e, r, a), n[r] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(e, r, n, a) {
    return bx(e, r, n, a);
  }
  isAttached(e) {
    const r = e && bc(e);
    return !!(r && r.isConnected);
  }
}
function lw(t6) {
  return !pc() || typeof OffscreenCanvas < "u" && t6 instanceof OffscreenCanvas ? Gx : ow;
}
var is;
let mi = (is = class {
  constructor() {
    K(this, "x");
    K(this, "y");
    K(this, "active", false);
    K(this, "options");
    K(this, "$animations");
  }
  tooltipPosition(e) {
    const { x: r, y: n } = this.getProps([
      "x",
      "y"
    ], e);
    return {
      x: r,
      y: n
    };
  }
  hasValue() {
    return _s(this.x) && _s(this.y);
  }
  getProps(e, r) {
    const n = this.$animations;
    if (!r || !n)
      return this;
    const a = {};
    return e.forEach((i) => {
      a[i] = n[i] && n[i].active() ? n[i]._to : this[i];
    }), a;
  }
}, K(is, "defaults", {}), K(is, "defaultRoutes"), is);
function cw(t6, e) {
  const r = t6.options.ticks, n = dw(t6), a = Math.min(r.maxTicksLimit || n, n), i = r.major.enabled ? fw(e) : [], s = i.length, o = i[0], l = i[s - 1], c = [];
  if (s > a)
    return hw(e, c, i, s / a), c;
  const d = uw(i, e, a);
  if (s > 0) {
    let u, f;
    const h = s > 1 ? Math.round((l - o) / (s - 1)) : null;
    for (zi(e, c, d, mt(h) ? 0 : o - h, o), u = 0, f = s - 1; u < f; u++)
      zi(e, c, d, i[u], i[u + 1]);
    return zi(e, c, d, l, mt(h) ? e.length : l + h), c;
  }
  return zi(e, c, d), c;
}
function dw(t6) {
  const e = t6.options.offset, r = t6._tickSize(), n = t6._length / r + (e ? 0 : 1), a = t6._maxLength / r;
  return Math.floor(Math.min(n, a));
}
function uw(t6, e, r) {
  const n = gw(t6), a = e.length / r;
  if (!n)
    return Math.max(a, 1);
  const i = Dv(n);
  for (let s = 0, o = i.length - 1; s < o; s++) {
    const l = i[s];
    if (l > a)
      return l;
  }
  return Math.max(a, 1);
}
function fw(t6) {
  const e = [];
  let r, n;
  for (r = 0, n = t6.length; r < n; r++)
    t6[r].major && e.push(r);
  return e;
}
function hw(t6, e, r, n) {
  let a = 0, i = r[0], s;
  for (n = Math.ceil(n), s = 0; s < t6.length; s++)
    s === i && (e.push(t6[s]), a++, i = r[a * n]);
}
function zi(t6, e, r, n, a) {
  const i = De(n, 0), s = Math.min(De(a, t6.length), t6.length);
  let o = 0, l, c, d;
  for (r = Math.ceil(r), a && (l = a - n, r = l / Math.floor(l / r)), d = i; d < 0; )
    o++, d = Math.round(i + o * r);
  for (c = Math.max(i, 0); c < s; c++)
    c === d && (e.push(t6[c]), o++, d = Math.round(i + o * r));
}
function gw(t6) {
  const e = t6.length;
  let r, n;
  if (e < 2)
    return false;
  for (n = t6[0], r = 1; r < e; ++r)
    if (t6[r] - t6[r - 1] !== n)
      return false;
  return n;
}
const mw = (t6) => t6 === "left" ? "right" : t6 === "right" ? "left" : t6, xu = (t6, e, r) => e === "top" || e === "left" ? t6[e] + r : t6[e] - r, wu = (t6, e) => Math.min(e || t6, t6);
function ku(t6, e) {
  const r = [], n = t6.length / e, a = t6.length;
  let i = 0;
  for (; i < a; i += n)
    r.push(t6[Math.floor(i)]);
  return r;
}
function pw(t6, e, r) {
  const n = t6.ticks.length, a = Math.min(e, n - 1), i = t6._startPixel, s = t6._endPixel, o = 1e-6;
  let l = t6.getPixelForTick(a), c;
  if (!(r && (n === 1 ? c = Math.max(l - i, s - l) : e === 0 ? c = (t6.getPixelForTick(1) - l) / 2 : c = (l - t6.getPixelForTick(a - 1)) / 2, l += a < e ? c : -c, l < i - o || l > s + o)))
    return l;
}
function bw(t6, e) {
  Se(t6, (r) => {
    const n = r.gc, a = n.length / 2;
    let i;
    if (a > e) {
      for (i = 0; i < a; ++i)
        delete r.data[n[i]];
      n.splice(0, a);
    }
  });
}
function Oa(t6) {
  return t6.drawTicks ? t6.tickLength : 0;
}
function _u(t6, e) {
  if (!t6.display)
    return 0;
  const r = _t(t6.font, e), n = Kt(t6.padding);
  return (ct(t6.text) ? t6.text.length : 1) * r.lineHeight + n.height;
}
function yw(t6, e) {
  return ha(t6, {
    scale: e,
    type: "scale"
  });
}
function vw(t6, e, r) {
  return ha(t6, {
    tick: r,
    index: e,
    type: "tick"
  });
}
function xw(t6, e, r) {
  let n = ng(t6);
  return (r && e !== "right" || !r && e === "right") && (n = mw(n)), n;
}
function ww(t6, e, r, n) {
  const { top: a, left: i, bottom: s, right: o, chart: l } = t6, { chartArea: c, scales: d } = l;
  let u = 0, f, h, g;
  const m = s - a, p = o - i;
  if (t6.isHorizontal()) {
    if (h = It(n, i, o), pe(r)) {
      const w = Object.keys(r)[0], b = r[w];
      g = d[w].getPixelForValue(b) + m - e;
    } else r === "center" ? g = (c.bottom + c.top) / 2 + m - e : g = xu(t6, r, e);
    f = o - i;
  } else {
    if (pe(r)) {
      const w = Object.keys(r)[0], b = r[w];
      h = d[w].getPixelForValue(b) - p + e;
    } else r === "center" ? h = (c.left + c.right) / 2 - p + e : h = xu(t6, r, e);
    g = It(n, s, a), u = r === "left" ? -tt : tt;
  }
  return {
    titleX: h,
    titleY: g,
    maxWidth: f,
    rotation: u
  };
}
class so extends mi {
  constructor(e) {
    super(), this.id = e.id, this.type = e.type, this.options = void 0, this.ctx = e.ctx, this.chart = e.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = false, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = false, this.$context = void 0;
  }
  init(e) {
    this.options = e.setContext(this.getContext()), this.axis = e.axis, this._userMin = this.parse(e.min), this._userMax = this.parse(e.max), this._suggestedMin = this.parse(e.suggestedMin), this._suggestedMax = this.parse(e.suggestedMax);
  }
  parse(e, r) {
    return e;
  }
  getUserBounds() {
    let { _userMin: e, _userMax: r, _suggestedMin: n, _suggestedMax: a } = this;
    return e = er(e, Number.POSITIVE_INFINITY), r = er(r, Number.NEGATIVE_INFINITY), n = er(n, Number.POSITIVE_INFINITY), a = er(a, Number.NEGATIVE_INFINITY), {
      min: er(e, n),
      max: er(r, a),
      minDefined: Er(e),
      maxDefined: Er(r)
    };
  }
  getMinMax(e) {
    let { min: r, max: n, minDefined: a, maxDefined: i } = this.getUserBounds(), s;
    if (a && i)
      return {
        min: r,
        max: n
      };
    const o = this.getMatchingVisibleMetas();
    for (let l = 0, c = o.length; l < c; ++l)
      s = o[l].controller.getMinMax(this, e), a || (r = Math.min(r, s.min)), i || (n = Math.max(n, s.max));
    return r = i && r > n ? n : r, n = a && r > n ? r : n, {
      min: er(r, er(n, r)),
      max: er(n, er(r, n))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const e = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? e.xLabels : e.yLabels) || e.labels || [];
  }
  getLabelItems(e = this.chart.chartArea) {
    return this._labelItems || (this._labelItems = this._computeLabelItems(e));
  }
  beforeLayout() {
    this._cache = {}, this._dataLimitsCached = false;
  }
  beforeUpdate() {
    Ae(this.options.beforeUpdate, [
      this
    ]);
  }
  update(e, r, n) {
    const { beginAtZero: a, grace: i, ticks: s } = this.options, o = s.sampleSize;
    this.beforeUpdate(), this.maxWidth = e, this.maxHeight = r, this._margins = n = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, n), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + n.left + n.right : this.height + n.top + n.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = rx(this, i, a), this._dataLimitsCached = true), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
    const l = o < this.ticks.length;
    this._convertTicksToLabels(l ? ku(this.ticks, o) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), s.display && (s.autoSkip || s.source === "auto") && (this.ticks = cw(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();
  }
  configure() {
    let e = this.options.reverse, r, n;
    this.isHorizontal() ? (r = this.left, n = this.right) : (r = this.top, n = this.bottom, e = !e), this._startPixel = r, this._endPixel = n, this._reversePixels = e, this._length = n - r, this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    Ae(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    Ae(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;
  }
  afterSetDimensions() {
    Ae(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(e) {
    this.chart.notifyPlugins(e, this.getContext()), Ae(this.options[e], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    Ae(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(e) {
    const r = this.options.ticks;
    let n, a, i;
    for (n = 0, a = e.length; n < a; n++)
      i = e[n], i.label = Ae(r.callback, [
        i.value,
        n,
        e
      ], this);
  }
  afterTickToLabelConversion() {
    Ae(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    Ae(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const e = this.options, r = e.ticks, n = wu(this.ticks.length, e.ticks.maxTicksLimit), a = r.minRotation || 0, i = r.maxRotation;
    let s = a, o, l, c;
    if (!this._isVisible() || !r.display || a >= i || n <= 1 || !this.isHorizontal()) {
      this.labelRotation = a;
      return;
    }
    const d = this._getLabelSizes(), u = d.widest.width, f = d.highest.height, h = jt(this.chart.width - u, 0, this.maxWidth);
    o = e.offset ? this.maxWidth / n : h / (n - 1), u + 6 > o && (o = h / (n - (e.offset ? 0.5 : 1)), l = this.maxHeight - Oa(e.grid) - r.padding - _u(e.title, this.chart.options.font), c = Math.sqrt(u * u + f * f), s = Cv(Math.min(Math.asin(jt((d.highest.height + 6) / o, -1, 1)), Math.asin(jt(l / c, -1, 1)) - Math.asin(jt(f / c, -1, 1)))), s = Math.max(a, Math.min(i, s))), this.labelRotation = s;
  }
  afterCalculateLabelRotation() {
    Ae(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    Ae(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const e = {
      width: 0,
      height: 0
    }, { chart: r, options: { ticks: n, title: a, grid: i } } = this, s = this._isVisible(), o = this.isHorizontal();
    if (s) {
      const l = _u(a, r.options.font);
      if (o ? (e.width = this.maxWidth, e.height = Oa(i) + l) : (e.height = this.maxHeight, e.width = Oa(i) + l), n.display && this.ticks.length) {
        const { first: c, last: d, widest: u, highest: f } = this._getLabelSizes(), h = n.padding * 2, g = xn(this.labelRotation), m = Math.cos(g), p = Math.sin(g);
        if (o) {
          const w = n.mirror ? 0 : p * u.width + m * f.height;
          e.height = Math.min(this.maxHeight, e.height + w + h);
        } else {
          const w = n.mirror ? 0 : m * u.width + p * f.height;
          e.width = Math.min(this.maxWidth, e.width + w + h);
        }
        this._calculatePadding(c, d, p, m);
      }
    }
    this._handleMargins(), o ? (this.width = this._length = r.width - this._margins.left - this._margins.right, this.height = e.height) : (this.width = e.width, this.height = this._length = r.height - this._margins.top - this._margins.bottom);
  }
  _calculatePadding(e, r, n, a) {
    const { ticks: { align: i, padding: s }, position: o } = this.options, l = this.labelRotation !== 0, c = o !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const d = this.getPixelForTick(0) - this.left, u = this.right - this.getPixelForTick(this.ticks.length - 1);
      let f = 0, h = 0;
      l ? c ? (f = a * e.width, h = n * r.height) : (f = n * e.height, h = a * r.width) : i === "start" ? h = r.width : i === "end" ? f = e.width : i !== "inner" && (f = e.width / 2, h = r.width / 2), this.paddingLeft = Math.max((f - d + s) * this.width / (this.width - d), 0), this.paddingRight = Math.max((h - u + s) * this.width / (this.width - u), 0);
    } else {
      let d = r.height / 2, u = e.height / 2;
      i === "start" ? (d = 0, u = e.height) : i === "end" && (d = r.height, u = 0), this.paddingTop = d + s, this.paddingBottom = u + s;
    }
  }
  _handleMargins() {
    this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));
  }
  afterFit() {
    Ae(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis: e, position: r } = this.options;
    return r === "top" || r === "bottom" || e === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(e) {
    this.beforeTickToLabelConversion(), this.generateTickLabels(e);
    let r, n;
    for (r = 0, n = e.length; r < n; r++)
      mt(e[r].label) && (e.splice(r, 1), n--, r--);
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let e = this._labelSizes;
    if (!e) {
      const r = this.options.ticks.sampleSize;
      let n = this.ticks;
      r < n.length && (n = ku(n, r)), this._labelSizes = e = this._computeLabelSizes(n, n.length, this.options.ticks.maxTicksLimit);
    }
    return e;
  }
  _computeLabelSizes(e, r, n) {
    const { ctx: a, _longestTextCache: i } = this, s = [], o = [], l = Math.floor(r / wu(r, n));
    let c = 0, d = 0, u, f, h, g, m, p, w, b, k, v, x;
    for (u = 0; u < r; u += l) {
      if (g = e[u].label, m = this._resolveTickFontOptions(u), a.font = p = m.string, w = i[p] = i[p] || {
        data: {},
        gc: []
      }, b = m.lineHeight, k = v = 0, !mt(g) && !ct(g))
        k = tu(a, w.data, w.gc, k, g), v = b;
      else if (ct(g))
        for (f = 0, h = g.length; f < h; ++f)
          x = g[f], !mt(x) && !ct(x) && (k = tu(a, w.data, w.gc, k, x), v += b);
      s.push(k), o.push(v), c = Math.max(k, c), d = Math.max(v, d);
    }
    bw(i, r);
    const _ = s.indexOf(c), T = o.indexOf(d), S = (C) => ({
      width: s[C] || 0,
      height: o[C] || 0
    });
    return {
      first: S(0),
      last: S(r - 1),
      widest: S(_),
      highest: S(T),
      widths: s,
      heights: o
    };
  }
  getLabelForValue(e) {
    return e;
  }
  getPixelForValue(e, r) {
    return NaN;
  }
  getValueForPixel(e) {
  }
  getPixelForTick(e) {
    const r = this.ticks;
    return e < 0 || e > r.length - 1 ? null : this.getPixelForValue(r[e].value);
  }
  getPixelForDecimal(e) {
    this._reversePixels && (e = 1 - e);
    const r = this._startPixel + e * this._length;
    return Tv(this._alignToPixels ? on(this.chart, r, 0) : r);
  }
  getDecimalForPixel(e) {
    const r = (e - this._startPixel) / this._length;
    return this._reversePixels ? 1 - r : r;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min: e, max: r } = this;
    return e < 0 && r < 0 ? r : e > 0 && r > 0 ? e : 0;
  }
  getContext(e) {
    const r = this.ticks || [];
    if (e >= 0 && e < r.length) {
      const n = r[e];
      return n.$context || (n.$context = vw(this.getContext(), e, n));
    }
    return this.$context || (this.$context = yw(this.chart.getContext(), this));
  }
  _tickSize() {
    const e = this.options.ticks, r = xn(this.labelRotation), n = Math.abs(Math.cos(r)), a = Math.abs(Math.sin(r)), i = this._getLabelSizes(), s = e.autoSkipPadding || 0, o = i ? i.widest.width + s : 0, l = i ? i.highest.height + s : 0;
    return this.isHorizontal() ? l * n > o * a ? o / n : l / a : l * a < o * n ? l / n : o / a;
  }
  _isVisible() {
    const e = this.options.display;
    return e !== "auto" ? !!e : this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(e) {
    const r = this.axis, n = this.chart, a = this.options, { grid: i, position: s, border: o } = a, l = i.offset, c = this.isHorizontal(), u = this.ticks.length + (l ? 1 : 0), f = Oa(i), h = [], g = o.setContext(this.getContext()), m = g.display ? g.width : 0, p = m / 2, w = function(W) {
      return on(n, W, m);
    };
    let b, k, v, x, _, T, S, C, D, z, A, L;
    if (s === "top")
      b = w(this.bottom), T = this.bottom - f, C = b - p, z = w(e.top) + p, L = e.bottom;
    else if (s === "bottom")
      b = w(this.top), z = e.top, L = w(e.bottom) - p, T = b + p, C = this.top + f;
    else if (s === "left")
      b = w(this.right), _ = this.right - f, S = b - p, D = w(e.left) + p, A = e.right;
    else if (s === "right")
      b = w(this.left), D = e.left, A = w(e.right) - p, _ = b + p, S = this.left + f;
    else if (r === "x") {
      if (s === "center")
        b = w((e.top + e.bottom) / 2 + 0.5);
      else if (pe(s)) {
        const W = Object.keys(s)[0], B = s[W];
        b = w(this.chart.scales[W].getPixelForValue(B));
      }
      z = e.top, L = e.bottom, T = b + p, C = T + f;
    } else if (r === "y") {
      if (s === "center")
        b = w((e.left + e.right) / 2);
      else if (pe(s)) {
        const W = Object.keys(s)[0], B = s[W];
        b = w(this.chart.scales[W].getPixelForValue(B));
      }
      _ = b - p, S = _ - f, D = e.left, A = e.right;
    }
    const M = De(a.ticks.maxTicksLimit, u), I = Math.max(1, Math.ceil(u / M));
    for (k = 0; k < u; k += I) {
      const W = this.getContext(k), B = i.setContext(W), U = o.setContext(W), J = B.lineWidth, E = B.color, j = U.dash || [], N = U.dashOffset, R = B.tickWidth, P = B.tickColor, O = B.tickBorderDash || [], F = B.tickBorderDashOffset;
      v = pw(this, k, l), v !== void 0 && (x = on(n, v, J), c ? _ = S = D = A = x : T = C = z = L = x, h.push({
        tx1: _,
        ty1: T,
        tx2: S,
        ty2: C,
        x1: D,
        y1: z,
        x2: A,
        y2: L,
        width: J,
        color: E,
        borderDash: j,
        borderDashOffset: N,
        tickWidth: R,
        tickColor: P,
        tickBorderDash: O,
        tickBorderDashOffset: F
      }));
    }
    return this._ticksLength = u, this._borderValue = b, h;
  }
  _computeLabelItems(e) {
    const r = this.axis, n = this.options, { position: a, ticks: i } = n, s = this.isHorizontal(), o = this.ticks, { align: l, crossAlign: c, padding: d, mirror: u } = i, f = Oa(n.grid), h = f + d, g = u ? -d : h, m = -xn(this.labelRotation), p = [];
    let w, b, k, v, x, _, T, S, C, D, z, A, L = "middle";
    if (a === "top")
      _ = this.bottom - g, T = this._getXAxisLabelAlignment();
    else if (a === "bottom")
      _ = this.top + g, T = this._getXAxisLabelAlignment();
    else if (a === "left") {
      const I = this._getYAxisLabelAlignment(f);
      T = I.textAlign, x = I.x;
    } else if (a === "right") {
      const I = this._getYAxisLabelAlignment(f);
      T = I.textAlign, x = I.x;
    } else if (r === "x") {
      if (a === "center")
        _ = (e.top + e.bottom) / 2 + h;
      else if (pe(a)) {
        const I = Object.keys(a)[0], W = a[I];
        _ = this.chart.scales[I].getPixelForValue(W) + h;
      }
      T = this._getXAxisLabelAlignment();
    } else if (r === "y") {
      if (a === "center")
        x = (e.left + e.right) / 2 - h;
      else if (pe(a)) {
        const I = Object.keys(a)[0], W = a[I];
        x = this.chart.scales[I].getPixelForValue(W);
      }
      T = this._getYAxisLabelAlignment(f).textAlign;
    }
    r === "y" && (l === "start" ? L = "top" : l === "end" && (L = "bottom"));
    const M = this._getLabelSizes();
    for (w = 0, b = o.length; w < b; ++w) {
      k = o[w], v = k.label;
      const I = i.setContext(this.getContext(w));
      S = this.getPixelForTick(w) + i.labelOffset, C = this._resolveTickFontOptions(w), D = C.lineHeight, z = ct(v) ? v.length : 1;
      const W = z / 2, B = I.color, U = I.textStrokeColor, J = I.textStrokeWidth;
      let E = T;
      s ? (x = S, T === "inner" && (w === b - 1 ? E = this.options.reverse ? "left" : "right" : w === 0 ? E = this.options.reverse ? "right" : "left" : E = "center"), a === "top" ? c === "near" || m !== 0 ? A = -z * D + D / 2 : c === "center" ? A = -M.highest.height / 2 - W * D + D : A = -M.highest.height + D / 2 : c === "near" || m !== 0 ? A = D / 2 : c === "center" ? A = M.highest.height / 2 - W * D : A = M.highest.height - z * D, u && (A *= -1), m !== 0 && !I.showLabelBackdrop && (x += D / 2 * Math.sin(m))) : (_ = S, A = (1 - z) * D / 2);
      let j;
      if (I.showLabelBackdrop) {
        const N = Kt(I.backdropPadding), R = M.heights[w], P = M.widths[w];
        let O = A - N.top, F = 0 - N.left;
        switch (L) {
          case "middle":
            O -= R / 2;
            break;
          case "bottom":
            O -= R;
            break;
        }
        switch (T) {
          case "center":
            F -= P / 2;
            break;
          case "right":
            F -= P;
            break;
          case "inner":
            w === b - 1 ? F -= P : w > 0 && (F -= P / 2);
            break;
        }
        j = {
          left: F,
          top: O,
          width: P + N.width,
          height: R + N.height,
          color: I.backdropColor
        };
      }
      p.push({
        label: v,
        font: C,
        textOffset: A,
        options: {
          rotation: m,
          color: B,
          strokeColor: U,
          strokeWidth: J,
          textAlign: E,
          textBaseline: L,
          translation: [
            x,
            _
          ],
          backdrop: j
        }
      });
    }
    return p;
  }
  _getXAxisLabelAlignment() {
    const { position: e, ticks: r } = this.options;
    if (-xn(this.labelRotation))
      return e === "top" ? "left" : "right";
    let a = "center";
    return r.align === "start" ? a = "left" : r.align === "end" ? a = "right" : r.align === "inner" && (a = "inner"), a;
  }
  _getYAxisLabelAlignment(e) {
    const { position: r, ticks: { crossAlign: n, mirror: a, padding: i } } = this.options, s = this._getLabelSizes(), o = e + i, l = s.widest.width;
    let c, d;
    return r === "left" ? a ? (d = this.right + i, n === "near" ? c = "left" : n === "center" ? (c = "center", d += l / 2) : (c = "right", d += l)) : (d = this.right - o, n === "near" ? c = "right" : n === "center" ? (c = "center", d -= l / 2) : (c = "left", d = this.left)) : r === "right" ? a ? (d = this.left + i, n === "near" ? c = "right" : n === "center" ? (c = "center", d -= l / 2) : (c = "left", d -= l)) : (d = this.left + o, n === "near" ? c = "left" : n === "center" ? (c = "center", d += l / 2) : (c = "right", d = this.right)) : c = "right", {
      textAlign: c,
      x: d
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror)
      return;
    const e = this.chart, r = this.options.position;
    if (r === "left" || r === "right")
      return {
        top: 0,
        left: this.left,
        bottom: e.height,
        right: this.right
      };
    if (r === "top" || r === "bottom")
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: e.width
      };
  }
  drawBackground() {
    const { ctx: e, options: { backgroundColor: r }, left: n, top: a, width: i, height: s } = this;
    r && (e.save(), e.fillStyle = r, e.fillRect(n, a, i, s), e.restore());
  }
  getLineWidthForValue(e) {
    const r = this.options.grid;
    if (!this._isVisible() || !r.display)
      return 0;
    const a = this.ticks.findIndex((i) => i.value === e);
    return a >= 0 ? r.setContext(this.getContext(a)).lineWidth : 0;
  }
  drawGrid(e) {
    const r = this.options.grid, n = this.ctx, a = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(e));
    let i, s;
    const o = (l, c, d) => {
      !d.width || !d.color || (n.save(), n.lineWidth = d.width, n.strokeStyle = d.color, n.setLineDash(d.borderDash || []), n.lineDashOffset = d.borderDashOffset, n.beginPath(), n.moveTo(l.x, l.y), n.lineTo(c.x, c.y), n.stroke(), n.restore());
    };
    if (r.display)
      for (i = 0, s = a.length; i < s; ++i) {
        const l = a[i];
        r.drawOnChartArea && o({
          x: l.x1,
          y: l.y1
        }, {
          x: l.x2,
          y: l.y2
        }, l), r.drawTicks && o({
          x: l.tx1,
          y: l.ty1
        }, {
          x: l.tx2,
          y: l.ty2
        }, {
          color: l.tickColor,
          width: l.tickWidth,
          borderDash: l.tickBorderDash,
          borderDashOffset: l.tickBorderDashOffset
        });
      }
  }
  drawBorder() {
    const { chart: e, ctx: r, options: { border: n, grid: a } } = this, i = n.setContext(this.getContext()), s = n.display ? i.width : 0;
    if (!s)
      return;
    const o = a.setContext(this.getContext(0)).lineWidth, l = this._borderValue;
    let c, d, u, f;
    this.isHorizontal() ? (c = on(e, this.left, s) - s / 2, d = on(e, this.right, o) + o / 2, u = f = l) : (u = on(e, this.top, s) - s / 2, f = on(e, this.bottom, o) + o / 2, c = d = l), r.save(), r.lineWidth = i.width, r.strokeStyle = i.color, r.beginPath(), r.moveTo(c, u), r.lineTo(d, f), r.stroke(), r.restore();
  }
  drawLabels(e) {
    if (!this.options.ticks.display)
      return;
    const n = this.ctx, a = this._computeLabelArea();
    a && dc(n, a);
    const i = this.getLabelItems(e);
    for (const s of i) {
      const o = s.options, l = s.font, c = s.label, d = s.textOffset;
      Ss(n, c, 0, d, l, o);
    }
    a && uc(n);
  }
  drawTitle() {
    const { ctx: e, options: { position: r, title: n, reverse: a } } = this;
    if (!n.display)
      return;
    const i = _t(n.font), s = Kt(n.padding), o = n.align;
    let l = i.lineHeight / 2;
    r === "bottom" || r === "center" || pe(r) ? (l += s.bottom, ct(n.text) && (l += i.lineHeight * (n.text.length - 1))) : l += s.top;
    const { titleX: c, titleY: d, maxWidth: u, rotation: f } = ww(this, l, r, o);
    Ss(e, n.text, 0, 0, i, {
      color: n.color,
      maxWidth: u,
      rotation: f,
      textAlign: xw(o, r, a),
      textBaseline: "middle",
      translation: [
        c,
        d
      ]
    });
  }
  draw(e) {
    this._isVisible() && (this.drawBackground(), this.drawGrid(e), this.drawBorder(), this.drawTitle(), this.drawLabels(e));
  }
  _layers() {
    const e = this.options, r = e.ticks && e.ticks.z || 0, n = De(e.grid && e.grid.z, -1), a = De(e.border && e.border.z, 0);
    return !this._isVisible() || this.draw !== so.prototype.draw ? [
      {
        z: r,
        draw: (i) => {
          this.draw(i);
        }
      }
    ] : [
      {
        z: n,
        draw: (i) => {
          this.drawBackground(), this.drawGrid(i), this.drawTitle();
        }
      },
      {
        z: a,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: r,
        draw: (i) => {
          this.drawLabels(i);
        }
      }
    ];
  }
  getMatchingVisibleMetas(e) {
    const r = this.chart.getSortedVisibleDatasetMetas(), n = this.axis + "AxisID", a = [];
    let i, s;
    for (i = 0, s = r.length; i < s; ++i) {
      const o = r[i];
      o[n] === this.id && (!e || o.type === e) && a.push(o);
    }
    return a;
  }
  _resolveTickFontOptions(e) {
    const r = this.options.ticks.setContext(this.getContext(e));
    return _t(r.font);
  }
  _maxDigits() {
    const e = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / e;
  }
}
class ji {
  constructor(e, r, n) {
    this.type = e, this.scope = r, this.override = n, this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(e) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, e.prototype);
  }
  register(e) {
    const r = Object.getPrototypeOf(e);
    let n;
    Ow(r) && (n = this.register(r));
    const a = this.items, i = e.id, s = this.scope + "." + i;
    if (!i)
      throw new Error("class does not have id: " + e);
    return i in a || (a[i] = e, kw(e, s, n), this.override && Ve.override(e.id, e.overrides)), s;
  }
  get(e) {
    return this.items[e];
  }
  unregister(e) {
    const r = this.items, n = e.id, a = this.scope;
    n in r && delete r[n], a && n in Ve[a] && (delete Ve[a][n], this.override && delete En[n]);
  }
}
function kw(t6, e, r) {
  const n = ti(/* @__PURE__ */ Object.create(null), [
    r ? Ve.get(r) : {},
    Ve.get(e),
    t6.defaults
  ]);
  Ve.set(e, n), t6.defaultRoutes && _w(e, t6.defaultRoutes), t6.descriptors && Ve.describe(e, t6.descriptors);
}
function _w(t6, e) {
  Object.keys(e).forEach((r) => {
    const n = r.split("."), a = n.pop(), i = [
      t6
    ].concat(n).join("."), s = e[r].split("."), o = s.pop(), l = s.join(".");
    Ve.route(i, a, l, o);
  });
}
function Ow(t6) {
  return "id" in t6 && "defaults" in t6;
}
class Sw {
  constructor() {
    this.controllers = new ji(Ua, "datasets", true), this.elements = new ji(mi, "elements"), this.plugins = new ji(Object, "plugins"), this.scales = new ji(so, "scales"), this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...e) {
    this._each("register", e);
  }
  remove(...e) {
    this._each("unregister", e);
  }
  addControllers(...e) {
    this._each("register", e, this.controllers);
  }
  addElements(...e) {
    this._each("register", e, this.elements);
  }
  addPlugins(...e) {
    this._each("register", e, this.plugins);
  }
  addScales(...e) {
    this._each("register", e, this.scales);
  }
  getController(e) {
    return this._get(e, this.controllers, "controller");
  }
  getElement(e) {
    return this._get(e, this.elements, "element");
  }
  getPlugin(e) {
    return this._get(e, this.plugins, "plugin");
  }
  getScale(e) {
    return this._get(e, this.scales, "scale");
  }
  removeControllers(...e) {
    this._each("unregister", e, this.controllers);
  }
  removeElements(...e) {
    this._each("unregister", e, this.elements);
  }
  removePlugins(...e) {
    this._each("unregister", e, this.plugins);
  }
  removeScales(...e) {
    this._each("unregister", e, this.scales);
  }
  _each(e, r, n) {
    [
      ...r
    ].forEach((a) => {
      const i = n || this._getRegistryForType(a);
      n || i.isForType(a) || i === this.plugins && a.id ? this._exec(e, i, a) : Se(a, (s) => {
        const o = n || this._getRegistryForType(s);
        this._exec(e, o, s);
      });
    });
  }
  _exec(e, r, n) {
    const a = lc(e);
    Ae(n["before" + a], [], n), r[e](n), Ae(n["after" + a], [], n);
  }
  _getRegistryForType(e) {
    for (let r = 0; r < this._typedRegistries.length; r++) {
      const n = this._typedRegistries[r];
      if (n.isForType(e))
        return n;
    }
    return this.plugins;
  }
  _get(e, r, n) {
    const a = r.get(e);
    if (a === void 0)
      throw new Error('"' + e + '" is not a registered ' + n + ".");
    return a;
  }
}
var ar = /* @__PURE__ */ new Sw();
class Dw {
  constructor() {
    this._init = [];
  }
  notify(e, r, n, a) {
    r === "beforeInit" && (this._init = this._createDescriptors(e, true), this._notify(this._init, e, "install"));
    const i = a ? this._descriptors(e).filter(a) : this._descriptors(e), s = this._notify(i, e, r, n);
    return r === "afterDestroy" && (this._notify(i, e, "stop"), this._notify(this._init, e, "uninstall")), s;
  }
  _notify(e, r, n, a) {
    a = a || {};
    for (const i of e) {
      const s = i.plugin, o = s[n], l = [
        r,
        a,
        i.options
      ];
      if (Ae(o, l, s) === false && a.cancelable)
        return false;
    }
    return true;
  }
  invalidate() {
    mt(this._cache) || (this._oldCache = this._cache, this._cache = void 0);
  }
  _descriptors(e) {
    if (this._cache)
      return this._cache;
    const r = this._cache = this._createDescriptors(e);
    return this._notifyStateChanges(e), r;
  }
  _createDescriptors(e, r) {
    const n = e && e.config, a = De(n.options && n.options.plugins, {}), i = Mw(n);
    return a === false && !r ? [] : Ew(e, i, a, r);
  }
  _notifyStateChanges(e) {
    const r = this._oldCache || [], n = this._cache, a = (i, s) => i.filter((o) => !s.some((l) => o.plugin.id === l.plugin.id));
    this._notify(a(r, n), e, "stop"), this._notify(a(n, r), e, "start");
  }
}
function Mw(t6) {
  const e = {}, r = [], n = Object.keys(ar.plugins.items);
  for (let i = 0; i < n.length; i++)
    r.push(ar.getPlugin(n[i]));
  const a = t6.plugins || [];
  for (let i = 0; i < a.length; i++) {
    const s = a[i];
    r.indexOf(s) === -1 && (r.push(s), e[s.id] = true);
  }
  return {
    plugins: r,
    localIds: e
  };
}
function Cw(t6, e) {
  return !e && t6 === false ? null : t6 === true ? {} : t6;
}
function Ew(t6, { plugins: e, localIds: r }, n, a) {
  const i = [], s = t6.getContext();
  for (const o of e) {
    const l = o.id, c = Cw(n[l], a);
    c !== null && i.push({
      plugin: o,
      options: Tw(t6.config, {
        plugin: o,
        local: r[l]
      }, c, s)
    });
  }
  return i;
}
function Tw(t6, { plugin: e, local: r }, n, a) {
  const i = t6.pluginScopeKeys(e), s = t6.getOptionScopes(n, i);
  return r && e.defaults && s.push(e.defaults), t6.createResolver(s, a, [
    ""
  ], {
    scriptable: false,
    indexable: false,
    allKeys: true
  });
}
function Tl(t6, e) {
  const r = Ve.datasets[t6] || {};
  return ((e.datasets || {})[t6] || {}).indexAxis || e.indexAxis || r.indexAxis || "x";
}
function Pw(t6, e) {
  let r = t6;
  return t6 === "_index_" ? r = e : t6 === "_value_" && (r = e === "x" ? "y" : "x"), r;
}
function Rw(t6, e) {
  return t6 === e ? "_index_" : "_value_";
}
function Ou(t6) {
  if (t6 === "x" || t6 === "y" || t6 === "r")
    return t6;
}
function Nw(t6) {
  if (t6 === "top" || t6 === "bottom")
    return "x";
  if (t6 === "left" || t6 === "right")
    return "y";
}
function Pl(t6, ...e) {
  if (Ou(t6))
    return t6;
  for (const r of e) {
    const n = r.axis || Nw(r.position) || t6.length > 1 && Ou(t6[0].toLowerCase());
    if (n)
      return n;
  }
  throw new Error(`Cannot determine type of '${t6}' axis. Please provide 'axis' or 'position' option.`);
}
function Su(t6, e, r) {
  if (r[e + "AxisID"] === t6)
    return {
      axis: e
    };
}
function Iw(t6, e) {
  if (e.data && e.data.datasets) {
    const r = e.data.datasets.filter((n) => n.xAxisID === t6 || n.yAxisID === t6);
    if (r.length)
      return Su(t6, "x", r[0]) || Su(t6, "y", r[0]);
  }
  return {};
}
function Aw(t6, e) {
  const r = En[t6.type] || {
    scales: {}
  }, n = e.scales || {}, a = Tl(t6.type, e), i = /* @__PURE__ */ Object.create(null);
  return Object.keys(n).forEach((s) => {
    const o = n[s];
    if (!pe(o))
      return console.error(`Invalid scale configuration for scale: ${s}`);
    if (o._proxy)
      return console.warn(`Ignoring resolver passed as options for scale: ${s}`);
    const l = Pl(s, o, Iw(s, t6), Ve.scales[o.type]), c = Rw(l, a), d = r.scales || {};
    i[s] = Ba(/* @__PURE__ */ Object.create(null), [
      {
        axis: l
      },
      o,
      d[l],
      d[c]
    ]);
  }), t6.data.datasets.forEach((s) => {
    const o = s.type || t6.type, l = s.indexAxis || Tl(o, e), d = (En[o] || {}).scales || {};
    Object.keys(d).forEach((u) => {
      const f = Pw(u, l), h = s[f + "AxisID"] || f;
      i[h] = i[h] || /* @__PURE__ */ Object.create(null), Ba(i[h], [
        {
          axis: f
        },
        n[h],
        d[u]
      ]);
    });
  }), Object.keys(i).forEach((s) => {
    const o = i[s];
    Ba(o, [
      Ve.scales[o.type],
      Ve.scale
    ]);
  }), i;
}
function xg(t6) {
  const e = t6.options || (t6.options = {});
  e.plugins = De(e.plugins, {}), e.scales = Aw(t6, e);
}
function wg(t6) {
  return t6 = t6 || {}, t6.datasets = t6.datasets || [], t6.labels = t6.labels || [], t6;
}
function Fw(t6) {
  return t6 = t6 || {}, t6.data = wg(t6.data), xg(t6), t6;
}
const Du = /* @__PURE__ */ new Map(), kg = /* @__PURE__ */ new Set();
function Hi(t6, e) {
  let r = Du.get(t6);
  return r || (r = e(), Du.set(t6, r), kg.add(r)), r;
}
const Sa = (t6, e, r) => {
  const n = ri(e, r);
  n !== void 0 && t6.add(n);
};
class Lw {
  constructor(e) {
    this._config = Fw(e), this._scopeCache = /* @__PURE__ */ new Map(), this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(e) {
    this._config.type = e;
  }
  get data() {
    return this._config.data;
  }
  set data(e) {
    this._config.data = wg(e);
  }
  get options() {
    return this._config.options;
  }
  set options(e) {
    this._config.options = e;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const e = this._config;
    this.clearCache(), xg(e);
  }
  clearCache() {
    this._scopeCache.clear(), this._resolverCache.clear();
  }
  datasetScopeKeys(e) {
    return Hi(e, () => [
      [
        `datasets.${e}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(e, r) {
    return Hi(`${e}.transition.${r}`, () => [
      [
        `datasets.${e}.transitions.${r}`,
        `transitions.${r}`
      ],
      [
        `datasets.${e}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(e, r) {
    return Hi(`${e}-${r}`, () => [
      [
        `datasets.${e}.elements.${r}`,
        `datasets.${e}`,
        `elements.${r}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(e) {
    const r = e.id, n = this.type;
    return Hi(`${n}-plugin-${r}`, () => [
      [
        `plugins.${r}`,
        ...e.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(e, r) {
    const n = this._scopeCache;
    let a = n.get(e);
    return (!a || r) && (a = /* @__PURE__ */ new Map(), n.set(e, a)), a;
  }
  getOptionScopes(e, r, n) {
    const { options: a, type: i } = this, s = this._cachedScopes(e, n), o = s.get(r);
    if (o)
      return o;
    const l = /* @__PURE__ */ new Set();
    r.forEach((d) => {
      e && (l.add(e), d.forEach((u) => Sa(l, e, u))), d.forEach((u) => Sa(l, a, u)), d.forEach((u) => Sa(l, En[i] || {}, u)), d.forEach((u) => Sa(l, Ve, u)), d.forEach((u) => Sa(l, Cl, u));
    });
    const c = Array.from(l);
    return c.length === 0 && c.push(/* @__PURE__ */ Object.create(null)), kg.has(r) && s.set(r, c), c;
  }
  chartOptionScopes() {
    const { options: e, type: r } = this;
    return [
      e,
      En[r] || {},
      Ve.datasets[r] || {},
      {
        type: r
      },
      Ve,
      Cl
    ];
  }
  resolveNamedOptions(e, r, n, a = [
    ""
  ]) {
    const i = {
      $shared: true
    }, { resolver: s, subPrefixes: o } = Mu(this._resolverCache, e, a);
    let l = s;
    if ($w(s, r)) {
      i.$shared = false, n = Xr(n) ? n() : n;
      const c = this.createResolver(e, n, o);
      l = ra(s, n, c);
    }
    for (const c of r)
      i[c] = l[c];
    return i;
  }
  createResolver(e, r, n = [
    ""
  ], a) {
    const { resolver: i } = Mu(this._resolverCache, e, n);
    return pe(r) ? ra(i, r, void 0, a) : i;
  }
}
function Mu(t6, e, r) {
  let n = t6.get(e);
  n || (n = /* @__PURE__ */ new Map(), t6.set(e, n));
  const a = r.join();
  let i = n.get(a);
  return i || (i = {
    resolver: hc(e, r),
    subPrefixes: r.filter((o) => !o.toLowerCase().includes("hover"))
  }, n.set(a, i)), i;
}
const Ww = (t6) => pe(t6) && Object.getOwnPropertyNames(t6).some((e) => Xr(t6[e]));
function $w(t6, e) {
  const { isScriptable: r, isIndexable: n } = og(t6);
  for (const a of e) {
    const i = r(a), s = n(a), o = (s || i) && t6[a];
    if (i && (Xr(o) || Ww(o)) || s && ct(o))
      return true;
  }
  return false;
}
var zw = "4.4.8";
const jw = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function Cu(t6, e) {
  return t6 === "top" || t6 === "bottom" || jw.indexOf(t6) === -1 && e === "x";
}
function Eu(t6, e) {
  return function(r, n) {
    return r[t6] === n[t6] ? r[e] - n[e] : r[t6] - n[t6];
  };
}
function Tu(t6) {
  const e = t6.chart, r = e.options.animation;
  e.notifyPlugins("afterRender"), Ae(r && r.onComplete, [
    t6
  ], e);
}
function Hw(t6) {
  const e = t6.chart, r = e.options.animation;
  Ae(r && r.onProgress, [
    t6
  ], e);
}
function _g(t6) {
  return pc() && typeof t6 == "string" ? t6 = document.getElementById(t6) : t6 && t6.length && (t6 = t6[0]), t6 && t6.canvas && (t6 = t6.canvas), t6;
}
const os = {}, Pu = (t6) => {
  const e = _g(t6);
  return Object.values(os).filter((r) => r.canvas === e).pop();
};
function Bw(t6, e, r) {
  const n = Object.keys(t6);
  for (const a of n) {
    const i = +a;
    if (i >= e) {
      const s = t6[a];
      delete t6[a], (r > 0 || i > e) && (t6[i + r] = s);
    }
  }
}
function Yw(t6, e, r, n) {
  return !r || t6.type === "mouseout" ? null : n ? e : t6;
}
function Bi(t6, e, r) {
  return t6.options.clip ? t6[r] : e[r];
}
function Vw(t6, e) {
  const { xScale: r, yScale: n } = t6;
  return r && n ? {
    left: Bi(r, e, "left"),
    right: Bi(r, e, "right"),
    top: Bi(n, e, "top"),
    bottom: Bi(n, e, "bottom")
  } : e;
}
var Hr;
let oo = (Hr = class {
  static register(...e) {
    ar.add(...e), Ru();
  }
  static unregister(...e) {
    ar.remove(...e), Ru();
  }
  constructor(e, r) {
    const n = this.config = new Lw(r), a = _g(e), i = Pu(a);
    if (i)
      throw new Error("Canvas is already in use. Chart with ID '" + i.id + "' must be destroyed before the canvas with ID '" + i.canvas.id + "' can be reused.");
    const s = n.createResolver(n.chartOptionScopes(), this.getContext());
    this.platform = new (n.platform || lw(a))(), this.platform.updateConfig(n);
    const o = this.platform.acquireContext(a, s.aspectRatio), l = o && o.canvas, c = l && l.height, d = l && l.width;
    if (this.id = yv(), this.ctx = o, this.canvas = l, this.width = d, this.height = c, this._options = s, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new Dw(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = false, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = Av((u) => this.update(u), s.resizeDelay || 0), this._dataChanges = [], os[this.id] = this, !o || !l) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    Or.listen(this, "complete", Tu), Or.listen(this, "progress", Hw), this._initialize(), this.attached && this.update();
  }
  get aspectRatio() {
    const { options: { aspectRatio: e, maintainAspectRatio: r }, width: n, height: a, _aspectRatio: i } = this;
    return mt(e) ? r && i ? i : a ? n / a : null : e;
  }
  get data() {
    return this.config.data;
  }
  set data(e) {
    this.config.data = e;
  }
  get options() {
    return this._options;
  }
  set options(e) {
    this.config.options = e;
  }
  get registry() {
    return ar;
  }
  _initialize() {
    return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : su(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this;
  }
  clear() {
    return ru(this.canvas, this.ctx), this;
  }
  stop() {
    return Or.stop(this), this;
  }
  resize(e, r) {
    Or.running(this) ? this._resizeBeforeDraw = {
      width: e,
      height: r
    } : this._resize(e, r);
  }
  _resize(e, r) {
    const n = this.options, a = this.canvas, i = n.maintainAspectRatio && this.aspectRatio, s = this.platform.getMaximumSize(a, e, r, i), o = n.devicePixelRatio || this.platform.getDevicePixelRatio(), l = this.width ? "resize" : "attach";
    this.width = s.width, this.height = s.height, this._aspectRatio = this.aspectRatio, su(this, o, true) && (this.notifyPlugins("resize", {
      size: s
    }), Ae(n.onResize, [
      this,
      s
    ], this), this.attached && this._doResize(l) && this.render());
  }
  ensureScalesHaveIDs() {
    const r = this.options.scales || {};
    Se(r, (n, a) => {
      n.id = a;
    });
  }
  buildOrUpdateScales() {
    const e = this.options, r = e.scales, n = this.scales, a = Object.keys(n).reduce((s, o) => (s[o] = false, s), {});
    let i = [];
    r && (i = i.concat(Object.keys(r).map((s) => {
      const o = r[s], l = Pl(s, o), c = l === "r", d = l === "x";
      return {
        options: o,
        dposition: c ? "chartArea" : d ? "bottom" : "left",
        dtype: c ? "radialLinear" : d ? "category" : "linear"
      };
    }))), Se(i, (s) => {
      const o = s.options, l = o.id, c = Pl(l, o), d = De(o.type, s.dtype);
      (o.position === void 0 || Cu(o.position, c) !== Cu(s.dposition)) && (o.position = s.dposition), a[l] = true;
      let u = null;
      if (l in n && n[l].type === d)
        u = n[l];
      else {
        const f = ar.getScale(d);
        u = new f({
          id: l,
          type: d,
          ctx: this.ctx,
          chart: this
        }), n[u.id] = u;
      }
      u.init(o, e);
    }), Se(a, (s, o) => {
      s || delete n[o];
    }), Se(n, (s) => {
      Vr.configure(this, s, s.options), Vr.addBox(this, s);
    });
  }
  _updateMetasets() {
    const e = this._metasets, r = this.data.datasets.length, n = e.length;
    if (e.sort((a, i) => a.index - i.index), n > r) {
      for (let a = r; a < n; ++a)
        this._destroyDatasetMeta(a);
      e.splice(r, n - r);
    }
    this._sortedMetasets = e.slice(0).sort(Eu("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: e, data: { datasets: r } } = this;
    e.length > r.length && delete this._stacks, e.forEach((n, a) => {
      r.filter((i) => i === n._dataset).length === 0 && this._destroyDatasetMeta(a);
    });
  }
  buildOrUpdateControllers() {
    const e = [], r = this.data.datasets;
    let n, a;
    for (this._removeUnreferencedMetasets(), n = 0, a = r.length; n < a; n++) {
      const i = r[n];
      let s = this.getDatasetMeta(n);
      const o = i.type || this.config.type;
      if (s.type && s.type !== o && (this._destroyDatasetMeta(n), s = this.getDatasetMeta(n)), s.type = o, s.indexAxis = i.indexAxis || Tl(o, this.options), s.order = i.order || 0, s.index = n, s.label = "" + i.label, s.visible = this.isDatasetVisible(n), s.controller)
        s.controller.updateIndex(n), s.controller.linkScales();
      else {
        const l = ar.getController(o), { datasetElementType: c, dataElementType: d } = Ve.datasets[o];
        Object.assign(l, {
          dataElementType: ar.getElement(d),
          datasetElementType: c && ar.getElement(c)
        }), s.controller = new l(this, n), e.push(s.controller);
      }
    }
    return this._updateMetasets(), e;
  }
  _resetElements() {
    Se(this.data.datasets, (e, r) => {
      this.getDatasetMeta(r).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements(), this.notifyPlugins("reset");
  }
  update(e) {
    const r = this.config;
    r.update();
    const n = this._options = r.createResolver(r.chartOptionScopes(), this.getContext()), a = this._animationsDisabled = !n.animation;
    if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", {
      mode: e,
      cancelable: true
    }) === false)
      return;
    const i = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let s = 0;
    for (let c = 0, d = this.data.datasets.length; c < d; c++) {
      const { controller: u } = this.getDatasetMeta(c), f = !a && i.indexOf(u) === -1;
      u.buildOrUpdateElements(f), s = Math.max(+u.getMaxOverflow(), s);
    }
    s = this._minPadding = n.layout.autoPadding ? s : 0, this._updateLayout(s), a || Se(i, (c) => {
      c.reset();
    }), this._updateDatasets(e), this.notifyPlugins("afterUpdate", {
      mode: e
    }), this._layers.sort(Eu("z", "_idx"));
    const { _active: o, _lastEvent: l } = this;
    l ? this._eventHandler(l, true) : o.length && this._updateHoverStyles(o, o, true), this.render();
  }
  _updateScales() {
    Se(this.scales, (e) => {
      Vr.removeBox(this, e);
    }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const e = this.options, r = new Set(Object.keys(this._listeners)), n = new Set(e.events);
    (!Ud(r, n) || !!this._responsiveListeners !== e.responsive) && (this.unbindEvents(), this.bindEvents());
  }
  _updateHiddenIndices() {
    const { _hiddenIndices: e } = this, r = this._getUniformDataChanges() || [];
    for (const { method: n, start: a, count: i } of r) {
      const s = n === "_removeElements" ? -i : i;
      Bw(e, a, s);
    }
  }
  _getUniformDataChanges() {
    const e = this._dataChanges;
    if (!e || !e.length)
      return;
    this._dataChanges = [];
    const r = this.data.datasets.length, n = (i) => new Set(e.filter((s) => s[0] === i).map((s, o) => o + "," + s.splice(1).join(","))), a = n(0);
    for (let i = 1; i < r; i++)
      if (!Ud(a, n(i)))
        return;
    return Array.from(a).map((i) => i.split(",")).map((i) => ({
      method: i[1],
      start: +i[2],
      count: +i[3]
    }));
  }
  _updateLayout(e) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: true
    }) === false)
      return;
    Vr.update(this, this.width, this.height, e);
    const r = this.chartArea, n = r.width <= 0 || r.height <= 0;
    this._layers = [], Se(this.boxes, (a) => {
      n && a.position === "chartArea" || (a.configure && a.configure(), this._layers.push(...a._layers()));
    }, this), this._layers.forEach((a, i) => {
      a._idx = i;
    }), this.notifyPlugins("afterLayout");
  }
  _updateDatasets(e) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode: e,
      cancelable: true
    }) !== false) {
      for (let r = 0, n = this.data.datasets.length; r < n; ++r)
        this.getDatasetMeta(r).controller.configure();
      for (let r = 0, n = this.data.datasets.length; r < n; ++r)
        this._updateDataset(r, Xr(e) ? e({
          datasetIndex: r
        }) : e);
      this.notifyPlugins("afterDatasetsUpdate", {
        mode: e
      });
    }
  }
  _updateDataset(e, r) {
    const n = this.getDatasetMeta(e), a = {
      meta: n,
      index: e,
      mode: r,
      cancelable: true
    };
    this.notifyPlugins("beforeDatasetUpdate", a) !== false && (n.controller._update(r), a.cancelable = false, this.notifyPlugins("afterDatasetUpdate", a));
  }
  render() {
    this.notifyPlugins("beforeRender", {
      cancelable: true
    }) !== false && (Or.has(this) ? this.attached && !Or.running(this) && Or.start(this) : (this.draw(), Tu({
      chart: this
    })));
  }
  draw() {
    let e;
    if (this._resizeBeforeDraw) {
      const { width: n, height: a } = this._resizeBeforeDraw;
      this._resizeBeforeDraw = null, this._resize(n, a);
    }
    if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", {
      cancelable: true
    }) === false)
      return;
    const r = this._layers;
    for (e = 0; e < r.length && r[e].z <= 0; ++e)
      r[e].draw(this.chartArea);
    for (this._drawDatasets(); e < r.length; ++e)
      r[e].draw(this.chartArea);
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(e) {
    const r = this._sortedMetasets, n = [];
    let a, i;
    for (a = 0, i = r.length; a < i; ++a) {
      const s = r[a];
      (!e || s.visible) && n.push(s);
    }
    return n;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: true
    }) === false)
      return;
    const e = this.getSortedVisibleDatasetMetas();
    for (let r = e.length - 1; r >= 0; --r)
      this._drawDataset(e[r]);
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(e) {
    const r = this.ctx, n = e._clip, a = !n.disabled, i = Vw(e, this.chartArea), s = {
      meta: e,
      index: e.index,
      cancelable: true
    };
    this.notifyPlugins("beforeDatasetDraw", s) !== false && (a && dc(r, {
      left: n.left === false ? 0 : i.left - n.left,
      right: n.right === false ? this.width : i.right + n.right,
      top: n.top === false ? 0 : i.top - n.top,
      bottom: n.bottom === false ? this.height : i.bottom + n.bottom
    }), e.controller.draw(), a && uc(r), s.cancelable = false, this.notifyPlugins("afterDatasetDraw", s));
  }
  isPointInArea(e) {
    return sg(e, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(e, r, n, a) {
    const i = jx.modes[r];
    return typeof i == "function" ? i(this, e, n, a) : [];
  }
  getDatasetMeta(e) {
    const r = this.data.datasets[e], n = this._metasets;
    let a = n.filter((i) => i && i._dataset === r).pop();
    return a || (a = {
      type: null,
      data: [],
      dataset: null,
      controller: null,
      hidden: null,
      xAxisID: null,
      yAxisID: null,
      order: r && r.order || 0,
      index: e,
      _dataset: r,
      _parsed: [],
      _sorted: false
    }, n.push(a)), a;
  }
  getContext() {
    return this.$context || (this.$context = ha(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(e) {
    const r = this.data.datasets[e];
    if (!r)
      return false;
    const n = this.getDatasetMeta(e);
    return typeof n.hidden == "boolean" ? !n.hidden : !r.hidden;
  }
  setDatasetVisibility(e, r) {
    const n = this.getDatasetMeta(e);
    n.hidden = !r;
  }
  toggleDataVisibility(e) {
    this._hiddenIndices[e] = !this._hiddenIndices[e];
  }
  getDataVisibility(e) {
    return !this._hiddenIndices[e];
  }
  _updateVisibility(e, r, n) {
    const a = n ? "show" : "hide", i = this.getDatasetMeta(e), s = i.controller._resolveAnimations(void 0, a);
    ws(r) ? (i.data[r].hidden = !n, this.update()) : (this.setDatasetVisibility(e, n), s.update(i, {
      visible: n
    }), this.update((o) => o.datasetIndex === e ? a : void 0));
  }
  hide(e, r) {
    this._updateVisibility(e, r, false);
  }
  show(e, r) {
    this._updateVisibility(e, r, true);
  }
  _destroyDatasetMeta(e) {
    const r = this._metasets[e];
    r && r.controller && r.controller._destroy(), delete this._metasets[e];
  }
  _stop() {
    let e, r;
    for (this.stop(), Or.remove(this), e = 0, r = this.data.datasets.length; e < r; ++e)
      this._destroyDatasetMeta(e);
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas: e, ctx: r } = this;
    this._stop(), this.config.clearCache(), e && (this.unbindEvents(), ru(e, r), this.platform.releaseContext(r), this.canvas = null, this.ctx = null), delete os[this.id], this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...e) {
    return this.canvas.toDataURL(...e);
  }
  bindEvents() {
    this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = true;
  }
  bindUserEvents() {
    const e = this._listeners, r = this.platform, n = (i, s) => {
      r.addEventListener(this, i, s), e[i] = s;
    }, a = (i, s, o) => {
      i.offsetX = s, i.offsetY = o, this._eventHandler(i);
    };
    Se(this.options.events, (i) => n(i, a));
  }
  bindResponsiveEvents() {
    this._responsiveListeners || (this._responsiveListeners = {});
    const e = this._responsiveListeners, r = this.platform, n = (l, c) => {
      r.addEventListener(this, l, c), e[l] = c;
    }, a = (l, c) => {
      e[l] && (r.removeEventListener(this, l, c), delete e[l]);
    }, i = (l, c) => {
      this.canvas && this.resize(l, c);
    };
    let s;
    const o = () => {
      a("attach", o), this.attached = true, this.resize(), n("resize", i), n("detach", s);
    };
    s = () => {
      this.attached = false, a("resize", i), this._stop(), this._resize(0, 0), n("attach", o);
    }, r.isAttached(this.canvas) ? o() : s();
  }
  unbindEvents() {
    Se(this._listeners, (e, r) => {
      this.platform.removeEventListener(this, r, e);
    }), this._listeners = {}, Se(this._responsiveListeners, (e, r) => {
      this.platform.removeEventListener(this, r, e);
    }), this._responsiveListeners = void 0;
  }
  updateHoverStyle(e, r, n) {
    const a = n ? "set" : "remove";
    let i, s, o, l;
    for (r === "dataset" && (i = this.getDatasetMeta(e[0].datasetIndex), i.controller["_" + a + "DatasetHoverStyle"]()), o = 0, l = e.length; o < l; ++o) {
      s = e[o];
      const c = s && this.getDatasetMeta(s.datasetIndex).controller;
      c && c[a + "HoverStyle"](s.element, s.datasetIndex, s.index);
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(e) {
    const r = this._active || [], n = e.map(({ datasetIndex: i, index: s }) => {
      const o = this.getDatasetMeta(i);
      if (!o)
        throw new Error("No dataset found at index " + i);
      return {
        datasetIndex: i,
        element: o.data[s],
        index: s
      };
    });
    !vs(n, r) && (this._active = n, this._lastEvent = null, this._updateHoverStyles(n, r));
  }
  notifyPlugins(e, r, n) {
    return this._plugins.notify(this, e, r, n);
  }
  isPluginEnabled(e) {
    return this._plugins._cache.filter((r) => r.plugin.id === e).length === 1;
  }
  _updateHoverStyles(e, r, n) {
    const a = this.options.hover, i = (l, c) => l.filter((d) => !c.some((u) => d.datasetIndex === u.datasetIndex && d.index === u.index)), s = i(r, e), o = n ? e : i(e, r);
    s.length && this.updateHoverStyle(s, a.mode, false), o.length && a.mode && this.updateHoverStyle(o, a.mode, true);
  }
  _eventHandler(e, r) {
    const n = {
      event: e,
      replay: r,
      cancelable: true,
      inChartArea: this.isPointInArea(e)
    }, a = (s) => (s.options.events || this.options.events).includes(e.native.type);
    if (this.notifyPlugins("beforeEvent", n, a) === false)
      return;
    const i = this._handleEvent(e, r, n.inChartArea);
    return n.cancelable = false, this.notifyPlugins("afterEvent", n, a), (i || n.changed) && this.render(), this;
  }
  _handleEvent(e, r, n) {
    const { _active: a = [], options: i } = this, s = r, o = this._getActiveElements(e, a, n, s), l = Ov(e), c = Yw(e, this._lastEvent, n, l);
    n && (this._lastEvent = null, Ae(i.onHover, [
      e,
      o,
      this
    ], this), l && Ae(i.onClick, [
      e,
      o,
      this
    ], this));
    const d = !vs(o, a);
    return (d || r) && (this._active = o, this._updateHoverStyles(o, a, r)), this._lastEvent = c, d;
  }
  _getActiveElements(e, r, n, a) {
    if (e.type === "mouseout")
      return [];
    if (!n)
      return r;
    const i = this.options.hover;
    return this.getElementsAtEventForMode(e, i.mode, i, a);
  }
}, K(Hr, "defaults", Ve), K(Hr, "instances", os), K(Hr, "overrides", En), K(Hr, "registry", ar), K(Hr, "version", zw), K(Hr, "getChart", Pu), Hr);
function Ru() {
  return Se(oo.instances, (t6) => t6._plugins.invalidate());
}
function qw(t6, e, r) {
  const { startAngle: n, pixelMargin: a, x: i, y: s, outerRadius: o, innerRadius: l } = e;
  let c = a / o;
  t6.beginPath(), t6.arc(i, s, o, n - c, r + c), l > a ? (c = a / l, t6.arc(i, s, l, r + c, n - c, true)) : t6.arc(i, s, a, r + tt, n - tt), t6.closePath(), t6.clip();
}
function Uw(t6) {
  return fc(t6, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function Xw(t6, e, r, n) {
  const a = Uw(t6.options.borderRadius), i = (r - e) / 2, s = Math.min(i, n * e / 2), o = (l) => {
    const c = (r - Math.min(i, l)) * n / 2;
    return jt(l, 0, Math.min(i, c));
  };
  return {
    outerStart: o(a.outerStart),
    outerEnd: o(a.outerEnd),
    innerStart: jt(a.innerStart, 0, s),
    innerEnd: jt(a.innerEnd, 0, s)
  };
}
function zn(t6, e, r, n) {
  return {
    x: r + t6 * Math.cos(e),
    y: n + t6 * Math.sin(e)
  };
}
function Cs(t6, e, r, n, a, i) {
  const { x: s, y: o, startAngle: l, pixelMargin: c, innerRadius: d } = e, u = Math.max(e.outerRadius + n + r - c, 0), f = d > 0 ? d + n + r + c : 0;
  let h = 0;
  const g = a - l;
  if (n) {
    const I = d > 0 ? d - n : 0, W = u > 0 ? u - n : 0, B = (I + W) / 2, U = B !== 0 ? g * B / (B + n) : g;
    h = (g - U) / 2;
  }
  const m = Math.max(1e-3, g * u - r / at) / u, p = (g - m) / 2, w = l + p + h, b = a - p - h, { outerStart: k, outerEnd: v, innerStart: x, innerEnd: _ } = Xw(e, f, u, b - w), T = u - k, S = u - v, C = w + k / T, D = b - v / S, z = f + x, A = f + _, L = w + x / z, M = b - _ / A;
  if (t6.beginPath(), i) {
    const I = (C + D) / 2;
    if (t6.arc(s, o, u, C, I), t6.arc(s, o, u, I, D), v > 0) {
      const J = zn(S, D, s, o);
      t6.arc(J.x, J.y, v, D, b + tt);
    }
    const W = zn(A, b, s, o);
    if (t6.lineTo(W.x, W.y), _ > 0) {
      const J = zn(A, M, s, o);
      t6.arc(J.x, J.y, _, b + tt, M + Math.PI);
    }
    const B = (b - _ / f + (w + x / f)) / 2;
    if (t6.arc(s, o, f, b - _ / f, B, true), t6.arc(s, o, f, B, w + x / f, true), x > 0) {
      const J = zn(z, L, s, o);
      t6.arc(J.x, J.y, x, L + Math.PI, w - tt);
    }
    const U = zn(T, w, s, o);
    if (t6.lineTo(U.x, U.y), k > 0) {
      const J = zn(T, C, s, o);
      t6.arc(J.x, J.y, k, w - tt, C);
    }
  } else {
    t6.moveTo(s, o);
    const I = Math.cos(C) * u + s, W = Math.sin(C) * u + o;
    t6.lineTo(I, W);
    const B = Math.cos(D) * u + s, U = Math.sin(D) * u + o;
    t6.lineTo(B, U);
  }
  t6.closePath();
}
function Gw(t6, e, r, n, a) {
  const { fullCircles: i, startAngle: s, circumference: o } = e;
  let l = e.endAngle;
  if (i) {
    Cs(t6, e, r, n, l, a);
    for (let c = 0; c < i; ++c)
      t6.fill();
    isNaN(o) || (l = s + (o % Qe || Qe));
  }
  return Cs(t6, e, r, n, l, a), t6.fill(), l;
}
function Kw(t6, e, r, n, a) {
  const { fullCircles: i, startAngle: s, circumference: o, options: l } = e, { borderWidth: c, borderJoinStyle: d, borderDash: u, borderDashOffset: f } = l, h = l.borderAlign === "inner";
  if (!c)
    return;
  t6.setLineDash(u || []), t6.lineDashOffset = f, h ? (t6.lineWidth = c * 2, t6.lineJoin = d || "round") : (t6.lineWidth = c, t6.lineJoin = d || "bevel");
  let g = e.endAngle;
  if (i) {
    Cs(t6, e, r, n, g, a);
    for (let m = 0; m < i; ++m)
      t6.stroke();
    isNaN(o) || (g = s + (o % Qe || Qe));
  }
  h && qw(t6, e, g), i || (Cs(t6, e, r, n, g, a), t6.stroke());
}
class ja extends mi {
  constructor(r) {
    super();
    K(this, "circumference");
    K(this, "endAngle");
    K(this, "fullCircles");
    K(this, "innerRadius");
    K(this, "outerRadius");
    K(this, "pixelMargin");
    K(this, "startAngle");
    this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, r && Object.assign(this, r);
  }
  inRange(r, n, a) {
    const i = this.getProps([
      "x",
      "y"
    ], a), { angle: s, distance: o } = Zh(i, {
      x: r,
      y: n
    }), { startAngle: l, endAngle: c, innerRadius: d, outerRadius: u, circumference: f } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], a), h = (this.options.spacing + this.options.borderWidth) / 2, g = De(f, c - l), m = Os(s, l, c) && l !== c, p = g >= Qe || m, w = Wa(o, d + h, u + h);
    return p && w;
  }
  getCenterPoint(r) {
    const { x: n, y: a, startAngle: i, endAngle: s, innerRadius: o, outerRadius: l } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius"
    ], r), { offset: c, spacing: d } = this.options, u = (i + s) / 2, f = (o + l + d + c) / 2;
    return {
      x: n + Math.cos(u) * f,
      y: a + Math.sin(u) * f
    };
  }
  tooltipPosition(r) {
    return this.getCenterPoint(r);
  }
  draw(r) {
    const { options: n, circumference: a } = this, i = (n.offset || 0) / 4, s = (n.spacing || 0) / 2, o = n.circular;
    if (this.pixelMargin = n.borderAlign === "inner" ? 0.33 : 0, this.fullCircles = a > Qe ? Math.floor(a / Qe) : 0, a === 0 || this.innerRadius < 0 || this.outerRadius < 0)
      return;
    r.save();
    const l = (this.startAngle + this.endAngle) / 2;
    r.translate(Math.cos(l) * i, Math.sin(l) * i);
    const c = 1 - Math.sin(Math.min(at, a || 0)), d = i * c;
    r.fillStyle = n.backgroundColor, r.strokeStyle = n.borderColor, Gw(r, this, d, s, o), Kw(r, this, d, s, o), r.restore();
  }
}
K(ja, "id", "arc"), K(ja, "defaults", {
  borderAlign: "center",
  borderColor: "#fff",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0,
  circular: true
}), K(ja, "defaultRoutes", {
  backgroundColor: "backgroundColor"
}), K(ja, "descriptors", {
  _scriptable: true,
  _indexable: (r) => r !== "borderDash"
});
const Nu = (t6, e) => {
  let { boxHeight: r = e, boxWidth: n = e } = t6;
  return t6.usePointStyle && (r = Math.min(r, e), n = t6.pointStyleWidth || Math.min(n, e)), {
    boxWidth: n,
    boxHeight: r,
    itemHeight: Math.max(e, r)
  };
}, Qw = (t6, e) => t6 !== null && e !== null && t6.datasetIndex === e.datasetIndex && t6.index === e.index;
class Iu extends mi {
  constructor(e) {
    super(), this._added = false, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = false, this.chart = e.chart, this.options = e.options, this.ctx = e.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(e, r, n) {
    this.maxWidth = e, this.maxHeight = r, this._margins = n, this.setDimensions(), this.buildLabels(), this.fit();
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);
  }
  buildLabels() {
    const e = this.options.labels || {};
    let r = Ae(e.generateLabels, [
      this.chart
    ], this) || [];
    e.filter && (r = r.filter((n) => e.filter(n, this.chart.data))), e.sort && (r = r.sort((n, a) => e.sort(n, a, this.chart.data))), this.options.reverse && r.reverse(), this.legendItems = r;
  }
  fit() {
    const { options: e, ctx: r } = this;
    if (!e.display) {
      this.width = this.height = 0;
      return;
    }
    const n = e.labels, a = _t(n.font), i = a.size, s = this._computeTitleHeight(), { boxWidth: o, itemHeight: l } = Nu(n, i);
    let c, d;
    r.font = a.string, this.isHorizontal() ? (c = this.maxWidth, d = this._fitRows(s, i, o, l) + 10) : (d = this.maxHeight, c = this._fitCols(s, a, o, l) + 10), this.width = Math.min(c, e.maxWidth || this.maxWidth), this.height = Math.min(d, e.maxHeight || this.maxHeight);
  }
  _fitRows(e, r, n, a) {
    const { ctx: i, maxWidth: s, options: { labels: { padding: o } } } = this, l = this.legendHitBoxes = [], c = this.lineWidths = [
      0
    ], d = a + o;
    let u = e;
    i.textAlign = "left", i.textBaseline = "middle";
    let f = -1, h = -d;
    return this.legendItems.forEach((g, m) => {
      const p = n + r / 2 + i.measureText(g.text).width;
      (m === 0 || c[c.length - 1] + p + 2 * o > s) && (u += d, c[c.length - (m > 0 ? 0 : 1)] = 0, h += d, f++), l[m] = {
        left: 0,
        top: h,
        row: f,
        width: p,
        height: a
      }, c[c.length - 1] += p + o;
    }), u;
  }
  _fitCols(e, r, n, a) {
    const { ctx: i, maxHeight: s, options: { labels: { padding: o } } } = this, l = this.legendHitBoxes = [], c = this.columnSizes = [], d = s - e;
    let u = o, f = 0, h = 0, g = 0, m = 0;
    return this.legendItems.forEach((p, w) => {
      const { itemWidth: b, itemHeight: k } = Jw(n, r, i, p, a);
      w > 0 && h + k + 2 * o > d && (u += f + o, c.push({
        width: f,
        height: h
      }), g += f + o, m++, f = h = 0), l[w] = {
        left: g,
        top: h,
        col: m,
        width: b,
        height: k
      }, f = Math.max(f, b), h += k + o;
    }), u += f, c.push({
      width: f,
      height: h
    }), u;
  }
  adjustHitBoxes() {
    if (!this.options.display)
      return;
    const e = this._computeTitleHeight(), { legendHitBoxes: r, options: { align: n, labels: { padding: a }, rtl: i } } = this, s = Jn(i, this.left, this.width);
    if (this.isHorizontal()) {
      let o = 0, l = It(n, this.left + a, this.right - this.lineWidths[o]);
      for (const c of r)
        o !== c.row && (o = c.row, l = It(n, this.left + a, this.right - this.lineWidths[o])), c.top += this.top + e + a, c.left = s.leftForLtr(s.x(l), c.width), l += c.width + a;
    } else {
      let o = 0, l = It(n, this.top + e + a, this.bottom - this.columnSizes[o].height);
      for (const c of r)
        c.col !== o && (o = c.col, l = It(n, this.top + e + a, this.bottom - this.columnSizes[o].height)), c.top = l, c.left += this.left + a, c.left = s.leftForLtr(s.x(c.left), c.width), l += c.height + a;
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const e = this.ctx;
      dc(e, this), this._draw(), uc(e);
    }
  }
  _draw() {
    const { options: e, columnSizes: r, lineWidths: n, ctx: a } = this, { align: i, labels: s } = e, o = Ve.color, l = Jn(e.rtl, this.left, this.width), c = _t(s.font), { padding: d } = s, u = c.size, f = u / 2;
    let h;
    this.drawTitle(), a.textAlign = l.textAlign("left"), a.textBaseline = "middle", a.lineWidth = 0.5, a.font = c.string;
    const { boxWidth: g, boxHeight: m, itemHeight: p } = Nu(s, u), w = function(_, T, S) {
      if (isNaN(g) || g <= 0 || isNaN(m) || m < 0)
        return;
      a.save();
      const C = De(S.lineWidth, 1);
      if (a.fillStyle = De(S.fillStyle, o), a.lineCap = De(S.lineCap, "butt"), a.lineDashOffset = De(S.lineDashOffset, 0), a.lineJoin = De(S.lineJoin, "miter"), a.lineWidth = C, a.strokeStyle = De(S.strokeStyle, o), a.setLineDash(De(S.lineDash, [])), s.usePointStyle) {
        const D = {
          radius: m * Math.SQRT2 / 2,
          pointStyle: S.pointStyle,
          rotation: S.rotation,
          borderWidth: C
        }, z = l.xPlus(_, g / 2), A = T + f;
        ig(a, D, z, A, s.pointStyleWidth && g);
      } else {
        const D = T + Math.max((u - m) / 2, 0), z = l.leftForLtr(_, g), A = qa(S.borderRadius);
        a.beginPath(), Object.values(A).some((L) => L !== 0) ? El(a, {
          x: z,
          y: D,
          w: g,
          h: m,
          radius: A
        }) : a.rect(z, D, g, m), a.fill(), C !== 0 && a.stroke();
      }
      a.restore();
    }, b = function(_, T, S) {
      Ss(a, S.text, _, T + p / 2, c, {
        strikethrough: S.hidden,
        textAlign: l.textAlign(S.textAlign)
      });
    }, k = this.isHorizontal(), v = this._computeTitleHeight();
    k ? h = {
      x: It(i, this.left + d, this.right - n[0]),
      y: this.top + d + v,
      line: 0
    } : h = {
      x: this.left + d,
      y: It(i, this.top + v + d, this.bottom - r[0].height),
      line: 0
    }, ug(this.ctx, e.textDirection);
    const x = p + d;
    this.legendItems.forEach((_, T) => {
      a.strokeStyle = _.fontColor, a.fillStyle = _.fontColor;
      const S = a.measureText(_.text).width, C = l.textAlign(_.textAlign || (_.textAlign = s.textAlign)), D = g + f + S;
      let z = h.x, A = h.y;
      l.setWidth(this.width), k ? T > 0 && z + D + d > this.right && (A = h.y += x, h.line++, z = h.x = It(i, this.left + d, this.right - n[h.line])) : T > 0 && A + x > this.bottom && (z = h.x = z + r[h.line].width + d, h.line++, A = h.y = It(i, this.top + v + d, this.bottom - r[h.line].height));
      const L = l.x(z);
      if (w(L, A, _), z = Fv(C, z + g + f, k ? z + D : this.right, e.rtl), b(l.x(z), A, _), k)
        h.x += D + d;
      else if (typeof _.text != "string") {
        const M = c.lineHeight;
        h.y += Og(_, M) + d;
      } else
        h.y += x;
    }), fg(this.ctx, e.textDirection);
  }
  drawTitle() {
    const e = this.options, r = e.title, n = _t(r.font), a = Kt(r.padding);
    if (!r.display)
      return;
    const i = Jn(e.rtl, this.left, this.width), s = this.ctx, o = r.position, l = n.size / 2, c = a.top + l;
    let d, u = this.left, f = this.width;
    if (this.isHorizontal())
      f = Math.max(...this.lineWidths), d = this.top + c, u = It(e.align, u, this.right - f);
    else {
      const g = this.columnSizes.reduce((m, p) => Math.max(m, p.height), 0);
      d = c + It(e.align, this.top, this.bottom - g - e.labels.padding - this._computeTitleHeight());
    }
    const h = It(o, u, u + f);
    s.textAlign = i.textAlign(ng(o)), s.textBaseline = "middle", s.strokeStyle = r.color, s.fillStyle = r.color, s.font = n.string, Ss(s, r.text, h, d, n);
  }
  _computeTitleHeight() {
    const e = this.options.title, r = _t(e.font), n = Kt(e.padding);
    return e.display ? r.lineHeight + n.height : 0;
  }
  _getLegendItemAt(e, r) {
    let n, a, i;
    if (Wa(e, this.left, this.right) && Wa(r, this.top, this.bottom)) {
      for (i = this.legendHitBoxes, n = 0; n < i.length; ++n)
        if (a = i[n], Wa(e, a.left, a.left + a.width) && Wa(r, a.top, a.top + a.height))
          return this.legendItems[n];
    }
    return null;
  }
  handleEvent(e) {
    const r = this.options;
    if (!t1(e.type, r))
      return;
    const n = this._getLegendItemAt(e.x, e.y);
    if (e.type === "mousemove" || e.type === "mouseout") {
      const a = this._hoveredItem, i = Qw(a, n);
      a && !i && Ae(r.onLeave, [
        e,
        a,
        this
      ], this), this._hoveredItem = n, n && !i && Ae(r.onHover, [
        e,
        n,
        this
      ], this);
    } else n && Ae(r.onClick, [
      e,
      n,
      this
    ], this);
  }
}
function Jw(t6, e, r, n, a) {
  const i = Zw(n, t6, e, r), s = e1(a, n, e.lineHeight);
  return {
    itemWidth: i,
    itemHeight: s
  };
}
function Zw(t6, e, r, n) {
  let a = t6.text;
  return a && typeof a != "string" && (a = a.reduce((i, s) => i.length > s.length ? i : s)), e + r.size / 2 + n.measureText(a).width;
}
function e1(t6, e, r) {
  let n = t6;
  return typeof e.text != "string" && (n = Og(e, r)), n;
}
function Og(t6, e) {
  const r = t6.text ? t6.text.length : 0;
  return e * r;
}
function t1(t6, e) {
  return !!((t6 === "mousemove" || t6 === "mouseout") && (e.onHover || e.onLeave) || e.onClick && (t6 === "click" || t6 === "mouseup"));
}
var r1 = {
  id: "legend",
  _element: Iu,
  start(t6, e, r) {
    const n = t6.legend = new Iu({
      ctx: t6.ctx,
      options: r,
      chart: t6
    });
    Vr.configure(t6, n, r), Vr.addBox(t6, n);
  },
  stop(t6) {
    Vr.removeBox(t6, t6.legend), delete t6.legend;
  },
  beforeUpdate(t6, e, r) {
    const n = t6.legend;
    Vr.configure(t6, n, r), n.options = r;
  },
  afterUpdate(t6) {
    const e = t6.legend;
    e.buildLabels(), e.adjustHitBoxes();
  },
  afterEvent(t6, e) {
    e.replay || t6.legend.handleEvent(e.event);
  },
  defaults: {
    display: true,
    position: "top",
    align: "center",
    fullSize: true,
    reverse: false,
    weight: 1e3,
    onClick(t6, e, r) {
      const n = e.datasetIndex, a = r.chart;
      a.isDatasetVisible(n) ? (a.hide(n), e.hidden = true) : (a.show(n), e.hidden = false);
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (t6) => t6.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(t6) {
        const e = t6.data.datasets, { labels: { usePointStyle: r, pointStyle: n, textAlign: a, color: i, useBorderRadius: s, borderRadius: o } } = t6.legend.options;
        return t6._getSortedDatasetMetas().map((l) => {
          const c = l.controller.getStyle(r ? 0 : void 0), d = Kt(c.borderWidth);
          return {
            text: e[l.index].label,
            fillStyle: c.backgroundColor,
            fontColor: i,
            hidden: !l.visible,
            lineCap: c.borderCapStyle,
            lineDash: c.borderDash,
            lineDashOffset: c.borderDashOffset,
            lineJoin: c.borderJoinStyle,
            lineWidth: (d.width + d.height) / 4,
            strokeStyle: c.borderColor,
            pointStyle: n || c.pointStyle,
            rotation: c.rotation,
            textAlign: a || c.textAlign,
            borderRadius: s && (o || c.borderRadius),
            datasetIndex: l.index
          };
        }, this);
      }
    },
    title: {
      color: (t6) => t6.chart.options.color,
      display: false,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (t6) => !t6.startsWith("on"),
    labels: {
      _scriptable: (t6) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(t6)
    }
  }
};
const Ha = {
  average(t6) {
    if (!t6.length)
      return false;
    let e, r, n = /* @__PURE__ */ new Set(), a = 0, i = 0;
    for (e = 0, r = t6.length; e < r; ++e) {
      const o = t6[e].element;
      if (o && o.hasValue()) {
        const l = o.tooltipPosition();
        n.add(l.x), a += l.y, ++i;
      }
    }
    return i === 0 || n.size === 0 ? false : {
      x: [
        ...n
      ].reduce((o, l) => o + l) / n.size,
      y: a / i
    };
  },
  nearest(t6, e) {
    if (!t6.length)
      return false;
    let r = e.x, n = e.y, a = Number.POSITIVE_INFINITY, i, s, o;
    for (i = 0, s = t6.length; i < s; ++i) {
      const l = t6[i].element;
      if (l && l.hasValue()) {
        const c = l.getCenterPoint(), d = Ev(e, c);
        d < a && (a = d, o = l);
      }
    }
    if (o) {
      const l = o.tooltipPosition();
      r = l.x, n = l.y;
    }
    return {
      x: r,
      y: n
    };
  }
};
function nr(t6, e) {
  return e && (ct(e) ? Array.prototype.push.apply(t6, e) : t6.push(e)), t6;
}
function Sr(t6) {
  return (typeof t6 == "string" || t6 instanceof String) && t6.indexOf(`
`) > -1 ? t6.split(`
`) : t6;
}
function n1(t6, e) {
  const { element: r, datasetIndex: n, index: a } = e, i = t6.getDatasetMeta(n).controller, { label: s, value: o } = i.getLabelAndValue(a);
  return {
    chart: t6,
    label: s,
    parsed: i.getParsed(a),
    raw: t6.data.datasets[n].data[a],
    formattedValue: o,
    dataset: i.getDataset(),
    dataIndex: a,
    datasetIndex: n,
    element: r
  };
}
function Au(t6, e) {
  const r = t6.chart.ctx, { body: n, footer: a, title: i } = t6, { boxWidth: s, boxHeight: o } = e, l = _t(e.bodyFont), c = _t(e.titleFont), d = _t(e.footerFont), u = i.length, f = a.length, h = n.length, g = Kt(e.padding);
  let m = g.height, p = 0, w = n.reduce((v, x) => v + x.before.length + x.lines.length + x.after.length, 0);
  if (w += t6.beforeBody.length + t6.afterBody.length, u && (m += u * c.lineHeight + (u - 1) * e.titleSpacing + e.titleMarginBottom), w) {
    const v = e.displayColors ? Math.max(o, l.lineHeight) : l.lineHeight;
    m += h * v + (w - h) * l.lineHeight + (w - 1) * e.bodySpacing;
  }
  f && (m += e.footerMarginTop + f * d.lineHeight + (f - 1) * e.footerSpacing);
  let b = 0;
  const k = function(v) {
    p = Math.max(p, r.measureText(v).width + b);
  };
  return r.save(), r.font = c.string, Se(t6.title, k), r.font = l.string, Se(t6.beforeBody.concat(t6.afterBody), k), b = e.displayColors ? s + 2 + e.boxPadding : 0, Se(n, (v) => {
    Se(v.before, k), Se(v.lines, k), Se(v.after, k);
  }), b = 0, r.font = d.string, Se(t6.footer, k), r.restore(), p += g.width, {
    width: p,
    height: m
  };
}
function a1(t6, e) {
  const { y: r, height: n } = e;
  return r < n / 2 ? "top" : r > t6.height - n / 2 ? "bottom" : "center";
}
function i1(t6, e, r, n) {
  const { x: a, width: i } = n, s = r.caretSize + r.caretPadding;
  if (t6 === "left" && a + i + s > e.width || t6 === "right" && a - i - s < 0)
    return true;
}
function s1(t6, e, r, n) {
  const { x: a, width: i } = r, { width: s, chartArea: { left: o, right: l } } = t6;
  let c = "center";
  return n === "center" ? c = a <= (o + l) / 2 ? "left" : "right" : a <= i / 2 ? c = "left" : a >= s - i / 2 && (c = "right"), i1(c, t6, e, r) && (c = "center"), c;
}
function Fu(t6, e, r) {
  const n = r.yAlign || e.yAlign || a1(t6, r);
  return {
    xAlign: r.xAlign || e.xAlign || s1(t6, e, r, n),
    yAlign: n
  };
}
function o1(t6, e) {
  let { x: r, width: n } = t6;
  return e === "right" ? r -= n : e === "center" && (r -= n / 2), r;
}
function l1(t6, e, r) {
  let { y: n, height: a } = t6;
  return e === "top" ? n += r : e === "bottom" ? n -= a + r : n -= a / 2, n;
}
function Lu(t6, e, r, n) {
  const { caretSize: a, caretPadding: i, cornerRadius: s } = t6, { xAlign: o, yAlign: l } = r, c = a + i, { topLeft: d, topRight: u, bottomLeft: f, bottomRight: h } = qa(s);
  let g = o1(e, o);
  const m = l1(e, l, c);
  return l === "center" ? o === "left" ? g += c : o === "right" && (g -= c) : o === "left" ? g -= Math.max(d, f) + a : o === "right" && (g += Math.max(u, h) + a), {
    x: jt(g, 0, n.width - e.width),
    y: jt(m, 0, n.height - e.height)
  };
}
function Yi(t6, e, r) {
  const n = Kt(r.padding);
  return e === "center" ? t6.x + t6.width / 2 : e === "right" ? t6.x + t6.width - n.right : t6.x + n.left;
}
function Wu(t6) {
  return nr([], Sr(t6));
}
function c1(t6, e, r) {
  return ha(t6, {
    tooltip: e,
    tooltipItems: r,
    type: "tooltip"
  });
}
function $u(t6, e) {
  const r = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks;
  return r ? t6.override(r) : t6;
}
const Sg = {
  beforeTitle: xr,
  title(t6) {
    if (t6.length > 0) {
      const e = t6[0], r = e.chart.data.labels, n = r ? r.length : 0;
      if (this && this.options && this.options.mode === "dataset")
        return e.dataset.label || "";
      if (e.label)
        return e.label;
      if (n > 0 && e.dataIndex < n)
        return r[e.dataIndex];
    }
    return "";
  },
  afterTitle: xr,
  beforeBody: xr,
  beforeLabel: xr,
  label(t6) {
    if (this && this.options && this.options.mode === "dataset")
      return t6.label + ": " + t6.formattedValue || t6.formattedValue;
    let e = t6.dataset.label || "";
    e && (e += ": ");
    const r = t6.formattedValue;
    return mt(r) || (e += r), e;
  },
  labelColor(t6) {
    const r = t6.chart.getDatasetMeta(t6.datasetIndex).controller.getStyle(t6.dataIndex);
    return {
      borderColor: r.borderColor,
      backgroundColor: r.backgroundColor,
      borderWidth: r.borderWidth,
      borderDash: r.borderDash,
      borderDashOffset: r.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(t6) {
    const r = t6.chart.getDatasetMeta(t6.datasetIndex).controller.getStyle(t6.dataIndex);
    return {
      pointStyle: r.pointStyle,
      rotation: r.rotation
    };
  },
  afterLabel: xr,
  afterBody: xr,
  beforeFooter: xr,
  footer: xr,
  afterFooter: xr
};
function xt(t6, e, r, n) {
  const a = t6[e].call(r, n);
  return typeof a > "u" ? Sg[e].call(r, n) : a;
}
var Sl;
let zu = (Sl = class extends mi {
  constructor(e) {
    super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = e.chart, this.options = e.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;
  }
  initialize(e) {
    this.options = e, this._cachedAnimations = void 0, this.$context = void 0;
  }
  _resolveAnimations() {
    const e = this._cachedAnimations;
    if (e)
      return e;
    const r = this.chart, n = this.options.setContext(this.getContext()), a = n.enabled && r.options.animation && n.animations, i = new hg(this.chart, a);
    return a._cacheable && (this._cachedAnimations = Object.freeze(i)), i;
  }
  getContext() {
    return this.$context || (this.$context = c1(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(e, r) {
    const { callbacks: n } = r, a = xt(n, "beforeTitle", this, e), i = xt(n, "title", this, e), s = xt(n, "afterTitle", this, e);
    let o = [];
    return o = nr(o, Sr(a)), o = nr(o, Sr(i)), o = nr(o, Sr(s)), o;
  }
  getBeforeBody(e, r) {
    return Wu(xt(r.callbacks, "beforeBody", this, e));
  }
  getBody(e, r) {
    const { callbacks: n } = r, a = [];
    return Se(e, (i) => {
      const s = {
        before: [],
        lines: [],
        after: []
      }, o = $u(n, i);
      nr(s.before, Sr(xt(o, "beforeLabel", this, i))), nr(s.lines, xt(o, "label", this, i)), nr(s.after, Sr(xt(o, "afterLabel", this, i))), a.push(s);
    }), a;
  }
  getAfterBody(e, r) {
    return Wu(xt(r.callbacks, "afterBody", this, e));
  }
  getFooter(e, r) {
    const { callbacks: n } = r, a = xt(n, "beforeFooter", this, e), i = xt(n, "footer", this, e), s = xt(n, "afterFooter", this, e);
    let o = [];
    return o = nr(o, Sr(a)), o = nr(o, Sr(i)), o = nr(o, Sr(s)), o;
  }
  _createItems(e) {
    const r = this._active, n = this.chart.data, a = [], i = [], s = [];
    let o = [], l, c;
    for (l = 0, c = r.length; l < c; ++l)
      o.push(n1(this.chart, r[l]));
    return e.filter && (o = o.filter((d, u, f) => e.filter(d, u, f, n))), e.itemSort && (o = o.sort((d, u) => e.itemSort(d, u, n))), Se(o, (d) => {
      const u = $u(e.callbacks, d);
      a.push(xt(u, "labelColor", this, d)), i.push(xt(u, "labelPointStyle", this, d)), s.push(xt(u, "labelTextColor", this, d));
    }), this.labelColors = a, this.labelPointStyles = i, this.labelTextColors = s, this.dataPoints = o, o;
  }
  update(e, r) {
    const n = this.options.setContext(this.getContext()), a = this._active;
    let i, s = [];
    if (!a.length)
      this.opacity !== 0 && (i = {
        opacity: 0
      });
    else {
      const o = Ha[n.position].call(this, a, this._eventPosition);
      s = this._createItems(n), this.title = this.getTitle(s, n), this.beforeBody = this.getBeforeBody(s, n), this.body = this.getBody(s, n), this.afterBody = this.getAfterBody(s, n), this.footer = this.getFooter(s, n);
      const l = this._size = Au(this, n), c = Object.assign({}, o, l), d = Fu(this.chart, n, c), u = Lu(n, c, d, this.chart);
      this.xAlign = d.xAlign, this.yAlign = d.yAlign, i = {
        opacity: 1,
        x: u.x,
        y: u.y,
        width: l.width,
        height: l.height,
        caretX: o.x,
        caretY: o.y
      };
    }
    this._tooltipItems = s, this.$context = void 0, i && this._resolveAnimations().update(this, i), e && n.external && n.external.call(this, {
      chart: this.chart,
      tooltip: this,
      replay: r
    });
  }
  drawCaret(e, r, n, a) {
    const i = this.getCaretPosition(e, n, a);
    r.lineTo(i.x1, i.y1), r.lineTo(i.x2, i.y2), r.lineTo(i.x3, i.y3);
  }
  getCaretPosition(e, r, n) {
    const { xAlign: a, yAlign: i } = this, { caretSize: s, cornerRadius: o } = n, { topLeft: l, topRight: c, bottomLeft: d, bottomRight: u } = qa(o), { x: f, y: h } = e, { width: g, height: m } = r;
    let p, w, b, k, v, x;
    return i === "center" ? (v = h + m / 2, a === "left" ? (p = f, w = p - s, k = v + s, x = v - s) : (p = f + g, w = p + s, k = v - s, x = v + s), b = p) : (a === "left" ? w = f + Math.max(l, d) + s : a === "right" ? w = f + g - Math.max(c, u) - s : w = this.caretX, i === "top" ? (k = h, v = k - s, p = w - s, b = w + s) : (k = h + m, v = k + s, p = w + s, b = w - s), x = k), {
      x1: p,
      x2: w,
      x3: b,
      y1: k,
      y2: v,
      y3: x
    };
  }
  drawTitle(e, r, n) {
    const a = this.title, i = a.length;
    let s, o, l;
    if (i) {
      const c = Jn(n.rtl, this.x, this.width);
      for (e.x = Yi(this, n.titleAlign, n), r.textAlign = c.textAlign(n.titleAlign), r.textBaseline = "middle", s = _t(n.titleFont), o = n.titleSpacing, r.fillStyle = n.titleColor, r.font = s.string, l = 0; l < i; ++l)
        r.fillText(a[l], c.x(e.x), e.y + s.lineHeight / 2), e.y += s.lineHeight + o, l + 1 === i && (e.y += n.titleMarginBottom - o);
    }
  }
  _drawColorBox(e, r, n, a, i) {
    const s = this.labelColors[n], o = this.labelPointStyles[n], { boxHeight: l, boxWidth: c } = i, d = _t(i.bodyFont), u = Yi(this, "left", i), f = a.x(u), h = l < d.lineHeight ? (d.lineHeight - l) / 2 : 0, g = r.y + h;
    if (i.usePointStyle) {
      const m = {
        radius: Math.min(c, l) / 2,
        pointStyle: o.pointStyle,
        rotation: o.rotation,
        borderWidth: 1
      }, p = a.leftForLtr(f, c) + c / 2, w = g + l / 2;
      e.strokeStyle = i.multiKeyBackground, e.fillStyle = i.multiKeyBackground, nu(e, m, p, w), e.strokeStyle = s.borderColor, e.fillStyle = s.backgroundColor, nu(e, m, p, w);
    } else {
      e.lineWidth = pe(s.borderWidth) ? Math.max(...Object.values(s.borderWidth)) : s.borderWidth || 1, e.strokeStyle = s.borderColor, e.setLineDash(s.borderDash || []), e.lineDashOffset = s.borderDashOffset || 0;
      const m = a.leftForLtr(f, c), p = a.leftForLtr(a.xPlus(f, 1), c - 2), w = qa(s.borderRadius);
      Object.values(w).some((b) => b !== 0) ? (e.beginPath(), e.fillStyle = i.multiKeyBackground, El(e, {
        x: m,
        y: g,
        w: c,
        h: l,
        radius: w
      }), e.fill(), e.stroke(), e.fillStyle = s.backgroundColor, e.beginPath(), El(e, {
        x: p,
        y: g + 1,
        w: c - 2,
        h: l - 2,
        radius: w
      }), e.fill()) : (e.fillStyle = i.multiKeyBackground, e.fillRect(m, g, c, l), e.strokeRect(m, g, c, l), e.fillStyle = s.backgroundColor, e.fillRect(p, g + 1, c - 2, l - 2));
    }
    e.fillStyle = this.labelTextColors[n];
  }
  drawBody(e, r, n) {
    const { body: a } = this, { bodySpacing: i, bodyAlign: s, displayColors: o, boxHeight: l, boxWidth: c, boxPadding: d } = n, u = _t(n.bodyFont);
    let f = u.lineHeight, h = 0;
    const g = Jn(n.rtl, this.x, this.width), m = function(S) {
      r.fillText(S, g.x(e.x + h), e.y + f / 2), e.y += f + i;
    }, p = g.textAlign(s);
    let w, b, k, v, x, _, T;
    for (r.textAlign = s, r.textBaseline = "middle", r.font = u.string, e.x = Yi(this, p, n), r.fillStyle = n.bodyColor, Se(this.beforeBody, m), h = o && p !== "right" ? s === "center" ? c / 2 + d : c + 2 + d : 0, v = 0, _ = a.length; v < _; ++v) {
      for (w = a[v], b = this.labelTextColors[v], r.fillStyle = b, Se(w.before, m), k = w.lines, o && k.length && (this._drawColorBox(r, e, v, g, n), f = Math.max(u.lineHeight, l)), x = 0, T = k.length; x < T; ++x)
        m(k[x]), f = u.lineHeight;
      Se(w.after, m);
    }
    h = 0, f = u.lineHeight, Se(this.afterBody, m), e.y -= i;
  }
  drawFooter(e, r, n) {
    const a = this.footer, i = a.length;
    let s, o;
    if (i) {
      const l = Jn(n.rtl, this.x, this.width);
      for (e.x = Yi(this, n.footerAlign, n), e.y += n.footerMarginTop, r.textAlign = l.textAlign(n.footerAlign), r.textBaseline = "middle", s = _t(n.footerFont), r.fillStyle = n.footerColor, r.font = s.string, o = 0; o < i; ++o)
        r.fillText(a[o], l.x(e.x), e.y + s.lineHeight / 2), e.y += s.lineHeight + n.footerSpacing;
    }
  }
  drawBackground(e, r, n, a) {
    const { xAlign: i, yAlign: s } = this, { x: o, y: l } = e, { width: c, height: d } = n, { topLeft: u, topRight: f, bottomLeft: h, bottomRight: g } = qa(a.cornerRadius);
    r.fillStyle = a.backgroundColor, r.strokeStyle = a.borderColor, r.lineWidth = a.borderWidth, r.beginPath(), r.moveTo(o + u, l), s === "top" && this.drawCaret(e, r, n, a), r.lineTo(o + c - f, l), r.quadraticCurveTo(o + c, l, o + c, l + f), s === "center" && i === "right" && this.drawCaret(e, r, n, a), r.lineTo(o + c, l + d - g), r.quadraticCurveTo(o + c, l + d, o + c - g, l + d), s === "bottom" && this.drawCaret(e, r, n, a), r.lineTo(o + h, l + d), r.quadraticCurveTo(o, l + d, o, l + d - h), s === "center" && i === "left" && this.drawCaret(e, r, n, a), r.lineTo(o, l + u), r.quadraticCurveTo(o, l, o + u, l), r.closePath(), r.fill(), a.borderWidth > 0 && r.stroke();
  }
  _updateAnimationTarget(e) {
    const r = this.chart, n = this.$animations, a = n && n.x, i = n && n.y;
    if (a || i) {
      const s = Ha[e.position].call(this, this._active, this._eventPosition);
      if (!s)
        return;
      const o = this._size = Au(this, e), l = Object.assign({}, s, this._size), c = Fu(r, e, l), d = Lu(e, l, c, r);
      (a._to !== d.x || i._to !== d.y) && (this.xAlign = c.xAlign, this.yAlign = c.yAlign, this.width = o.width, this.height = o.height, this.caretX = s.x, this.caretY = s.y, this._resolveAnimations().update(this, d));
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(e) {
    const r = this.options.setContext(this.getContext());
    let n = this.opacity;
    if (!n)
      return;
    this._updateAnimationTarget(r);
    const a = {
      width: this.width,
      height: this.height
    }, i = {
      x: this.x,
      y: this.y
    };
    n = Math.abs(n) < 1e-3 ? 0 : n;
    const s = Kt(r.padding), o = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    r.enabled && o && (e.save(), e.globalAlpha = n, this.drawBackground(i, e, a, r), ug(e, r.textDirection), i.y += s.top, this.drawTitle(i, e, r), this.drawBody(i, e, r), this.drawFooter(i, e, r), fg(e, r.textDirection), e.restore());
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(e, r) {
    const n = this._active, a = e.map(({ datasetIndex: o, index: l }) => {
      const c = this.chart.getDatasetMeta(o);
      if (!c)
        throw new Error("Cannot find a dataset at index " + o);
      return {
        datasetIndex: o,
        element: c.data[l],
        index: l
      };
    }), i = !vs(n, a), s = this._positionChanged(a, r);
    (i || s) && (this._active = a, this._eventPosition = r, this._ignoreReplayEvents = true, this.update(true));
  }
  handleEvent(e, r, n = true) {
    if (r && this._ignoreReplayEvents)
      return false;
    this._ignoreReplayEvents = false;
    const a = this.options, i = this._active || [], s = this._getActiveElements(e, i, r, n), o = this._positionChanged(s, e), l = r || !vs(s, i) || o;
    return l && (this._active = s, (a.enabled || a.external) && (this._eventPosition = {
      x: e.x,
      y: e.y
    }, this.update(true, r))), l;
  }
  _getActiveElements(e, r, n, a) {
    const i = this.options;
    if (e.type === "mouseout")
      return [];
    if (!a)
      return r.filter((o) => this.chart.data.datasets[o.datasetIndex] && this.chart.getDatasetMeta(o.datasetIndex).controller.getParsed(o.index) !== void 0);
    const s = this.chart.getElementsAtEventForMode(e, i.mode, i, n);
    return i.reverse && s.reverse(), s;
  }
  _positionChanged(e, r) {
    const { caretX: n, caretY: a, options: i } = this, s = Ha[i.position].call(this, e, r);
    return s !== false && (n !== s.x || a !== s.y);
  }
}, K(Sl, "positioners", Ha), Sl);
var d1 = {
  id: "tooltip",
  _element: zu,
  positioners: Ha,
  afterInit(t6, e, r) {
    r && (t6.tooltip = new zu({
      chart: t6,
      options: r
    }));
  },
  beforeUpdate(t6, e, r) {
    t6.tooltip && t6.tooltip.initialize(r);
  },
  reset(t6, e, r) {
    t6.tooltip && t6.tooltip.initialize(r);
  },
  afterDraw(t6) {
    const e = t6.tooltip;
    if (e && e._willRender()) {
      const r = {
        tooltip: e
      };
      if (t6.notifyPlugins("beforeTooltipDraw", {
        ...r,
        cancelable: true
      }) === false)
        return;
      e.draw(t6.ctx), t6.notifyPlugins("afterTooltipDraw", r);
    }
  },
  afterEvent(t6, e) {
    if (t6.tooltip) {
      const r = e.replay;
      t6.tooltip.handleEvent(e.event, r, e.inChartArea) && (e.changed = true);
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (t6, e) => e.bodyFont.size,
    boxWidth: (t6, e) => e.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: true,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: Sg
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (t6) => t6 !== "filter" && t6 !== "itemSort" && t6 !== "external",
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
};
const lo = {
  millisecond: {
    common: true,
    size: 1,
    steps: 1e3
  },
  second: {
    common: true,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: true,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: true,
    size: 36e5,
    steps: 24
  },
  day: {
    common: true,
    size: 864e5,
    steps: 30
  },
  week: {
    common: false,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: true,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: false,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: true,
    size: 3154e7
  }
}, kt = /* @__PURE__ */ Object.keys(lo);
function ju(t6, e) {
  return t6 - e;
}
function Hu(t6, e) {
  if (mt(e))
    return null;
  const r = t6._adapter, { parser: n, round: a, isoWeekday: i } = t6._parseOpts;
  let s = e;
  return typeof n == "function" && (s = n(s)), Er(s) || (s = typeof n == "string" ? r.parse(s, n) : r.parse(s)), s === null ? null : (a && (s = a === "week" && (_s(i) || i === true) ? r.startOf(s, "isoWeek", i) : r.startOf(s, a)), +s);
}
function Bu(t6, e, r, n) {
  const a = kt.length;
  for (let i = kt.indexOf(t6); i < a - 1; ++i) {
    const s = lo[kt[i]], o = s.steps ? s.steps : Number.MAX_SAFE_INTEGER;
    if (s.common && Math.ceil((r - e) / (o * s.size)) <= n)
      return kt[i];
  }
  return kt[a - 1];
}
function u1(t6, e, r, n, a) {
  for (let i = kt.length - 1; i >= kt.indexOf(r); i--) {
    const s = kt[i];
    if (lo[s].common && t6._adapter.diff(a, n, s) >= e - 1)
      return s;
  }
  return kt[r ? kt.indexOf(r) : 0];
}
function f1(t6) {
  for (let e = kt.indexOf(t6) + 1, r = kt.length; e < r; ++e)
    if (lo[kt[e]].common)
      return kt[e];
}
function Yu(t6, e, r) {
  if (!r)
    t6[e] = true;
  else if (r.length) {
    const { lo: n, hi: a } = cc(r, e), i = r[n] >= e ? r[n] : r[a];
    t6[i] = true;
  }
}
function h1(t6, e, r, n) {
  const a = t6._adapter, i = +a.startOf(e[0].value, n), s = e[e.length - 1].value;
  let o, l;
  for (o = i; o <= s; o = +a.add(o, 1, n))
    l = r[o], l >= 0 && (e[l].major = true);
  return e;
}
function Vu(t6, e, r) {
  const n = [], a = {}, i = e.length;
  let s, o;
  for (s = 0; s < i; ++s)
    o = e[s], a[o] = s, n.push({
      value: o,
      major: false
    });
  return i === 0 || !r ? n : h1(t6, n, a, r);
}
class Es extends so {
  constructor(e) {
    super(e), this._cache = {
      data: [],
      labels: [],
      all: []
    }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = false, this._parseOpts = void 0;
  }
  init(e, r = {}) {
    const n = e.time || (e.time = {}), a = this._adapter = new Fx._date(e.adapters.date);
    a.init(r), Ba(n.displayFormats, a.formats()), this._parseOpts = {
      parser: n.parser,
      round: n.round,
      isoWeekday: n.isoWeekday
    }, super.init(e), this._normalized = r.normalized;
  }
  parse(e, r) {
    return e === void 0 ? null : Hu(this, e);
  }
  beforeLayout() {
    super.beforeLayout(), this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const e = this.options, r = this._adapter, n = e.time.unit || "day";
    let { min: a, max: i, minDefined: s, maxDefined: o } = this.getUserBounds();
    function l(c) {
      !s && !isNaN(c.min) && (a = Math.min(a, c.min)), !o && !isNaN(c.max) && (i = Math.max(i, c.max));
    }
    (!s || !o) && (l(this._getLabelBounds()), (e.bounds !== "ticks" || e.ticks.source !== "labels") && l(this.getMinMax(false))), a = Er(a) && !isNaN(a) ? a : +r.startOf(Date.now(), n), i = Er(i) && !isNaN(i) ? i : +r.endOf(Date.now(), n) + 1, this.min = Math.min(a, i - 1), this.max = Math.max(a + 1, i);
  }
  _getLabelBounds() {
    const e = this.getLabelTimestamps();
    let r = Number.POSITIVE_INFINITY, n = Number.NEGATIVE_INFINITY;
    return e.length && (r = e[0], n = e[e.length - 1]), {
      min: r,
      max: n
    };
  }
  buildTicks() {
    const e = this.options, r = e.time, n = e.ticks, a = n.source === "labels" ? this.getLabelTimestamps() : this._generate();
    e.bounds === "ticks" && a.length && (this.min = this._userMin || a[0], this.max = this._userMax || a[a.length - 1]);
    const i = this.min, s = this.max, o = Rv(a, i, s);
    return this._unit = r.unit || (n.autoSkip ? Bu(r.minUnit, this.min, this.max, this._getLabelCapacity(i)) : u1(this, o.length, r.minUnit, this.min, this.max)), this._majorUnit = !n.major.enabled || this._unit === "year" ? void 0 : f1(this._unit), this.initOffsets(a), e.reverse && o.reverse(), Vu(this, o, this._majorUnit);
  }
  afterAutoSkip() {
    this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((e) => +e.value));
  }
  initOffsets(e = []) {
    let r = 0, n = 0, a, i;
    this.options.offset && e.length && (a = this.getDecimalForValue(e[0]), e.length === 1 ? r = 1 - a : r = (this.getDecimalForValue(e[1]) - a) / 2, i = this.getDecimalForValue(e[e.length - 1]), e.length === 1 ? n = i : n = (i - this.getDecimalForValue(e[e.length - 2])) / 2);
    const s = e.length < 3 ? 0.5 : 0.25;
    r = jt(r, 0, s), n = jt(n, 0, s), this._offsets = {
      start: r,
      end: n,
      factor: 1 / (r + 1 + n)
    };
  }
  _generate() {
    const e = this._adapter, r = this.min, n = this.max, a = this.options, i = a.time, s = i.unit || Bu(i.minUnit, r, n, this._getLabelCapacity(r)), o = De(a.ticks.stepSize, 1), l = s === "week" ? i.isoWeekday : false, c = _s(l) || l === true, d = {};
    let u = r, f, h;
    if (c && (u = +e.startOf(u, "isoWeek", l)), u = +e.startOf(u, c ? "day" : s), e.diff(n, r, s) > 1e5 * o)
      throw new Error(r + " and " + n + " are too far apart with stepSize of " + o + " " + s);
    const g = a.ticks.source === "data" && this.getDataTimestamps();
    for (f = u, h = 0; f < n; f = +e.add(f, o, s), h++)
      Yu(d, f, g);
    return (f === n || a.bounds === "ticks" || h === 1) && Yu(d, f, g), Object.keys(d).sort(ju).map((m) => +m);
  }
  getLabelForValue(e) {
    const r = this._adapter, n = this.options.time;
    return n.tooltipFormat ? r.format(e, n.tooltipFormat) : r.format(e, n.displayFormats.datetime);
  }
  format(e, r) {
    const a = this.options.time.displayFormats, i = this._unit, s = r || a[i];
    return this._adapter.format(e, s);
  }
  _tickFormatFunction(e, r, n, a) {
    const i = this.options, s = i.ticks.callback;
    if (s)
      return Ae(s, [
        e,
        r,
        n
      ], this);
    const o = i.time.displayFormats, l = this._unit, c = this._majorUnit, d = l && o[l], u = c && o[c], f = n[r], h = c && u && f && f.major;
    return this._adapter.format(e, a || (h ? u : d));
  }
  generateTickLabels(e) {
    let r, n, a;
    for (r = 0, n = e.length; r < n; ++r)
      a = e[r], a.label = this._tickFormatFunction(a.value, r, e);
  }
  getDecimalForValue(e) {
    return e === null ? NaN : (e - this.min) / (this.max - this.min);
  }
  getPixelForValue(e) {
    const r = this._offsets, n = this.getDecimalForValue(e);
    return this.getPixelForDecimal((r.start + n) * r.factor);
  }
  getValueForPixel(e) {
    const r = this._offsets, n = this.getDecimalForPixel(e) / r.factor - r.end;
    return this.min + n * (this.max - this.min);
  }
  _getLabelSize(e) {
    const r = this.options.ticks, n = this.ctx.measureText(e).width, a = xn(this.isHorizontal() ? r.maxRotation : r.minRotation), i = Math.cos(a), s = Math.sin(a), o = this._resolveTickFontOptions(0).size;
    return {
      w: n * i + o * s,
      h: n * s + o * i
    };
  }
  _getLabelCapacity(e) {
    const r = this.options.time, n = r.displayFormats, a = n[r.unit] || n.millisecond, i = this._tickFormatFunction(e, 0, Vu(this, [
      e
    ], this._majorUnit), a), s = this._getLabelSize(i), o = Math.floor(this.isHorizontal() ? this.width / s.w : this.height / s.h) - 1;
    return o > 0 ? o : 1;
  }
  getDataTimestamps() {
    let e = this._cache.data || [], r, n;
    if (e.length)
      return e;
    const a = this.getMatchingVisibleMetas();
    if (this._normalized && a.length)
      return this._cache.data = a[0].controller.getAllParsedValues(this);
    for (r = 0, n = a.length; r < n; ++r)
      e = e.concat(a[r].controller.getAllParsedValues(this));
    return this._cache.data = this.normalize(e);
  }
  getLabelTimestamps() {
    const e = this._cache.labels || [];
    let r, n;
    if (e.length)
      return e;
    const a = this.getLabels();
    for (r = 0, n = a.length; r < n; ++r)
      e.push(Hu(this, a[r]));
    return this._cache.labels = this._normalized ? e : this.normalize(e);
  }
  normalize(e) {
    return Iv(e.sort(ju));
  }
}
K(Es, "id", "time"), K(Es, "defaults", {
  bounds: "data",
  adapters: {},
  time: {
    parser: false,
    unit: false,
    round: false,
    isoWeekday: false,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    callback: false,
    major: {
      enabled: false
    }
  }
});
function Vi(t6, e, r) {
  let n = 0, a = t6.length - 1, i, s, o, l;
  r ? (e >= t6[n].pos && e <= t6[a].pos && ({ lo: n, hi: a } = Ml(t6, "pos", e)), { pos: i, time: o } = t6[n], { pos: s, time: l } = t6[a]) : (e >= t6[n].time && e <= t6[a].time && ({ lo: n, hi: a } = Ml(t6, "time", e)), { time: i, pos: o } = t6[n], { time: s, pos: l } = t6[a]);
  const c = s - i;
  return c ? o + (l - o) * (e - i) / c : o;
}
class qu extends Es {
  constructor(e) {
    super(e), this._table = [], this._minPos = void 0, this._tableRange = void 0;
  }
  initOffsets() {
    const e = this._getTimestampsForTable(), r = this._table = this.buildLookupTable(e);
    this._minPos = Vi(r, this.min), this._tableRange = Vi(r, this.max) - this._minPos, super.initOffsets(e);
  }
  buildLookupTable(e) {
    const { min: r, max: n } = this, a = [], i = [];
    let s, o, l, c, d;
    for (s = 0, o = e.length; s < o; ++s)
      c = e[s], c >= r && c <= n && a.push(c);
    if (a.length < 2)
      return [
        {
          time: r,
          pos: 0
        },
        {
          time: n,
          pos: 1
        }
      ];
    for (s = 0, o = a.length; s < o; ++s)
      d = a[s + 1], l = a[s - 1], c = a[s], Math.round((d + l) / 2) !== c && i.push({
        time: c,
        pos: s / (o - 1)
      });
    return i;
  }
  _generate() {
    const e = this.min, r = this.max;
    let n = super.getDataTimestamps();
    return (!n.includes(e) || !n.length) && n.splice(0, 0, e), (!n.includes(r) || n.length === 1) && n.push(r), n.sort((a, i) => a - i);
  }
  _getTimestampsForTable() {
    let e = this._cache.all || [];
    if (e.length)
      return e;
    const r = this.getDataTimestamps(), n = this.getLabelTimestamps();
    return r.length && n.length ? e = this.normalize(r.concat(n)) : e = r.length ? r : n, e = this._cache.all = e, e;
  }
  getDecimalForValue(e) {
    return (Vi(this._table, e) - this._minPos) / this._tableRange;
  }
  getValueForPixel(e) {
    const r = this._offsets, n = this.getDecimalForPixel(e) / r.factor - r.end;
    return Vi(this._table, n * this._tableRange + this._minPos, true);
  }
}
K(qu, "id", "timeseries"), K(qu, "defaults", Es.defaults);
const Dg = "label";
function Uu(t6, e) {
  typeof t6 == "function" ? t6(e) : t6 && (t6.current = e);
}
function g1(t6, e) {
  const r = t6.options;
  r && e && Object.assign(r, e);
}
function Mg(t6, e) {
  t6.labels = e;
}
function Cg(t6, e) {
  let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Dg;
  const n = [];
  t6.datasets = e.map((a) => {
    const i = t6.datasets.find((s) => s[r] === a[r]);
    return !i || !a.data || n.includes(i) ? {
      ...a
    } : (n.push(i), Object.assign(i, a), i);
  });
}
function m1(t6) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Dg;
  const r = {
    labels: [],
    datasets: []
  };
  return Mg(r, t6.labels), Cg(r, t6.datasets, e), r;
}
function p1(t6, e) {
  const { height: r = 150, width: n = 300, redraw: a = false, datasetIdKey: i, type: s, data: o, options: l, plugins: c = [], fallbackContent: d, updateMode: u, ...f } = t6, h = reactExports.useRef(null), g = reactExports.useRef(null), m = () => {
    h.current && (g.current = new oo(h.current, {
      type: s,
      data: m1(o, i),
      options: l && {
        ...l
      },
      plugins: c
    }), Uu(e, g.current));
  }, p = () => {
    Uu(e, null), g.current && (g.current.destroy(), g.current = null);
  };
  return reactExports.useEffect(() => {
    !a && g.current && l && g1(g.current, l);
  }, [
    a,
    l
  ]), reactExports.useEffect(() => {
    !a && g.current && Mg(g.current.config.data, o.labels);
  }, [
    a,
    o.labels
  ]), reactExports.useEffect(() => {
    !a && g.current && o.datasets && Cg(g.current.config.data, o.datasets, i);
  }, [
    a,
    o.datasets
  ]), reactExports.useEffect(() => {
    g.current && (a ? (p(), setTimeout(m)) : g.current.update(u));
  }, [
    a,
    l,
    o.labels,
    o.datasets,
    u
  ]), reactExports.useEffect(() => {
    g.current && (p(), setTimeout(m));
  }, [
    s
  ]), reactExports.useEffect(() => (m(), () => p()), []), /* @__PURE__ */ React$1.createElement("canvas", {
    ref: h,
    role: "img",
    height: r,
    width: n,
    ...f
  }, d);
}
const b1 = /* @__PURE__ */ reactExports.forwardRef(p1);
function y1(t6, e) {
  return oo.register(e), /* @__PURE__ */ reactExports.forwardRef((r, n) => /* @__PURE__ */ React$1.createElement(b1, {
    ...r,
    ref: n,
    type: t6
  }));
}
const v1 = /* @__PURE__ */ y1("doughnut", $a);
oo.register(ja, d1, r1);
const HN = () => {
  const t6 = {
    labels: ["Planeado", "Ejecutado"],
    datasets: [
      {
        label: "Presupuesto",
        data: [14.7, 11.6],
        backgroundColor: ["#EBE1FF", "#9873e8"],
        borderColor: ["#EBE1F9", "#9873e1"],
        borderWidth: 1,
        circumference: 180,
        rotation: -90
      }
    ]
  }, e = {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      title: {
        display: true,
        text: "PRESUPUESTO"
      },
      legend: {
        position: "right"
      },
      tooltip: {
        enabled: true
      },
      doughnutLabel: {
        labels: [
          {
            text: "Total",
            font: {
              size: "16",
              weight: "bold"
            }
          },
          {
            text: `${t6.datasets[0].data.reduce((n, a) => n + a, 0).toFixed(1)}`,
            font: {
              size: "20"
            }
          }
        ]
      }
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "size-full min-h-[200px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(v1, { data: t6, options: e, plugins: [{
    id: "textCenter",
    beforeDraw(n) {
      const {
        ctx: a,
        chartArea: { top: i, width: s, height: o }
      } = n, l = "Total", c = t6.datasets[0].data.reduce((u, f) => u + f, 0).toFixed(1), d = i + o * 0.75;
      a.save(), a.font = "16px Arial", a.fillStyle = "black", a.textAlign = "center", a.fillText(l, s / 2, d - 15), a.font = "bold 20px Arial", a.fillText(c, s / 2, d + 15), a.restore();
    }
  }] }) });
}, x1 = "modal-module__overlay__cc2Es", w1 = "modal-module__modal__WAkuU", k1 = "modal-module__closeButton__1lo1j", Zo = {
  overlay: x1,
  modal: w1,
  closeButton: k1
};
function _1(t6) {
  return We({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M256 48C141.1 48 48 141.1 48 256s93.1 208 208 208 208-93.1 208-208S370.9 48 256 48zm52.7 283.3L256 278.6l-52.7 52.7c-6.2 6.2-16.4 6.2-22.6 0-3.1-3.1-4.7-7.2-4.7-11.3 0-4.1 1.6-8.2 4.7-11.3l52.7-52.7-52.7-52.7c-3.1-3.1-4.7-7.2-4.7-11.3 0-4.1 1.6-8.2 4.7-11.3 6.2-6.2 16.4-6.2 22.6 0l52.7 52.7 52.7-52.7c6.2-6.2 16.4-6.2 22.6 0 6.2 6.2 6.2 16.4 0 22.6L278.6 256l52.7 52.7c6.2 6.2 6.2 16.4 0 22.6-6.2 6.3-16.4 6.3-22.6 0z" }, child: [] }] })(t6);
}
const S1 = reactExports.forwardRef(
  ({ isOpen: t6, onClose: e, children: r, width: n = "auto" }, a) => t6 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: Zo.overlay, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref: a, className: Zo.modal, style: { width: n }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: e, className: Zo.closeButton, children: /* @__PURE__ */ jsxRuntimeExports.jsx(_1, {}) }),
    r
  ] }) }) : null
);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var At = function() {
  return At = Object.assign || function(e) {
    for (var r, n = 1, a = arguments.length; n < a; n++) {
      r = arguments[n];
      for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, At.apply(this, arguments);
};
function Tn(t6, e) {
  var r = {};
  for (var n in t6) Object.prototype.hasOwnProperty.call(t6, n) && e.indexOf(n) < 0 && (r[n] = t6[n]);
  if (t6 != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a = 0, n = Object.getOwnPropertySymbols(t6); a < n.length; a++)
      e.indexOf(n[a]) < 0 && Object.prototype.propertyIsEnumerable.call(t6, n[a]) && (r[n[a]] = t6[n[a]]);
  return r;
}
function pt(t6, e) {
  return Object.defineProperty ? Object.defineProperty(t6, "raw", { value: e }) : t6.raw = e, t6;
}
function Rl() {
  return Rl = Object.assign ? Object.assign.bind() : function(t6) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (t6[n] = r[n]);
    }
    return t6;
  }, Rl.apply(this, arguments);
}
function co(t6) {
  var e = /* @__PURE__ */ Object.create(null);
  return function(r) {
    return e[r] === void 0 && (e[r] = t6(r)), e[r];
  };
}
var D1 = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, M1 = /* @__PURE__ */ co(
  function(t6) {
    return D1.test(t6) || t6.charCodeAt(0) === 111 && t6.charCodeAt(1) === 110 && t6.charCodeAt(2) < 91;
  }
  /* Z+1 */
);
function C1(t6) {
  if (t6.sheet)
    return t6.sheet;
  for (var e = 0; e < document.styleSheets.length; e++)
    if (document.styleSheets[e].ownerNode === t6)
      return document.styleSheets[e];
}
function E1(t6) {
  var e = document.createElement("style");
  return e.setAttribute("data-emotion", t6.key), t6.nonce !== void 0 && e.setAttribute("nonce", t6.nonce), e.appendChild(document.createTextNode("")), e.setAttribute("data-s", ""), e;
}
var T1 = /* @__PURE__ */ function() {
  function t6(r) {
    var n = this;
    this._insertTag = function(a) {
      var i;
      n.tags.length === 0 ? n.insertionPoint ? i = n.insertionPoint.nextSibling : n.prepend ? i = n.container.firstChild : i = n.before : i = n.tags[n.tags.length - 1].nextSibling, n.container.insertBefore(a, i), n.tags.push(a);
    }, this.isSpeedy = r.speedy === void 0 ? true : r.speedy, this.tags = [], this.ctr = 0, this.nonce = r.nonce, this.key = r.key, this.container = r.container, this.prepend = r.prepend, this.insertionPoint = r.insertionPoint, this.before = null;
  }
  var e = t6.prototype;
  return e.hydrate = function(n) {
    n.forEach(this._insertTag);
  }, e.insert = function(n) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(E1(this));
    var a = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var s = C1(a);
      try {
        s.insertRule(n, s.cssRules.length);
      } catch (o) {
      }
    } else
      a.appendChild(document.createTextNode(n));
    this.ctr++;
  }, e.flush = function() {
    this.tags.forEach(function(n) {
      return n.parentNode && n.parentNode.removeChild(n);
    }), this.tags = [], this.ctr = 0;
  }, t6;
}(), ht = "-ms-", Ts = "-moz-", be = "-webkit-", vc = "comm", xc = "rule", wc = "decl", P1 = "@import", Eg = "@keyframes", R1 = Math.abs, uo = String.fromCharCode, N1 = Object.assign;
function I1(t6, e) {
  return ot(t6, 0) ^ 45 ? (((e << 2 ^ ot(t6, 0)) << 2 ^ ot(t6, 1)) << 2 ^ ot(t6, 2)) << 2 ^ ot(t6, 3) : 0;
}
function Tg(t6) {
  return t6.trim();
}
function A1(t6, e) {
  return (t6 = e.exec(t6)) ? t6[0] : t6;
}
function _e(t6, e, r) {
  return t6.replace(e, r);
}
function Nl(t6, e) {
  return t6.indexOf(e);
}
function ot(t6, e) {
  return t6.charCodeAt(e) | 0;
}
function ai(t6, e, r) {
  return t6.slice(e, r);
}
function sr(t6) {
  return t6.length;
}
function kc(t6) {
  return t6.length;
}
function qi(t6, e) {
  return e.push(t6), t6;
}
function F1(t6, e) {
  return t6.map(e).join("");
}
var fo = 1, na = 1, Pg = 0, Mt = 0, Ke = 0, ga = "";
function ho(t6, e, r, n, a, i, s) {
  return { value: t6, root: e, parent: r, type: n, props: a, children: i, line: fo, column: na, length: s, return: "" };
}
function Da(t6, e) {
  return N1(ho("", null, null, "", null, null, 0), t6, { length: -t6.length }, e);
}
function L1() {
  return Ke;
}
function W1() {
  return Ke = Mt > 0 ? ot(ga, --Mt) : 0, na--, Ke === 10 && (na = 1, fo--), Ke;
}
function Ft() {
  return Ke = Mt < Pg ? ot(ga, Mt++) : 0, na++, Ke === 10 && (na = 1, fo++), Ke;
}
function fr() {
  return ot(ga, Mt);
}
function ls() {
  return Mt;
}
function pi(t6, e) {
  return ai(ga, t6, e);
}
function ii(t6) {
  switch (t6) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function Rg(t6) {
  return fo = na = 1, Pg = sr(ga = t6), Mt = 0, [];
}
function Ng(t6) {
  return ga = "", t6;
}
function cs(t6) {
  return Tg(pi(Mt - 1, Il(t6 === 91 ? t6 + 2 : t6 === 40 ? t6 + 1 : t6)));
}
function $1(t6) {
  for (; (Ke = fr()) && Ke < 33; )
    Ft();
  return ii(t6) > 2 || ii(Ke) > 3 ? "" : " ";
}
function z1(t6, e) {
  for (; --e && Ft() && !(Ke < 48 || Ke > 102 || Ke > 57 && Ke < 65 || Ke > 70 && Ke < 97); )
    ;
  return pi(t6, ls() + (e < 6 && fr() == 32 && Ft() == 32));
}
function Il(t6) {
  for (; Ft(); )
    switch (Ke) {
      case t6:
        return Mt;
      case 34:
      case 39:
        t6 !== 34 && t6 !== 39 && Il(Ke);
        break;
      case 40:
        t6 === 41 && Il(t6);
        break;
      case 92:
        Ft();
        break;
    }
  return Mt;
}
function j1(t6, e) {
  for (; Ft() && t6 + Ke !== 57; )
    if (t6 + Ke === 84 && fr() === 47)
      break;
  return "/*" + pi(e, Mt - 1) + "*" + uo(t6 === 47 ? t6 : Ft());
}
function H1(t6) {
  for (; !ii(fr()); )
    Ft();
  return pi(t6, Mt);
}
function Xu(t6) {
  return Ng(ds("", null, null, null, [""], t6 = Rg(t6), 0, [0], t6));
}
function ds(t6, e, r, n, a, i, s, o, l) {
  for (var c = 0, d = 0, u = s, f = 0, h = 0, g = 0, m = 1, p = 1, w = 1, b = 0, k = "", v = a, x = i, _ = n, T = k; p; )
    switch (g = b, b = Ft()) {
      case 40:
        if (g != 108 && ot(T, u - 1) == 58) {
          Nl(T += _e(cs(b), "&", "&\f"), "&\f") != -1 && (w = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        T += cs(b);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        T += $1(g);
        break;
      case 92:
        T += z1(ls() - 1, 7);
        continue;
      case 47:
        switch (fr()) {
          case 42:
          case 47:
            qi(B1(j1(Ft(), ls()), e, r), l);
            break;
          default:
            T += "/";
        }
        break;
      case 123 * m:
        o[c++] = sr(T) * w;
      case 125 * m:
      case 59:
      case 0:
        switch (b) {
          case 0:
          case 125:
            p = 0;
          case 59 + d:
            h > 0 && sr(T) - u && qi(h > 32 ? Ku(T + ";", n, r, u - 1) : Ku(_e(T, " ", "") + ";", n, r, u - 2), l);
            break;
          case 59:
            T += ";";
          default:
            if (qi(_ = Gu(T, e, r, c, d, a, o, k, v = [], x = [], u), i), b === 123)
              if (d === 0)
                ds(T, e, _, _, v, i, u, o, x);
              else
                switch (f === 99 && ot(T, 3) === 110 ? 100 : f) {
                  case 100:
                  case 109:
                  case 115:
                    ds(t6, _, _, n && qi(Gu(t6, _, _, 0, 0, a, o, k, a, v = [], u), x), a, x, u, o, n ? v : x);
                    break;
                  default:
                    ds(T, _, _, _, [""], x, 0, o, x);
                }
        }
        c = d = h = 0, m = w = 1, k = T = "", u = s;
        break;
      case 58:
        u = 1 + sr(T), h = g;
      default:
        if (m < 1) {
          if (b == 123)
            --m;
          else if (b == 125 && m++ == 0 && W1() == 125)
            continue;
        }
        switch (T += uo(b), b * m) {
          case 38:
            w = d > 0 ? 1 : (T += "\f", -1);
            break;
          case 44:
            o[c++] = (sr(T) - 1) * w, w = 1;
            break;
          case 64:
            fr() === 45 && (T += cs(Ft())), f = fr(), d = u = sr(k = T += H1(ls())), b++;
            break;
          case 45:
            g === 45 && sr(T) == 2 && (m = 0);
        }
    }
  return i;
}
function Gu(t6, e, r, n, a, i, s, o, l, c, d) {
  for (var u = a - 1, f = a === 0 ? i : [""], h = kc(f), g = 0, m = 0, p = 0; g < n; ++g)
    for (var w = 0, b = ai(t6, u + 1, u = R1(m = s[g])), k = t6; w < h; ++w)
      (k = Tg(m > 0 ? f[w] + " " + b : _e(b, /&\f/g, f[w]))) && (l[p++] = k);
  return ho(t6, e, r, a === 0 ? xc : o, l, c, d);
}
function B1(t6, e, r) {
  return ho(t6, e, r, vc, uo(L1()), ai(t6, 2, -2), 0);
}
function Ku(t6, e, r, n) {
  return ho(t6, e, r, wc, ai(t6, 0, n), ai(t6, n + 1, -1), n);
}
function On(t6, e) {
  for (var r = "", n = kc(t6), a = 0; a < n; a++)
    r += e(t6[a], a, t6, e) || "";
  return r;
}
function Qu(t6, e, r, n) {
  switch (t6.type) {
    case P1:
    case wc:
      return t6.return = t6.return || t6.value;
    case vc:
      return "";
    case Eg:
      return t6.return = t6.value + "{" + On(t6.children, n) + "}";
    case xc:
      t6.value = t6.props.join(",");
  }
  return sr(r = On(t6.children, n)) ? t6.return = t6.value + "{" + r + "}" : "";
}
function Ju(t6) {
  var e = kc(t6);
  return function(r, n, a, i) {
    for (var s = "", o = 0; o < e; o++)
      s += t6[o](r, n, a, i) || "";
    return s;
  };
}
function Y1(t6) {
  return function(e) {
    e.root || (e = e.return) && t6(e);
  };
}
var V1 = function(e) {
  var r = /* @__PURE__ */ new WeakMap();
  return function(n) {
    if (r.has(n))
      return r.get(n);
    var a = e(n);
    return r.set(n, a), a;
  };
}, q1 = function(e, r, n) {
  for (var a = 0, i = 0; a = i, i = fr(), a === 38 && i === 12 && (r[n] = 1), !ii(i); )
    Ft();
  return pi(e, Mt);
}, U1 = function(e, r) {
  var n = -1, a = 44;
  do
    switch (ii(a)) {
      case 0:
        a === 38 && fr() === 12 && (r[n] = 1), e[n] += q1(Mt - 1, r, n);
        break;
      case 2:
        e[n] += cs(a);
        break;
      case 4:
        if (a === 44) {
          e[++n] = fr() === 58 ? "&\f" : "", r[n] = e[n].length;
          break;
        }
      default:
        e[n] += uo(a);
    }
  while (a = Ft());
  return e;
}, X1 = function(e, r) {
  return Ng(U1(Rg(e), r));
}, Zu = /* @__PURE__ */ new WeakMap(), G1 = function(e) {
  if (!(e.type !== "rule" || !e.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  e.length < 1)) {
    for (var r = e.value, n = e.parent, a = e.column === n.column && e.line === n.line; n.type !== "rule"; )
      if (n = n.parent, !n) return;
    if (!(e.props.length === 1 && r.charCodeAt(0) !== 58 && !Zu.get(n)) && !a) {
      Zu.set(e, true);
      for (var i = [], s = X1(r, i), o = n.props, l = 0, c = 0; l < s.length; l++)
        for (var d = 0; d < o.length; d++, c++)
          e.props[c] = i[l] ? s[l].replace(/&\f/g, o[d]) : o[d] + " " + s[l];
    }
  }
}, K1 = function(e) {
  if (e.type === "decl") {
    var r = e.value;
    r.charCodeAt(0) === 108 && // charcode for b
    r.charCodeAt(2) === 98 && (e.return = "", e.value = "");
  }
};
function Ag(t6, e) {
  switch (I1(t6, e)) {
    case 5103:
      return be + "print-" + t6 + t6;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return be + t6 + t6;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return be + t6 + Ts + t6 + ht + t6 + t6;
    case 6828:
    case 4268:
      return be + t6 + ht + t6 + t6;
    case 6165:
      return be + t6 + ht + "flex-" + t6 + t6;
    case 5187:
      return be + t6 + _e(t6, /(\w+).+(:[^]+)/, be + "box-$1$2" + ht + "flex-$1$2") + t6;
    case 5443:
      return be + t6 + ht + "flex-item-" + _e(t6, /flex-|-self/, "") + t6;
    case 4675:
      return be + t6 + ht + "flex-line-pack" + _e(t6, /align-content|flex-|-self/, "") + t6;
    case 5548:
      return be + t6 + ht + _e(t6, "shrink", "negative") + t6;
    case 5292:
      return be + t6 + ht + _e(t6, "basis", "preferred-size") + t6;
    case 6060:
      return be + "box-" + _e(t6, "-grow", "") + be + t6 + ht + _e(t6, "grow", "positive") + t6;
    case 4554:
      return be + _e(t6, /([^-])(transform)/g, "$1" + be + "$2") + t6;
    case 6187:
      return _e(_e(_e(t6, /(zoom-|grab)/, be + "$1"), /(image-set)/, be + "$1"), t6, "") + t6;
    case 5495:
    case 3959:
      return _e(t6, /(image-set\([^]*)/, be + "$1$`$1");
    case 4968:
      return _e(_e(t6, /(.+:)(flex-)?(.*)/, be + "box-pack:$3" + ht + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + be + t6 + t6;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return _e(t6, /(.+)-inline(.+)/, be + "$1$2") + t6;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (sr(t6) - 1 - e > 6) switch (ot(t6, e + 1)) {
        case 109:
          if (ot(t6, e + 4) !== 45) break;
        case 102:
          return _e(t6, /(.+:)(.+)-([^]+)/, "$1" + be + "$2-$3$1" + Ts + (ot(t6, e + 3) == 108 ? "$3" : "$2-$3")) + t6;
        case 115:
          return ~Nl(t6, "stretch") ? Ag(_e(t6, "stretch", "fill-available"), e) + t6 : t6;
      }
      break;
    case 4949:
      if (ot(t6, e + 1) !== 115) break;
    case 6444:
      switch (ot(t6, sr(t6) - 3 - (~Nl(t6, "!important") && 10))) {
        case 107:
          return _e(t6, ":", ":" + be) + t6;
        case 101:
          return _e(t6, /(.+:)([^;!]+)(;|!.+)?/, "$1" + be + (ot(t6, 14) === 45 ? "inline-" : "") + "box$3$1" + be + "$2$3$1" + ht + "$2box$3") + t6;
      }
      break;
    case 5936:
      switch (ot(t6, e + 11)) {
        case 114:
          return be + t6 + ht + _e(t6, /[svh]\w+-[tblr]{2}/, "tb") + t6;
        case 108:
          return be + t6 + ht + _e(t6, /[svh]\w+-[tblr]{2}/, "tb-rl") + t6;
        case 45:
          return be + t6 + ht + _e(t6, /[svh]\w+-[tblr]{2}/, "lr") + t6;
      }
      return be + t6 + ht + t6 + t6;
  }
  return t6;
}
var rk = function(e, r, n, a) {
  if (e.length > -1 && !e.return) switch (e.type) {
    case wc:
      e.return = Ag(e.value, e.length);
      break;
    case Eg:
      return On([Da(e, {
        value: _e(e.value, "@", "@" + be)
      })], a);
    case xc:
      if (e.length) return F1(e.props, function(i) {
        switch (A1(i, /(::plac\w+|:read-\w+)/)) {
          case ":read-only":
          case ":read-write":
            return On([Da(e, {
              props: [_e(i, /:(read-\w+)/, ":" + Ts + "$1")]
            })], a);
          case "::placeholder":
            return On([Da(e, {
              props: [_e(i, /:(plac\w+)/, ":" + be + "input-$1")]
            }), Da(e, {
              props: [_e(i, /:(plac\w+)/, ":" + Ts + "$1")]
            }), Da(e, {
              props: [_e(i, /:(plac\w+)/, ht + "input-$1")]
            })], a);
        }
        return "";
      });
  }
}, us = typeof document < "u", nk = us ? void 0 : V1(function() {
  return co(function() {
    var t6 = {};
    return function(e) {
      return t6[e];
    };
  });
}), ak = [rk], Fg = function(e) {
  var r = e.key;
  if (us && r === "css") {
    var n = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(n, function(v) {
      var x = v.getAttribute("data-emotion");
      x.indexOf(" ") !== -1 && (document.head.appendChild(v), v.setAttribute("data-s", ""));
    });
  }
  var a = e.stylisPlugins || ak;
  var i = {}, s, o = [];
  us && (s = e.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + r + ' "]'),
    function(v) {
      for (var x = v.getAttribute("data-emotion").split(" "), _ = 1; _ < x.length; _++)
        i[x[_]] = true;
      o.push(v);
    }
  ));
  var l, c = [G1, K1];
  if (us) {
    var d, u = [Qu, Y1(function(v) {
      d.insert(v);
    })], f = Ju(c.concat(a, u)), h = function(x) {
      return On(Xu(x), f);
    };
    l = function(x, _, T, S) {
      d = T, h(x ? x + "{" + _.styles + "}" : _.styles), S && (k.inserted[_.name] = true);
    };
  } else {
    var g = [Qu], m = Ju(c.concat(a, g)), p = function(x) {
      return On(Xu(x), m);
    }, w = nk(a)(r), b = function(x, _) {
      var T = _.name;
      return w[T] === void 0 && (w[T] = p(x ? x + "{" + _.styles + "}" : _.styles)), w[T];
    };
    l = function(x, _, T, S) {
      var C = _.name, D = b(x, _);
      if (k.compat === void 0)
        return S && (k.inserted[C] = true), // using === development instead of !== production
        // because if people do ssr in tests, the source maps showing up would be annoying
        D;
      if (S)
        k.inserted[C] = D;
      else
        return D;
    };
  }
  var k = {
    key: r,
    sheet: new T1({
      key: r,
      container: s,
      nonce: e.nonce,
      speedy: e.speedy,
      prepend: e.prepend,
      insertionPoint: e.insertionPoint
    }),
    nonce: e.nonce,
    inserted: i,
    registered: {},
    insert: l
  };
  return k.sheet.hydrate(o), k;
};
var bk = typeof document < "u", of = function(e) {
  return e();
}, yk = reactExports.useInsertionEffect ? reactExports.useInsertionEffect : false, jg = bk && yk || of, Hg = typeof document < "u", oi = /* @__PURE__ */ reactExports.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement < "u" ? /* @__PURE__ */ Fg({
    key: "css"
  }) : null
);
oi.Provider;
var Oc = function(e) {
  return /* @__PURE__ */ reactExports.forwardRef(function(r, n) {
    var a = reactExports.useContext(oi);
    return e(r, a, n);
  });
};
Hg || (Oc = function(e) {
  return function(r) {
    var n = reactExports.useContext(oi);
    return n === null ? (n = Fg({
      key: "css"
    }), /* @__PURE__ */ reactExports.createElement(oi.Provider, {
      value: n
    }, e(r, n))) : e(r, n);
  };
});
var Sc = /* @__PURE__ */ reactExports.createContext({});
var Fl = typeof document < "u";
function kk(t6, e, r) {
  var n = "";
  return r.split(" ").forEach(function(a) {
    t6[a] !== void 0 ? e.push(t6[a] + ";") : n += a + " ";
  }), n;
}
var Bg = function(e, r, n) {
  var a = e.key + "-" + r.name;
  (n === false || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  Fl === false && e.compat !== void 0) && e.registered[a] === void 0 && (e.registered[a] = r.styles);
}, _k = function(e, r, n) {
  Bg(e, r, n);
  var a = e.key + "-" + r.name;
  if (e.inserted[r.name] === void 0) {
    var i = "", s = r;
    do {
      var o = e.insert(r === s ? "." + a : "", s, e.sheet, true);
      !Fl && o !== void 0 && (i += o), s = s.next;
    } while (s !== void 0);
    if (!Fl && i.length !== 0)
      return i;
  }
};
function Ok(t6) {
  for (var e = 0, r, n = 0, a = t6.length; a >= 4; ++n, a -= 4)
    r = t6.charCodeAt(n) & 255 | (t6.charCodeAt(++n) & 255) << 8 | (t6.charCodeAt(++n) & 255) << 16 | (t6.charCodeAt(++n) & 255) << 24, r = /* Math.imul(k, m): */
    (r & 65535) * 1540483477 + ((r >>> 16) * 59797 << 16), r ^= /* k >>> r: */
    r >>> 24, e = /* Math.imul(k, m): */
    (r & 65535) * 1540483477 + ((r >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16);
  switch (a) {
    case 3:
      e ^= (t6.charCodeAt(n + 2) & 255) << 16;
    case 2:
      e ^= (t6.charCodeAt(n + 1) & 255) << 8;
    case 1:
      e ^= t6.charCodeAt(n) & 255, e = /* Math.imul(h, m): */
      (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16);
  }
  return e ^= e >>> 13, e = /* Math.imul(h, m): */
  (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16), ((e ^ e >>> 15) >>> 0).toString(36);
}
var Sk = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, Mk = /[A-Z]|^ms/g, Yg = /_EMO_([^_]+?)_([^]*?)_EMO_/g, Dc = function(e) {
  return e.charCodeAt(1) === 45;
}, uf = function(e) {
  return e != null && typeof e != "boolean";
}, tl = /* @__PURE__ */ co(function(t6) {
  return Dc(t6) ? t6 : t6.replace(Mk, "-$&").toLowerCase();
}), Rs = function(e, r) {
  switch (e) {
    case "animation":
    case "animationName":
      if (typeof r == "string")
        return r.replace(Yg, function(n, a, i) {
          return Ut = {
            name: a,
            styles: i,
            next: Ut
          }, a;
        });
  }
  return Sk[e] !== 1 && !Dc(e) && typeof r == "number" && r !== 0 ? r + "px" : r;
};
function li(t6, e, r) {
  if (r == null)
    return "";
  if (r.__emotion_styles !== void 0) {
    return r;
  }
  switch (typeof r) {
    case "boolean":
      return "";
    case "object": {
      if (r.anim === 1)
        return Ut = {
          name: r.name,
          styles: r.styles,
          next: Ut
        }, r.name;
      if (r.styles !== void 0) {
        var n = r.next;
        if (n !== void 0)
          for (; n !== void 0; )
            Ut = {
              name: n.name,
              styles: n.styles,
              next: Ut
            }, n = n.next;
        var a = r.styles + ";";
        return a;
      }
      return Nk(t6, e, r);
    }
    case "function": {
      if (t6 !== void 0) {
        var i = Ut, s = r(t6);
        return Ut = i, li(t6, e, s);
      }
      break;
    }
  }
  if (e == null)
    return r;
  var c = e[r];
  return c !== void 0 ? c : r;
}
function Nk(t6, e, r) {
  var n = "";
  if (Array.isArray(r))
    for (var a = 0; a < r.length; a++)
      n += li(t6, e, r[a]) + ";";
  else
    for (var i in r) {
      var s = r[i];
      if (typeof s != "object")
        e != null && e[s] !== void 0 ? n += i + "{" + e[s] + "}" : uf(s) && (n += tl(i) + ":" + Rs(i, s) + ";");
      else {
        if (Array.isArray(s) && typeof s[0] == "string" && (e == null || e[s[0]] === void 0))
          for (var o = 0; o < s.length; o++)
            uf(s[o]) && (n += tl(i) + ":" + Rs(i, s[o]) + ";");
        else {
          var l = li(t6, e, s);
          switch (i) {
            case "animation":
            case "animationName": {
              n += tl(i) + ":" + l + ";";
              break;
            }
            default:
              n += i + "{" + l + "}";
          }
        }
      }
    }
  return n;
}
var hf = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var Ut, Ik = function(e, r, n) {
  if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
    return e[0];
  var a = true, i = "";
  Ut = void 0;
  var s = e[0];
  s == null || s.raw === void 0 ? (a = false, i += li(n, r, s)) : (i += s[0]);
  for (var o = 1; o < e.length; o++)
    i += li(n, r, e[o]), a && (i += s[o]);
  hf.lastIndex = 0;
  for (var c = "", d; (d = hf.exec(i)) !== null; )
    c += "-" + // $FlowFixMe we know it's not null
    d[1];
  var u = Ok(i) + c;
  return {
    name: u,
    styles: i,
    next: Ut
  };
}, Ak = M1, Fk = function(e) {
  return e !== "theme";
}, gf = function(e) {
  return typeof e == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  e.charCodeAt(0) > 96 ? Ak : Fk;
}, mf = function(e, r, n) {
  var a;
  if (r) {
    var i = r.shouldForwardProp;
    a = e.__emotion_forwardProp && i ? function(s) {
      return e.__emotion_forwardProp(s) && i(s);
    } : i;
  }
  return typeof a != "function" && n && (a = e.__emotion_forwardProp), a;
}, Lk = typeof document < "u", Wk = function(e) {
  var r = e.cache, n = e.serialized, a = e.isStringTag;
  Bg(r, n, a);
  var i = jg(function() {
    return _k(r, n, a);
  });
  if (!Lk && i !== void 0) {
    for (var s, o = n.name, l = n.next; l !== void 0; )
      o += " " + l.name, l = l.next;
    return /* @__PURE__ */ reactExports.createElement("style", (s = {}, s["data-emotion"] = r.key + " " + o, s.dangerouslySetInnerHTML = {
      __html: i
    }, s.nonce = r.sheet.nonce, s));
  }
  return null;
}, $k = function t(e, r) {
  var n = e.__emotion_real === e, a = n && e.__emotion_base || e, i, s;
  r !== void 0 && (i = r.label, s = r.target);
  var o = mf(e, r, n), l = o || gf(a), c = !l("as");
  return function() {
    var d = arguments, u = n && e.__emotion_styles !== void 0 ? e.__emotion_styles.slice(0) : [];
    if (i !== void 0 && u.push("label:" + i + ";"), d[0] == null || d[0].raw === void 0)
      u.push.apply(u, d);
    else {
      u.push(d[0][0]);
      for (var f = d.length, h = 1; h < f; h++)
        u.push(d[h], d[0][h]);
    }
    var g = Oc(function(m, p, w) {
      var b = c && m.as || a, k = "", v = [], x = m;
      if (m.theme == null) {
        x = {};
        for (var _ in m)
          x[_] = m[_];
        x.theme = reactExports.useContext(Sc);
      }
      typeof m.className == "string" ? k = kk(p.registered, v, m.className) : m.className != null && (k = m.className + " ");
      var T = Ik(u.concat(v), p.registered, x);
      k += p.key + "-" + T.name, s !== void 0 && (k += " " + s);
      var S = c && o === void 0 ? gf(b) : l, C = {};
      for (var D in m)
        c && D === "as" || // $FlowFixMe
        S(D) && (C[D] = m[D]);
      return C.className = k, C.ref = w, /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Wk, {
        cache: p,
        serialized: T,
        isStringTag: typeof b == "string"
      }), /* @__PURE__ */ reactExports.createElement(b, C));
    });
    return g.displayName = i !== void 0 ? i : "Styled(" + (typeof a == "string" ? a : a.displayName || a.name || "Component") + ")", g.defaultProps = e.defaultProps, g.__emotion_real = g, g.__emotion_base = a, g.__emotion_styles = u, g.__emotion_forwardProp = o, Object.defineProperty(g, "toString", {
      value: function() {
        return "." + s;
      }
    }), g.withComponent = function(m, p) {
      return t(m, Rl({}, r, p, {
        shouldForwardProp: mf(g, p, true)
      })).apply(void 0, u);
    }, g;
  };
}, zk = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
], it = $k.bind();
zk.forEach(function(t6) {
  it[t6] = it(t6);
});
var Ug = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(t6) {
  (function() {
    var e = {}.hasOwnProperty;
    function r() {
      for (var n = [], a = 0; a < arguments.length; a++) {
        var i = arguments[a];
        if (i) {
          var s = typeof i;
          if (s === "string" || s === "number")
            n.push(i);
          else if (Array.isArray(i)) {
            if (i.length) {
              var o = r.apply(null, i);
              o && n.push(o);
            }
          } else if (s === "object") {
            if (i.toString !== Object.prototype.toString && !i.toString.toString().includes("[native code]")) {
              n.push(i.toString());
              continue;
            }
            for (var l in i)
              e.call(i, l) && i[l] && n.push(l);
          }
        }
      }
      return n.join(" ");
    }
    t6.exports ? (r.default = r, t6.exports = r) : window.classNames = r;
  })();
})(Ug);
var et = Ug.exports, jk = React$1.createContext(void 0), Hk = function() {
  var t6 = React$1.useContext(jk);
  return t6;
}, Bk = function(t6) {
  var e = React$1.useState(!!t6 && typeof window < "u" && window.matchMedia(t6).matches), r = e[0], n = e[1];
  return React$1.useEffect(function() {
    if (t6) {
      var a = window.matchMedia(t6), i = function() {
        a.matches !== r && n(a.matches);
      };
      return i(), a.addEventListener("change", i), function() {
        return a.removeEventListener("change", i);
      };
    }
  }, [r, t6]), r;
}, He = {
  root: "ps-sidebar-root",
  container: "ps-sidebar-container",
  image: "ps-sidebar-image",
  backdrop: "ps-sidebar-backdrop",
  collapsed: "ps-collapsed",
  toggled: "ps-toggled",
  rtl: "ps-rtl",
  broken: "ps-broken"
}, ye = {
  root: "ps-menu-root",
  menuItemRoot: "ps-menuitem-root",
  subMenuRoot: "ps-submenu-root",
  button: "ps-menu-button",
  prefix: "ps-menu-prefix",
  suffix: "ps-menu-suffix",
  label: "ps-menu-label",
  icon: "ps-menu-icon",
  subMenuContent: "ps-submenu-content",
  SubMenuExpandIcon: "ps-submenu-expand-icon",
  disabled: "ps-disabled",
  active: "ps-active",
  open: "ps-open"
}, Yk = it.div(bf || (bf = pt([`
  position: fixed;
  top: 0px;
  right: 0px;
  bottom: 0px;
  left: 0px;
  z-index: 1;
  background-color: rgb(0, 0, 0, 0.3);
`], [`
  position: fixed;
  top: 0px;
  right: 0px;
  bottom: 0px;
  left: 0px;
  z-index: 1;
  background-color: rgb(0, 0, 0, 0.3);
`]))), bf, Vk = {
  xs: "480px",
  sm: "576px",
  md: "768px",
  lg: "992px",
  xl: "1200px",
  xxl: "1600px",
  always: "always",
  all: "all"
}, qk = it.aside(yf || (yf = pt([`
  position: relative;
  border-right-width: 1px;
  border-right-style: solid;
  border-color: #efefef;

  transition: `, `;

  width: `, `;
  min-width: `, `;

  &.`, ` {
    width: `, `;
    min-width: `, `;
  }

  &.`, ` {
    direction: rtl;
    border-right-width: none;
    border-left-width: 1px;
    border-right-style: none;
    border-left-style: solid;
  }

  &.`, ` {
    position: fixed;
    height: 100%;
    top: 0px;
    z-index: 100;

    `, `

    &.`, ` {
      `, `
    }

    &.`, ` {
      `, `
    }

    &.`, ` {
      right: -`, `;

      &.`, ` {
        right: -`, `;
      }

      &.`, ` {
        right: 0;
      }
    }
  }

  `, `
`], [`
  position: relative;
  border-right-width: 1px;
  border-right-style: solid;
  border-color: #efefef;

  transition: `, `;

  width: `, `;
  min-width: `, `;

  &.`, ` {
    width: `, `;
    min-width: `, `;
  }

  &.`, ` {
    direction: rtl;
    border-right-width: none;
    border-left-width: 1px;
    border-right-style: none;
    border-left-style: solid;
  }

  &.`, ` {
    position: fixed;
    height: 100%;
    top: 0px;
    z-index: 100;

    `, `

    &.`, ` {
      `, `
    }

    &.`, ` {
      `, `
    }

    &.`, ` {
      right: -`, `;

      &.`, ` {
        right: -`, `;
      }

      &.`, ` {
        right: 0;
      }
    }
  }

  `, `
`])), function(t6) {
  var e = t6.transitionDuration;
  return "width, left, right, ".concat(e, "ms");
}, function(t6) {
  var e = t6.width;
  return e;
}, function(t6) {
  var e = t6.width;
  return e;
}, He.collapsed, function(t6) {
  var e = t6.collapsedWidth;
  return e;
}, function(t6) {
  var e = t6.collapsedWidth;
  return e;
}, He.rtl, He.broken, function(t6) {
  var e = t6.rtl, r = t6.width;
  return e ? "" : "left: -".concat(r, ";");
}, He.collapsed, function(t6) {
  var e = t6.rtl, r = t6.collapsedWidth;
  return e ? "" : "left: -".concat(r, "; ");
}, He.toggled, function(t6) {
  var e = t6.rtl;
  return e ? "" : "left: 0;";
}, He.rtl, function(t6) {
  var e = t6.width;
  return e;
}, He.collapsed, function(t6) {
  var e = t6.collapsedWidth;
  return e;
}, He.toggled, function(t6) {
  var e = t6.rootStyles;
  return e;
}), Uk = it.div(vf || (vf = pt([`
  position: relative;
  height: 100%;
  overflow-y: auto;
  overflow-x: hidden;
  z-index: 3;

  `, `
`], [`
  position: relative;
  height: 100%;
  overflow-y: auto;
  overflow-x: hidden;
  z-index: 3;

  `, `
`])), function(t6) {
  var e = t6.backgroundColor;
  return e ? "background-color:".concat(e, ";") : "";
}), Xk = it.img(xf || (xf = pt([`
  &.`, ` {
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center;
    position: absolute;
    left: 0;
    top: 0;
    z-index: 2;
  }
`], [`
  &.`, ` {
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center;
    position: absolute;
    left: 0;
    top: 0;
    z-index: 2;
  }
`])), He.image), go = React$1.createContext({
  collapsed: false,
  toggled: false,
  rtl: false,
  transitionDuration: 300
}); React$1.forwardRef(function(t6, e) {
  var r, n = t6.collapsed, a = t6.toggled, i = t6.onBackdropClick, s = t6.onBreakPoint, o = t6.width, l = o === void 0 ? "250px" : o, c = t6.collapsedWidth, d = c === void 0 ? "80px" : c, u = t6.defaultCollapsed, f = t6.className, h = t6.children, g = t6.breakPoint, m = t6.customBreakPoint, p = t6.backgroundColor, w = p === void 0 ? "rgb(249, 249, 249, 0.7)" : p, b = t6.transitionDuration, k = b === void 0 ? 300 : b, v = t6.image, x = t6.rtl, _ = t6.rootStyles, T = Tn(t6, ["collapsed", "toggled", "onBackdropClick", "onBreakPoint", "width", "collapsedWidth", "defaultCollapsed", "className", "children", "breakPoint", "customBreakPoint", "backgroundColor", "transitionDuration", "image", "rtl", "rootStyles"]), S = function() {
    if (m)
      return "(max-width: ".concat(m, ")");
    if (g)
      return ["xs", "sm", "md", "lg", "xl", "xxl"].includes(g) ? "(max-width: ".concat(Vk[g], ")") : g === "always" || g === "all" ? (g === "always" && console.warn('The "always" breakPoint is deprecated and will be removed in future release. Please use the "all" breakPoint instead.'), "screen") : "(max-width: ".concat(g, ")");
  }, C = React$1.useRef();
  C.current = function(U) {
    s == null || s(U);
  };
  var D = Bk(S()), z = React$1.useState(false), A = z[0], L = z[1], M = Hk(), I = n ?? (!A && u ? true : M == null ? void 0 : M.collapsed), W = a ?? (M == null ? void 0 : M.toggled), B = function() {
    i == null || i(), M == null || M.updateSidebarState({ toggled: false });
  };
  return React$1.useEffect(function() {
    var U;
    (U = C.current) === null || U === void 0 || U.call(C, D);
  }, [D]), React$1.useEffect(function() {
    M == null || M.updateSidebarState({ broken: D, rtl: x, transitionDuration: k });
  }, [D, M == null ? void 0 : M.updateSidebarState, x, k]), React$1.useEffect(function() {
    A || (M == null || M.updateSidebarState({
      collapsed: u
    }), L(true));
  }, [u, A, M == null ? void 0 : M.updateSidebarState]), React$1.createElement(
    go.Provider,
    { value: { collapsed: I, toggled: W, rtl: x, transitionDuration: k } },
    React$1.createElement(
      qk,
      At({ ref: e, "data-testid": "".concat(He.root, "-test-id"), rtl: x, rootStyles: _, width: l, collapsedWidth: d, transitionDuration: k, className: et(He.root, (r = {}, r[He.collapsed] = I, r[He.toggled] = W, r[He.broken] = D, r[He.rtl] = x, r), f) }, T),
      React$1.createElement(Uk, { "data-testid": "".concat(He.container, "-test-id"), className: He.container, backgroundColor: w }, h),
      v && React$1.createElement(Xk, { "data-testid": "".concat(He.image, "-test-id"), src: v, alt: "sidebar background", className: He.image }),
      D && W && React$1.createElement(Yk, { "data-testid": "".concat(He.backdrop, "-test-id"), role: "button", tabIndex: 0, "aria-label": "backdrop", onClick: B, onKeyPress: B, className: He.backdrop })
    )
  );
}); var yf, vf, xf, Xg = it.ul(wf || (wf = pt([`
  list-style-type: none;
  padding: 0;
  margin: 0;
`], [`
  list-style-type: none;
  padding: 0;
  margin: 0;
`]))), wf, Kk = it.nav(kf || (kf = pt([`
  &.`, ` {
    `, `
  }
`], [`
  &.`, ` {
    `, `
  }
`])), ye.root, function(t6) {
  var e = t6.rootStyles;
  return e;
}), Gg = React$1.createContext(void 0), Ns = React$1.createContext(0), Qk = function(t6, e) {
  var r = t6.children, n = t6.className, a = t6.transitionDuration, i = a === void 0 ? 300 : a, s = t6.closeOnClick, o = s === void 0 ? false : s, l = t6.rootStyles, c = t6.menuItemStyles, d = t6.renderExpandIcon, u = Tn(t6, ["children", "className", "transitionDuration", "closeOnClick", "rootStyles", "menuItemStyles", "renderExpandIcon"]), f = React$1.useMemo(function() {
    return { transitionDuration: i, closeOnClick: o, menuItemStyles: c, renderExpandIcon: d };
  }, [i, o, c, d]);
  return React$1.createElement(
    Gg.Provider,
    { value: f },
    React$1.createElement(
      Ns.Provider,
      { value: 0 },
      React$1.createElement(
        Kk,
        At({ ref: e, className: et(ye.root, n), rootStyles: l }, u),
        React$1.createElement(Xg, null, r)
      )
    )
  );
}; React$1.forwardRef(Qk); var kf, Mc = function() {
  var t6 = React$1.useContext(Gg);
  if (t6 === void 0)
    throw new Error("Menu Component is required!");
  return t6;
}, Zk = it.div(_f || (_f = pt([`
  height: 0px;
  overflow: hidden;
  z-index: 999;
  transition: height `, `ms;
  box-sizing: border-box;
  background-color: white;

  `, `

  `, `

  `, `;

  `, `;
`], [`
  height: 0px;
  overflow: hidden;
  z-index: 999;
  transition: height `, `ms;
  box-sizing: border-box;
  background-color: white;

  `, `

  `, `

  `, `;

  `, `;
`])), function(t6) {
  var e = t6.transitionDuration;
  return e;
}, function(t6) {
  var e = t6.firstLevel, r = t6.collapsed;
  return e && r && `
     background-color: white;
     box-shadow: 0 3px 6px -4px #0000001f, 0 6px 16px #00000014, 0 9px 28px 8px #0000000d;
     `;
}, function(t6) {
  var e = t6.defaultOpen;
  return e && "height: auto;display: block;";
}, function(t6) {
  var e = t6.collapsed, r = t6.firstLevel, n = t6.openWhenCollapsed;
  return e && r ? `
      position: fixed;
      padding-left: 0px;
      width: 200px;
      border-radius: 4px;
      height: auto!important;
      display: block!important;     
      transition: none!important;     
      visibility: `.concat(n ? "visible" : "hidden", `;
     `) : `
      position: static!important;
      transform: none!important;
      `;
}, function(t6) {
  var e = t6.rootStyles;
  return e;
}), e_ = function(t6, e) {
  var r = t6.children, n = t6.open, a = t6.openWhenCollapsed, i = t6.firstLevel, s = t6.collapsed, o = t6.defaultOpen, l = Tn(t6, ["children", "open", "openWhenCollapsed", "firstLevel", "collapsed", "defaultOpen"]), c = Mc().transitionDuration, d = React$1.useState(o)[0];
  return React$1.createElement(
    Zk,
    At({ "data-testid": "".concat(ye.subMenuContent, "-test-id"), ref: e, firstLevel: i, collapsed: s, open: n, openWhenCollapsed: a, transitionDuration: c, defaultOpen: d }, l),
    React$1.createElement(Xg, null, r)
  );
}, t_ = React$1.forwardRef(e_), _f, Kg = it.span(Of || (Of = pt([`
  flex-grow: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;

  `, `;
`], [`
  flex-grow: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;

  `, `;
`])), function(t6) {
  var e = t6.rootStyles;
  return e;
}), Of, Qg = it.span(Sf || (Sf = pt([`
  width: 35px;
  min-width: 35px;
  height: 35px;
  line-height: 35px;
  text-align: center;
  display: inline-block;
  border-radius: 2px;
  display: flex;
  align-items: center;
  justify-content: center;

  `, `

  `, `;
`], [`
  width: 35px;
  min-width: 35px;
  height: 35px;
  line-height: 35px;
  text-align: center;
  display: inline-block;
  border-radius: 2px;
  display: flex;
  align-items: center;
  justify-content: center;

  `, `

  `, `;
`])), function(t6) {
  var e = t6.rtl;
  return e ? "margin-left: 10px;" : "margin-right: 10px;";
}, function(t6) {
  var e = t6.rootStyles;
  return e;
}), Sf, Jg = it.span(Df || (Df = pt([`
  `, `
  opacity: `, `;
  transition: opacity `, `ms;

  `, `;
`], [`
  `, `
  opacity: `, `;
  transition: opacity `, `ms;

  `, `;
`])), function(t6) {
  var e = t6.rtl;
  return e ? "margin-left: 5px;" : "margin-right: 5px;";
}, function(t6) {
  var e = t6.firstLevel, r = t6.collapsed;
  return e && r ? "0" : "1";
}, function(t6) {
  var e = t6.transitionDuration;
  return e;
}, function(t6) {
  var e = t6.rootStyles;
  return e;
}), Df, Zg = it.span(Mf || (Mf = pt([`
  margin-right: 5px;
  margin-left: 5px;
  opacity: `, `;
  transition: opacity `, `ms;

  `, `;
`], [`
  margin-right: 5px;
  margin-left: 5px;
  opacity: `, `;
  transition: opacity `, `ms;

  `, `;
`])), function(t6) {
  var e = t6.firstLevel, r = t6.collapsed;
  return e && r ? "0" : "1";
}, function(t6) {
  var e = t6.transitionDuration;
  return e;
}, function(t6) {
  var e = t6.rootStyles;
  return e;
}), Mf, r_ = it.span(Cf || (Cf = pt([`
  `, `

  `, `;
`], [`
  `, `

  `, `;
`])), function(t6) {
  var e = t6.collapsed, r = t6.level, n = t6.rtl;
  return e && r === 0 && `
    position: absolute;
    `.concat(n ? "left: 10px;" : "right: 10px;", `
    top: 50%;
    transform: translateY(-50%);
    
    `);
}, function(t6) {
  var e = t6.rootStyles;
  return e;
}), n_ = it.span(Ef || (Ef = pt([`
  display: inline-block;
  transition: transform 0.3s;
  `, `

  width: 5px;
  height: 5px;
  transform: rotate(`, `);
`], [`
  display: inline-block;
  transition: transform 0.3s;
  `, `

  width: 5px;
  height: 5px;
  transform: rotate(`, `);
`])), function(t6) {
  var e = t6.rtl;
  return e ? `
          border-left: 2px solid currentcolor;
          border-top: 2px solid currentcolor;
        ` : ` border-right: 2px solid currentcolor;
          border-bottom: 2px solid currentcolor;
        `;
}, function(t6) {
  var e = t6.open, r = t6.rtl;
  return e ? r ? "-135deg" : "45deg" : "-45deg";
}), a_ = it.span(Tf || (Tf = pt([`
  width: 5px;
  height: 5px;
  background-color: currentcolor;
  border-radius: 50%;
  display: inline-block;
`], [`
  width: 5px;
  height: 5px;
  background-color: currentcolor;
  border-radius: 50%;
  display: inline-block;
`]))), Cf, Ef, Tf, Ot = "top", Ht = "bottom", Bt = "right", St = "left", mo = "auto", bi = [Ot, Ht, Bt, St], aa = "start", ci = "end", i_ = "clippingParents", e0 = "viewport", Ma = "popper", s_ = "reference", Pf = /* @__PURE__ */ bi.reduce(function(t6, e) {
  return t6.concat([e + "-" + aa, e + "-" + ci]);
}, []), t0 = /* @__PURE__ */ [].concat(bi, [mo]).reduce(function(t6, e) {
  return t6.concat([e, e + "-" + aa, e + "-" + ci]);
}, []), o_ = "beforeRead", l_ = "read", c_ = "afterRead", d_ = "beforeMain", u_ = "main", f_ = "afterMain", h_ = "beforeWrite", g_ = "write", m_ = "afterWrite", Ll = [o_, l_, c_, d_, u_, f_, h_, g_, m_];
function yr(t6) {
  return t6 ? (t6.nodeName || "").toLowerCase() : null;
}
function Vt(t6) {
  if (t6 == null)
    return window;
  if (t6.toString() !== "[object Window]") {
    var e = t6.ownerDocument;
    return e && e.defaultView || window;
  }
  return t6;
}
function Pn(t6) {
  var e = Vt(t6).Element;
  return t6 instanceof e || t6 instanceof Element;
}
function Lt(t6) {
  var e = Vt(t6).HTMLElement;
  return t6 instanceof e || t6 instanceof HTMLElement;
}
function Cc(t6) {
  if (typeof ShadowRoot > "u")
    return false;
  var e = Vt(t6).ShadowRoot;
  return t6 instanceof e || t6 instanceof ShadowRoot;
}
function p_(t6) {
  var e = t6.state;
  Object.keys(e.elements).forEach(function(r) {
    var n = e.styles[r] || {}, a = e.attributes[r] || {}, i = e.elements[r];
    !Lt(i) || !yr(i) || (Object.assign(i.style, n), Object.keys(a).forEach(function(s) {
      var o = a[s];
      o === false ? i.removeAttribute(s) : i.setAttribute(s, o === true ? "" : o);
    }));
  });
}
function b_(t6) {
  var e = t6.state, r = {
    popper: {
      position: e.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(e.elements.popper.style, r.popper), e.styles = r, e.elements.arrow && Object.assign(e.elements.arrow.style, r.arrow), function() {
    Object.keys(e.elements).forEach(function(n) {
      var a = e.elements[n], i = e.attributes[n] || {}, s = Object.keys(e.styles.hasOwnProperty(n) ? e.styles[n] : r[n]), o = s.reduce(function(l, c) {
        return l[c] = "", l;
      }, {});
      !Lt(a) || !yr(a) || (Object.assign(a.style, o), Object.keys(i).forEach(function(l) {
        a.removeAttribute(l);
      }));
    });
  };
}
var y_ = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: p_,
  effect: b_,
  requires: ["computeStyles"]
};
function Xt(t6) {
  return t6.split("-")[0];
}
var Sn = Math.max, Is = Math.min, ia = Math.round;
function Wl() {
  var t6 = navigator.userAgentData;
  return t6 != null && t6.brands ? t6.brands.map(function(e) {
    return e.brand + "/" + e.version;
  }).join(" ") : navigator.userAgent;
}
function r0() {
  return !/^((?!chrome|android).)*safari/i.test(Wl());
}
function sa(t6, e, r) {
  e === void 0 && (e = false), r === void 0 && (r = false);
  var n = t6.getBoundingClientRect(), a = 1, i = 1;
  e && Lt(t6) && (a = t6.offsetWidth > 0 && ia(n.width) / t6.offsetWidth || 1, i = t6.offsetHeight > 0 && ia(n.height) / t6.offsetHeight || 1);
  var s = Pn(t6) ? Vt(t6) : window, o = s.visualViewport, l = !r0() && r, c = (n.left + (l && o ? o.offsetLeft : 0)) / a, d = (n.top + (l && o ? o.offsetTop : 0)) / i, u = n.width / a, f = n.height / i;
  return {
    width: u,
    height: f,
    top: d,
    right: c + u,
    bottom: d + f,
    left: c,
    x: c,
    y: d
  };
}
function Ec(t6) {
  var e = sa(t6), r = t6.offsetWidth, n = t6.offsetHeight;
  return Math.abs(e.width - r) <= 1 && (r = e.width), Math.abs(e.height - n) <= 1 && (n = e.height), {
    x: t6.offsetLeft,
    y: t6.offsetTop,
    width: r,
    height: n
  };
}
function n0(t6, e) {
  var r = e.getRootNode && e.getRootNode();
  if (t6.contains(e))
    return true;
  if (r && Cc(r)) {
    var n = e;
    do {
      if (n && t6.isSameNode(n))
        return true;
      n = n.parentNode || n.host;
    } while (n);
  }
  return false;
}
function Qt(t6) {
  return Vt(t6).getComputedStyle(t6);
}
function v_(t6) {
  return ["table", "td", "th"].indexOf(yr(t6)) >= 0;
}
function Zr(t6) {
  return ((Pn(t6) ? t6.ownerDocument : (
    // $FlowFixMe[prop-missing]
    t6.document
  )) || window.document).documentElement;
}
function po(t6) {
  return yr(t6) === "html" ? t6 : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    t6.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    t6.parentNode || // DOM Element detected
    (Cc(t6) ? t6.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    Zr(t6)
  );
}
function Rf(t6) {
  return !Lt(t6) || // https://github.com/popperjs/popper-core/issues/837
  Qt(t6).position === "fixed" ? null : t6.offsetParent;
}
function x_(t6) {
  var e = /firefox/i.test(Wl()), r = /Trident/i.test(Wl());
  if (r && Lt(t6)) {
    var n = Qt(t6);
    if (n.position === "fixed")
      return null;
  }
  var a = po(t6);
  for (Cc(a) && (a = a.host); Lt(a) && ["html", "body"].indexOf(yr(a)) < 0; ) {
    var i = Qt(a);
    if (i.transform !== "none" || i.perspective !== "none" || i.contain === "paint" || ["transform", "perspective"].indexOf(i.willChange) !== -1 || e && i.willChange === "filter" || e && i.filter && i.filter !== "none")
      return a;
    a = a.parentNode;
  }
  return null;
}
function yi(t6) {
  for (var e = Vt(t6), r = Rf(t6); r && v_(r) && Qt(r).position === "static"; )
    r = Rf(r);
  return r && (yr(r) === "html" || yr(r) === "body" && Qt(r).position === "static") ? e : r || x_(t6) || e;
}
function Tc(t6) {
  return ["top", "bottom"].indexOf(t6) >= 0 ? "x" : "y";
}
function Xa(t6, e, r) {
  return Sn(t6, Is(e, r));
}
function w_(t6, e, r) {
  var n = Xa(t6, e, r);
  return n > r ? r : n;
}
function a0() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function i0(t6) {
  return Object.assign({}, a0(), t6);
}
function s0(t6, e) {
  return e.reduce(function(r, n) {
    return r[n] = t6, r;
  }, {});
}
var k_ = function(e, r) {
  return e = typeof e == "function" ? e(Object.assign({}, r.rects, {
    placement: r.placement
  })) : e, i0(typeof e != "number" ? e : s0(e, bi));
};
function __(t6) {
  var e, r = t6.state, n = t6.name, a = t6.options, i = r.elements.arrow, s = r.modifiersData.popperOffsets, o = Xt(r.placement), l = Tc(o), c = [St, Bt].indexOf(o) >= 0, d = c ? "height" : "width";
  if (!(!i || !s)) {
    var u = k_(a.padding, r), f = Ec(i), h = l === "y" ? Ot : St, g = l === "y" ? Ht : Bt, m = r.rects.reference[d] + r.rects.reference[l] - s[l] - r.rects.popper[d], p = s[l] - r.rects.reference[l], w = yi(i), b = w ? l === "y" ? w.clientHeight || 0 : w.clientWidth || 0 : 0, k = m / 2 - p / 2, v = u[h], x = b - f[d] - u[g], _ = b / 2 - f[d] / 2 + k, T = Xa(v, _, x), S = l;
    r.modifiersData[n] = (e = {}, e[S] = T, e.centerOffset = T - _, e);
  }
}
function O_(t6) {
  var e = t6.state, r = t6.options, n = r.element, a = n === void 0 ? "[data-popper-arrow]" : n;
  if (a != null && !(typeof a == "string" && (a = e.elements.popper.querySelector(a), !a))) {
    if (!n0(e.elements.popper, a)) {
      return;
    }
    e.elements.arrow = a;
  }
}
var S_ = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: __,
  effect: O_,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function oa(t6) {
  return t6.split("-")[1];
}
var D_ = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function M_(t6) {
  var e = t6.x, r = t6.y, n = window, a = n.devicePixelRatio || 1;
  return {
    x: ia(e * a) / a || 0,
    y: ia(r * a) / a || 0
  };
}
function Nf(t6) {
  var e, r = t6.popper, n = t6.popperRect, a = t6.placement, i = t6.variation, s = t6.offsets, o = t6.position, l = t6.gpuAcceleration, c = t6.adaptive, d = t6.roundOffsets, u = t6.isFixed, f = s.x, h = f === void 0 ? 0 : f, g = s.y, m = g === void 0 ? 0 : g, p = typeof d == "function" ? d({
    x: h,
    y: m
  }) : {
    x: h,
    y: m
  };
  h = p.x, m = p.y;
  var w = s.hasOwnProperty("x"), b = s.hasOwnProperty("y"), k = St, v = Ot, x = window;
  if (c) {
    var _ = yi(r), T = "clientHeight", S = "clientWidth";
    if (_ === Vt(r) && (_ = Zr(r), Qt(_).position !== "static" && o === "absolute" && (T = "scrollHeight", S = "scrollWidth")), _ = _, a === Ot || (a === St || a === Bt) && i === ci) {
      v = Ht;
      var C = u && _ === x && x.visualViewport ? x.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        _[T]
      );
      m -= C - n.height, m *= l ? 1 : -1;
    }
    if (a === St || (a === Ot || a === Ht) && i === ci) {
      k = Bt;
      var D = u && _ === x && x.visualViewport ? x.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        _[S]
      );
      h -= D - n.width, h *= l ? 1 : -1;
    }
  }
  var z = Object.assign({
    position: o
  }, c && D_), A = d === true ? M_({
    x: h,
    y: m
  }) : {
    x: h,
    y: m
  };
  if (h = A.x, m = A.y, l) {
    var L;
    return Object.assign({}, z, (L = {}, L[v] = b ? "0" : "", L[k] = w ? "0" : "", L.transform = (x.devicePixelRatio || 1) <= 1 ? "translate(" + h + "px, " + m + "px)" : "translate3d(" + h + "px, " + m + "px, 0)", L));
  }
  return Object.assign({}, z, (e = {}, e[v] = b ? m + "px" : "", e[k] = w ? h + "px" : "", e.transform = "", e));
}
function C_(t6) {
  var e = t6.state, r = t6.options, n = r.gpuAcceleration, a = n === void 0 ? true : n, i = r.adaptive, s = i === void 0 ? true : i, o = r.roundOffsets, l = o === void 0 ? true : o;
  var d = {
    placement: Xt(e.placement),
    variation: oa(e.placement),
    popper: e.elements.popper,
    popperRect: e.rects.popper,
    gpuAcceleration: a,
    isFixed: e.options.strategy === "fixed"
  };
  e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, Nf(Object.assign({}, d, {
    offsets: e.modifiersData.popperOffsets,
    position: e.options.strategy,
    adaptive: s,
    roundOffsets: l
  })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, Nf(Object.assign({}, d, {
    offsets: e.modifiersData.arrow,
    position: "absolute",
    adaptive: false,
    roundOffsets: l
  })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-placement": e.placement
  });
}
var E_ = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: C_,
  data: {}
}, Ui = {
  passive: true
};
function T_(t6) {
  var e = t6.state, r = t6.instance, n = t6.options, a = n.scroll, i = a === void 0 ? true : a, s = n.resize, o = s === void 0 ? true : s, l = Vt(e.elements.popper), c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return i && c.forEach(function(d) {
    d.addEventListener("scroll", r.update, Ui);
  }), o && l.addEventListener("resize", r.update, Ui), function() {
    i && c.forEach(function(d) {
      d.removeEventListener("scroll", r.update, Ui);
    }), o && l.removeEventListener("resize", r.update, Ui);
  };
}
var P_ = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function() {
  },
  effect: T_,
  data: {}
}, R_ = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function fs(t6) {
  return t6.replace(/left|right|bottom|top/g, function(e) {
    return R_[e];
  });
}
var N_ = {
  start: "end",
  end: "start"
};
function If(t6) {
  return t6.replace(/start|end/g, function(e) {
    return N_[e];
  });
}
function Pc(t6) {
  var e = Vt(t6), r = e.pageXOffset, n = e.pageYOffset;
  return {
    scrollLeft: r,
    scrollTop: n
  };
}
function Rc(t6) {
  return sa(Zr(t6)).left + Pc(t6).scrollLeft;
}
function I_(t6, e) {
  var r = Vt(t6), n = Zr(t6), a = r.visualViewport, i = n.clientWidth, s = n.clientHeight, o = 0, l = 0;
  if (a) {
    i = a.width, s = a.height;
    var c = r0();
    (c || !c && e === "fixed") && (o = a.offsetLeft, l = a.offsetTop);
  }
  return {
    width: i,
    height: s,
    x: o + Rc(t6),
    y: l
  };
}
function A_(t6) {
  var e, r = Zr(t6), n = Pc(t6), a = (e = t6.ownerDocument) == null ? void 0 : e.body, i = Sn(r.scrollWidth, r.clientWidth, a ? a.scrollWidth : 0, a ? a.clientWidth : 0), s = Sn(r.scrollHeight, r.clientHeight, a ? a.scrollHeight : 0, a ? a.clientHeight : 0), o = -n.scrollLeft + Rc(t6), l = -n.scrollTop;
  return Qt(a || r).direction === "rtl" && (o += Sn(r.clientWidth, a ? a.clientWidth : 0) - i), {
    width: i,
    height: s,
    x: o,
    y: l
  };
}
function Nc(t6) {
  var e = Qt(t6), r = e.overflow, n = e.overflowX, a = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(r + a + n);
}
function o0(t6) {
  return ["html", "body", "#document"].indexOf(yr(t6)) >= 0 ? t6.ownerDocument.body : Lt(t6) && Nc(t6) ? t6 : o0(po(t6));
}
function Ga(t6, e) {
  var r;
  e === void 0 && (e = []);
  var n = o0(t6), a = n === ((r = t6.ownerDocument) == null ? void 0 : r.body), i = Vt(n), s = a ? [i].concat(i.visualViewport || [], Nc(n) ? n : []) : n, o = e.concat(s);
  return a ? o : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    o.concat(Ga(po(s)))
  );
}
function $l(t6) {
  return Object.assign({}, t6, {
    left: t6.x,
    top: t6.y,
    right: t6.x + t6.width,
    bottom: t6.y + t6.height
  });
}
function F_(t6, e) {
  var r = sa(t6, false, e === "fixed");
  return r.top = r.top + t6.clientTop, r.left = r.left + t6.clientLeft, r.bottom = r.top + t6.clientHeight, r.right = r.left + t6.clientWidth, r.width = t6.clientWidth, r.height = t6.clientHeight, r.x = r.left, r.y = r.top, r;
}
function Af(t6, e, r) {
  return e === e0 ? $l(I_(t6, r)) : Pn(e) ? F_(e, r) : $l(A_(Zr(t6)));
}
function L_(t6) {
  var e = Ga(po(t6)), r = ["absolute", "fixed"].indexOf(Qt(t6).position) >= 0, n = r && Lt(t6) ? yi(t6) : t6;
  return Pn(n) ? e.filter(function(a) {
    return Pn(a) && n0(a, n) && yr(a) !== "body";
  }) : [];
}
function W_(t6, e, r, n) {
  var a = e === "clippingParents" ? L_(t6) : [].concat(e), i = [].concat(a, [r]), s = i[0], o = i.reduce(function(l, c) {
    var d = Af(t6, c, n);
    return l.top = Sn(d.top, l.top), l.right = Is(d.right, l.right), l.bottom = Is(d.bottom, l.bottom), l.left = Sn(d.left, l.left), l;
  }, Af(t6, s, n));
  return o.width = o.right - o.left, o.height = o.bottom - o.top, o.x = o.left, o.y = o.top, o;
}
function l0(t6) {
  var e = t6.reference, r = t6.element, n = t6.placement, a = n ? Xt(n) : null, i = n ? oa(n) : null, s = e.x + e.width / 2 - r.width / 2, o = e.y + e.height / 2 - r.height / 2, l;
  switch (a) {
    case Ot:
      l = {
        x: s,
        y: e.y - r.height
      };
      break;
    case Ht:
      l = {
        x: s,
        y: e.y + e.height
      };
      break;
    case Bt:
      l = {
        x: e.x + e.width,
        y: o
      };
      break;
    case St:
      l = {
        x: e.x - r.width,
        y: o
      };
      break;
    default:
      l = {
        x: e.x,
        y: e.y
      };
  }
  var c = a ? Tc(a) : null;
  if (c != null) {
    var d = c === "y" ? "height" : "width";
    switch (i) {
      case aa:
        l[c] = l[c] - (e[d] / 2 - r[d] / 2);
        break;
      case ci:
        l[c] = l[c] + (e[d] / 2 - r[d] / 2);
        break;
    }
  }
  return l;
}
function di(t6, e) {
  e === void 0 && (e = {});
  var r = e, n = r.placement, a = n === void 0 ? t6.placement : n, i = r.strategy, s = i === void 0 ? t6.strategy : i, o = r.boundary, l = o === void 0 ? i_ : o, c = r.rootBoundary, d = c === void 0 ? e0 : c, u = r.elementContext, f = u === void 0 ? Ma : u, h = r.altBoundary, g = h === void 0 ? false : h, m = r.padding, p = m === void 0 ? 0 : m, w = i0(typeof p != "number" ? p : s0(p, bi)), b = f === Ma ? s_ : Ma, k = t6.rects.popper, v = t6.elements[g ? b : f], x = W_(Pn(v) ? v : v.contextElement || Zr(t6.elements.popper), l, d, s), _ = sa(t6.elements.reference), T = l0({
    reference: _,
    element: k,
    placement: a
  }), S = $l(Object.assign({}, k, T)), C = f === Ma ? S : _, D = {
    top: x.top - C.top + w.top,
    bottom: C.bottom - x.bottom + w.bottom,
    left: x.left - C.left + w.left,
    right: C.right - x.right + w.right
  }, z = t6.modifiersData.offset;
  if (f === Ma && z) {
    var A = z[a];
    Object.keys(D).forEach(function(L) {
      var M = [Bt, Ht].indexOf(L) >= 0 ? 1 : -1, I = [Ot, Ht].indexOf(L) >= 0 ? "y" : "x";
      D[L] += A[I] * M;
    });
  }
  return D;
}
function $_(t6, e) {
  e === void 0 && (e = {});
  var r = e, n = r.placement, a = r.boundary, i = r.rootBoundary, s = r.padding, o = r.flipVariations, l = r.allowedAutoPlacements, c = l === void 0 ? t0 : l, d = oa(n), u = d ? o ? Pf : Pf.filter(function(g) {
    return oa(g) === d;
  }) : bi, f = u.filter(function(g) {
    return c.indexOf(g) >= 0;
  });
  f.length === 0 && (f = u, false);
  var h = f.reduce(function(g, m) {
    return g[m] = di(t6, {
      placement: m,
      boundary: a,
      rootBoundary: i,
      padding: s
    })[Xt(m)], g;
  }, {});
  return Object.keys(h).sort(function(g, m) {
    return h[g] - h[m];
  });
}
function z_(t6) {
  if (Xt(t6) === mo)
    return [];
  var e = fs(t6);
  return [If(t6), e, If(e)];
}
function j_(t6) {
  var e = t6.state, r = t6.options, n = t6.name;
  if (!e.modifiersData[n]._skip) {
    for (var a = r.mainAxis, i = a === void 0 ? true : a, s = r.altAxis, o = s === void 0 ? true : s, l = r.fallbackPlacements, c = r.padding, d = r.boundary, u = r.rootBoundary, f = r.altBoundary, h = r.flipVariations, g = h === void 0 ? true : h, m = r.allowedAutoPlacements, p = e.options.placement, w = Xt(p), b = w === p, k = l || (b || !g ? [fs(p)] : z_(p)), v = [p].concat(k).reduce(function(P, O) {
      return P.concat(Xt(O) === mo ? $_(e, {
        placement: O,
        boundary: d,
        rootBoundary: u,
        padding: c,
        flipVariations: g,
        allowedAutoPlacements: m
      }) : O);
    }, []), x = e.rects.reference, _ = e.rects.popper, T = /* @__PURE__ */ new Map(), S = true, C = v[0], D = 0; D < v.length; D++) {
      var z = v[D], A = Xt(z), L = oa(z) === aa, M = [Ot, Ht].indexOf(A) >= 0, I = M ? "width" : "height", W = di(e, {
        placement: z,
        boundary: d,
        rootBoundary: u,
        altBoundary: f,
        padding: c
      }), B = M ? L ? Bt : St : L ? Ht : Ot;
      x[I] > _[I] && (B = fs(B));
      var U = fs(B), J = [];
      if (i && J.push(W[A] <= 0), o && J.push(W[B] <= 0, W[U] <= 0), J.every(function(P) {
        return P;
      })) {
        C = z, S = false;
        break;
      }
      T.set(z, J);
    }
    if (S)
      for (var E = g ? 3 : 1, j = function(O) {
        var F = v.find(function(X) {
          var q = T.get(X);
          if (q)
            return q.slice(0, O).every(function(G) {
              return G;
            });
        });
        if (F)
          return C = F, "break";
      }, N = E; N > 0; N--) {
        var R = j(N);
        if (R === "break") break;
      }
    e.placement !== C && (e.modifiersData[n]._skip = true, e.placement = C, e.reset = true);
  }
}
var H_ = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: j_,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function Ff(t6, e, r) {
  return r === void 0 && (r = {
    x: 0,
    y: 0
  }), {
    top: t6.top - e.height - r.y,
    right: t6.right - e.width + r.x,
    bottom: t6.bottom - e.height + r.y,
    left: t6.left - e.width - r.x
  };
}
function Lf(t6) {
  return [Ot, Bt, Ht, St].some(function(e) {
    return t6[e] >= 0;
  });
}
function B_(t6) {
  var e = t6.state, r = t6.name, n = e.rects.reference, a = e.rects.popper, i = e.modifiersData.preventOverflow, s = di(e, {
    elementContext: "reference"
  }), o = di(e, {
    altBoundary: true
  }), l = Ff(s, n), c = Ff(o, a, i), d = Lf(l), u = Lf(c);
  e.modifiersData[r] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: c,
    isReferenceHidden: d,
    hasPopperEscaped: u
  }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-reference-hidden": d,
    "data-popper-escaped": u
  });
}
var Y_ = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: B_
};
function V_(t6, e, r) {
  var n = Xt(t6), a = [St, Ot].indexOf(n) >= 0 ? -1 : 1, i = typeof r == "function" ? r(Object.assign({}, e, {
    placement: t6
  })) : r, s = i[0], o = i[1];
  return s = s || 0, o = (o || 0) * a, [St, Bt].indexOf(n) >= 0 ? {
    x: o,
    y: s
  } : {
    x: s,
    y: o
  };
}
function q_(t6) {
  var e = t6.state, r = t6.options, n = t6.name, a = r.offset, i = a === void 0 ? [0, 0] : a, s = t0.reduce(function(d, u) {
    return d[u] = V_(u, e.rects, i), d;
  }, {}), o = s[e.placement], l = o.x, c = o.y;
  e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c), e.modifiersData[n] = s;
}
var U_ = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: q_
};
function X_(t6) {
  var e = t6.state, r = t6.name;
  e.modifiersData[r] = l0({
    reference: e.rects.reference,
    element: e.rects.popper,
    placement: e.placement
  });
}
var G_ = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: X_,
  data: {}
};
function K_(t6) {
  return t6 === "x" ? "y" : "x";
}
function Q_(t6) {
  var e = t6.state, r = t6.options, n = t6.name, a = r.mainAxis, i = a === void 0 ? true : a, s = r.altAxis, o = s === void 0 ? false : s, l = r.boundary, c = r.rootBoundary, d = r.altBoundary, u = r.padding, f = r.tether, h = f === void 0 ? true : f, g = r.tetherOffset, m = g === void 0 ? 0 : g, p = di(e, {
    boundary: l,
    rootBoundary: c,
    padding: u,
    altBoundary: d
  }), w = Xt(e.placement), b = oa(e.placement), k = !b, v = Tc(w), x = K_(v), _ = e.modifiersData.popperOffsets, T = e.rects.reference, S = e.rects.popper, C = typeof m == "function" ? m(Object.assign({}, e.rects, {
    placement: e.placement
  })) : m, D = typeof C == "number" ? {
    mainAxis: C,
    altAxis: C
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, C), z = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, A = {
    x: 0,
    y: 0
  };
  if (_) {
    if (i) {
      var L, M = v === "y" ? Ot : St, I = v === "y" ? Ht : Bt, W = v === "y" ? "height" : "width", B = _[v], U = B + p[M], J = B - p[I], E = h ? -S[W] / 2 : 0, j = b === aa ? T[W] : S[W], N = b === aa ? -S[W] : -T[W], R = e.elements.arrow, P = h && R ? Ec(R) : {
        width: 0,
        height: 0
      }, O = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : a0(), F = O[M], X = O[I], q = Xa(0, T[W], P[W]), G = k ? T[W] / 2 - E - q - F - D.mainAxis : j - q - F - D.mainAxis, Z = k ? -T[W] / 2 + E + q + X + D.mainAxis : N + q + X + D.mainAxis, ne = e.elements.arrow && yi(e.elements.arrow), H = ne ? v === "y" ? ne.clientTop || 0 : ne.clientLeft || 0 : 0, ae = (L = z == null ? void 0 : z[v]) != null ? L : 0, re = B + G - ae - H, le = B + Z - ae, fe = Xa(h ? Is(U, re) : U, B, h ? Sn(J, le) : J);
      _[v] = fe, A[v] = fe - B;
    }
    if (o) {
      var de, ie = v === "x" ? Ot : St, $e = v === "x" ? Ht : Bt, ge = _[x], Fe = x === "y" ? "height" : "width", je = ge + p[ie], Ye = ge - p[$e], Et = [Ot, St].indexOf(w) !== -1, Tt = (de = z == null ? void 0 : z[x]) != null ? de : 0, Pt = Et ? je : ge - T[Fe] - S[Fe] - Tt + D.altAxis, Wr = Et ? ge + T[Fe] + S[Fe] - Tt - D.altAxis : Ye, Rt = h && Et ? w_(Pt, ge, Wr) : Xa(h ? Pt : je, ge, h ? Wr : Ye);
      _[x] = Rt, A[x] = Rt - ge;
    }
    e.modifiersData[n] = A;
  }
}
var J_ = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: Q_,
  requiresIfExists: ["offset"]
};
function Z_(t6) {
  return {
    scrollLeft: t6.scrollLeft,
    scrollTop: t6.scrollTop
  };
}
function eO(t6) {
  return t6 === Vt(t6) || !Lt(t6) ? Pc(t6) : Z_(t6);
}
function tO(t6) {
  var e = t6.getBoundingClientRect(), r = ia(e.width) / t6.offsetWidth || 1, n = ia(e.height) / t6.offsetHeight || 1;
  return r !== 1 || n !== 1;
}
function rO(t6, e, r) {
  r === void 0 && (r = false);
  var n = Lt(e), a = Lt(e) && tO(e), i = Zr(e), s = sa(t6, a, r), o = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = {
    x: 0,
    y: 0
  };
  return (n || !n && !r) && ((yr(e) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  Nc(i)) && (o = eO(e)), Lt(e) ? (l = sa(e, true), l.x += e.clientLeft, l.y += e.clientTop) : i && (l.x = Rc(i))), {
    x: s.left + o.scrollLeft - l.x,
    y: s.top + o.scrollTop - l.y,
    width: s.width,
    height: s.height
  };
}
function nO(t6) {
  var e = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Set(), n = [];
  t6.forEach(function(i) {
    e.set(i.name, i);
  });
  function a(i) {
    r.add(i.name);
    var s = [].concat(i.requires || [], i.requiresIfExists || []);
    s.forEach(function(o) {
      if (!r.has(o)) {
        var l = e.get(o);
        l && a(l);
      }
    }), n.push(i);
  }
  return t6.forEach(function(i) {
    r.has(i.name) || a(i);
  }), n;
}
function aO(t6) {
  var e = nO(t6);
  return Ll.reduce(function(r, n) {
    return r.concat(e.filter(function(a) {
      return a.phase === n;
    }));
  }, []);
}
function iO(t6) {
  var e;
  return function() {
    return e || (e = new Promise(function(r) {
      Promise.resolve().then(function() {
        e = void 0, r(t6());
      });
    })), e;
  };
}
function cO(t6) {
  var e = t6.reduce(function(r, n) {
    var a = r[n.name];
    return r[n.name] = a ? Object.assign({}, a, n, {
      options: Object.assign({}, a.options, n.options),
      data: Object.assign({}, a.data, n.data)
    }) : n, r;
  }, {});
  return Object.keys(e).map(function(r) {
    return e[r];
  });
}
var zf = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function jf() {
  for (var t6 = arguments.length, e = new Array(t6), r = 0; r < t6; r++)
    e[r] = arguments[r];
  return !e.some(function(n) {
    return !(n && typeof n.getBoundingClientRect == "function");
  });
}
function uO(t6) {
  t6 === void 0 && (t6 = {});
  var e = t6, r = e.defaultModifiers, n = r === void 0 ? [] : r, a = e.defaultOptions, i = a === void 0 ? zf : a;
  return function(o, l, c) {
    c === void 0 && (c = i);
    var d = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, zf, i),
      modifiersData: {},
      elements: {
        reference: o,
        popper: l
      },
      attributes: {},
      styles: {}
    }, u = [], f = false, h = {
      state: d,
      setOptions: function(w) {
        var b = typeof w == "function" ? w(d.options) : w;
        m(), d.options = Object.assign({}, i, d.options, b), d.scrollParents = {
          reference: Pn(o) ? Ga(o) : o.contextElement ? Ga(o.contextElement) : [],
          popper: Ga(l)
        };
        var k = aO(cO([].concat(n, d.options.modifiers)));
        if (d.orderedModifiers = k.filter(function(z) {
          return z.enabled;
        }), false) ;
        return g(), h.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!f) {
          var w = d.elements, b = w.reference, k = w.popper;
          if (!jf(b, k)) {
            return;
          }
          d.rects = {
            reference: rO(b, yi(k), d.options.strategy === "fixed"),
            popper: Ec(k)
          }, d.reset = false, d.placement = d.options.placement, d.orderedModifiers.forEach(function(z) {
            return d.modifiersData[z.name] = Object.assign({}, z.data);
          });
          for (var v = 0, x = 0; x < d.orderedModifiers.length; x++) {
            if (d.reset === true) {
              d.reset = false, x = -1;
              continue;
            }
            var _ = d.orderedModifiers[x], T = _.fn, S = _.options, C = S === void 0 ? {} : S, D = _.name;
            typeof T == "function" && (d = T({
              state: d,
              options: C,
              name: D,
              instance: h
            }) || d);
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: iO(function() {
        return new Promise(function(p) {
          h.forceUpdate(), p(d);
        });
      }),
      destroy: function() {
        m(), f = true;
      }
    };
    if (!jf(o, l))
      return h;
    h.setOptions(c).then(function(p) {
      !f && c.onFirstUpdate && c.onFirstUpdate(p);
    });
    function g() {
      d.orderedModifiers.forEach(function(p) {
        var w = p.name, b = p.options, k = b === void 0 ? {} : b, v = p.effect;
        if (typeof v == "function") {
          var x = v({
            state: d,
            name: w,
            instance: h,
            options: k
          }), _ = function() {
          };
          u.push(x || _);
        }
      });
    }
    function m() {
      u.forEach(function(p) {
        return p();
      }), u = [];
    }
    return h;
  };
}
var fO = [P_, G_, E_, y_, U_, H_, J_, S_, Y_], hO = /* @__PURE__ */ uO({
  defaultModifiers: fO
}), gO = function(t6) {
  var e = t6.level, r = t6.buttonRef, n = t6.contentRef, a = React$1.useContext(go), i = a.collapsed, s = a.toggled, o = a.transitionDuration, l = React$1.useRef();
  return React$1.useEffect(function() {
    return e === 0 && i && n.current && r.current && (l.current = hO(r.current, n.current, {
      placement: "right",
      strategy: "fixed",
      modifiers: [
        {
          name: "offset",
          options: {
            offset: [0, 5]
          }
        }
      ]
    })), function() {
      var c;
      return (c = l.current) === null || c === void 0 ? void 0 : c.destroy();
    };
  }, [e, i, n, r]), React$1.useEffect(function() {
    if (n.current && r.current) {
      var c = new ResizeObserver(function() {
        var d;
        (d = l.current) === null || d === void 0 || d.update();
      });
      c.observe(n.current), c.observe(r.current);
    }
    setTimeout(function() {
      var d;
      (d = l.current) === null || d === void 0 || d.update();
    }, o);
  }, [o, s, n, r]), { popperInstance: l.current };
}, c0 = function(t6) {
  var e = t6.rtl, r = t6.level, n = t6.collapsed, a = t6.disabled, i = t6.active;
  return `
    display: flex;
    align-items: center;
    height: 50px;
    text-decoration: none;
    color: inherit;
    box-sizing: border-box;
    cursor: pointer;

    `.concat(e ? `padding-left: 20px;
           padding-right: `.concat(r === 0 ? 20 : (n ? r : r + 1) * 20, `px;
            `) : `padding-right: 20px;
           padding-left: `.concat(r === 0 ? 20 : (n ? r : r + 1) * 20, `px;
           `), `

    &:hover {
      background-color: #f3f3f3;
    }

    `).concat(a && ` 
      pointer-events: none;
      cursor: default;
      color:#adadad;
        `, `

    `).concat(i && "background-color: #e2eef9;", `
  
  `);
}, mO = function(t6, e) {
  var r = t6.className, n = t6.component, a = t6.children, i = Tn(t6, ["className", "component", "children"]);
  if (n) {
    if (typeof n == "string")
      return React$1.createElement(n, At(At({ className: et(r) }, i), { ref: e }), a);
    var s = n.props, o = s.className, l = Tn(s, ["className"]);
    return React$1.cloneElement(n, At(At(At({ className: et(r, o) }, i), l), { ref: e }), a);
  } else
    return React$1.createElement("a", At({ ref: e, className: et(r) }, i), a);
}, d0 = React$1.forwardRef(mO), pO = it.li(Hf || (Hf = pt([`
  position: relative;
  width: 100%;

  `, `;

  `, `;

  > .`, ` {
    `, `;

    `, `;
  }
`], [`
  position: relative;
  width: 100%;

  `, `;

  `, `;

  > .`, ` {
    `, `;

    `, `;
  }
`])), function(t6) {
  var e = t6.menuItemStyles;
  return e;
}, function(t6) {
  var e = t6.rootStyles;
  return e;
}, ye.button, function(t6) {
  var e = t6.level, r = t6.disabled, n = t6.active, a = t6.collapsed, i = t6.rtl;
  return c0({
    level: e,
    disabled: r,
    active: n,
    collapsed: a,
    rtl: i
  });
}, function(t6) {
  var e = t6.buttonStyles;
  return e;
}), bO = function(t6, e) {
  var r, n = t6.children, a = t6.className, i = t6.label, s = t6.icon, o = t6.title, l = t6.prefix, c = t6.suffix, d = t6.open, u = t6.defaultOpen, f = t6.active, h = f === void 0 ? false : f, g = t6.disabled, m = g === void 0 ? false : g, p = t6.rootStyles, w = t6.component, b = t6.onOpenChange, k = t6.onClick, v = t6.onKeyUp, x = Tn(t6, ["children", "className", "label", "icon", "title", "prefix", "suffix", "open", "defaultOpen", "active", "disabled", "rootStyles", "component", "onOpenChange", "onClick", "onKeyUp"]), _ = React$1.useContext(Ns), T = React$1.useContext(go), S = T.collapsed, C = T.rtl, D = T.transitionDuration, z = Mc(), A = z.renderExpandIcon, L = z.closeOnClick, M = z.menuItemStyles, I = z.transitionDuration, W = React$1.useState(!!u), B = W[0], U = W[1], J = React$1.useState(false), E = J[0], j = J[1], N = React$1.useState(false), R = N[0], P = N[1], O = React$1.useRef(null), F = React$1.useRef(null), X = React$1.useRef(), q = gO({
    level: _,
    buttonRef: O,
    contentRef: F
  }).popperInstance, G = React$1.useCallback(function() {
    var fe, de = F.current;
    if (de) {
      var ie = (fe = de == null ? void 0 : de.querySelector(".".concat(ye.subMenuContent, " > ul"))) === null || fe === void 0 ? void 0 : fe.clientHeight;
      de.style.overflow = "hidden", de.style.height = "".concat(ie, "px"), X.current = setTimeout(function() {
        de.style.overflow = "auto", de.style.height = "auto";
      }, I);
    }
  }, [I]), Z = function() {
    var fe, de = F.current;
    if (de) {
      var ie = (fe = de == null ? void 0 : de.querySelector(".".concat(ye.subMenuContent, " > ul"))) === null || fe === void 0 ? void 0 : fe.clientHeight;
      de.style.overflow = "hidden", de.style.height = "".concat(ie, "px"), de.offsetHeight, de.style.height = "0px";
    }
  }, ne = function() {
    _ === 0 && S || (typeof d > "u" ? (clearTimeout(Number(X.current)), B ? Z() : G(), b == null || b(!B), U(!B)) : b == null || b(!d));
  };
  React$1.useEffect(function() {
    !(_ === 0 && S) && typeof d < "u" && R && (clearTimeout(Number(X.current)), d ? G() : Z());
  }, [S, G, i, _, b, d]);
  var H = function(fe) {
    k == null || k(fe), ne();
  }, ae = function(fe) {
    v == null || v(fe), fe.key === "Enter" && ne();
  }, re = function(fe) {
    if (M) {
      var de = { level: _, disabled: m, active: h, isSubmenu: true, open: d ?? B }, ie = M.root, $e = M.button, ge = M.label, Fe = M.icon, je = M.prefix, Ye = M.suffix, Et = M.subMenuContent, Tt = M.SubMenuExpandIcon;
      switch (fe) {
        case "root":
          return typeof ie == "function" ? ie(de) : ie;
        case "button":
          return typeof $e == "function" ? $e(de) : $e;
        case "label":
          return typeof ge == "function" ? ge(de) : ge;
        case "icon":
          return typeof Fe == "function" ? Fe(de) : Fe;
        case "prefix":
          return typeof je == "function" ? je(de) : je;
        case "suffix":
          return typeof Ye == "function" ? Ye(de) : Ye;
        case "SubMenuExpandIcon":
          return typeof Tt == "function" ? Tt(de) : Tt;
        case "subMenuContent":
          return typeof Et == "function" ? Et(de) : Et;
        default:
          return;
      }
    }
  };
  React$1.useEffect(function() {
    setTimeout(function() {
      return q == null ? void 0 : q.update();
    }, D), S && _ === 0 && j(false);
  }, [S, _, C, D, q]), React$1.useEffect(function() {
    var fe = function(ge) {
      var Fe, je, Ye;
      !E && (!((Fe = O.current) === null || Fe === void 0) && Fe.contains(ge)) ? j(true) : (L && !(!((je = ge.closest(".".concat(ye.menuItemRoot))) === null || je === void 0) && je.classList.contains(ye.subMenuRoot)) || !(!((Ye = F.current) === null || Ye === void 0) && Ye.contains(ge)) && E) && j(false);
    }, de = function(ge) {
      fe(ge.target);
    }, ie = function(ge) {
      ge.key === "Enter" ? fe(ge.target) : ge.key === "Escape" && j(false);
    }, $e = function() {
      document.removeEventListener("click", de), document.removeEventListener("keyup", ie);
    };
    return $e(), S && _ === 0 && (document.addEventListener("click", de, false), document.addEventListener("keyup", ie, false)), function() {
      $e();
    };
  }, [S, _, L, E]), React$1.useEffect(function() {
    P(true);
  }, []);
  var le = (r = {}, r[ye.active] = h, r[ye.disabled] = m, r[ye.open] = d ?? B, r);
  return React$1.createElement(
    pO,
    { ref: e, className: et(ye.menuItemRoot, ye.subMenuRoot, le, a), menuItemStyles: re("root"), level: _, collapsed: S, rtl: C, disabled: m, active: h, buttonStyles: re("button"), rootStyles: p },
    React$1.createElement(
      d0,
      At({ "data-testid": "".concat(ye.button, "-test-id"), ref: O, title: o, className: et(ye.button, le), onClick: H, onKeyUp: ae, component: w, tabIndex: 0 }, x),
      s && React$1.createElement(Qg, { rtl: C, className: et(ye.icon, le), rootStyles: re("icon") }, s),
      l && React$1.createElement(Jg, { collapsed: S, transitionDuration: D, firstLevel: _ === 0, className: et(ye.prefix, le), rtl: C, rootStyles: re("prefix") }, l),
      React$1.createElement(Kg, { className: et(ye.label, le), rootStyles: re("label") }, i),
      c && React$1.createElement(Zg, { collapsed: S, transitionDuration: D, firstLevel: _ === 0, className: et(ye.suffix, le), rootStyles: re("suffix") }, c),
      React$1.createElement(r_, { rtl: C, className: et(ye.SubMenuExpandIcon, le), collapsed: S, level: _, rootStyles: re("SubMenuExpandIcon") }, A ? A({
        level: _,
        disabled: m,
        active: h,
        open: d ?? B
      }) : S && _ === 0 ? React$1.createElement(a_, null) : React$1.createElement(n_, { rtl: C, open: d ?? B }))
    ),
    React$1.createElement(
      t_,
      { ref: F, openWhenCollapsed: E, open: d ?? B, firstLevel: _ === 0, collapsed: S, defaultOpen: d && !R || u, className: et(ye.subMenuContent, le), rootStyles: re("subMenuContent") },
      React$1.createElement(Ns.Provider, { value: _ + 1 }, n)
    )
  );
};
React$1.forwardRef(bO);
var Hf, yO = it.li(Bf || (Bf = pt([`
  width: 100%;
  position: relative;

  `, `;

  `, `;

  > .`, ` {
    `, `;

    `, `;
  }
`], [`
  width: 100%;
  position: relative;

  `, `;

  `, `;

  > .`, ` {
    `, `;

    `, `;
  }
`])), function(t6) {
  var e = t6.menuItemStyles;
  return e;
}, function(t6) {
  var e = t6.rootStyles;
  return e;
}, ye.button, function(t6) {
  var e = t6.level, r = t6.disabled, n = t6.active, a = t6.collapsed, i = t6.rtl;
  return c0({
    level: e,
    disabled: r,
    active: n,
    collapsed: a,
    rtl: i
  });
}, function(t6) {
  var e = t6.buttonStyles;
  return e;
}), vO = function(t6, e) {
  var r, n = t6.children, a = t6.icon, i = t6.className, s = t6.prefix, o = t6.suffix, l = t6.active, c = l === void 0 ? false : l, d = t6.disabled, u = d === void 0 ? false : d, f = t6.component, h = t6.rootStyles, g = Tn(t6, ["children", "icon", "className", "prefix", "suffix", "active", "disabled", "component", "rootStyles"]), m = React$1.useContext(Ns), p = React$1.useContext(go), w = p.collapsed, b = p.rtl, k = p.transitionDuration, v = Mc().menuItemStyles, x = function(T) {
    if (v) {
      var S = { level: m, disabled: u, active: c, isSubmenu: false }, C = v.root, D = v.button, z = v.label, A = v.icon, L = v.prefix, M = v.suffix;
      switch (T) {
        case "root":
          return typeof C == "function" ? C(S) : C;
        case "button":
          return typeof D == "function" ? D(S) : D;
        case "label":
          return typeof z == "function" ? z(S) : z;
        case "icon":
          return typeof A == "function" ? A(S) : A;
        case "prefix":
          return typeof L == "function" ? L(S) : L;
        case "suffix":
          return typeof M == "function" ? M(S) : M;
        default:
          return;
      }
    }
  }, _ = (r = {}, r[ye.active] = c, r[ye.disabled] = u, r);
  return React$1.createElement(
    yO,
    { ref: e, className: et(ye.menuItemRoot, _, i), menuItemStyles: x("root"), level: m, collapsed: w, rtl: b, disabled: u, active: c, buttonStyles: x("button"), rootStyles: h },
    React$1.createElement(
      d0,
      At({ className: et(ye.button, _), "data-testid": "".concat(ye.button, "-test-id"), component: f, tabIndex: 0 }, g),
      a && React$1.createElement(Qg, { rtl: b, className: et(ye.icon, _), rootStyles: x("icon") }, a),
      s && React$1.createElement(Jg, { collapsed: w, transitionDuration: k, firstLevel: m === 0, className: et(ye.prefix, _), rtl: b, rootStyles: x("prefix") }, s),
      React$1.createElement(Kg, { className: et(ye.label, _), rootStyles: x("label") }, n),
      o && React$1.createElement(Zg, { collapsed: w, transitionDuration: k, firstLevel: m === 0, className: et(ye.suffix, _), rootStyles: x("suffix") }, o)
    )
  );
}; React$1.forwardRef(vO); var Bf;
const wO = {}, u0 = reactExports.forwardRef(
  (t6, e) => {
    const { imageUrl: r, icon: n, title: a, description: i } = t6;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${wO.Card} border px-3.5 py-7`, ref: e, children: [
      r ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Cn,
        {
          classIm: "mx-auto",
          src: r,
          alt: a,
          width: 74,
          height: 74
        }
      ) : n ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(n, { size: 74 }) }) : null,
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "my-3 font-bold", children: a }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: i })
    ] });
  }
);
u0.displayName = "Card";
function kO(t6) {
  return We({ attr: { viewBox: "0 0 20 20", fill: "currentColor", "aria-hidden": "true" }, child: [{ tag: "path", attr: { fillRule: "evenodd", d: "M9.707 16.707a1 1 0 01-1.414 0l-6-6a1 1 0 010-1.414l6-6a1 1 0 011.414 1.414L5.414 9H17a1 1 0 110 2H5.414l4.293 4.293a1 1 0 010 1.414z", clipRule: "evenodd" }, child: [] }] })(t6);
}
function _O(t6) {
  return We({ attr: { viewBox: "0 0 20 20", fill: "currentColor", "aria-hidden": "true" }, child: [{ tag: "path", attr: { fillRule: "evenodd", d: "M10.293 3.293a1 1 0 011.414 0l6 6a1 1 0 010 1.414l-6 6a1 1 0 01-1.414-1.414L14.586 11H3a1 1 0 110-2h11.586l-4.293-4.293a1 1 0 010-1.414z", clipRule: "evenodd" }, child: [] }] })(t6);
}
function OO(t6) {
  return We({ attr: { viewBox: "0 0 20 20", fill: "currentColor", "aria-hidden": "true" }, child: [{ tag: "path", attr: { fillRule: "evenodd", d: "M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z", clipRule: "evenodd" }, child: [] }] })(t6);
}
function f0(t6) {
  return We({ attr: { viewBox: "0 0 20 20", fill: "currentColor", "aria-hidden": "true" }, child: [{ tag: "path", attr: { fillRule: "evenodd", d: "M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z", clipRule: "evenodd" }, child: [] }] })(t6);
}
function h0(t6) {
  return We({ attr: { viewBox: "0 0 20 20", fill: "currentColor", "aria-hidden": "true" }, child: [{ tag: "path", attr: { fillRule: "evenodd", d: "M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z", clipRule: "evenodd" }, child: [] }] })(t6);
}
function g0(t6) {
  return We({ attr: { viewBox: "0 0 20 20", fill: "currentColor", "aria-hidden": "true" }, child: [{ tag: "path", attr: { fillRule: "evenodd", d: "M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z", clipRule: "evenodd" }, child: [] }] })(t6);
}
function SO(t6) {
  return We({ attr: { viewBox: "0 0 20 20", fill: "currentColor", "aria-hidden": "true" }, child: [{ tag: "path", attr: { fillRule: "evenodd", d: "M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z", clipRule: "evenodd" }, child: [] }] })(t6);
}
function Yf(t6) {
  return We({ attr: { viewBox: "0 0 20 20", fill: "currentColor", "aria-hidden": "true" }, child: [{ tag: "path", attr: { d: "M3 3a1 1 0 000 2h11a1 1 0 100-2H3zM3 7a1 1 0 000 2h5a1 1 0 000-2H3zM3 11a1 1 0 100 2h4a1 1 0 100-2H3zM13 16a1 1 0 102 0v-5.586l1.293 1.293a1 1 0 001.414-1.414l-3-3a1 1 0 00-1.414 0l-3 3a1 1 0 101.414 1.414L13 10.414V16z" }, child: [] }] })(t6);
}
function DO(t6) {
  return We({ attr: { viewBox: "0 0 20 20", fill: "currentColor", "aria-hidden": "true" }, child: [{ tag: "path", attr: { d: "M3 3a1 1 0 000 2h11a1 1 0 100-2H3zM3 7a1 1 0 000 2h7a1 1 0 100-2H3zM3 11a1 1 0 100 2h4a1 1 0 100-2H3zM15 8a1 1 0 10-2 0v5.586l-1.293-1.293a1 1 0 00-1.414 1.414l3 3a1 1 0 001.414 0l3-3a1 1 0 00-1.414-1.414L15 13.586V8z" }, child: [] }] })(t6);
}
function MO(t6) {
  return We({ attr: { viewBox: "0 0 20 20", fill: "currentColor", "aria-hidden": "true" }, child: [{ tag: "path", attr: { d: "M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" }, child: [] }] })(t6);
}
function CO(t6) {
  return We({ attr: { viewBox: "0 0 20 20", fill: "currentColor", "aria-hidden": "true" }, child: [{ tag: "path", attr: { fillRule: "evenodd", d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z", clipRule: "evenodd" }, child: [] }] })(t6);
}
function m0(t6) {
  return We({ attr: { fill: "none", viewBox: "0 0 24 24", strokeWidth: "2", stroke: "currentColor", "aria-hidden": "true" }, child: [{ tag: "path", attr: { strokeLinecap: "round", strokeLinejoin: "round", d: "M19 9l-7 7-7-7" }, child: [] }] })(t6);
}
function EO(t6) {
  return We({ attr: { fill: "none", viewBox: "0 0 24 24", strokeWidth: "2", stroke: "currentColor", "aria-hidden": "true" }, child: [{ tag: "path", attr: { strokeLinecap: "round", strokeLinejoin: "round", d: "M15 19l-7-7 7-7" }, child: [] }] })(t6);
}
function p0(t6) {
  return We({ attr: { fill: "none", viewBox: "0 0 24 24", strokeWidth: "2", stroke: "currentColor", "aria-hidden": "true" }, child: [{ tag: "path", attr: { strokeLinecap: "round", strokeLinejoin: "round", d: "M9 5l7 7-7 7" }, child: [] }] })(t6);
}
function TO(t6) {
  return We({ attr: { fill: "none", viewBox: "0 0 24 24", strokeWidth: "2", stroke: "currentColor", "aria-hidden": "true" }, child: [{ tag: "path", attr: { strokeLinecap: "round", strokeLinejoin: "round", d: "M5 15l7-7 7 7" }, child: [] }] })(t6);
}
function PO(t6) {
  return We({ attr: { fill: "none", viewBox: "0 0 24 24", strokeWidth: "2", stroke: "currentColor", "aria-hidden": "true" }, child: [{ tag: "path", attr: { strokeLinecap: "round", strokeLinejoin: "round", d: "M6 18L18 6M6 6l12 12" }, child: [] }] })(t6);
}
const Ic = "-";
function RO(t6) {
  const e = IO(t6), {
    conflictingClassGroups: r,
    conflictingClassGroupModifiers: n
  } = t6;
  function a(s) {
    const o = s.split(Ic);
    return o[0] === "" && o.length !== 1 && o.shift(), b0(o, e) || NO(s);
  }
  function i(s, o) {
    const l = r[s] || [];
    return o && n[s] ? [...l, ...n[s]] : l;
  }
  return {
    getClassGroupId: a,
    getConflictingClassGroupIds: i
  };
}
function b0(t6, e) {
  var s;
  if (t6.length === 0)
    return e.classGroupId;
  const r = t6[0], n = e.nextPart.get(r), a = n ? b0(t6.slice(1), n) : void 0;
  if (a)
    return a;
  if (e.validators.length === 0)
    return;
  const i = t6.join(Ic);
  return (s = e.validators.find(({
    validator: o
  }) => o(i))) == null ? void 0 : s.classGroupId;
}
const Vf = /^\[(.+)\]$/;
function NO(t6) {
  if (Vf.test(t6)) {
    const e = Vf.exec(t6)[1], r = e == null ? void 0 : e.substring(0, e.indexOf(":"));
    if (r)
      return "arbitrary.." + r;
  }
}
function IO(t6) {
  const {
    theme: e,
    prefix: r
  } = t6, n = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return FO(Object.entries(t6.classGroups), r).forEach(([i, s]) => {
    zl(s, n, i, e);
  }), n;
}
function zl(t6, e, r, n) {
  t6.forEach((a) => {
    if (typeof a == "string") {
      const i = a === "" ? e : qf(e, a);
      i.classGroupId = r;
      return;
    }
    if (typeof a == "function") {
      if (AO(a)) {
        zl(a(n), e, r, n);
        return;
      }
      e.validators.push({
        validator: a,
        classGroupId: r
      });
      return;
    }
    Object.entries(a).forEach(([i, s]) => {
      zl(s, qf(e, i), r, n);
    });
  });
}
function qf(t6, e) {
  let r = t6;
  return e.split(Ic).forEach((n) => {
    r.nextPart.has(n) || r.nextPart.set(n, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), r = r.nextPart.get(n);
  }), r;
}
function AO(t6) {
  return t6.isThemeGetter;
}
function FO(t6, e) {
  return e ? t6.map(([r, n]) => {
    const a = n.map((i) => typeof i == "string" ? e + i : typeof i == "object" ? Object.fromEntries(Object.entries(i).map(([s, o]) => [e + s, o])) : i);
    return [r, a];
  }) : t6;
}
function LO(t6) {
  if (t6 < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let e = 0, r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  function a(i, s) {
    r.set(i, s), e++, e > t6 && (e = 0, n = r, r = /* @__PURE__ */ new Map());
  }
  return {
    get(i) {
      let s = r.get(i);
      if (s !== void 0)
        return s;
      if ((s = n.get(i)) !== void 0)
        return a(i, s), s;
    },
    set(i, s) {
      r.has(i) ? r.set(i, s) : a(i, s);
    }
  };
}
const y0 = "!";
function WO(t6) {
  const e = t6.separator, r = e.length === 1, n = e[0], a = e.length;
  return function(s) {
    const o = [];
    let l = 0, c = 0, d;
    for (let m = 0; m < s.length; m++) {
      let p = s[m];
      if (l === 0) {
        if (p === n && (r || s.slice(m, m + a) === e)) {
          o.push(s.slice(c, m)), c = m + a;
          continue;
        }
        if (p === "/") {
          d = m;
          continue;
        }
      }
      p === "[" ? l++ : p === "]" && l--;
    }
    const u = o.length === 0 ? s : s.substring(c), f = u.startsWith(y0), h = f ? u.substring(1) : u, g = d && d > c ? d - c : void 0;
    return {
      modifiers: o,
      hasImportantModifier: f,
      baseClassName: h,
      maybePostfixModifierPosition: g
    };
  };
}
function $O(t6) {
  if (t6.length <= 1)
    return t6;
  const e = [];
  let r = [];
  return t6.forEach((n) => {
    n[0] === "[" ? (e.push(...r.sort(), n), r = []) : r.push(n);
  }), e.push(...r.sort()), e;
}
function zO(t6) {
  return {
    cache: LO(t6.cacheSize),
    splitModifiers: WO(t6),
    ...RO(t6)
  };
}
const jO = /\s+/;
function HO(t6, e) {
  const {
    splitModifiers: r,
    getClassGroupId: n,
    getConflictingClassGroupIds: a
  } = e, i = /* @__PURE__ */ new Set();
  return t6.trim().split(jO).map((s) => {
    const {
      modifiers: o,
      hasImportantModifier: l,
      baseClassName: c,
      maybePostfixModifierPosition: d
    } = r(s);
    let u = n(d ? c.substring(0, d) : c), f = !!d;
    if (!u) {
      if (!d)
        return {
          isTailwindClass: false,
          originalClassName: s
        };
      if (u = n(c), !u)
        return {
          isTailwindClass: false,
          originalClassName: s
        };
      f = false;
    }
    const h = $O(o).join(":");
    return {
      isTailwindClass: true,
      modifierId: l ? h + y0 : h,
      classGroupId: u,
      originalClassName: s,
      hasPostfixModifier: f
    };
  }).reverse().filter((s) => {
    if (!s.isTailwindClass)
      return true;
    const {
      modifierId: o,
      classGroupId: l,
      hasPostfixModifier: c
    } = s, d = o + l;
    return i.has(d) ? false : (i.add(d), a(l, c).forEach((u) => i.add(o + u)), true);
  }).reverse().map((s) => s.originalClassName).join(" ");
}
function BO() {
  let t6 = 0, e, r, n = "";
  for (; t6 < arguments.length; )
    (e = arguments[t6++]) && (r = v0(e)) && (n && (n += " "), n += r);
  return n;
}
function v0(t6) {
  if (typeof t6 == "string")
    return t6;
  let e, r = "";
  for (let n = 0; n < t6.length; n++)
    t6[n] && (e = v0(t6[n])) && (r && (r += " "), r += e);
  return r;
}
function YO(t6, ...e) {
  let r, n, a, i = s;
  function s(l) {
    const c = e.reduce((d, u) => u(d), t6());
    return r = zO(c), n = r.cache.get, a = r.cache.set, i = o, o(l);
  }
  function o(l) {
    const c = n(l);
    if (c)
      return c;
    const d = HO(l, r);
    return a(l, d), d;
  }
  return function() {
    return i(BO.apply(null, arguments));
  };
}
function Ne(t6) {
  const e = (r) => r[t6] || [];
  return e.isThemeGetter = true, e;
}
const x0 = /^\[(?:([a-z-]+):)?(.+)\]$/i, VO = /^\d+\/\d+$/, qO = /* @__PURE__ */ new Set(["px", "full", "screen"]), UO = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, XO = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, GO = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, KO = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, QO = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
function wr(t6) {
  return wn(t6) || qO.has(t6) || VO.test(t6);
}
function zr(t6) {
  return ma(t6, "length", iS);
}
function wn(t6) {
  return !!t6 && !Number.isNaN(Number(t6));
}
function Xi(t6) {
  return ma(t6, "number", wn);
}
function Ca(t6) {
  return !!t6 && Number.isInteger(Number(t6));
}
function JO(t6) {
  return t6.endsWith("%") && wn(t6.slice(0, -1));
}
function he(t6) {
  return x0.test(t6);
}
function jr(t6) {
  return UO.test(t6);
}
const ZO = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
function eS(t6) {
  return ma(t6, ZO, w0);
}
function tS(t6) {
  return ma(t6, "position", w0);
}
const rS = /* @__PURE__ */ new Set(["image", "url"]);
function nS(t6) {
  return ma(t6, rS, oS);
}
function aS(t6) {
  return ma(t6, "", sS);
}
function Ea() {
  return true;
}
function ma(t6, e, r) {
  const n = x0.exec(t6);
  return n ? n[1] ? typeof e == "string" ? n[1] === e : e.has(n[1]) : r(n[2]) : false;
}
function iS(t6) {
  return XO.test(t6) && !GO.test(t6);
}
function w0() {
  return false;
}
function sS(t6) {
  return KO.test(t6);
}
function oS(t6) {
  return QO.test(t6);
}
function lS() {
  const t6 = Ne("colors"), e = Ne("spacing"), r = Ne("blur"), n = Ne("brightness"), a = Ne("borderColor"), i = Ne("borderRadius"), s = Ne("borderSpacing"), o = Ne("borderWidth"), l = Ne("contrast"), c = Ne("grayscale"), d = Ne("hueRotate"), u = Ne("invert"), f = Ne("gap"), h = Ne("gradientColorStops"), g = Ne("gradientColorStopPositions"), m = Ne("inset"), p = Ne("margin"), w = Ne("opacity"), b = Ne("padding"), k = Ne("saturate"), v = Ne("scale"), x = Ne("sepia"), _ = Ne("skew"), T = Ne("space"), S = Ne("translate"), C = () => ["auto", "contain", "none"], D = () => ["auto", "hidden", "clip", "visible", "scroll"], z = () => ["auto", he, e], A = () => [he, e], L = () => ["", wr, zr], M = () => ["auto", wn, he], I = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], W = () => ["solid", "dashed", "dotted", "double", "none"], B = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity", "plus-lighter"], U = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], J = () => ["", "0", he], E = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], j = () => [wn, Xi], N = () => [wn, he];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [Ea],
      spacing: [wr, zr],
      blur: ["none", "", jr, he],
      brightness: j(),
      borderColor: [t6],
      borderRadius: ["none", "", "full", jr, he],
      borderSpacing: A(),
      borderWidth: L(),
      contrast: j(),
      grayscale: J(),
      hueRotate: N(),
      invert: J(),
      gap: A(),
      gradientColorStops: [t6],
      gradientColorStopPositions: [JO, zr],
      inset: z(),
      margin: z(),
      opacity: j(),
      padding: A(),
      saturate: j(),
      scale: j(),
      sepia: J(),
      skew: N(),
      space: A(),
      translate: A()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", he]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [jr]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": E()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": E()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...I(), he]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: D()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": D()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": D()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: C()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": C()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": C()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [m]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [m]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [m]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [m]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [m]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [m]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [m]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [m]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [m]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", Ca, he]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: z()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", he]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: J()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: J()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", Ca, he]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [Ea]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", Ca, he]
        }, he]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": M()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": M()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [Ea]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [Ca, he]
        }, he]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": M()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": M()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", he]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", he]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [f]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [f]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [f]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...U()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...U(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...U(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [b]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [b]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [b]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [b]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [b]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [b]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [b]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [b]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [b]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [p]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [p]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [p]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [p]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [p]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [p]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [p]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [p]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [p]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [T]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [T]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", he, e]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [he, e, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [he, e, "none", "full", "min", "max", "fit", "prose", {
          screen: [jr]
        }, jr]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [he, e, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [he, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [he, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [he, e, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", jr, zr]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", Xi]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [Ea]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", he]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", wn, Xi]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", wr, he]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", he]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", he]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [t6]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [w]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [t6]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [w]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...W(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", wr, zr]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", wr, he]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [t6]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: A()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", he]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", he]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [w]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...I(), tS]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", eS]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, nS]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [t6]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [g]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [g]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [g]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [h]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [h]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [h]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [i]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [i]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [i]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [i]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [i]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [i]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [i]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [i]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [i]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [i]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [i]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [i]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [i]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [i]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [i]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [o]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [o]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [o]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [o]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [o]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [o]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [o]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [o]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [o]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [w]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...W(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [o]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [o]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [w]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: W()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [a]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [a]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [a]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [a]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [a]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [a]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [a]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [a]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...W()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [wr, he]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [wr, zr]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [t6]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: L()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [t6]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [w]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [wr, zr]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [t6]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", jr, aS]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [Ea]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [w]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": B()
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": B()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [r]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [n]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [l]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", jr, he]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [c]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [d]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [u]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [k]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [x]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [r]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [n]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [l]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [c]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [d]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [u]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [w]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [k]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [x]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [s]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [s]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [s]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", he]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: N()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", he]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: N()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", he]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [v]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [v]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [v]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [Ca, he]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [S]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [S]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [_]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [_]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", he]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", t6]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", he]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [t6]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": A()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": A()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": A()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": A()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": A()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": A()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": A()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": A()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": A()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": A()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": A()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": A()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": A()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": A()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": A()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": A()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": A()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": A()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", he]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [t6, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [wr, zr, Xi]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [t6, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}
const Y = /* @__PURE__ */ YO(lS);
function mn(t6) {
  return t6 !== null && typeof t6 == "object" && t6.constructor === Object;
}
function ui(t6) {
  if (!mn(t6))
    return t6;
  const e = {};
  for (const r in t6)
    e[r] = ui(t6[r]);
  return e;
}
function te(t6, e) {
  if (mn(e) && Object.keys(e).length === 0)
    return ui({ ...t6, ...e });
  const r = { ...t6, ...e };
  if (mn(e) && mn(t6))
    for (const n in e)
      mn(e[n]) && n in t6 && mn(t6[n]) ? r[n] = te(t6[n], e[n]) : r[n] = mn(e[n]) ? ui(e[n]) : e[n];
  return r;
}
const cS = {
  root: {
    base: "divide-y divide-gray-200 border-gray-200 dark:divide-gray-700 dark:border-gray-700",
    flush: {
      off: "rounded-lg border",
      on: "border-b"
    }
  },
  content: {
    base: "p-5 first:rounded-t-lg last:rounded-b-lg dark:bg-gray-900"
  },
  title: {
    arrow: {
      base: "h-6 w-6 shrink-0",
      open: {
        off: "",
        on: "rotate-180"
      }
    },
    base: "flex w-full items-center justify-between p-5 text-left font-medium text-gray-500 first:rounded-t-lg last:rounded-b-lg dark:text-gray-400",
    flush: {
      off: "hover:bg-gray-100 focus:ring-4 focus:ring-gray-200 dark:hover:bg-gray-800 dark:focus:ring-gray-800",
      on: "bg-transparent dark:bg-transparent"
    },
    heading: "",
    open: {
      off: "",
      on: "bg-gray-100 text-gray-900 dark:bg-gray-800 dark:text-white"
    }
  }
}, dS = {
  base: "flex flex-col gap-2 p-4 text-sm",
  borderAccent: "border-t-4",
  closeButton: {
    base: "-m-1.5 ml-auto inline-flex h-8 w-8 rounded-lg p-1.5 focus:ring-2",
    icon: "h-5 w-5",
    color: {
      info: "bg-cyan-100 text-cyan-500 hover:bg-cyan-200 focus:ring-cyan-400 dark:bg-cyan-200 dark:text-cyan-600 dark:hover:bg-cyan-300",
      gray: "bg-gray-100 text-gray-500 hover:bg-gray-200 focus:ring-gray-400 dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-800 dark:hover:text-white",
      failure: "bg-red-100 text-red-500 hover:bg-red-200 focus:ring-red-400 dark:bg-red-200 dark:text-red-600 dark:hover:bg-red-300",
      success: "bg-green-100 text-green-500 hover:bg-green-200 focus:ring-green-400 dark:bg-green-200 dark:text-green-600 dark:hover:bg-green-300",
      warning: "bg-yellow-100 text-yellow-500 hover:bg-yellow-200 focus:ring-yellow-400 dark:bg-yellow-200 dark:text-yellow-600 dark:hover:bg-yellow-300",
      red: "bg-red-100 text-red-500 hover:bg-red-200 focus:ring-red-400 dark:bg-red-200 dark:text-red-600 dark:hover:bg-red-300",
      green: "bg-green-100 text-green-500 hover:bg-green-200 focus:ring-green-400 dark:bg-green-200 dark:text-green-600 dark:hover:bg-green-300",
      yellow: "bg-yellow-100 text-yellow-500 hover:bg-yellow-200 focus:ring-yellow-400 dark:bg-yellow-200 dark:text-yellow-600 dark:hover:bg-yellow-300",
      blue: "bg-blue-100 text-blue-500 hover:bg-blue-200 focus:ring-blue-400 dark:bg-blue-200 dark:text-blue-600 dark:hover:bg-blue-300",
      cyan: "bg-cyan-100 text-cyan-500 hover:bg-cyan-200 focus:ring-cyan-400 dark:bg-cyan-200 dark:text-cyan-600 dark:hover:bg-cyan-300",
      pink: "bg-pink-100 text-pink-500 hover:bg-pink-200 focus:ring-pink-400 dark:bg-pink-200 dark:text-pink-600 dark:hover:bg-pink-300",
      lime: "bg-lime-100 text-lime-500 hover:bg-lime-200 focus:ring-lime-400 dark:bg-lime-200 dark:text-lime-600 dark:hover:bg-lime-300",
      dark: "bg-gray-100 text-gray-500 hover:bg-gray-200 focus:ring-gray-400 dark:bg-gray-200 dark:text-gray-600 dark:hover:bg-gray-300",
      indigo: "bg-indigo-100 text-indigo-500 hover:bg-indigo-200 focus:ring-indigo-400 dark:bg-indigo-200 dark:text-indigo-600 dark:hover:bg-indigo-300",
      purple: "bg-purple-100 text-purple-500 hover:bg-purple-200 focus:ring-purple-400 dark:bg-purple-200 dark:text-purple-600 dark:hover:bg-purple-300",
      teal: "bg-teal-100 text-teal-500 hover:bg-teal-200 focus:ring-teal-400 dark:bg-teal-200 dark:text-teal-600 dark:hover:bg-teal-300",
      light: "bg-gray-50 text-gray-500 hover:bg-gray-100 focus:ring-gray-200 dark:bg-gray-600 dark:text-gray-200 dark:hover:bg-gray-700 dark:hover:text-white"
    }
  },
  color: {
    info: "border-cyan-500 bg-cyan-100 text-cyan-700 dark:bg-cyan-200 dark:text-cyan-800",
    gray: "border-gray-500 bg-gray-100 text-gray-700 dark:bg-gray-700 dark:text-gray-300",
    failure: "border-red-500 bg-red-100 text-red-700 dark:bg-red-200 dark:text-red-800",
    success: "border-green-500 bg-green-100 text-green-700 dark:bg-green-200 dark:text-green-800",
    warning: "border-yellow-500 bg-yellow-100 text-yellow-700 dark:bg-yellow-200 dark:text-yellow-800",
    red: "border-red-500 bg-red-100 text-red-700 dark:bg-red-200 dark:text-red-800",
    green: "border-green-500 bg-green-100 text-green-700 dark:bg-green-200 dark:text-green-800",
    yellow: "border-yellow-500 bg-yellow-100 text-yellow-700 dark:bg-yellow-200 dark:text-yellow-800",
    blue: "border-blue-500 bg-blue-100 text-blue-700 dark:bg-blue-200 dark:text-blue-800",
    cyan: "border-cyan-500 bg-cyan-100 text-cyan-700 dark:bg-cyan-200 dark:text-cyan-800",
    pink: "border-pink-500 bg-pink-100 text-pink-700 dark:bg-pink-200 dark:text-pink-800",
    lime: "border-lime-500 bg-lime-100 text-lime-700 dark:bg-lime-200 dark:text-lime-800",
    dark: "border-gray-600 bg-gray-800 text-gray-200 dark:bg-gray-900 dark:text-gray-300",
    indigo: "border-indigo-500 bg-indigo-100 text-indigo-700 dark:bg-indigo-200 dark:text-indigo-800",
    purple: "border-purple-500 bg-purple-100 text-purple-700 dark:bg-purple-200 dark:text-purple-800",
    teal: "border-teal-500 bg-teal-100 text-teal-700 dark:bg-teal-200 dark:text-teal-800",
    light: "border-gray-400 bg-gray-50 text-gray-600 dark:bg-gray-500 dark:text-gray-200"
  },
  icon: "mr-3 inline h-5 w-5 flex-shrink-0",
  rounded: "rounded-lg",
  wrapper: "flex items-center"
}, uS = {
  root: {
    base: "flex items-center justify-center space-x-4 rounded",
    bordered: "p-1 ring-2",
    rounded: "rounded-full",
    color: {
      dark: "ring-gray-800 dark:ring-gray-800",
      failure: "ring-red-500 dark:ring-red-700",
      gray: "ring-gray-500 dark:ring-gray-400",
      info: "ring-cyan-400 dark:ring-cyan-800",
      light: "ring-gray-300 dark:ring-gray-500",
      purple: "ring-purple-500 dark:ring-purple-600",
      success: "ring-green-500 dark:ring-green-500",
      warning: "ring-yellow-300 dark:ring-yellow-500",
      pink: "ring-pink-500 dark:ring-pink-500"
    },
    img: {
      base: "rounded",
      off: "relative overflow-hidden bg-gray-100 dark:bg-gray-600",
      on: "",
      placeholder: "absolute -bottom-1 h-auto w-auto text-gray-400"
    },
    size: {
      xs: "h-6 w-6",
      sm: "h-8 w-8",
      md: "h-10 w-10",
      lg: "h-20 w-20",
      xl: "h-36 w-36"
    },
    stacked: "ring-2 ring-gray-300 dark:ring-gray-500",
    statusPosition: {
      "bottom-left": "-bottom-1 -left-1",
      "bottom-center": "-bottom-1",
      "bottom-right": "-bottom-1 -right-1",
      "top-left": "-left-1 -top-1",
      "top-center": "-top-1",
      "top-right": "-right-1 -top-1",
      "center-right": "-right-1",
      center: "",
      "center-left": "-left-1"
    },
    status: {
      away: "bg-yellow-400",
      base: "absolute h-3.5 w-3.5 rounded-full border-2 border-white dark:border-gray-800",
      busy: "bg-red-400",
      offline: "bg-gray-400",
      online: "bg-green-400"
    },
    initials: {
      text: "font-medium text-gray-600 dark:text-gray-300",
      base: "relative inline-flex items-center justify-center overflow-hidden bg-gray-100 dark:bg-gray-600"
    }
  },
  group: {
    base: "flex -space-x-4"
  },
  groupCounter: {
    base: "relative flex h-10 w-10 items-center justify-center rounded-full bg-gray-700 text-xs font-medium text-white ring-2 ring-gray-300 hover:bg-gray-600 dark:ring-gray-500"
  }
}, fS = {
  root: {
    base: "flex h-fit items-center gap-1 font-semibold",
    color: {
      info: "bg-cyan-100 text-cyan-800 group-hover:bg-cyan-200 dark:bg-cyan-200 dark:text-cyan-800 dark:group-hover:bg-cyan-300",
      gray: "bg-gray-100 text-gray-800 group-hover:bg-gray-200 dark:bg-gray-700 dark:text-gray-300 dark:group-hover:bg-gray-600",
      failure: "bg-red-100 text-red-800 group-hover:bg-red-200 dark:bg-red-200 dark:text-red-900 dark:group-hover:bg-red-300",
      success: "bg-green-100 text-green-800 group-hover:bg-green-200 dark:bg-green-200 dark:text-green-900 dark:group-hover:bg-green-300",
      warning: "bg-yellow-100 text-yellow-800 group-hover:bg-yellow-200 dark:bg-yellow-200 dark:text-yellow-900 dark:group-hover:bg-yellow-300",
      indigo: "bg-indigo-100 text-indigo-800 group-hover:bg-indigo-200 dark:bg-indigo-200 dark:text-indigo-900 dark:group-hover:bg-indigo-300",
      purple: "bg-purple-100 text-purple-800 group-hover:bg-purple-200 dark:bg-purple-200 dark:text-purple-900 dark:group-hover:bg-purple-300",
      pink: "bg-pink-100 text-pink-800 group-hover:bg-pink-200 dark:bg-pink-200 dark:text-pink-900 dark:group-hover:bg-pink-300",
      blue: "bg-blue-100 text-blue-800 group-hover:bg-blue-200 dark:bg-blue-200 dark:text-blue-900 dark:group-hover:bg-blue-300",
      cyan: "bg-cyan-100 text-cyan-800 group-hover:bg-cyan-200 dark:bg-cyan-200 dark:text-cyan-900 dark:group-hover:bg-cyan-300",
      dark: "bg-gray-600 text-gray-100 group-hover:bg-gray-500 dark:bg-gray-900 dark:text-gray-200 dark:group-hover:bg-gray-700",
      light: "bg-gray-200 text-gray-800 group-hover:bg-gray-300 dark:bg-gray-400 dark:text-gray-900 dark:group-hover:bg-gray-500",
      green: "bg-green-100 text-green-800 group-hover:bg-green-200 dark:bg-green-200 dark:text-green-900 dark:group-hover:bg-green-300",
      lime: "bg-lime-100 text-lime-800 group-hover:bg-lime-200 dark:bg-lime-200 dark:text-lime-900 dark:group-hover:bg-lime-300",
      red: "bg-red-100 text-red-800 group-hover:bg-red-200 dark:bg-red-200 dark:text-red-900 dark:group-hover:bg-red-300",
      teal: "bg-teal-100 text-teal-800 group-hover:bg-teal-200 dark:bg-teal-200 dark:text-teal-900 dark:group-hover:bg-teal-300",
      yellow: "bg-yellow-100 text-yellow-800 group-hover:bg-yellow-200 dark:bg-yellow-200 dark:text-yellow-900 dark:group-hover:bg-yellow-300"
    },
    href: "group",
    size: {
      xs: "p-1 text-xs",
      sm: "p-1.5 text-sm"
    }
  },
  icon: {
    off: "rounded px-2 py-0.5",
    on: "rounded-full p-1.5",
    size: {
      xs: "h-3 w-3",
      sm: "h-3.5 w-3.5"
    }
  }
}, hS = {
  root: {
    base: "text-xl font-semibold italic text-gray-900 dark:text-white"
  }
}, gS = {
  root: {
    base: "",
    list: "flex items-center"
  },
  item: {
    base: "group flex items-center",
    chevron: "mx-1 h-4 w-4 text-gray-400 group-first:hidden md:mx-2",
    href: {
      off: "flex items-center text-sm font-medium text-gray-500 dark:text-gray-400",
      on: "flex items-center text-sm font-medium text-gray-700 hover:text-gray-900 dark:text-gray-400 dark:hover:text-white"
    },
    icon: "mr-2 h-4 w-4"
  }
}, mS = {
  base: "group relative flex items-stretch justify-center p-0.5 text-center font-medium transition-[color,background-color,border-color,text-decoration-color,fill,stroke,box-shadow] focus:z-10 focus:outline-none",
  fullSized: "w-full",
  color: {
    dark: "border border-transparent bg-gray-800 text-white focus:ring-4 focus:ring-gray-300 enabled:hover:bg-gray-900 dark:border-gray-700 dark:bg-gray-800 dark:focus:ring-gray-800 dark:enabled:hover:bg-gray-700",
    failure: "border border-transparent bg-red-700 text-white focus:ring-4 focus:ring-red-300 enabled:hover:bg-red-800 dark:bg-red-600 dark:focus:ring-red-900 dark:enabled:hover:bg-red-700",
    gray: ":ring-cyan-700 border border-gray-200 bg-white text-gray-900 focus:text-cyan-700 focus:ring-4 enabled:hover:bg-gray-100 enabled:hover:text-cyan-700 dark:border-gray-600 dark:bg-transparent dark:text-gray-400 dark:enabled:hover:bg-gray-700 dark:enabled:hover:text-white",
    info: "border border-transparent bg-cyan-700 text-white focus:ring-4 focus:ring-cyan-300 enabled:hover:bg-cyan-800 dark:bg-cyan-600 dark:focus:ring-cyan-800 dark:enabled:hover:bg-cyan-700",
    light: "border border-gray-300 bg-white text-gray-900 focus:ring-4 focus:ring-cyan-300 enabled:hover:bg-gray-100 dark:border-gray-600 dark:bg-gray-600 dark:text-white dark:focus:ring-gray-700 dark:enabled:hover:border-gray-700 dark:enabled:hover:bg-gray-700",
    purple: "border border-transparent bg-purple-700 text-white focus:ring-4 focus:ring-purple-300 enabled:hover:bg-purple-800 dark:bg-purple-600 dark:focus:ring-purple-900 dark:enabled:hover:bg-purple-700",
    success: "border border-transparent bg-green-700 text-white focus:ring-4 focus:ring-green-300 enabled:hover:bg-green-800 dark:bg-green-600 dark:focus:ring-green-800 dark:enabled:hover:bg-green-700",
    warning: "border border-transparent bg-yellow-400 text-white focus:ring-4 focus:ring-yellow-300 enabled:hover:bg-yellow-500 dark:focus:ring-yellow-900",
    blue: "border border-transparent bg-blue-700 text-white focus:ring-4 focus:ring-blue-300 enabled:hover:bg-blue-800 dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800",
    cyan: "border border-cyan-300 bg-white text-cyan-900 focus:ring-4 focus:ring-cyan-300 enabled:hover:bg-cyan-100 dark:border-cyan-600 dark:bg-cyan-600 dark:text-white dark:focus:ring-cyan-700 dark:enabled:hover:border-cyan-700 dark:enabled:hover:bg-cyan-700",
    green: "border border-green-300 bg-white text-green-900 focus:ring-4 focus:ring-green-300 enabled:hover:bg-green-100 dark:border-green-600 dark:bg-green-600 dark:text-white dark:focus:ring-green-700 dark:enabled:hover:border-green-700 dark:enabled:hover:bg-green-700",
    indigo: "border border-indigo-300 bg-white text-indigo-900 focus:ring-4 focus:ring-indigo-300 enabled:hover:bg-indigo-100 dark:border-indigo-600 dark:bg-indigo-600 dark:text-white dark:focus:ring-indigo-700 dark:enabled:hover:border-indigo-700 dark:enabled:hover:bg-indigo-700",
    lime: "border border-lime-300 bg-white text-lime-900 focus:ring-4 focus:ring-lime-300 enabled:hover:bg-lime-100 dark:border-lime-600 dark:bg-lime-600 dark:text-white dark:focus:ring-lime-700 dark:enabled:hover:border-lime-700 dark:enabled:hover:bg-lime-700",
    pink: "border border-pink-300 bg-white text-pink-900 focus:ring-4 focus:ring-pink-300 enabled:hover:bg-pink-100 dark:border-pink-600 dark:bg-pink-600 dark:text-white dark:focus:ring-pink-700 dark:enabled:hover:border-pink-700 dark:enabled:hover:bg-pink-700",
    red: "border border-red-300 bg-white text-red-900 focus:ring-4 focus:ring-red-300 enabled:hover:bg-red-100 dark:border-red-600 dark:bg-red-600 dark:text-white dark:focus:ring-red-700 dark:enabled:hover:border-red-700 dark:enabled:hover:bg-red-700",
    teal: "border border-teal-300 bg-white text-teal-900 focus:ring-4 focus:ring-teal-300 enabled:hover:bg-teal-100 dark:border-teal-600 dark:bg-teal-600 dark:text-white dark:focus:ring-teal-700 dark:enabled:hover:border-teal-700 dark:enabled:hover:bg-teal-700",
    yellow: "border border-yellow-300 bg-white text-yellow-900 focus:ring-4 focus:ring-yellow-300 enabled:hover:bg-yellow-100 dark:border-yellow-600 dark:bg-yellow-600 dark:text-white dark:focus:ring-yellow-700 dark:enabled:hover:border-yellow-700 dark:enabled:hover:bg-yellow-700"
  },
  disabled: "cursor-not-allowed opacity-50",
  isProcessing: "cursor-wait",
  spinnerSlot: "absolute top-0 flex h-full items-center",
  spinnerLeftPosition: {
    xs: "left-2",
    sm: "left-3",
    md: "left-4",
    lg: "left-5",
    xl: "left-6"
  },
  gradient: {
    cyan: "bg-gradient-to-r from-cyan-400 via-cyan-500 to-cyan-600 text-white focus:ring-4 focus:ring-cyan-300 enabled:hover:bg-gradient-to-br dark:focus:ring-cyan-800",
    failure: "bg-gradient-to-r from-red-400 via-red-500 to-red-600 text-white focus:ring-4 focus:ring-red-300 enabled:hover:bg-gradient-to-br dark:focus:ring-red-800",
    info: "bg-gradient-to-r from-cyan-500 via-cyan-600 to-cyan-700 text-white focus:ring-4 focus:ring-cyan-300 enabled:hover:bg-gradient-to-br dark:focus:ring-cyan-800 ",
    lime: "bg-gradient-to-r from-lime-200 via-lime-400 to-lime-500 text-gray-900 focus:ring-4 focus:ring-lime-300 enabled:hover:bg-gradient-to-br dark:focus:ring-lime-800",
    pink: "bg-gradient-to-r from-pink-400 via-pink-500 to-pink-600 text-white focus:ring-4 focus:ring-pink-300 enabled:hover:bg-gradient-to-br dark:focus:ring-pink-800",
    purple: "bg-gradient-to-r from-purple-500 via-purple-600 to-purple-700 text-white focus:ring-4 focus:ring-purple-300 enabled:hover:bg-gradient-to-br dark:focus:ring-purple-800",
    success: "bg-gradient-to-r from-green-400 via-green-500 to-green-600 text-white focus:ring-4 focus:ring-green-300 enabled:hover:bg-gradient-to-br dark:focus:ring-green-800",
    teal: "bg-gradient-to-r from-teal-400 via-teal-500 to-teal-600 text-white focus:ring-4 focus:ring-teal-300 enabled:hover:bg-gradient-to-br dark:focus:ring-teal-800"
  },
  gradientDuoTone: {
    cyanToBlue: "bg-gradient-to-r from-cyan-500 to-cyan-500 text-white focus:ring-4 focus:ring-cyan-300 enabled:hover:bg-gradient-to-bl dark:focus:ring-cyan-800",
    greenToBlue: "bg-gradient-to-br from-green-400 to-cyan-600 text-white focus:ring-4 focus:ring-green-200 enabled:hover:bg-gradient-to-bl dark:focus:ring-green-800",
    pinkToOrange: "bg-gradient-to-br from-pink-500 to-orange-400 text-white focus:ring-4 focus:ring-pink-200 enabled:hover:bg-gradient-to-bl dark:focus:ring-pink-800",
    purpleToBlue: "bg-gradient-to-br from-purple-600 to-cyan-500 text-white focus:ring-4 focus:ring-cyan-300 enabled:hover:bg-gradient-to-bl dark:focus:ring-cyan-800",
    purpleToPink: "bg-gradient-to-r from-purple-500 to-pink-500 text-white focus:ring-4 focus:ring-purple-200 enabled:hover:bg-gradient-to-l dark:focus:ring-purple-800",
    redToYellow: "bg-gradient-to-r from-red-200 via-red-300 to-yellow-200 text-gray-900 focus:ring-4 focus:ring-red-100 enabled:hover:bg-gradient-to-bl dark:focus:ring-red-400",
    tealToLime: "bg-gradient-to-r from-teal-200 to-lime-200 text-gray-900 focus:ring-4 focus:ring-lime-200 enabled:hover:bg-gradient-to-l enabled:hover:from-teal-200 enabled:hover:to-lime-200 enabled:hover:text-gray-900 dark:focus:ring-teal-700"
  },
  inner: {
    base: "flex items-stretch transition-all duration-200",
    position: {
      none: "",
      start: "rounded-r-none",
      middle: "rounded-none",
      end: "rounded-l-none"
    },
    outline: "border border-transparent",
    isProcessingPadding: {
      xs: "pl-8",
      sm: "pl-10",
      md: "pl-12",
      lg: "pl-16",
      xl: "pl-20"
    }
  },
  label: "ml-2 inline-flex h-4 w-4 items-center justify-center rounded-full bg-cyan-200 text-xs font-semibold text-cyan-800",
  outline: {
    color: {
      gray: "border border-gray-900 dark:border-white",
      default: "border-0",
      light: ""
    },
    off: "",
    on: "flex w-full justify-center bg-white text-gray-900 transition-all duration-75 ease-in group-enabled:group-hover:bg-opacity-0 group-enabled:group-hover:text-inherit dark:bg-gray-900 dark:text-white",
    pill: {
      off: "rounded-md",
      on: "rounded-full"
    }
  },
  pill: {
    off: "rounded-lg",
    on: "rounded-full"
  },
  size: {
    xs: "px-2 py-1 text-xs",
    sm: "px-3 py-1.5 text-sm",
    md: "px-4 py-2 text-sm",
    lg: "px-5 py-2.5 text-base",
    xl: "px-6 py-3 text-base"
  }
}, pS = {
  base: "inline-flex",
  position: {
    none: "",
    start: "rounded-r-none focus:ring-2",
    middle: "rounded-none border-l-0 pl-0 focus:ring-2",
    end: "rounded-l-none border-l-0 pl-0 focus:ring-2"
  }
}, bS = {
  root: {
    base: "flex rounded-lg border border-gray-200 bg-white shadow-md dark:border-gray-700 dark:bg-gray-800",
    children: "flex h-full flex-col justify-center gap-4 p-6",
    horizontal: {
      off: "flex-col",
      on: "flex-col md:max-w-xl md:flex-row"
    },
    href: "hover:bg-gray-100 dark:hover:bg-gray-700"
  },
  img: {
    base: "",
    horizontal: {
      off: "rounded-t-lg",
      on: "h-96 w-full rounded-t-lg object-cover md:h-auto md:w-48 md:rounded-none md:rounded-l-lg"
    }
  }
}, yS = {
  root: {
    base: "relative h-full w-full",
    leftControl: "absolute left-0 top-0 flex h-full items-center justify-center px-4 focus:outline-none",
    rightControl: "absolute right-0 top-0 flex h-full items-center justify-center px-4 focus:outline-none"
  },
  indicators: {
    active: {
      off: "bg-white/50 hover:bg-white dark:bg-gray-800/50 dark:hover:bg-gray-800",
      on: "bg-white dark:bg-gray-800"
    },
    base: "h-3 w-3 rounded-full",
    wrapper: "absolute bottom-5 left-1/2 flex -translate-x-1/2 space-x-3"
  },
  item: {
    base: "absolute left-1/2 top-1/2 block w-full -translate-x-1/2 -translate-y-1/2",
    wrapper: {
      off: "w-full flex-shrink-0 transform cursor-default snap-center",
      on: "w-full flex-shrink-0 transform cursor-grab snap-center"
    }
  },
  control: {
    base: "inline-flex h-8 w-8 items-center justify-center rounded-full bg-white/30 group-hover:bg-white/50 group-focus:outline-none group-focus:ring-4 group-focus:ring-white dark:bg-gray-800/30 dark:group-hover:bg-gray-800/60 dark:group-focus:ring-gray-800/70 sm:h-10 sm:w-10",
    icon: "h-5 w-5 text-white dark:text-gray-800 sm:h-6 sm:w-6"
  },
  scrollContainer: {
    base: "flex h-full snap-mandatory overflow-y-hidden overflow-x-scroll scroll-smooth rounded-lg",
    snap: "snap-x"
  }
}, vS = {
  root: {
    base: "h-4 w-4 rounded border border-gray-300 bg-gray-100 focus:ring-2 dark:border-gray-600 dark:bg-gray-700",
    color: {
      default: "text-cyan-600 focus:ring-cyan-600 dark:ring-offset-gray-800 dark:focus:ring-cyan-600",
      dark: "text-gray-800 focus:ring-gray-800 dark:ring-offset-gray-800 dark:focus:ring-gray-800",
      failure: "text-red-900 focus:ring-red-900 dark:ring-offset-red-900 dark:focus:ring-red-900",
      gray: "text-gray-900 focus:ring-gray-900 dark:ring-offset-gray-900 dark:focus:ring-gray-900",
      info: "text-cyan-800 focus:ring-cyan-800 dark:ring-offset-gray-800 dark:focus:ring-cyan-800",
      light: "text-gray-900 focus:ring-gray-900 dark:ring-offset-gray-900 dark:focus:ring-gray-900",
      purple: "text-purple-600 focus:ring-purple-600 dark:ring-offset-purple-600 dark:focus:ring-purple-600",
      success: "text-green-800 focus:ring-green-800 dark:ring-offset-green-800 dark:focus:ring-green-800",
      warning: "text-yellow-400 focus:ring-yellow-400 dark:ring-offset-yellow-400 dark:focus:ring-yellow-400",
      blue: "text-blue-700 focus:ring-blue-600 dark:ring-offset-blue-700 dark:focus:ring-blue-700",
      cyan: "text-cyan-600 focus:ring-cyan-600 dark:ring-offset-cyan-600 dark:focus:ring-cyan-600",
      green: "text-green-600 focus:ring-green-600 dark:ring-offset-green-600 dark:focus:ring-green-600",
      indigo: "text-indigo-700 focus:ring-indigo-700 dark:ring-offset-indigo-700 dark:focus:ring-indigo-700",
      lime: "text-lime-700 focus:ring-lime-700 dark:ring-offset-lime-700 dark:focus:ring-lime-700",
      pink: "text-pink-600 focus:ring-pink-600 dark:ring-offset-pink-600 dark:focus:ring-pink-600",
      red: "text-red-600 focus:ring-red-600 dark:ring-offset-red-600 dark:focus:ring-red-600",
      teal: "text-teal-600 focus:ring-teal-600 dark:ring-offset-teal-600 dark:focus:ring-teal-600",
      yellow: "text-yellow-400 focus:ring-yellow-400 dark:ring-offset-yellow-400 dark:focus:ring-yellow-400"
    }
  }
}, xS = {
  root: {
    base: "rounded-lg p-2.5 text-sm text-gray-500 hover:bg-gray-100 focus:outline-none focus:ring-4 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-700",
    icon: "h-5 w-5"
  }
}, wS = {
  root: {
    base: "relative"
  },
  popup: {
    root: {
      base: "absolute top-10 z-50 block pt-2",
      inline: "relative top-0 z-auto",
      inner: "inline-block rounded-lg bg-white p-4 shadow-lg dark:bg-gray-700"
    },
    header: {
      base: "",
      title: "px-2 py-3 text-center font-semibold text-gray-900 dark:text-white",
      selectors: {
        base: "mb-2 flex justify-between",
        button: {
          base: "rounded-lg bg-white px-5 py-2.5 text-sm font-semibold text-gray-900 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:bg-gray-700 dark:text-white dark:hover:bg-gray-600",
          prev: "",
          next: "",
          view: ""
        }
      }
    },
    view: {
      base: "p-1"
    },
    footer: {
      base: "mt-2 flex space-x-2",
      button: {
        base: "w-full rounded-lg px-5 py-2 text-center text-sm font-medium focus:ring-4 focus:ring-cyan-300",
        today: "bg-cyan-700 text-white hover:bg-cyan-800 dark:bg-cyan-600 dark:hover:bg-cyan-700",
        clear: "border border-gray-300 bg-white text-gray-900 hover:bg-gray-100 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:hover:bg-gray-600"
      }
    }
  },
  views: {
    days: {
      header: {
        base: "mb-1 grid grid-cols-7",
        title: "h-6 text-center text-sm font-medium leading-6 text-gray-500 dark:text-gray-400"
      },
      items: {
        base: "grid w-64 grid-cols-7",
        item: {
          base: "block flex-1 cursor-pointer rounded-lg border-0 text-center text-sm font-semibold leading-9 text-gray-900 hover:bg-gray-100 dark:text-white dark:hover:bg-gray-600 ",
          selected: "bg-cyan-700 text-white hover:bg-cyan-600",
          disabled: "text-gray-500"
        }
      }
    },
    months: {
      items: {
        base: "grid w-64 grid-cols-4",
        item: {
          base: "block flex-1 cursor-pointer rounded-lg border-0 text-center text-sm font-semibold leading-9 text-gray-900 hover:bg-gray-100 dark:text-white dark:hover:bg-gray-600",
          selected: "bg-cyan-700 text-white hover:bg-cyan-600",
          disabled: "text-gray-500"
        }
      }
    },
    years: {
      items: {
        base: "grid w-64 grid-cols-4",
        item: {
          base: "block flex-1 cursor-pointer rounded-lg border-0 text-center text-sm font-semibold leading-9 text-gray-900 hover:bg-gray-100 dark:text-white dark:hover:bg-gray-600",
          selected: "bg-cyan-700 text-white hover:bg-cyan-600",
          disabled: "text-gray-500"
        }
      }
    },
    decades: {
      items: {
        base: "grid w-64 grid-cols-4",
        item: {
          base: "block flex-1 cursor-pointer rounded-lg border-0 text-center text-sm font-semibold leading-9  text-gray-900 hover:bg-gray-100 dark:text-white dark:hover:bg-gray-600",
          selected: "bg-cyan-700 text-white hover:bg-cyan-600",
          disabled: "text-gray-500"
        }
      }
    }
  }
}, kS = {
  arrowIcon: "ml-2 h-4 w-4",
  content: "py-1 focus:outline-none",
  floating: {
    animation: "transition-opacity",
    arrow: {
      base: "absolute z-10 h-2 w-2 rotate-45",
      style: {
        dark: "bg-gray-900 dark:bg-gray-700",
        light: "bg-white",
        auto: "bg-white dark:bg-gray-700"
      },
      placement: "-4px"
    },
    base: "z-10 w-fit divide-y divide-gray-100 rounded shadow focus:outline-none",
    content: "py-1 text-sm text-gray-700 dark:text-gray-200",
    divider: "my-1 h-px bg-gray-100 dark:bg-gray-600",
    header: "block px-4 py-2 text-sm text-gray-700 dark:text-gray-200",
    hidden: "invisible opacity-0",
    item: {
      container: "",
      base: "flex w-full cursor-pointer items-center justify-start px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 focus:bg-gray-100 focus:outline-none dark:text-gray-200 dark:hover:bg-gray-600 dark:hover:text-white dark:focus:bg-gray-600 dark:focus:text-white",
      icon: "mr-2 h-4 w-4"
    },
    style: {
      dark: "bg-gray-900 text-white dark:bg-gray-700",
      light: "border border-gray-200 bg-white text-gray-900",
      auto: "border border-gray-200 bg-white text-gray-900 dark:border-none dark:bg-gray-700 dark:text-white"
    },
    target: "w-fit"
  },
  inlineWrapper: "flex items-center"
}, _S = {
  root: {
    base: "flex"
  },
  field: {
    base: "relative w-full",
    input: {
      base: "block w-full overflow-hidden rounded-lg border disabled:cursor-not-allowed disabled:opacity-50",
      sizes: {
        sm: "sm:text-xs",
        md: "text-sm",
        lg: "sm:text-base"
      },
      colors: {
        gray: "border-gray-300 bg-gray-50 text-gray-900 focus:border-cyan-500 focus:ring-cyan-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 dark:focus:border-cyan-500 dark:focus:ring-cyan-500",
        info: "border-cyan-500 bg-cyan-50 text-cyan-900 placeholder-cyan-700 focus:border-cyan-500 focus:ring-cyan-500 dark:border-cyan-400 dark:bg-cyan-100 dark:focus:border-cyan-500 dark:focus:ring-cyan-500",
        failure: "border-red-500 bg-red-50 text-red-900 placeholder-red-700 focus:border-red-500 focus:ring-red-500 dark:border-red-400 dark:bg-red-100 dark:focus:border-red-500 dark:focus:ring-red-500",
        warning: "border-yellow-500 bg-yellow-50 text-yellow-900 placeholder-yellow-700 focus:border-yellow-500 focus:ring-yellow-500 dark:border-yellow-400 dark:bg-yellow-100 dark:focus:border-yellow-500 dark:focus:ring-yellow-500",
        success: "border-green-500 bg-green-50 text-green-900 placeholder-green-700 focus:border-green-500 focus:ring-green-500 dark:border-green-400 dark:bg-green-100 dark:focus:border-green-500 dark:focus:ring-green-500"
      }
    }
  }
}, OS = {
  input: {
    default: {
      filled: {
        sm: "peer block w-full appearance-none rounded-t-lg border-0 border-b-2 border-gray-300 bg-gray-50 px-2.5 pb-2.5 pt-5 text-xs text-gray-900 focus:border-blue-600 focus:outline-none focus:ring-0 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:focus:border-blue-500",
        md: "peer block w-full appearance-none rounded-t-lg border-0 border-b-2 border-gray-300 bg-gray-50 px-2.5 pb-2.5 pt-5 text-sm text-gray-900 focus:border-blue-600 focus:outline-none focus:ring-0 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:focus:border-blue-500"
      },
      outlined: {
        sm: "peer block w-full appearance-none rounded-lg border border-gray-300 bg-transparent px-2.5 pb-2.5 pt-4 text-xs text-gray-900 focus:border-blue-600 focus:outline-none focus:ring-0 dark:border-gray-600 dark:text-white dark:focus:border-blue-500",
        md: "peer block w-full appearance-none rounded-lg border border-gray-300 bg-transparent px-2.5 pb-2.5 pt-4 text-sm text-gray-900 focus:border-blue-600 focus:outline-none focus:ring-0 dark:border-gray-600 dark:text-white dark:focus:border-blue-500"
      },
      standard: {
        sm: "peer block w-full appearance-none border-0 border-b-2 border-gray-300 bg-transparent px-0 py-2.5 text-xs text-gray-900 focus:border-blue-600 focus:outline-none focus:ring-0 dark:border-gray-600 dark:text-white dark:focus:border-blue-500",
        md: "peer block w-full appearance-none border-0 border-b-2 border-gray-300 bg-transparent px-0 py-2.5 text-sm text-gray-900 focus:border-blue-600 focus:outline-none focus:ring-0 dark:border-gray-600 dark:text-white dark:focus:border-blue-500"
      }
    },
    success: {
      filled: {
        sm: "peer block w-full appearance-none rounded-t-lg border-0 border-b-2 border-green-600 bg-gray-50 px-2.5 pb-2.5 pt-5 text-xs text-gray-900 focus:border-green-600 focus:outline-none focus:ring-0 dark:border-green-500 dark:bg-gray-700 dark:text-white dark:focus:border-green-500",
        md: "peer block w-full appearance-none rounded-t-lg border-0 border-b-2 border-green-600 bg-gray-50 px-2.5 pb-2.5 pt-5 text-sm text-gray-900 focus:border-green-600 focus:outline-none focus:ring-0 dark:border-green-500 dark:bg-gray-700 dark:text-white dark:focus:border-green-500"
      },
      outlined: {
        sm: "peer block w-full appearance-none rounded-lg border border-green-600 bg-transparent px-2.5 pb-2.5 pt-4 text-xs text-gray-900 focus:border-green-600 focus:outline-none focus:ring-0 dark:border-green-500 dark:text-white dark:focus:border-green-500",
        md: "peer block w-full appearance-none rounded-lg border border-green-600 bg-transparent px-2.5 pb-2.5 pt-4 text-sm text-gray-900 focus:border-green-600 focus:outline-none focus:ring-0 dark:border-green-500 dark:text-white dark:focus:border-green-500"
      },
      standard: {
        sm: "peer block w-full appearance-none border-0 border-b-2 border-green-600 bg-transparent px-0 py-2.5 text-xs text-gray-900 focus:border-green-600 focus:outline-none focus:ring-0 dark:border-green-500 dark:text-white dark:focus:border-green-500",
        md: "peer block w-full appearance-none border-0 border-b-2 border-green-600 bg-transparent px-0 py-2.5 text-sm text-gray-900 focus:border-green-600 focus:outline-none focus:ring-0 dark:border-green-500 dark:text-white dark:focus:border-green-500"
      }
    },
    error: {
      filled: {
        sm: "peer block w-full appearance-none rounded-t-lg border-0 border-b-2 border-red-600 bg-gray-50 px-2.5 pb-2.5 pt-5 text-xs text-gray-900 focus:border-red-600 focus:outline-none focus:ring-0 dark:border-red-500 dark:bg-gray-700 dark:text-white dark:focus:border-red-500",
        md: "peer block w-full appearance-none rounded-t-lg border-0 border-b-2 border-red-600 bg-gray-50 px-2.5 pb-2.5 pt-5 text-sm text-gray-900 focus:border-red-600 focus:outline-none focus:ring-0 dark:border-red-500 dark:bg-gray-700 dark:text-white dark:focus:border-red-500"
      },
      outlined: {
        sm: "peer block w-full appearance-none rounded-lg border border-red-600 bg-transparent px-2.5 pb-2.5 pt-4 text-xs text-gray-900 focus:border-red-600 focus:outline-none focus:ring-0 dark:border-red-500 dark:text-white dark:focus:border-red-500",
        md: "peer block w-full appearance-none rounded-lg border border-red-600 bg-transparent px-2.5 pb-2.5 pt-4 text-sm text-gray-900 focus:border-red-600 focus:outline-none focus:ring-0 dark:border-red-500 dark:text-white dark:focus:border-red-500"
      },
      standard: {
        sm: "peer block w-full appearance-none border-0 border-b-2 border-red-600 bg-transparent px-0 py-2.5 text-xs text-gray-900 focus:border-red-600 focus:outline-none focus:ring-0 dark:border-red-500 dark:text-white dark:focus:border-red-500",
        md: "peer block w-full appearance-none border-0 border-b-2 border-red-600 bg-transparent px-0 py-2.5 text-sm text-gray-900 focus:border-red-600 focus:outline-none focus:ring-0 dark:border-red-500 dark:text-white dark:focus:border-red-500"
      }
    }
  },
  label: {
    default: {
      filled: {
        sm: "absolute left-2.5 top-4 z-10 origin-[0] -translate-y-4 scale-75 text-xs text-gray-500 transition-transform  duration-300 peer-placeholder-shown:translate-y-0 peer-placeholder-shown:scale-100 peer-focus:-translate-y-4 peer-focus:scale-75 peer-focus:text-blue-600 dark:text-gray-400 peer-focus:dark:text-blue-500",
        md: "absolute left-2.5 top-4 z-10 origin-[0] -translate-y-4 scale-75 text-sm text-gray-500 transition-transform duration-300 peer-placeholder-shown:translate-y-0 peer-placeholder-shown:scale-100 peer-focus:-translate-y-4 peer-focus:scale-75 peer-focus:text-blue-600 dark:text-gray-400 peer-focus:dark:text-blue-500"
      },
      outlined: {
        sm: "absolute left-1 top-2 z-10 origin-[0] -translate-y-4 scale-75 bg-white px-2 text-xs text-gray-500 transition-transform duration-300 peer-placeholder-shown:top-1/2 peer-placeholder-shown:-translate-y-1/2 peer-placeholder-shown:scale-100 peer-focus:top-2 peer-focus:-translate-y-4 peer-focus:scale-75 peer-focus:px-2 peer-focus:text-blue-600 dark:bg-gray-900 dark:text-gray-400 peer-focus:dark:text-blue-500",
        md: "absolute left-1 top-2 z-10 origin-[0] -translate-y-4 scale-75 bg-white px-2 text-sm text-gray-500 transition-transform duration-300 peer-placeholder-shown:top-1/2 peer-placeholder-shown:-translate-y-1/2 peer-placeholder-shown:scale-100 peer-focus:top-2 peer-focus:-translate-y-4 peer-focus:scale-75 peer-focus:px-2 peer-focus:text-blue-600 dark:bg-gray-900 dark:text-gray-400 peer-focus:dark:text-blue-500"
      },
      standard: {
        sm: "absolute top-3 -z-10 origin-[0] -translate-y-6 scale-75 text-xs text-gray-500 transition-transform duration-300 peer-placeholder-shown:translate-y-0 peer-placeholder-shown:scale-100 peer-focus:left-0 peer-focus:-translate-y-6 peer-focus:scale-75 peer-focus:text-blue-600 dark:text-gray-400 peer-focus:dark:text-blue-500",
        md: "absolute top-3 -z-10 origin-[0] -translate-y-6 scale-75 text-sm text-gray-500 transition-transform duration-300 peer-placeholder-shown:translate-y-0 peer-placeholder-shown:scale-100 peer-focus:left-0 peer-focus:-translate-y-6 peer-focus:scale-75 peer-focus:text-blue-600 dark:text-gray-400 peer-focus:dark:text-blue-500"
      }
    },
    success: {
      filled: {
        sm: "absolute left-2.5 top-4 z-10 origin-[0] -translate-y-4 scale-75 text-sm text-green-600 transition-transform duration-300 peer-placeholder-shown:translate-y-0 peer-placeholder-shown:scale-100 peer-focus:-translate-y-4 peer-focus:scale-75 dark:text-green-500",
        md: "absolute left-2.5 top-4 z-10 origin-[0] -translate-y-4 scale-75 text-sm text-green-600 transition-transform duration-300 peer-placeholder-shown:translate-y-0 peer-placeholder-shown:scale-100 peer-focus:-translate-y-4 peer-focus:scale-75 dark:text-green-500"
      },
      outlined: {
        sm: "absolute left-1 top-2 z-10 origin-[0] -translate-y-4 scale-75 bg-white px-2 text-sm text-green-600 transition-transform duration-300 peer-placeholder-shown:top-1/2 peer-placeholder-shown:-translate-y-1/2 peer-placeholder-shown:scale-100 peer-focus:top-2 peer-focus:-translate-y-4 peer-focus:scale-75 peer-focus:px-2 dark:bg-gray-900 dark:text-green-500",
        md: "absolute left-1 top-2 z-10 origin-[0] -translate-y-4 scale-75 bg-white px-2 text-sm text-green-600 transition-transform duration-300 peer-placeholder-shown:top-1/2 peer-placeholder-shown:-translate-y-1/2 peer-placeholder-shown:scale-100 peer-focus:top-2 peer-focus:-translate-y-4 peer-focus:scale-75 peer-focus:px-2 dark:bg-gray-900 dark:text-green-500"
      },
      standard: {
        sm: "absolute top-3 -z-10 origin-[0] -translate-y-6 scale-75 text-xs text-green-600 transition-transform duration-300 peer-placeholder-shown:translate-y-0 peer-placeholder-shown:scale-100 peer-focus:left-0 peer-focus:-translate-y-6 peer-focus:scale-75 dark:text-green-500",
        md: "absolute top-3 -z-10 origin-[0] -translate-y-6 scale-75 text-sm text-green-600 transition-transform duration-300 peer-placeholder-shown:translate-y-0 peer-placeholder-shown:scale-100 peer-focus:left-0 peer-focus:-translate-y-6 peer-focus:scale-75 dark:text-green-500"
      }
    },
    error: {
      filled: {
        sm: "absolute left-2.5 top-4 z-10 origin-[0] -translate-y-4 scale-75 text-xs text-red-600 transition-transform duration-300 peer-placeholder-shown:translate-y-0 peer-placeholder-shown:scale-100 peer-focus:-translate-y-4 peer-focus:scale-75 dark:text-red-500",
        md: "absolute left-2.5 top-4 z-10 origin-[0] -translate-y-4 scale-75 text-xs text-red-600 transition-transform duration-300 peer-placeholder-shown:translate-y-0 peer-placeholder-shown:scale-100 peer-focus:-translate-y-4 peer-focus:scale-75 dark:text-red-500"
      },
      outlined: {
        sm: "absolute left-1 top-2 z-10 origin-[0] -translate-y-4 scale-75 bg-white px-2 text-xs text-red-600 transition-transform duration-300 peer-placeholder-shown:top-1/2 peer-placeholder-shown:-translate-y-1/2 peer-placeholder-shown:scale-100 peer-focus:top-2 peer-focus:-translate-y-4 peer-focus:scale-75 peer-focus:px-2 dark:bg-gray-900 dark:text-red-500",
        md: "absolute left-1 top-2 z-10 origin-[0] -translate-y-4 scale-75 bg-white px-2 text-xs text-red-600 transition-transform duration-300 peer-placeholder-shown:top-1/2 peer-placeholder-shown:-translate-y-1/2 peer-placeholder-shown:scale-100 peer-focus:top-2 peer-focus:-translate-y-4 peer-focus:scale-75 peer-focus:px-2 dark:bg-gray-900 dark:text-red-500"
      },
      standard: {
        sm: "absolute top-3 -z-10 origin-[0] -translate-y-6 scale-75 text-xs text-red-600 transition-transform duration-300 peer-placeholder-shown:translate-y-0 peer-placeholder-shown:scale-100 peer-focus:left-0 peer-focus:-translate-y-6 peer-focus:scale-75 dark:text-red-500",
        md: "absolute top-3 -z-10 origin-[0] -translate-y-6 scale-75 text-sm text-red-600 transition-transform duration-300 peer-placeholder-shown:translate-y-0 peer-placeholder-shown:scale-100 peer-focus:left-0 peer-focus:-translate-y-6 peer-focus:scale-75 dark:text-red-500"
      }
    }
  },
  helperText: {
    default: "mt-2 text-xs text-gray-600 dark:text-gray-400",
    success: "mt-2 text-xs text-green-600 dark:text-green-400",
    error: "mt-2 text-xs text-red-600 dark:text-red-400"
  }
}, SS = {
  root: {
    base: "w-full rounded-lg bg-white shadow dark:bg-gray-800 md:flex md:items-center md:justify-between",
    container: "w-full p-6",
    bgDark: "bg-gray-800"
  },
  groupLink: {
    base: "flex flex-wrap text-sm text-gray-500 dark:text-white",
    link: {
      base: "me-4 last:mr-0 md:mr-6",
      href: "hover:underline"
    },
    col: "flex-col space-y-4"
  },
  icon: {
    base: "text-gray-500 dark:hover:text-white",
    size: "h-5 w-5"
  },
  title: {
    base: "mb-6 text-sm font-semibold uppercase text-gray-500 dark:text-white"
  },
  divider: {
    base: "my-6 w-full border-gray-200 dark:border-gray-700 sm:mx-auto lg:my-8"
  },
  copyright: {
    base: "text-sm text-gray-500 dark:text-gray-400 sm:text-center",
    href: "ml-1 hover:underline",
    span: "ml-1"
  },
  brand: {
    base: "mb-4 flex items-center sm:mb-0",
    img: "mr-3 h-8",
    span: "self-center whitespace-nowrap text-2xl font-semibold text-gray-800 dark:text-white"
  }
}, DS = {
  root: {
    base: "mt-2 text-sm",
    colors: {
      gray: "text-gray-500 dark:text-gray-400",
      info: "text-cyan-700 dark:text-cyan-800",
      success: "text-green-600 dark:text-green-500",
      failure: "text-red-600 dark:text-red-500",
      warning: "text-yellow-500 dark:text-yellow-600"
    }
  }
}, MS$1 = {
  root: {
    base: "rounded-lg border border-gray-200 bg-gray-100 px-2 py-1.5 text-xs font-semibold text-gray-800 dark:border-gray-500 dark:bg-gray-600 dark:text-gray-100",
    icon: "inline-block"
  }
}, CS = {
  root: {
    base: "text-sm font-medium",
    disabled: "opacity-50",
    colors: {
      default: "text-gray-900 dark:text-white",
      info: "text-cyan-500 dark:text-cyan-600",
      failure: "text-red-700 dark:text-red-500",
      warning: "text-yellow-500 dark:text-yellow-600",
      success: "text-green-700 dark:text-green-500"
    }
  }
}, ES = {
  root: {
    base: "list-inside space-y-1 text-gray-500 dark:text-gray-400",
    ordered: {
      off: "list-disc",
      on: "list-decimal"
    },
    horizontal: "flex list-none flex-wrap items-center justify-center space-x-4 space-y-0",
    unstyled: "list-none",
    nested: "mt-2 ps-5"
  },
  item: {
    withIcon: {
      off: "",
      on: "flex items-center"
    },
    icon: "me-2 h-3.5 w-3.5 flex-shrink-0"
  }
}, TS = {
  root: {
    base: "list-none rounded-lg border border-gray-200 bg-white text-left text-sm font-medium text-gray-900 dark:border-gray-600 dark:bg-gray-700 dark:text-white"
  },
  item: {
    base: "[&>*]:first:rounded-t-lg [&>*]:last:rounded-b-lg [&>*]:last:border-b-0",
    link: {
      base: "flex w-full items-center border-b border-gray-200 px-4 py-2 dark:border-gray-600",
      active: {
        off: "hover:bg-gray-100 hover:text-cyan-700 focus:text-cyan-700 focus:outline-none focus:ring-2 focus:ring-cyan-700 dark:border-gray-600 dark:hover:bg-gray-600 dark:hover:text-white dark:focus:text-white dark:focus:ring-gray-500",
        on: "bg-cyan-700 text-white dark:bg-gray-800"
      },
      disabled: {
        off: "",
        on: "cursor-not-allowed bg-gray-100 text-gray-900 hover:bg-gray-100 hover:text-gray-900 focus:text-gray-900"
      },
      href: {
        off: "",
        on: ""
      },
      icon: "mr-2 h-4 w-4 fill-current"
    }
  }
}, PS = {
  root: {
    base: "fixed inset-x-0 top-0 z-50 h-screen overflow-y-auto overflow-x-hidden md:inset-0 md:h-full",
    show: {
      on: "flex bg-gray-900 bg-opacity-50 dark:bg-opacity-80",
      off: "hidden"
    },
    sizes: {
      sm: "max-w-sm",
      md: "max-w-md",
      lg: "max-w-lg",
      xl: "max-w-xl",
      "2xl": "max-w-2xl",
      "3xl": "max-w-3xl",
      "4xl": "max-w-4xl",
      "5xl": "max-w-5xl",
      "6xl": "max-w-6xl",
      "7xl": "max-w-7xl"
    },
    positions: {
      "top-left": "items-start justify-start",
      "top-center": "items-start justify-center",
      "top-right": "items-start justify-end",
      "center-left": "items-center justify-start",
      center: "items-center justify-center",
      "center-right": "items-center justify-end",
      "bottom-right": "items-end justify-end",
      "bottom-center": "items-end justify-center",
      "bottom-left": "items-end justify-start"
    }
  },
  content: {
    base: "relative h-full w-full p-4 md:h-auto",
    inner: "relative flex max-h-[90dvh] flex-col rounded-lg bg-white shadow dark:bg-gray-700"
  },
  body: {
    base: "flex-1 overflow-auto p-6",
    popup: "pt-0"
  },
  header: {
    base: "flex items-start justify-between rounded-t border-b p-5 dark:border-gray-600",
    popup: "border-b-0 p-2",
    title: "text-xl font-medium text-gray-900 dark:text-white",
    close: {
      base: "ml-auto inline-flex items-center rounded-lg bg-transparent p-1.5 text-sm text-gray-400 hover:bg-gray-200 hover:text-gray-900 dark:hover:bg-gray-600 dark:hover:text-white",
      icon: "h-5 w-5"
    }
  },
  footer: {
    base: "flex items-center space-x-2 rounded-b border-gray-200 p-6 dark:border-gray-600",
    popup: "border-t"
  }
}, RS = {
  root: {
    base: "bg-white px-2 py-2.5 dark:border-gray-700 dark:bg-gray-800 sm:px-4",
    rounded: {
      on: "rounded",
      off: ""
    },
    bordered: {
      on: "border",
      off: ""
    },
    inner: {
      base: "mx-auto flex flex-wrap items-center justify-between",
      fluid: {
        on: "",
        off: "container"
      }
    }
  },
  brand: {
    base: "flex items-center"
  },
  collapse: {
    base: "w-full md:block md:w-auto",
    list: "mt-4 flex flex-col md:mt-0 md:flex-row md:space-x-8 md:text-sm md:font-medium",
    hidden: {
      on: "hidden",
      off: ""
    }
  },
  link: {
    base: "block py-2 pl-3 pr-4 md:p-0",
    active: {
      on: "bg-cyan-700 text-white dark:text-white md:bg-transparent md:text-cyan-700",
      off: "border-b border-gray-100  text-gray-700 hover:bg-gray-50 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white md:border-0 md:hover:bg-transparent md:hover:text-cyan-700 md:dark:hover:bg-transparent md:dark:hover:text-white"
    },
    disabled: {
      on: "text-gray-400 hover:cursor-not-allowed dark:text-gray-600",
      off: ""
    }
  },
  toggle: {
    base: "inline-flex items-center rounded-lg p-2 text-sm text-gray-500 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600 md:hidden",
    icon: "h-6 w-6 shrink-0"
  }
}, NS = {
  base: "",
  layout: {
    table: {
      base: "text-sm text-gray-700 dark:text-gray-400",
      span: "font-semibold text-gray-900 dark:text-white"
    }
  },
  pages: {
    base: "xs:mt-0 mt-2 inline-flex items-center -space-x-px",
    showIcon: "inline-flex",
    previous: {
      base: "ml-0 rounded-l-lg border border-gray-300 bg-white px-3 py-2 leading-tight text-gray-500 enabled:hover:bg-gray-100 enabled:hover:text-gray-700 dark:border-gray-700 dark:bg-gray-800 dark:text-gray-400 enabled:dark:hover:bg-gray-700 enabled:dark:hover:text-white",
      icon: "h-5 w-5"
    },
    next: {
      base: "rounded-r-lg border border-gray-300 bg-white px-3 py-2 leading-tight text-gray-500 enabled:hover:bg-gray-100 enabled:hover:text-gray-700 dark:border-gray-700 dark:bg-gray-800 dark:text-gray-400 enabled:dark:hover:bg-gray-700 enabled:dark:hover:text-white",
      icon: "h-5 w-5"
    },
    selector: {
      base: "w-12 border border-gray-300 bg-white py-2 leading-tight text-gray-500 enabled:hover:bg-gray-100 enabled:hover:text-gray-700 dark:border-gray-700 dark:bg-gray-800 dark:text-gray-400 enabled:dark:hover:bg-gray-700 enabled:dark:hover:text-white",
      active: "bg-cyan-50 text-cyan-600 hover:bg-cyan-100 hover:text-cyan-700 dark:border-gray-700 dark:bg-gray-700 dark:text-white",
      disabled: "cursor-not-allowed opacity-50"
    }
  }
}, IS = {
  base: "absolute z-20 inline-block w-max max-w-[100vw] bg-white outline-none border border-gray-200 rounded-lg shadow-sm dark:border-gray-600 dark:bg-gray-800",
  content: "z-10 overflow-hidden rounded-[7px]",
  arrow: {
    base: "absolute h-2 w-2 z-0 rotate-45 mix-blend-lighten bg-white border border-gray-200 dark:border-gray-600 dark:bg-gray-800 dark:mix-blend-color",
    placement: "-4px"
  }
}, AS = {
  base: "w-full overflow-hidden rounded-full bg-gray-200 dark:bg-gray-700",
  label: "mb-1 flex justify-between font-medium dark:text-white",
  bar: "space-x-2 rounded-full text-center font-medium leading-none text-cyan-300 dark:text-cyan-100",
  color: {
    dark: "bg-gray-600 dark:bg-gray-300",
    blue: "bg-blue-600",
    red: "bg-red-600 dark:bg-red-500",
    green: "bg-green-600 dark:bg-green-500",
    yellow: "bg-yellow-400",
    indigo: "bg-indigo-600 dark:bg-indigo-500",
    purple: "bg-purple-600 dark:bg-purple-500",
    cyan: "bg-cyan-600",
    gray: "bg-gray-500",
    lime: "bg-lime-600",
    pink: "bg-pink-500",
    teal: "bg-teal-600"
  },
  size: {
    sm: "h-1.5",
    md: "h-2.5",
    lg: "h-4",
    xl: "h-6"
  }
}, FS = {
  root: {
    base: "h-4 w-4 border border-gray-300 text-cyan-600 focus:ring-2 focus:ring-cyan-500 dark:border-gray-600 dark:bg-gray-700 dark:focus:bg-cyan-600 dark:focus:ring-cyan-600"
  }
}, LS = {
  root: {
    base: "flex"
  },
  field: {
    base: "relative w-full",
    input: {
      base: "w-full cursor-pointer appearance-none rounded-lg bg-gray-200 dark:bg-gray-700",
      sizes: {
        sm: "h-1",
        md: "h-2",
        lg: "h-3"
      }
    }
  }
}, WS = {
  root: {
    base: "flex items-center"
  },
  star: {
    empty: "text-gray-300 dark:text-gray-500",
    filled: "text-yellow-400",
    sizes: {
      sm: "h-5 w-5",
      md: "h-7 w-7",
      lg: "h-10 w-10"
    }
  }
}, $S = {
  base: "flex items-center",
  label: "text-sm font-medium text-cyan-600 dark:text-cyan-500",
  progress: {
    base: "mx-4 h-5 w-2/4 rounded bg-gray-200 dark:bg-gray-700",
    fill: "h-5 rounded bg-yellow-400",
    label: "text-sm font-medium text-cyan-600 dark:text-cyan-500"
  }
}, zS = {
  base: "flex",
  addon: "inline-flex items-center rounded-l-md border border-r-0 border-gray-300 bg-gray-200 px-3 text-sm text-gray-900 dark:border-gray-600 dark:bg-gray-600 dark:text-gray-400",
  field: {
    base: "relative w-full",
    icon: {
      base: "pointer-events-none absolute inset-y-0 left-0 flex items-center pl-3",
      svg: "h-5 w-5 text-gray-500 dark:text-gray-400"
    },
    select: {
      base: "block w-full border disabled:cursor-not-allowed disabled:opacity-50",
      withIcon: {
        on: "pl-10",
        off: ""
      },
      withAddon: {
        on: "rounded-r-lg",
        off: "rounded-lg"
      },
      withShadow: {
        on: "shadow-sm dark:shadow-sm-light",
        off: ""
      },
      sizes: {
        sm: "p-2 sm:text-xs",
        md: "p-2.5 text-sm",
        lg: "p-4 sm:text-base"
      },
      colors: {
        gray: "border-gray-300 bg-gray-50 text-gray-900 focus:border-cyan-500 focus:ring-cyan-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 dark:focus:border-cyan-500 dark:focus:ring-cyan-500",
        info: "border-cyan-500 bg-cyan-50 text-cyan-900 placeholder-cyan-700 focus:border-cyan-500 focus:ring-cyan-500 dark:border-cyan-400 dark:bg-cyan-100 dark:focus:border-cyan-500 dark:focus:ring-cyan-500",
        failure: "border-red-500 bg-red-50 text-red-900 placeholder-red-700 focus:border-red-500 focus:ring-red-500 dark:border-red-400 dark:bg-red-100 dark:focus:border-red-500 dark:focus:ring-red-500",
        warning: "border-yellow-500 bg-yellow-50 text-yellow-900 placeholder-yellow-700 focus:border-yellow-500 focus:ring-yellow-500 dark:border-yellow-400 dark:bg-yellow-100 dark:focus:border-yellow-500 dark:focus:ring-yellow-500",
        success: "border-green-500 bg-green-50 text-green-900 placeholder-green-700 focus:border-green-500 focus:ring-green-500 dark:border-green-400 dark:bg-green-100 dark:focus:border-green-500 dark:focus:ring-green-500"
      }
    }
  }
}, jS = {
  root: {
    base: "h-full",
    collapsed: {
      on: "w-16",
      off: "w-64"
    },
    inner: "h-full overflow-y-auto overflow-x-hidden rounded bg-gray-50 px-3 py-4 dark:bg-gray-800"
  },
  collapse: {
    button: "group flex w-full items-center rounded-lg p-2 text-base font-normal text-gray-900 transition duration-75 hover:bg-gray-100 dark:text-white dark:hover:bg-gray-700",
    icon: {
      base: "h-6 w-6 text-gray-500 transition duration-75 group-hover:text-gray-900 dark:text-gray-400 dark:group-hover:text-white",
      open: {
        off: "",
        on: "text-gray-900"
      }
    },
    label: {
      base: "ml-3 flex-1 whitespace-nowrap text-left",
      icon: {
        base: "h-6 w-6 transition delay-0 ease-in-out",
        open: {
          on: "rotate-180",
          off: ""
        }
      }
    },
    list: "space-y-2 py-2"
  },
  cta: {
    base: "mt-6 rounded-lg bg-gray-100 p-4 dark:bg-gray-700",
    color: {
      blue: "bg-cyan-50 dark:bg-cyan-900",
      dark: "bg-dark-50 dark:bg-dark-900",
      failure: "bg-red-50 dark:bg-red-900",
      gray: "bg-alternative-50 dark:bg-alternative-900",
      green: "bg-green-50 dark:bg-green-900",
      light: "bg-light-50 dark:bg-light-900",
      red: "bg-red-50 dark:bg-red-900",
      purple: "bg-purple-50 dark:bg-purple-900",
      success: "bg-green-50 dark:bg-green-900",
      yellow: "bg-yellow-50 dark:bg-yellow-900",
      warning: "bg-yellow-50 dark:bg-yellow-900"
    }
  },
  item: {
    base: "flex items-center justify-center rounded-lg p-2 text-base font-normal text-gray-900 hover:bg-gray-100 dark:text-white dark:hover:bg-gray-700",
    active: "bg-gray-100 dark:bg-gray-700",
    collapsed: {
      insideCollapse: "group w-full pl-8 transition duration-75",
      noIcon: "font-bold"
    },
    content: {
      base: "flex-1 whitespace-nowrap px-3"
    },
    icon: {
      base: "h-6 w-6 flex-shrink-0 text-gray-500 transition duration-75 group-hover:text-gray-900 dark:text-gray-400 dark:group-hover:text-white",
      active: "text-gray-700 dark:text-gray-100"
    },
    label: "",
    listItem: ""
  },
  items: {
    base: ""
  },
  itemGroup: {
    base: "mt-4 space-y-2 border-t border-gray-200 pt-4 first:mt-0 first:border-t-0 first:pt-0 dark:border-gray-700"
  },
  logo: {
    base: "mb-5 flex items-center pl-2.5",
    collapsed: {
      on: "hidden",
      off: "self-center whitespace-nowrap text-xl font-semibold dark:text-white"
    },
    img: "mr-3 h-6 sm:h-7"
  }
}, HS = {
  base: "inline animate-spin text-gray-200",
  color: {
    failure: "fill-red-600",
    gray: "fill-gray-600",
    info: "fill-cyan-600",
    pink: "fill-pink-600",
    purple: "fill-purple-600",
    success: "fill-green-500",
    warning: "fill-yellow-400"
  },
  light: {
    off: {
      base: "dark:text-gray-600",
      color: {
        failure: "",
        gray: "dark:fill-gray-300",
        info: "",
        pink: "",
        purple: "",
        success: "",
        warning: ""
      }
    },
    on: {
      base: "",
      color: {
        failure: "",
        gray: "",
        info: "",
        pink: "",
        purple: "",
        success: "",
        warning: ""
      }
    }
  },
  size: {
    xs: "h-3 w-3",
    sm: "h-4 w-4",
    md: "h-6 w-6",
    lg: "h-8 w-8",
    xl: "h-10 w-10"
  }
}, BS = {
  root: {
    base: "w-full text-left text-sm text-gray-500 dark:text-gray-400",
    shadow: "absolute left-0 top-0 -z-10 h-full w-full rounded-lg bg-white drop-shadow-md dark:bg-black",
    wrapper: "relative"
  },
  body: {
    base: "group/body",
    cell: {
      base: "px-6 py-4 group-first/body:group-first/row:first:rounded-tl-lg group-first/body:group-first/row:last:rounded-tr-lg group-last/body:group-last/row:first:rounded-bl-lg group-last/body:group-last/row:last:rounded-br-lg"
    }
  },
  head: {
    base: "group/head text-xs uppercase text-gray-700 dark:text-gray-400",
    cell: {
      base: "bg-gray-50 px-6 py-3 group-first/head:first:rounded-tl-lg group-first/head:last:rounded-tr-lg dark:bg-gray-700"
    }
  },
  row: {
    base: "group/row",
    hovered: "hover:bg-gray-50 dark:hover:bg-gray-600",
    striped: "odd:bg-white even:bg-gray-50 odd:dark:bg-gray-800 even:dark:bg-gray-700"
  }
}, YS = {
  base: "flex flex-col gap-2",
  tablist: {
    base: "flex text-center",
    styles: {
      default: "flex-wrap border-b border-gray-200 dark:border-gray-700",
      underline: "-mb-px flex-wrap border-b border-gray-200 dark:border-gray-700",
      pills: "flex-wrap space-x-2 text-sm font-medium text-gray-500 dark:text-gray-400",
      fullWidth: "grid w-full grid-flow-col divide-x divide-gray-200 rounded-none text-sm font-medium shadow dark:divide-gray-700 dark:text-gray-400"
    },
    tabitem: {
      base: "flex items-center justify-center rounded-t-lg p-4 text-sm font-medium first:ml-0 focus:outline-none focus:ring-4 focus:ring-cyan-300 disabled:cursor-not-allowed disabled:text-gray-400 disabled:dark:text-gray-500",
      styles: {
        default: {
          base: "rounded-t-lg",
          active: {
            on: "bg-gray-100 text-cyan-600 dark:bg-gray-800 dark:text-cyan-500",
            off: "text-gray-500 hover:bg-gray-50 hover:text-gray-600 dark:text-gray-400 dark:hover:bg-gray-800  dark:hover:text-gray-300"
          }
        },
        underline: {
          base: "rounded-t-lg",
          active: {
            on: "active rounded-t-lg border-b-2 border-cyan-600 text-cyan-600 dark:border-cyan-500 dark:text-cyan-500",
            off: "border-b-2 border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-600 dark:text-gray-400 dark:hover:text-gray-300"
          }
        },
        pills: {
          base: "",
          active: {
            on: "rounded-lg bg-cyan-600 text-white",
            off: "rounded-lg hover:bg-gray-100 hover:text-gray-900 dark:hover:bg-gray-800 dark:hover:text-white"
          }
        },
        fullWidth: {
          base: "ml-0 flex w-full rounded-none first:ml-0",
          active: {
            on: "active rounded-none bg-gray-100 p-4 text-gray-900 dark:bg-gray-700 dark:text-white",
            off: "rounded-none bg-white hover:bg-gray-50 hover:text-gray-700 dark:bg-gray-800 dark:hover:bg-gray-700 dark:hover:text-white"
          }
        }
      },
      icon: "mr-2 h-5 w-5"
    }
  },
  tabitemcontainer: {
    base: "",
    styles: {
      default: "",
      underline: "",
      pills: "",
      fullWidth: ""
    }
  },
  tabpanel: "py-3"
}, VS = {
  base: "block w-full rounded-lg border text-sm disabled:cursor-not-allowed disabled:opacity-50",
  colors: {
    gray: "border-gray-300 bg-gray-50 text-gray-900 focus:border-cyan-500 focus:ring-cyan-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 dark:focus:border-cyan-500 dark:focus:ring-cyan-500",
    info: "border-cyan-500 bg-cyan-50 text-cyan-900 placeholder-cyan-700 focus:border-cyan-500 focus:ring-cyan-500 dark:border-cyan-400 dark:bg-cyan-100 dark:focus:border-cyan-500 dark:focus:ring-cyan-500",
    failure: "border-red-500 bg-red-50 text-red-900 placeholder-red-700 focus:border-red-500 focus:ring-red-500 dark:border-red-400 dark:bg-red-100 dark:focus:border-red-500 dark:focus:ring-red-500",
    warning: "border-yellow-500 bg-yellow-50 text-yellow-900 placeholder-yellow-700 focus:border-yellow-500 focus:ring-yellow-500 dark:border-yellow-400 dark:bg-yellow-100 dark:focus:border-yellow-500 dark:focus:ring-yellow-500",
    success: "border-green-500 bg-green-50 text-green-900 placeholder-green-700 focus:border-green-500 focus:ring-green-500 dark:border-green-400 dark:bg-green-100 dark:focus:border-green-500 dark:focus:ring-green-500"
  },
  withShadow: {
    on: "shadow-sm dark:shadow-sm-light",
    off: ""
  }
}, qS = {
  base: "flex",
  addon: "inline-flex items-center rounded-l-md border border-r-0 border-gray-300 bg-gray-200 px-3 text-sm text-gray-900 dark:border-gray-600 dark:bg-gray-600 dark:text-gray-400",
  field: {
    base: "relative w-full",
    icon: {
      base: "pointer-events-none absolute inset-y-0 left-0 flex items-center pl-3",
      svg: "h-5 w-5 text-gray-500 dark:text-gray-400"
    },
    rightIcon: {
      base: "pointer-events-none absolute inset-y-0 right-0 flex items-center pr-3",
      svg: "h-5 w-5 text-gray-500 dark:text-gray-400"
    },
    input: {
      base: "block w-full border disabled:cursor-not-allowed disabled:opacity-50",
      sizes: {
        sm: "p-2 sm:text-xs",
        md: "p-2.5 text-sm",
        lg: "p-4 sm:text-base"
      },
      colors: {
        gray: "border-gray-300 bg-gray-50 text-gray-900 focus:border-cyan-500 focus:ring-cyan-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 dark:focus:border-cyan-500 dark:focus:ring-cyan-500",
        info: "border-cyan-500 bg-cyan-50 text-cyan-900 placeholder-cyan-700 focus:border-cyan-500 focus:ring-cyan-500 dark:border-cyan-400 dark:bg-cyan-100 dark:focus:border-cyan-500 dark:focus:ring-cyan-500",
        failure: "border-red-500 bg-red-50 text-red-900 placeholder-red-700 focus:border-red-500 focus:ring-red-500 dark:border-red-400 dark:bg-red-100 dark:focus:border-red-500 dark:focus:ring-red-500",
        warning: "border-yellow-500 bg-yellow-50 text-yellow-900 placeholder-yellow-700 focus:border-yellow-500 focus:ring-yellow-500 dark:border-yellow-400 dark:bg-yellow-100 dark:focus:border-yellow-500 dark:focus:ring-yellow-500",
        success: "border-green-500 bg-green-50 text-green-900 placeholder-green-700 focus:border-green-500 focus:ring-green-500 dark:border-green-400 dark:bg-green-100 dark:focus:border-green-500 dark:focus:ring-green-500"
      },
      withRightIcon: {
        on: "pr-10",
        off: ""
      },
      withIcon: {
        on: "pl-10",
        off: ""
      },
      withAddon: {
        on: "rounded-r-lg",
        off: "rounded-lg"
      },
      withShadow: {
        on: "shadow-sm dark:shadow-sm-light",
        off: ""
      }
    }
  }
}, US = {
  root: {
    direction: {
      horizontal: "sm:flex",
      vertical: "relative border-l border-gray-200 dark:border-gray-700"
    }
  },
  item: {
    root: {
      horizontal: "relative mb-6 sm:mb-0",
      vertical: "mb-10 ml-6"
    },
    content: {
      root: {
        base: "mt-3 sm:pr-8"
      },
      body: {
        base: "mb-4 text-base font-normal text-gray-500 dark:text-gray-400"
      },
      time: {
        base: "mb-1 text-sm font-normal leading-none text-gray-400 dark:text-gray-500"
      },
      title: {
        base: "text-lg font-semibold text-gray-900 dark:text-white"
      }
    },
    point: {
      horizontal: "flex items-center",
      line: "hidden h-0.5 w-full bg-gray-200 dark:bg-gray-700 sm:flex",
      marker: {
        base: {
          horizontal: "absolute -left-1.5 h-3 w-3 rounded-full border border-white bg-gray-200 dark:border-gray-900 dark:bg-gray-700",
          vertical: "absolute -left-1.5 mt-1.5 h-3 w-3 rounded-full border border-white bg-gray-200 dark:border-gray-900 dark:bg-gray-700"
        },
        icon: {
          base: "h-3 w-3 text-cyan-600 dark:text-cyan-300",
          wrapper: "absolute -left-3 flex h-6 w-6 items-center justify-center rounded-full bg-cyan-200 ring-8 ring-white dark:bg-cyan-900 dark:ring-gray-900"
        }
      },
      vertical: ""
    }
  }
}, XS = {
  root: {
    base: "flex w-full max-w-xs items-center rounded-lg bg-white p-4 text-gray-500 shadow dark:bg-gray-800 dark:text-gray-400",
    closed: "opacity-0 ease-out"
  },
  toggle: {
    base: "-m-1.5 ml-auto inline-flex h-8 w-8 rounded-lg bg-white p-1.5 text-gray-400 hover:bg-gray-100 hover:text-gray-900 focus:ring-2 focus:ring-gray-300 dark:bg-gray-800 dark:text-gray-500 dark:hover:bg-gray-700 dark:hover:text-white",
    icon: "h-5 w-5 shrink-0"
  }
}, GS = {
  root: {
    base: "group relative flex items-center rounded-lg focus:outline-none",
    active: {
      on: "cursor-pointer",
      off: "cursor-not-allowed opacity-50"
    },
    label: "ml-3 text-sm font-medium text-gray-900 dark:text-gray-300"
  },
  toggle: {
    base: "rounded-full border group-focus:ring-4 group-focus:ring-cyan-500/25",
    checked: {
      on: "after:translate-x-full after:border-white",
      off: "border-gray-200 bg-gray-200 dark:border-gray-600 dark:bg-gray-700",
      color: {
        blue: "border-cyan-700 bg-cyan-700",
        dark: "bg-dark-700 border-dark-900",
        failure: "border-red-900 bg-red-700",
        gray: "border-gray-600 bg-gray-500",
        green: "border-green-700 bg-green-600",
        light: "bg-light-700 border-light-900",
        red: "border-red-900 bg-red-700",
        purple: "border-purple-900 bg-purple-700",
        success: "border-green-500 bg-green-500",
        yellow: "border-yellow-400 bg-yellow-400",
        warning: "border-yellow-600 bg-yellow-600",
        cyan: "border-cyan-500 bg-cyan-500",
        lime: "border-lime-400 bg-lime-400",
        indigo: "border-indigo-400 bg-indigo-400",
        teal: "bg-gradient-to-r from-teal-400 via-teal-500 to-teal-600 hover:bg-gradient-to-br focus:ring-4",
        info: "border-cyan-600 bg-cyan-600",
        pink: "border-pink-600 bg-pink-600"
      }
    },
    sizes: {
      sm: "h-5 w-9 after:absolute after:left-[2px] after:top-[2px] after:h-4 after:w-4",
      md: "h-6 w-11 after:absolute after:left-[2px] after:top-[2px] after:h-5 after:w-5",
      lg: "h-7 w-14 after:absolute after:left-[4px] after:top-0.5 after:h-6 after:w-6"
    }
  }
}, KS = {
  target: "w-fit",
  animation: "transition-opacity",
  arrow: {
    base: "absolute z-10 h-2 w-2 rotate-45",
    style: {
      dark: "bg-gray-900 dark:bg-gray-700",
      light: "bg-white",
      auto: "bg-white dark:bg-gray-700"
    },
    placement: "-4px"
  },
  base: "absolute z-10 inline-block rounded-lg px-3 py-2 text-sm font-medium shadow-sm",
  hidden: "invisible opacity-0",
  style: {
    dark: "bg-gray-900 text-white dark:bg-gray-700",
    light: "border border-gray-200 bg-white text-gray-900",
    auto: "border border-gray-200 bg-white text-gray-900 dark:border-none dark:bg-gray-700 dark:text-white"
  },
  content: "relative z-20"
}, QS = {
  accordion: cS,
  alert: dS,
  avatar: uS,
  badge: fS,
  blockquote: hS,
  breadcrumb: gS,
  button: mS,
  buttonGroup: pS,
  card: bS,
  carousel: yS,
  checkbox: vS,
  datepicker: wS,
  darkThemeToggle: xS,
  dropdown: kS,
  fileInput: _S,
  floatingLabel: OS,
  footer: SS,
  helperText: DS,
  kbd: MS$1,
  label: CS,
  listGroup: TS,
  list: ES,
  modal: PS,
  navbar: RS,
  pagination: NS,
  popover: IS,
  progress: AS,
  radio: FS,
  rangeSlider: LS,
  rating: WS,
  ratingAdvanced: $S,
  select: zS,
  textInput: qS,
  textarea: VS,
  toggleSwitch: GS,
  sidebar: jS,
  spinner: HS,
  table: BS,
  tabs: YS,
  timeline: US,
  toast: XS,
  tooltip: KS
}, JS = {
  theme: ui(QS)
};
function ue() {
  return ui(JS.theme);
}
const k0 = reactExports.createContext(void 0);
function _0() {
  const t6 = reactExports.useContext(k0);
  if (!t6)
    throw new Error("useAccordionContext should be used within the AccordionPanelContext provider!");
  return t6;
}
const O0 = ({
  children: t6,
  className: e,
  theme: r = {},
  ...n
}) => {
  const { isOpen: a } = _0(), i = te(ue().accordion.content, r);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: Y(i.base, e),
      "data-testid": "flowbite-accordion-content",
      hidden: !a,
      ...n,
      children: t6
    }
  );
}, S0 = ({ children: t6, ...e }) => {
  const { alwaysOpen: r } = e, [n, a] = reactExports.useState(e.isOpen), i = r ? {
    ...e,
    isOpen: n,
    setOpen: () => a(!n)
  } : e;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(k0.Provider, { value: i, children: t6 });
}, D0 = ({
  as: t6 = "h2",
  children: e,
  className: r,
  theme: n = {},
  ...a
}) => {
  const { arrowIcon: i, flush: s, isOpen: o, setOpen: l } = _0(), c = () => typeof l < "u" && l(), d = te(ue().accordion.title, n);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "button",
    {
      className: Y(d.base, d.flush[s ? "on" : "off"], d.open[o ? "on" : "off"], r),
      onClick: c,
      type: "button",
      ...a,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(t6, { className: d.heading, "data-testid": "flowbite-accordion-heading", children: e }),
        i && /* @__PURE__ */ jsxRuntimeExports.jsx(
          i,
          {
            "aria-hidden": true,
            className: Y(d.arrow.base, d.arrow.open[o ? "on" : "off"]),
            "data-testid": "flowbite-accordion-arrow"
          }
        )
      ]
    }
  );
}, M0 = ({
  alwaysOpen: t6 = false,
  arrowIcon: e = f0,
  children: r,
  flush: n = false,
  collapseAll: a = false,
  className: i,
  theme: s = {},
  ...o
}) => {
  const [l, c] = reactExports.useState(a ? -1 : 0), d = reactExports.useMemo(
    () => reactExports.Children.map(
      r,
      (f, h) => reactExports.cloneElement(f, {
        alwaysOpen: t6,
        arrowIcon: e,
        flush: n,
        isOpen: l === h,
        setOpen: () => c(l === h ? -1 : h)
      })
    ),
    [t6, e, r, n, l]
  ), u = te(ue().accordion.root, s);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: Y(u.base, u.flush[n ? "on" : "off"], i),
      "data-testid": "flowbite-accordion",
      ...o,
      children: d
    }
  );
};
M0.displayName = "Accordion";
S0.displayName = "Accordion.Panel";
D0.displayName = "Accordion.Title";
O0.displayName = "Accordion.Content";
Object.assign(M0, {
  Panel: S0,
  Title: D0,
  Content: O0
});
const C0 = ({ children: t6, className: e, theme: r = {}, ...n }) => {
  const a = te(ue().avatar.group, r);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { "data-testid": "avatar-group-element", className: Y(a.base, e), ...n, children: t6 });
};
C0.displayName = "Avatar.Group";
const E0 = ({
  className: t6,
  href: e,
  theme: r = {},
  total: n,
  ...a
}) => {
  const i = te(ue().avatar.groupCounter, r);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: e, className: Y(i.base, t6), ...a, children: [
    "+",
    n
  ] });
};
E0.displayName = "Avatar.GroupCounter";
const T0 = ({
  alt: t6 = "",
  bordered: e = false,
  children: r,
  className: n,
  color: a = "light",
  img: i,
  placeholderInitials: s = "",
  rounded: o = false,
  size: l = "md",
  stacked: c = false,
  status: d,
  statusPosition: u = "top-left",
  theme: f = {},
  ...h
}) => {
  const g = te(ue().avatar, f), m = Y(
    g.root.img.base,
    e && g.root.bordered,
    e && g.root.color[a],
    o && g.root.rounded,
    c && g.root.stacked,
    g.root.img.on,
    g.root.size[l]
  ), p = {
    className: Y(m, g.root.img.on),
    "data-testid": "flowbite-avatar-img"
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: Y(g.root.base, n), "data-testid": "flowbite-avatar", ...h, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
      i ? typeof i == "string" ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { alt: t6, src: i, ...p }) : i({ alt: t6, ...p }) : s ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: Y(
            g.root.img.off,
            g.root.initials.base,
            c && g.root.stacked,
            e && g.root.bordered,
            e && g.root.color[a],
            g.root.size[l],
            o && g.root.rounded
          ),
          "data-testid": "flowbite-avatar-initials-placeholder",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: Y(g.root.initials.text), "data-testid": "flowbite-avatar-initials-placeholder-text", children: s })
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: Y(m, g.root.img.off), "data-testid": "flowbite-avatar-img", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "svg",
        {
          className: g.root.img.placeholder,
          fill: "currentColor",
          viewBox: "0 0 20 20",
          xmlns: "http://www.w3.org/2000/svg",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fillRule: "evenodd", d: "M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z", clipRule: "evenodd" })
        }
      ) }),
      d && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          "data-testid": "flowbite-avatar-status",
          className: Y(
            g.root.status.base,
            g.root.status[d],
            g.root.statusPosition[u]
          )
        }
      )
    ] }),
    r && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: r })
  ] });
};
T0.displayName = "Avatar";
Object.assign(T0, {
  Group: C0,
  Counter: E0
});
const P0 = ({
  children: t6,
  color: e = "info",
  href: r,
  icon: n,
  size: a = "xs",
  className: i,
  theme: s = {},
  ...o
}) => {
  const l = te(ue().badge, s), c = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "span",
    {
      className: Y(
        l.root.base,
        l.root.color[e],
        l.root.size[a],
        l.icon[n ? "on" : "off"],
        i
      ),
      "data-testid": "flowbite-badge",
      ...o,
      children: [
        n && /* @__PURE__ */ jsxRuntimeExports.jsx(n, { "aria-hidden": true, className: l.icon.size[a], "data-testid": "flowbite-badge-icon" }),
        t6 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t6 })
      ]
    }
  );
  return r ? /* @__PURE__ */ jsxRuntimeExports.jsx("a", { className: l.root.href, href: r, children: /* @__PURE__ */ jsxRuntimeExports.jsx(c, {}) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(c, {});
};
P0.displayName = "Badge";
const R0 = ({
  className: t6,
  color: e = "info",
  light: r,
  size: n = "md",
  theme: a = {},
  ...i
}) => {
  const s = te(ue().spinner, a);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { role: "status", ...i, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "svg",
    {
      fill: "none",
      viewBox: "0 0 100 101",
      className: Y(
        s.base,
        s.color[e],
        s.light[r ? "on" : "off"].base,
        s.light[r ? "on" : "off"].color[e],
        s.size[n],
        t6
      ),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z",
            fill: "currentFill"
          }
        )
      ]
    }
  ) });
};
R0.displayName = "Spinner";
const Ac = reactExports.forwardRef(
  ({ children: t6, as: e, href: r, type: n = "button", ...a }, i) => reactExports.createElement(e || (r ? "a" : "button"), { ref: i, href: r, type: n, ...a }, t6)
);
Ac.displayName = "ButtonBaseComponent";
const N0 = (t6, e, r) => reactExports.Children.map(t6, (n, a) => reactExports.isValidElement(n) ? n.props.children ? reactExports.cloneElement(n, {
  ...n.props,
  children: N0(n.props.children, e, r),
  positionInGroup: Uf(a, reactExports.Children.count(t6))
}) : reactExports.cloneElement(n, {
  outline: e,
  pill: r,
  positionInGroup: Uf(a, reactExports.Children.count(t6))
}) : n), Uf = (t6, e) => t6 === 0 ? "start" : t6 === e - 1 ? "end" : "middle", I0 = ({
  children: t6,
  className: e,
  outline: r,
  pill: n,
  theme: a = {},
  ...i
}) => {
  const s = reactExports.useMemo(() => N0(t6, r, n), [t6, r, n]), o = te(ue().buttonGroup, a);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: Y(o.base, e), role: "group", ...i, children: s });
};
I0.displayName = "Button.Group";
const A0 = reactExports.forwardRef(
  ({
    children: t6,
    className: e,
    color: r = "info",
    disabled: n,
    fullSized: a,
    isProcessing: i = false,
    processingLabel: s = "Loading...",
    processingSpinner: o,
    gradientDuoTone: l,
    gradientMonochrome: c,
    label: d,
    outline: u = false,
    pill: f = false,
    positionInGroup: h = "none",
    size: g = "md",
    theme: m = {},
    ...p
  }, w) => {
    const { buttonGroup: b, button: k } = ue(), v = te(k, m), x = p;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Ac,
      {
        ref: w,
        disabled: n,
        className: Y(
          v.base,
          n && v.disabled,
          !l && !c && v.color[r],
          l && !c && v.gradientDuoTone[l],
          !l && c && v.gradient[c],
          u && (v.outline.color[r] ?? v.outline.color.default),
          v.pill[f ? "on" : "off"],
          a && v.fullSized,
          b.position[h],
          e
        ),
        ...x,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            className: Y(
              v.inner.base,
              v.outline[u ? "on" : "off"],
              v.outline.pill[u && f ? "on" : "off"],
              v.size[g],
              u && !v.outline.color[r] && v.inner.outline,
              i && v.isProcessing,
              i && v.inner.isProcessingPadding[g],
              v.inner.position[h]
            ),
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              i && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: Y(v.spinnerSlot, v.spinnerLeftPosition[g]), children: o || /* @__PURE__ */ jsxRuntimeExports.jsx(R0, { size: g }) }),
              typeof t6 < "u" ? t6 : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { "data-testid": "flowbite-button-label", className: Y(v.label), children: i ? s : d })
            ] })
          }
        )
      }
    );
  }
);
A0.displayName = "Button";
const F0 = Object.assign(A0, {
  Group: I0
}), L0 = ({ children: t6, ...e }) => /* @__PURE__ */ jsxRuntimeExports.jsx(F0, { onClick: (n) => {
  const i = n.target.closest('[role="banner"]');
  i == null || i.remove();
}, ...e, children: t6 });
L0.displayName = "Banner.CollapseButton";
const W0 = ({ children: t6, ...e }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { "data-testid": "flowbite-banner", role: "banner", tabIndex: -1, ...e, children: t6 });
W0.displayName = "Banner";
Object.assign(W0, {
  CollapseButton: L0
});
const $0 = reactExports.forwardRef(
  ({ children: t6, className: e, href: r, icon: n, theme: a = {}, ...i }, s) => {
    const o = typeof r < "u", l = o ? "a" : "span", c = te(ue().breadcrumb.item, a);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: Y(c.base, e), ...i, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(p0, { "aria-hidden": true, className: c.chevron, "data-testid": "flowbite-breadcrumb-separator" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        l,
        {
          ref: s,
          className: c.href[o ? "on" : "off"],
          "data-testid": "flowbite-breadcrumb-item",
          href: r,
          children: [
            n && /* @__PURE__ */ jsxRuntimeExports.jsx(n, { "aria-hidden": true, className: c.icon }),
            t6
          ]
        }
      )
    ] });
  }
);
$0.displayName = "Breadcrumb.Item";
const z0 = ({
  children: t6,
  className: e,
  theme: r = {},
  ...n
}) => {
  const a = te(ue().breadcrumb.root, r);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("nav", { "aria-label": "Breadcrumb", className: Y(a.base, e), ...n, children: /* @__PURE__ */ jsxRuntimeExports.jsx("ol", { className: a.list, children: t6 }) });
};
z0.displayName = "Breadcrumb";
Object.assign(z0, {
  Item: $0
});
var ZS = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function j0(t6) {
  return t6 && t6.__esModule && Object.prototype.hasOwnProperty.call(t6, "default") ? t6.default : t6;
}
function H0(t6) {
  if (t6.__esModule) return t6;
  var e = t6.default;
  if (typeof e == "function") {
    var r = function n() {
      return this instanceof n ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    r.prototype = e.prototype;
  } else r = {};
  return Object.defineProperty(r, "__esModule", { value: true }), Object.keys(t6).forEach(function(n) {
    var a = Object.getOwnPropertyDescriptor(t6, n);
    Object.defineProperty(r, n, a.get ? a : {
      enumerable: true,
      get: function() {
        return t6[n];
      }
    });
  }), r;
}
var B0 = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(t6) {
  (function() {
    var e = {}.hasOwnProperty;
    function r() {
      for (var i = "", s = 0; s < arguments.length; s++) {
        var o = arguments[s];
        o && (i = a(i, n(o)));
      }
      return i;
    }
    function n(i) {
      if (typeof i == "string" || typeof i == "number")
        return i;
      if (typeof i != "object")
        return "";
      if (Array.isArray(i))
        return r.apply(null, i);
      if (i.toString !== Object.prototype.toString && !i.toString.toString().includes("[native code]"))
        return i.toString();
      var s = "";
      for (var o in i)
        e.call(i, o) && i[o] && (s = a(s, o));
      return s;
    }
    function a(i, s) {
      return s ? i ? i + " " + s : i + s : i;
    }
    t6.exports ? (r.default = r, t6.exports = r) : window.classNames = r;
  })();
})(B0);
var en = B0.exports;
const eD = /* @__PURE__ */ j0(en);
var Fc = { exports: {} };
function Y0(t6, e = 100, r = {}) {
  if (typeof t6 != "function")
    throw new TypeError(`Expected the first parameter to be a function, got \`${typeof t6}\`.`);
  if (e < 0)
    throw new RangeError("`wait` must not be negative.");
  const { immediate: n } = typeof r == "boolean" ? { immediate: r } : r;
  let a, i, s, o, l;
  function c() {
    const u = Date.now() - o;
    if (u < e && u >= 0)
      s = setTimeout(c, e - u);
    else if (s = void 0, !n) {
      const f = a, h = i;
      a = void 0, i = void 0, l = t6.apply(f, h);
    }
  }
  const d = function(...u) {
    if (a && this !== a)
      throw new Error("Debounced method called with different contexts.");
    a = this, i = u, o = Date.now();
    const f = n && !s;
    if (s || (s = setTimeout(c, e)), f) {
      const h = a, g = i;
      a = void 0, i = void 0, l = t6.apply(h, g);
    }
    return l;
  };
  return d.clear = () => {
    s && (clearTimeout(s), s = void 0);
  }, d.flush = () => {
    if (!s)
      return;
    const u = a, f = i;
    a = void 0, i = void 0, l = t6.apply(u, f), clearTimeout(s), s = void 0;
  }, d;
}
Fc.exports.debounce = Y0;
Fc.exports = Y0;
var tD = Fc.exports;
const rD = /* @__PURE__ */ j0(tD);
var nD = Object.defineProperty, aD = (t6, e, r) => e in t6 ? nD(t6, e, { enumerable: true, configurable: true, writable: true, value: r }) : t6[e] = r, Ze = (t6, e, r) => (aD(t6, typeof e != "symbol" ? e + "" : e, r), r);
const iD = 300, sD = 0;
class oD extends reactExports.PureComponent {
  constructor(e) {
    super(e), Ze(this, "container"), Ze(this, "scrolling"), Ze(this, "started"), Ze(this, "pressed"), Ze(this, "isMobile", false), Ze(this, "internal"), Ze(this, "scrollLeft"), Ze(this, "scrollTop"), Ze(this, "clientX"), Ze(this, "clientY"), Ze(this, "onEndScroll", () => {
      this.scrolling = false, !this.pressed && this.started && this.processEnd();
    }), Ze(this, "onScroll", () => {
      const r = this.container.current;
      (r.scrollLeft !== this.scrollLeft || r.scrollTop !== this.scrollTop) && (this.scrolling = true, this.processScroll(), this.onEndScroll());
    }), Ze(this, "onTouchStart", (r) => {
      const { nativeMobileScroll: n } = this.props;
      if (this.isDraggable(r.target))
        if (this.internal = true, n && this.scrolling)
          this.pressed = true;
        else {
          const a = r.touches[0];
          this.processClick(a.clientX, a.clientY), !n && this.props.stopPropagation && r.stopPropagation();
        }
    }), Ze(this, "onTouchEnd", () => {
      const { nativeMobileScroll: r } = this.props;
      this.pressed && (this.started && (!this.scrolling || !r) ? this.processEnd() : this.pressed = false, this.forceUpdate());
    }), Ze(this, "onTouchMove", (r) => {
      const { nativeMobileScroll: n } = this.props;
      if (this.pressed && (!n || !this.isMobile)) {
        const a = r.touches[0];
        a && this.processMove(a.clientX, a.clientY), r.preventDefault(), this.props.stopPropagation && r.stopPropagation();
      }
    }), Ze(this, "onMouseDown", (r) => {
      var n, a;
      this.isDraggable(r.target) && this.isScrollable() && (this.internal = true, ((a = (n = this.props) == null ? void 0 : n.buttons) == null ? void 0 : a.indexOf(r.button)) !== -1 && (this.processClick(r.clientX, r.clientY), r.preventDefault(), this.props.stopPropagation && r.stopPropagation()));
    }), Ze(this, "onMouseMove", (r) => {
      this.pressed && (this.processMove(r.clientX, r.clientY), r.preventDefault(), this.props.stopPropagation && r.stopPropagation());
    }), Ze(this, "onMouseUp", (r) => {
      this.pressed && (this.started ? this.processEnd() : (this.internal = false, this.pressed = false, this.forceUpdate(), this.props.onClick && this.props.onClick(r)), r.preventDefault(), this.props.stopPropagation && r.stopPropagation());
    }), this.container = React$1.createRef(), this.onEndScroll = rD(this.onEndScroll, iD), this.scrolling = false, this.started = false, this.pressed = false, this.internal = false, this.getRef = this.getRef.bind(this);
  }
  componentDidMount() {
    const { nativeMobileScroll: e } = this.props, r = this.container.current;
    window.addEventListener("mouseup", this.onMouseUp), window.addEventListener("mousemove", this.onMouseMove), window.addEventListener("touchmove", this.onTouchMove, { passive: false }), window.addEventListener("touchend", this.onTouchEnd), r.addEventListener("touchstart", this.onTouchStart, {
      passive: false
    }), r.addEventListener("mousedown", this.onMouseDown, {
      passive: false
    }), e && (this.isMobile = this.isMobileDevice(), this.isMobile && this.forceUpdate());
  }
  componentWillUnmount() {
    window.removeEventListener("mouseup", this.onMouseUp), window.removeEventListener("mousemove", this.onMouseMove), window.removeEventListener("touchmove", this.onTouchMove), window.removeEventListener("touchend", this.onTouchEnd);
  }
  getElement() {
    return this.container.current;
  }
  isMobileDevice() {
    return typeof window.orientation < "u" || navigator.userAgent.indexOf("IEMobile") !== -1;
  }
  isDraggable(e) {
    const r = this.props.ignoreElements;
    if (r) {
      const n = e.closest(r);
      return n === null || n.contains(this.getElement());
    } else
      return true;
  }
  isScrollable() {
    const e = this.container.current;
    return e && (e.scrollWidth > e.clientWidth || e.scrollHeight > e.clientHeight);
  }
  processClick(e, r) {
    const n = this.container.current;
    this.scrollLeft = n == null ? void 0 : n.scrollLeft, this.scrollTop = n == null ? void 0 : n.scrollTop, this.clientX = e, this.clientY = r, this.pressed = true;
  }
  processStart(e = true) {
    const { onStartScroll: r } = this.props;
    this.started = true, e && document.body.classList.add("cursor-grab"), r && r({
      external: !this.internal
    }), this.forceUpdate();
  }
  // Process native scroll (scrollbar, mobile scroll)
  processScroll() {
    if (this.started) {
      const { onScroll: e } = this.props;
      e && e({
        external: !this.internal
      });
    } else
      this.processStart(false);
  }
  // Process non-native scroll
  processMove(e, r) {
    const { horizontal: n, vertical: a, activationDistance: i, onScroll: s } = this.props, o = this.container.current;
    this.started ? (n && (o.scrollLeft -= e - this.clientX), a && (o.scrollTop -= r - this.clientY), s && s({ external: !this.internal }), this.clientX = e, this.clientY = r, this.scrollLeft = o.scrollLeft, this.scrollTop = o.scrollTop) : (n && Math.abs(e - this.clientX) > i || a && Math.abs(r - this.clientY) > i) && (this.clientX = e, this.clientY = r, this.processStart());
  }
  processEnd() {
    const { onEndScroll: e } = this.props;
    this.container.current && e && e({
      external: !this.internal
    }), this.pressed = false, this.started = false, this.scrolling = false, this.internal = false, document.body.classList.remove("cursor-grab"), this.forceUpdate();
  }
  getRef(e) {
    [this.container, this.props.innerRef].forEach((r) => {
      r && (typeof r == "function" ? r(e) : r.current = e);
    });
  }
  render() {
    const { children: e, draggingClassName: r, className: n, style: a, hideScrollbars: i } = this.props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: eD(n, this.pressed && r, {
          "!scroll-auto [&>*]:pointer-events-none [&>*]:cursor-grab": this.pressed,
          "overflow-auto": this.isMobile,
          "overflow-hidden !overflow-x-hidden [overflow:-moz-scrollbars-none] [scrollbar-width:none]": i,
          "[&::-webkit-scrollbar]:[-webkit-appearance:none !important] [&::-webkit-scrollbar]:!hidden [&::-webkit-scrollbar]:!h-0 [&::-webkit-scrollbar]:!w-0 [&::-webkit-scrollbar]:!bg-transparent": i
        }),
        style: a,
        ref: this.getRef,
        onScroll: this.onScroll,
        children: e
      }
    );
  }
}
Ze(oD, "defaultProps", {
  nativeMobileScroll: true,
  hideScrollbars: true,
  activationDistance: 10,
  vertical: true,
  horizontal: true,
  stopPropagation: false,
  style: {},
  buttons: [sD]
});
const lD = reactExports.forwardRef(
  ({ className: t6, color: e = "default", theme: r = {}, ...n }, a) => {
    const i = te(ue().checkbox, r);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        ref: a,
        type: "checkbox",
        className: Y(i.root.base, i.root.color[e], t6),
        ...n
      }
    );
  }
);
lD.displayName = "Checkbox";
const vi = ({
  children: t6,
  className: e,
  color: r = "default",
  theme: n = {},
  value: a,
  ...i
}) => {
  const s = te(ue().helperText, n);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: Y(s.root.base, s.root.colors[r], e), ...i, children: a ?? t6 ?? "" });
};
vi.displayName = "HelperText";
const Lc = reactExports.forwardRef(
  ({
    addon: t6,
    className: e,
    color: r = "gray",
    helperText: n,
    icon: a,
    rightIcon: i,
    shadow: s,
    sizing: o = "md",
    theme: l = {},
    type: c = "text",
    ...d
  }, u) => {
    const f = te(ue().textInput, l);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: Y(f.base, e), children: [
        t6 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: f.addon, children: t6 }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: f.field.base, children: [
          a && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: f.field.icon.base, children: /* @__PURE__ */ jsxRuntimeExports.jsx(a, { className: f.field.icon.svg }) }),
          i && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { "data-testid": "right-icon", className: f.field.rightIcon.base, children: /* @__PURE__ */ jsxRuntimeExports.jsx(i, { className: f.field.rightIcon.svg }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              className: Y(
                f.field.input.base,
                f.field.input.colors[r],
                f.field.input.sizes[o],
                f.field.input.withIcon[a ? "on" : "off"],
                f.field.input.withRightIcon[i ? "on" : "off"],
                f.field.input.withAddon[t6 ? "on" : "off"],
                f.field.input.withShadow[s ? "on" : "off"]
              ),
              type: c,
              ...d,
              ref: u
            }
          )
        ] })
      ] }),
      n && /* @__PURE__ */ jsxRuntimeExports.jsx(vi, { color: r, children: n })
    ] });
  }
);
Lc.displayName = "TextInput";
const V0 = reactExports.createContext(void 0);
function bo() {
  const t6 = reactExports.useContext(V0);
  if (!t6)
    throw new Error("useDatePickerContext should be used within the DatePickerContext provider!");
  return t6;
}
var Le = /* @__PURE__ */ ((t6) => (t6[t6.Days = 0] = "Days", t6[t6.Months = 1] = "Months", t6[t6.Years = 2] = "Years", t6[t6.Decades = 3] = "Decades", t6))(Le || {}), q0 = /* @__PURE__ */ ((t6) => (t6[t6.Sunday = 0] = "Sunday", t6[t6.Monday = 1] = "Monday", t6[t6.Tuesday = 2] = "Tuesday", t6[t6.Wednesday = 3] = "Wednesday", t6[t6.Thursday = 4] = "Thursday", t6[t6.Friday = 5] = "Friday", t6[t6.Saturday = 6] = "Saturday", t6))(q0 || {});
const xi = (t6, e, r) => {
  const n = new Date(t6.getFullYear(), t6.getMonth(), t6.getDate()).getTime();
  if (e && r) {
    const a = new Date(e.getFullYear(), e.getMonth(), e.getDate()).getTime(), i = new Date(r.getFullYear(), r.getMonth(), r.getDate()).getTime();
    return n >= a && n <= i;
  }
  if (e) {
    const a = new Date(e.getFullYear(), e.getMonth(), e.getDate()).getTime();
    return n >= a;
  }
  if (r) {
    const a = new Date(r.getFullYear(), r.getMonth(), r.getDate()).getTime();
    return n <= a;
  }
  return true;
}, yo = (t6, e) => (t6 = new Date(t6.getFullYear(), t6.getMonth(), t6.getDate()), e = new Date(e.getFullYear(), e.getMonth(), e.getDate()), t6.getTime() === e.getTime()), cD = (t6, e, r) => (xi(t6, e, r) || (e && t6 < e ? t6 = e : r && t6 > r && (t6 = r)), t6), dD = (t6, e) => {
  const r = new Date(t6.getFullYear(), t6.getMonth(), 1);
  let a = r.getDay() - e;
  return a < 0 && (a += 7), Wc(r, -a);
}, uD = (t6, e) => {
  const r = [], n = /* @__PURE__ */ new Date(0);
  n.setDate(n.getDate() - n.getDay() + e);
  const a = new Intl.DateTimeFormat(t6, { weekday: "short" });
  for (let i = 0; i < 7; i++)
    r.push(a.format(Wc(n, i)));
  return r;
}, Wc = (t6, e) => {
  const r = new Date(t6);
  return r.setDate(r.getDate() + e), r;
}, fD = (t6, e) => {
  const r = new Date(t6);
  return r.setMonth(r.getMonth() + e), r;
}, qn = (t6, e) => {
  const r = new Date(t6);
  return r.setFullYear(r.getFullYear() + e), r;
}, Ka = (t6, e, r) => {
  let n = {
    day: "numeric",
    month: "long",
    year: "numeric"
  };
  return r && (n = r), new Intl.DateTimeFormat(t6, n).format(e);
}, Un = (t6, e) => {
  const r = t6.getFullYear();
  return Math.floor(r / e) * e;
}, hD = (t6, e) => {
  const r = t6.getFullYear(), n = e + 9;
  return r >= e && r <= n;
}, gD = ({ theme: t6 = {} }) => {
  const {
    theme: e,
    weekStart: r,
    minDate: n,
    maxDate: a,
    viewDate: i,
    selectedDate: s,
    changeSelectedDate: o,
    language: l
  } = bo(), c = te(e.views.days, t6), d = uD(l, r), u = dD(i, r);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: c.header.base, children: d.map((f, h) => /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: c.header.title, children: f }, h)) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: c.items.base, children: [...Array(42)].map((f, h) => {
      const g = Wc(u, h), m = Ka(l, g, { day: "numeric" }), p = yo(s, g), w = !xi(g, n, a);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          disabled: w,
          type: "button",
          className: Y(
            c.items.item.base,
            p && c.items.item.selected,
            w && c.items.item.disabled
          ),
          onClick: () => {
            w || o(g, true);
          },
          children: m
        },
        h
      );
    }) })
  ] });
}, mD = ({ theme: t6 = {} }) => {
  const { theme: e, selectedDate: r, viewDate: n, setViewDate: a, setView: i } = bo(), s = te(e.views.decades, t6);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s.items.base, children: [...Array(12)].map((o, l) => {
    const d = Un(n, 100) - 10 + l * 10, u = new Date(d, 0, 1), f = qn(u, 9), h = hD(n, d), g = !xi(n, u, f);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        disabled: g,
        type: "button",
        className: Y(
          s.items.item.base,
          h && s.items.item.selected,
          g && s.items.item.disabled
        ),
        onClick: () => {
          g || (a(qn(n, d - r.getFullYear())), i(Le.Years));
        },
        children: d
      },
      l
    );
  }) });
}, pD = ({ theme: t6 = {} }) => {
  const {
    theme: e,
    minDate: r,
    maxDate: n,
    selectedDate: a,
    viewDate: i,
    language: s,
    setViewDate: o,
    setView: l
  } = bo(), c = te(e.views.months, t6);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: c.items.base, children: [...Array(12)].map((d, u) => {
    const f = new Date(i.getTime());
    f.setMonth(u);
    const h = Ka(s, f, { month: "short" }), g = yo(a, f), m = !xi(f, r, n);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        disabled: m,
        type: "button",
        className: Y(
          c.items.item.base,
          g && c.items.item.selected,
          m && c.items.item.disabled
        ),
        onClick: () => {
          m || (o(f), l(Le.Days));
        },
        children: h
      },
      u
    );
  }) });
}, bD = ({ theme: t6 = {} }) => {
  const { theme: e, selectedDate: r, minDate: n, maxDate: a, viewDate: i, setViewDate: s, setView: o } = bo(), l = te(e.views.years, t6);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: l.items.base, children: [...Array(12)].map((c, d) => {
    const f = Un(i, 10) - 1 + d * 1, h = new Date(i.getTime());
    h.setFullYear(f);
    const g = yo(r, h), m = !xi(h, n, a);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        disabled: m,
        type: "button",
        className: Y(
          l.items.item.base,
          g && l.items.item.selected,
          m && l.items.item.disabled
        ),
        onClick: () => {
          m || (s(h), o(Le.Months));
        },
        children: f
      },
      d
    );
  }) });
}, yD = ({
  title: t6,
  open: e,
  inline: r = false,
  autoHide: n = true,
  // Hide when selected the day
  showClearButton: a = true,
  labelClearButton: i = "Clear",
  showTodayButton: s = true,
  labelTodayButton: o = "Today",
  defaultDate: l = /* @__PURE__ */ new Date(),
  minDate: c,
  maxDate: d,
  language: u = "en",
  weekStart: f = q0.Sunday,
  className: h,
  theme: g = {},
  onSelectedDateChanged: m,
  ...p
}, w) => {
  const b = te(ue().datepicker, g);
  l = cD(l, c, d);
  const [k, v] = reactExports.useState(e), [x, _] = reactExports.useState(Le.Days), [T, S] = reactExports.useState(l), [C, D] = reactExports.useState(l), z = reactExports.useRef(null), A = reactExports.useRef(null), L = (J, E) => {
    S(J), m && m(J), n && x === Le.Days && E == true && !r && v(false);
  }, M = () => {
    L(l, true), l && D(l);
  };
  reactExports.useImperativeHandle(w, () => ({
    focus() {
      var J;
      (J = z.current) == null || J.focus();
    },
    clear() {
      M();
    }
  }));
  const I = (J) => {
    switch (J) {
      case Le.Decades:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(mD, { theme: b.views.decades });
      case Le.Years:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(bD, { theme: b.views.years });
      case Le.Months:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(pD, { theme: b.views.months });
      case Le.Days:
      default:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(gD, { theme: b.views.days });
    }
  }, W = () => {
    switch (x) {
      case Le.Days:
        return Le.Months;
      case Le.Months:
        return Le.Years;
      case Le.Years:
        return Le.Decades;
    }
    return x;
  }, B = () => {
    switch (x) {
      case Le.Decades:
        return `${Un(C, 100)} - ${Un(C, 100) + 90}`;
      case Le.Years:
        return `${Un(C, 10)} - ${Un(C, 10) + 9}`;
      case Le.Months:
        return Ka(u, C, { year: "numeric" });
      case Le.Days:
      default:
        return Ka(u, C, { month: "long", year: "numeric" });
    }
  }, U = (J, E, j) => {
    switch (J) {
      case Le.Days:
        return new Date(fD(E, j));
      case Le.Months:
        return new Date(qn(E, j));
      case Le.Years:
        return new Date(qn(E, j * 10));
      case Le.Decades:
        return new Date(qn(E, j * 100));
      default:
        return new Date(qn(E, j * 10));
    }
  };
  return reactExports.useEffect(() => {
    const J = (E) => {
      var R, P;
      const j = (R = A == null ? void 0 : A.current) == null ? void 0 : R.contains(E.target), N = (P = z == null ? void 0 : z.current) == null ? void 0 : P.contains(E.target);
      !j && !N && v(false);
    };
    return document.addEventListener("mousedown", J), () => {
      document.removeEventListener("mousedown", J);
    };
  }, [z, A, v]), /* @__PURE__ */ jsxRuntimeExports.jsx(
    V0.Provider,
    {
      value: {
        theme: b,
        language: u,
        minDate: c,
        maxDate: d,
        weekStart: f,
        isOpen: k,
        setIsOpen: v,
        view: x,
        setView: _,
        viewDate: C,
        setViewDate: D,
        selectedDate: T,
        setSelectedDate: S,
        changeSelectedDate: L
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: Y(b.root.base, h), children: [
        !r && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Lc,
          {
            theme: b.root.input,
            icon: OO,
            ref: z,
            onFocus: () => {
              yo(C, T) || D(T), v(true);
            },
            value: T && Ka(u, T),
            readOnly: true,
            ...p
          }
        ),
        (k || r) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: A, className: Y(b.popup.root.base, r && b.popup.root.inline), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: b.popup.root.inner, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: b.popup.header.base, children: [
            t6 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: b.popup.header.title, children: t6 }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: b.popup.header.selectors.base, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  className: Y(
                    b.popup.header.selectors.button.base,
                    b.popup.header.selectors.button.prev
                  ),
                  onClick: () => D(U(x, C, -1)),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(kO, {})
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  className: Y(
                    b.popup.header.selectors.button.base,
                    b.popup.header.selectors.button.view
                  ),
                  onClick: () => _(W()),
                  children: B()
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  className: Y(
                    b.popup.header.selectors.button.base,
                    b.popup.header.selectors.button.next
                  ),
                  onClick: () => D(U(x, C, 1)),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(_O, {})
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: b.popup.view.base, children: I(x) }),
          (a || s) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: b.popup.footer.base, children: [
            s && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                className: Y(b.popup.footer.button.base, b.popup.footer.button.today),
                onClick: () => {
                  const J = /* @__PURE__ */ new Date();
                  L(J, true), D(J);
                },
                children: o
              }
            ),
            a && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                className: Y(b.popup.footer.button.base, b.popup.footer.button.clear),
                onClick: () => {
                  L(l, true), l && D(l);
                },
                children: i
              }
            )
          ] })
        ] }) })
      ] })
    }
  );
}, U0 = reactExports.forwardRef(yD);
U0.displayName = "Datepicker";
function vo() {
  return typeof window < "u";
}
function An(t6) {
  return X0(t6) ? (t6.nodeName || "").toLowerCase() : "#document";
}
function Dt(t6) {
  var e;
  return (t6 == null || (e = t6.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function vr(t6) {
  var e;
  return (e = (X0(t6) ? t6.ownerDocument : t6.document) || window.document) == null ? void 0 : e.documentElement;
}
function X0(t6) {
  return vo() ? t6 instanceof Node || t6 instanceof Dt(t6).Node : false;
}
function Ce(t6) {
  return vo() ? t6 instanceof Element || t6 instanceof Dt(t6).Element : false;
}
function ut(t6) {
  return vo() ? t6 instanceof HTMLElement || t6 instanceof Dt(t6).HTMLElement : false;
}
function jl(t6) {
  return !vo() || typeof ShadowRoot > "u" ? false : t6 instanceof ShadowRoot || t6 instanceof Dt(t6).ShadowRoot;
}
function wi(t6) {
  const {
    overflow: e,
    overflowX: r,
    overflowY: n,
    display: a
  } = Yt(t6);
  return /auto|scroll|overlay|hidden|clip/.test(e + n + r) && !["inline", "contents"].includes(a);
}
function vD(t6) {
  return ["table", "td", "th"].includes(An(t6));
}
function xo(t6) {
  return [":popover-open", ":modal"].some((e) => {
    try {
      return t6.matches(e);
    } catch {
      return false;
    }
  });
}
function $c(t6) {
  const e = zc(), r = Ce(t6) ? Yt(t6) : t6;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((n) => r[n] ? r[n] !== "none" : false) || (r.containerType ? r.containerType !== "normal" : false) || !e && (r.backdropFilter ? r.backdropFilter !== "none" : false) || !e && (r.filter ? r.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((n) => (r.willChange || "").includes(n)) || ["paint", "layout", "strict", "content"].some((n) => (r.contain || "").includes(n));
}
function xD(t6) {
  let e = Tr(t6);
  for (; ut(e) && !Gr(e); ) {
    if ($c(e))
      return e;
    if (xo(e))
      return null;
    e = Tr(e);
  }
  return null;
}
function zc() {
  return typeof CSS > "u" || !CSS.supports ? false : CSS.supports("-webkit-backdrop-filter", "none");
}
function Gr(t6) {
  return ["html", "body", "#document"].includes(An(t6));
}
function Yt(t6) {
  return Dt(t6).getComputedStyle(t6);
}
function wo(t6) {
  return Ce(t6) ? {
    scrollLeft: t6.scrollLeft,
    scrollTop: t6.scrollTop
  } : {
    scrollLeft: t6.scrollX,
    scrollTop: t6.scrollY
  };
}
function Tr(t6) {
  if (An(t6) === "html")
    return t6;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    t6.assignedSlot || // DOM Element detected.
    t6.parentNode || // ShadowRoot detected.
    jl(t6) && t6.host || // Fallback.
    vr(t6)
  );
  return jl(e) ? e.host : e;
}
function G0(t6) {
  const e = Tr(t6);
  return Gr(e) ? t6.ownerDocument ? t6.ownerDocument.body : t6.body : ut(e) && wi(e) ? e : G0(e);
}
function Ur(t6, e, r) {
  var n;
  e === void 0 && (e = []), r === void 0 && (r = true);
  const a = G0(t6), i = a === ((n = t6.ownerDocument) == null ? void 0 : n.body), s = Dt(a);
  if (i) {
    const o = Hl(s);
    return e.concat(s, s.visualViewport || [], wi(a) ? a : [], o && r ? Ur(o) : []);
  }
  return e.concat(a, Ur(a, [], r));
}
function Hl(t6) {
  return t6.parent && Object.getPrototypeOf(t6.parent) ? t6.frameElement : null;
}
function or(t6) {
  let e = t6.activeElement;
  for (; ((r = e) == null || (r = r.shadowRoot) == null ? void 0 : r.activeElement) != null; ) {
    var r;
    e = e.shadowRoot.activeElement;
  }
  return e;
}
function Ge(t6, e) {
  if (!t6 || !e)
    return false;
  const r = e.getRootNode == null ? void 0 : e.getRootNode();
  if (t6.contains(e))
    return true;
  if (r && jl(r)) {
    let n = e;
    for (; n; ) {
      if (t6 === n)
        return true;
      n = n.parentNode || n.host;
    }
  }
  return false;
}
function jc() {
  const t6 = navigator.userAgentData;
  return t6 != null && t6.platform ? t6.platform : navigator.platform;
}
function K0() {
  const t6 = navigator.userAgentData;
  return t6 && Array.isArray(t6.brands) ? t6.brands.map((e) => {
    let {
      brand: r,
      version: n
    } = e;
    return r + "/" + n;
  }).join(" ") : navigator.userAgent;
}
function Q0(t6) {
  return t6.mozInputSource === 0 && t6.isTrusted ? true : Bl() && t6.pointerType ? t6.type === "click" && t6.buttons === 1 : t6.detail === 0 && !t6.pointerType;
}
function Hc(t6) {
  return wD() ? false : !Bl() && t6.width === 0 && t6.height === 0 || Bl() && t6.width === 1 && t6.height === 1 && t6.pressure === 0 && t6.detail === 0 && t6.pointerType === "mouse" || // iOS VoiceOver returns 0.333• for width/height.
  t6.width < 1 && t6.height < 1 && t6.pressure === 0 && t6.detail === 0 && t6.pointerType === "touch";
}
function Bc() {
  return /apple/i.test(navigator.vendor);
}
function Bl() {
  const t6 = /android/i;
  return t6.test(jc()) || t6.test(K0());
}
function J0() {
  return jc().toLowerCase().startsWith("mac") && !navigator.maxTouchPoints;
}
function wD() {
  return K0().includes("jsdom/");
}
function As(t6, e) {
  const r = ["mouse", "pen"];
  return e || r.push("", void 0), r.includes(t6);
}
function kD(t6) {
  return "nativeEvent" in t6;
}
function _D(t6) {
  return t6.matches("html,body");
}
function yt(t6) {
  return (t6 == null ? void 0 : t6.ownerDocument) || document;
}
function rl(t6, e) {
  if (e == null)
    return false;
  if ("composedPath" in t6)
    return t6.composedPath().includes(e);
  const r = t6;
  return r.target != null && e.contains(r.target);
}
function Br(t6) {
  return "composedPath" in t6 ? t6.composedPath()[0] : t6.target;
}
const OD = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
function Yc(t6) {
  return ut(t6) && t6.matches(OD);
}
function st(t6) {
  t6.preventDefault(), t6.stopPropagation();
}
function Z0(t6) {
  return t6 ? t6.getAttribute("role") === "combobox" && Yc(t6) : false;
}
const SD = ["top", "right", "bottom", "left"], Xf = ["start", "end"], Gf = /* @__PURE__ */ SD.reduce((t6, e) => t6.concat(e, e + "-" + Xf[0], e + "-" + Xf[1]), []), la = Math.min, Dn = Math.max, Fs = Math.round, Xn = Math.floor, hr = (t6) => ({
  x: t6,
  y: t6
}), DD = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, MD = {
  start: "end",
  end: "start"
};
function Yl(t6, e, r) {
  return Dn(t6, la(e, r));
}
function pa(t6, e) {
  return typeof t6 == "function" ? t6(e) : t6;
}
function Pr(t6) {
  return t6.split("-")[0];
}
function gr(t6) {
  return t6.split("-")[1];
}
function em(t6) {
  return t6 === "x" ? "y" : "x";
}
function Vc(t6) {
  return t6 === "y" ? "height" : "width";
}
function ko(t6) {
  return ["top", "bottom"].includes(Pr(t6)) ? "y" : "x";
}
function qc(t6) {
  return em(ko(t6));
}
function tm(t6, e, r) {
  r === void 0 && (r = false);
  const n = gr(t6), a = qc(t6), i = Vc(a);
  let s = a === "x" ? n === (r ? "end" : "start") ? "right" : "left" : n === "start" ? "bottom" : "top";
  return e.reference[i] > e.floating[i] && (s = Ws(s)), [s, Ws(s)];
}
function CD(t6) {
  const e = Ws(t6);
  return [Ls(t6), e, Ls(e)];
}
function Ls(t6) {
  return t6.replace(/start|end/g, (e) => MD[e]);
}
function ED(t6, e, r) {
  const n = ["left", "right"], a = ["right", "left"], i = ["top", "bottom"], s = ["bottom", "top"];
  switch (t6) {
    case "top":
    case "bottom":
      return r ? e ? a : n : e ? n : a;
    case "left":
    case "right":
      return e ? i : s;
    default:
      return [];
  }
}
function TD(t6, e, r, n) {
  const a = gr(t6);
  let i = ED(Pr(t6), r === "start", n);
  return a && (i = i.map((s) => s + "-" + a), e && (i = i.concat(i.map(Ls)))), i;
}
function Ws(t6) {
  return t6.replace(/left|right|bottom|top/g, (e) => DD[e]);
}
function PD(t6) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t6
  };
}
function rm(t6) {
  return typeof t6 != "number" ? PD(t6) : {
    top: t6,
    right: t6,
    bottom: t6,
    left: t6
  };
}
function $s(t6) {
  const {
    x: e,
    y: r,
    width: n,
    height: a
  } = t6;
  return {
    width: n,
    height: a,
    top: r,
    left: e,
    right: e + n,
    bottom: r + a,
    x: e,
    y: r
  };
}
function Kf(t6, e, r) {
  let {
    reference: n,
    floating: a
  } = t6;
  const i = ko(e), s = qc(e), o = Vc(s), l = Pr(e), c = i === "y", d = n.x + n.width / 2 - a.width / 2, u = n.y + n.height / 2 - a.height / 2, f = n[o] / 2 - a[o] / 2;
  let h;
  switch (l) {
    case "top":
      h = {
        x: d,
        y: n.y - a.height
      };
      break;
    case "bottom":
      h = {
        x: d,
        y: n.y + n.height
      };
      break;
    case "right":
      h = {
        x: n.x + n.width,
        y: u
      };
      break;
    case "left":
      h = {
        x: n.x - a.width,
        y: u
      };
      break;
    default:
      h = {
        x: n.x,
        y: n.y
      };
  }
  switch (gr(e)) {
    case "start":
      h[s] -= f * (r && c ? -1 : 1);
      break;
    case "end":
      h[s] += f * (r && c ? -1 : 1);
      break;
  }
  return h;
}
const RD = async (t6, e, r) => {
  const {
    placement: n = "bottom",
    strategy: a = "absolute",
    middleware: i = [],
    platform: s
  } = r, o = i.filter(Boolean), l = await (s.isRTL == null ? void 0 : s.isRTL(e));
  let c = await s.getElementRects({
    reference: t6,
    floating: e,
    strategy: a
  }), {
    x: d,
    y: u
  } = Kf(c, n, l), f = n, h = {}, g = 0;
  for (let m = 0; m < o.length; m++) {
    const {
      name: p,
      fn: w
    } = o[m], {
      x: b,
      y: k,
      data: v,
      reset: x
    } = await w({
      x: d,
      y: u,
      initialPlacement: n,
      placement: f,
      strategy: a,
      middlewareData: h,
      rects: c,
      platform: s,
      elements: {
        reference: t6,
        floating: e
      }
    });
    d = b ?? d, u = k ?? u, h = {
      ...h,
      [p]: {
        ...h[p],
        ...v
      }
    }, x && g <= 50 && (g++, typeof x == "object" && (x.placement && (f = x.placement), x.rects && (c = x.rects === true ? await s.getElementRects({
      reference: t6,
      floating: e,
      strategy: a
    }) : x.rects), {
      x: d,
      y: u
    } = Kf(c, f, l)), m = -1);
  }
  return {
    x: d,
    y: u,
    placement: f,
    strategy: a,
    middlewareData: h
  };
};
async function Uc(t6, e) {
  var r;
  e === void 0 && (e = {});
  const {
    x: n,
    y: a,
    platform: i,
    rects: s,
    elements: o,
    strategy: l
  } = t6, {
    boundary: c = "clippingAncestors",
    rootBoundary: d = "viewport",
    elementContext: u = "floating",
    altBoundary: f = false,
    padding: h = 0
  } = pa(e, t6), g = rm(h), p = o[f ? u === "floating" ? "reference" : "floating" : u], w = $s(await i.getClippingRect({
    element: (r = await (i.isElement == null ? void 0 : i.isElement(p))) == null || r ? p : p.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(o.floating)),
    boundary: c,
    rootBoundary: d,
    strategy: l
  })), b = u === "floating" ? {
    ...s.floating,
    x: n,
    y: a
  } : s.reference, k = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(o.floating)), v = await (i.isElement == null ? void 0 : i.isElement(k)) ? await (i.getScale == null ? void 0 : i.getScale(k)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, x = $s(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: o,
    rect: b,
    offsetParent: k,
    strategy: l
  }) : b);
  return {
    top: (w.top - x.top + g.top) / v.y,
    bottom: (x.bottom - w.bottom + g.bottom) / v.y,
    left: (w.left - x.left + g.left) / v.x,
    right: (x.right - w.right + g.right) / v.x
  };
}
const ND = (t6) => ({
  name: "arrow",
  options: t6,
  async fn(e) {
    const {
      x: r,
      y: n,
      placement: a,
      rects: i,
      platform: s,
      elements: o,
      middlewareData: l
    } = e, {
      element: c,
      padding: d = 0
    } = pa(t6, e) || {};
    if (c == null)
      return {};
    const u = rm(d), f = {
      x: r,
      y: n
    }, h = qc(a), g = Vc(h), m = await s.getDimensions(c), p = h === "y", w = p ? "top" : "left", b = p ? "bottom" : "right", k = p ? "clientHeight" : "clientWidth", v = i.reference[g] + i.reference[h] - f[h] - i.floating[g], x = f[h] - i.reference[h], _ = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(c));
    let T = _ ? _[k] : 0;
    (!T || !await (s.isElement == null ? void 0 : s.isElement(_))) && (T = o.floating[k] || i.floating[g]);
    const S = v / 2 - x / 2, C = T / 2 - m[g] / 2 - 1, D = la(u[w], C), z = la(u[b], C), A = D, L = T - m[g] - z, M = T / 2 - m[g] / 2 + S, I = Yl(A, M, L), W = !l.arrow && gr(a) != null && M !== I && i.reference[g] / 2 - (M < A ? D : z) - m[g] / 2 < 0, B = W ? M < A ? M - A : M - L : 0;
    return {
      [h]: f[h] + B,
      data: {
        [h]: I,
        centerOffset: M - I - B,
        ...W && {
          alignmentOffset: B
        }
      },
      reset: W
    };
  }
});
function ID(t6, e, r) {
  return (t6 ? [...r.filter((a) => gr(a) === t6), ...r.filter((a) => gr(a) !== t6)] : r.filter((a) => Pr(a) === a)).filter((a) => t6 ? gr(a) === t6 || (e ? Ls(a) !== a : false) : true);
}
const AD = function(t6) {
  return t6 === void 0 && (t6 = {}), {
    name: "autoPlacement",
    options: t6,
    async fn(e) {
      var r, n, a;
      const {
        rects: i,
        middlewareData: s,
        placement: o,
        platform: l,
        elements: c
      } = e, {
        crossAxis: d = false,
        alignment: u,
        allowedPlacements: f = Gf,
        autoAlignment: h = true,
        ...g
      } = pa(t6, e), m = u !== void 0 || f === Gf ? ID(u || null, h, f) : f, p = await Uc(e, g), w = ((r = s.autoPlacement) == null ? void 0 : r.index) || 0, b = m[w];
      if (b == null)
        return {};
      const k = tm(b, i, await (l.isRTL == null ? void 0 : l.isRTL(c.floating)));
      if (o !== b)
        return {
          reset: {
            placement: m[0]
          }
        };
      const v = [p[Pr(b)], p[k[0]], p[k[1]]], x = [...((n = s.autoPlacement) == null ? void 0 : n.overflows) || [], {
        placement: b,
        overflows: v
      }], _ = m[w + 1];
      if (_)
        return {
          data: {
            index: w + 1,
            overflows: x
          },
          reset: {
            placement: _
          }
        };
      const T = x.map((D) => {
        const z = gr(D.placement);
        return [D.placement, z && d ? (
          // Check along the mainAxis and main crossAxis side.
          D.overflows.slice(0, 2).reduce((A, L) => A + L, 0)
        ) : (
          // Check only the mainAxis.
          D.overflows[0]
        ), D.overflows];
      }).sort((D, z) => D[1] - z[1]), C = ((a = T.filter((D) => D[2].slice(
        0,
        // Aligned placements should not check their opposite crossAxis
        // side.
        gr(D[0]) ? 2 : 3
      ).every((z) => z <= 0))[0]) == null ? void 0 : a[0]) || T[0][0];
      return C !== o ? {
        data: {
          index: w + 1,
          overflows: x
        },
        reset: {
          placement: C
        }
      } : {};
    }
  };
}, FD = function(t6) {
  return t6 === void 0 && (t6 = {}), {
    name: "flip",
    options: t6,
    async fn(e) {
      var r, n;
      const {
        placement: a,
        middlewareData: i,
        rects: s,
        initialPlacement: o,
        platform: l,
        elements: c
      } = e, {
        mainAxis: d = true,
        crossAxis: u = true,
        fallbackPlacements: f,
        fallbackStrategy: h = "bestFit",
        fallbackAxisSideDirection: g = "none",
        flipAlignment: m = true,
        ...p
      } = pa(t6, e);
      if ((r = i.arrow) != null && r.alignmentOffset)
        return {};
      const w = Pr(a), b = Pr(o) === o, k = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), v = f || (b || !m ? [Ws(o)] : CD(o));
      !f && g !== "none" && v.push(...TD(o, m, g, k));
      const x = [o, ...v], _ = await Uc(e, p), T = [];
      let S = ((n = i.flip) == null ? void 0 : n.overflows) || [];
      if (d && T.push(_[w]), u) {
        const A = tm(a, s, k);
        T.push(_[A[0]], _[A[1]]);
      }
      if (S = [...S, {
        placement: a,
        overflows: T
      }], !T.every((A) => A <= 0)) {
        var C, D;
        const A = (((C = i.flip) == null ? void 0 : C.index) || 0) + 1, L = x[A];
        if (L)
          return {
            data: {
              index: A,
              overflows: S
            },
            reset: {
              placement: L
            }
          };
        let M = (D = S.filter((I) => I.overflows[0] <= 0).sort((I, W) => I.overflows[1] - W.overflows[1])[0]) == null ? void 0 : D.placement;
        if (!M)
          switch (h) {
            case "bestFit": {
              var z;
              const I = (z = S.map((W) => [W.placement, W.overflows.filter((B) => B > 0).reduce((B, U) => B + U, 0)]).sort((W, B) => W[1] - B[1])[0]) == null ? void 0 : z[0];
              I && (M = I);
              break;
            }
            case "initialPlacement":
              M = o;
              break;
          }
        if (a !== M)
          return {
            reset: {
              placement: M
            }
          };
      }
      return {};
    }
  };
};
async function LD(t6, e) {
  const {
    placement: r,
    platform: n,
    elements: a
  } = t6, i = await (n.isRTL == null ? void 0 : n.isRTL(a.floating)), s = Pr(r), o = gr(r), l = ko(r) === "y", c = ["left", "top"].includes(s) ? -1 : 1, d = i && l ? -1 : 1, u = pa(e, t6);
  let {
    mainAxis: f,
    crossAxis: h,
    alignmentAxis: g
  } = typeof u == "number" ? {
    mainAxis: u,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...u
  };
  return o && typeof g == "number" && (h = o === "end" ? g * -1 : g), l ? {
    x: h * d,
    y: f * c
  } : {
    x: f * c,
    y: h * d
  };
}
const WD = function(t6) {
  return t6 === void 0 && (t6 = 0), {
    name: "offset",
    options: t6,
    async fn(e) {
      var r, n;
      const {
        x: a,
        y: i,
        placement: s,
        middlewareData: o
      } = e, l = await LD(e, t6);
      return s === ((r = o.offset) == null ? void 0 : r.placement) && (n = o.arrow) != null && n.alignmentOffset ? {} : {
        x: a + l.x,
        y: i + l.y,
        data: {
          ...l,
          placement: s
        }
      };
    }
  };
}, $D = function(t6) {
  return t6 === void 0 && (t6 = {}), {
    name: "shift",
    options: t6,
    async fn(e) {
      const {
        x: r,
        y: n,
        placement: a
      } = e, {
        mainAxis: i = true,
        crossAxis: s = false,
        limiter: o = {
          fn: (p) => {
            let {
              x: w,
              y: b
            } = p;
            return {
              x: w,
              y: b
            };
          }
        },
        ...l
      } = pa(t6, e), c = {
        x: r,
        y: n
      }, d = await Uc(e, l), u = ko(Pr(a)), f = em(u);
      let h = c[f], g = c[u];
      if (i) {
        const p = f === "y" ? "top" : "left", w = f === "y" ? "bottom" : "right", b = h + d[p], k = h - d[w];
        h = Yl(b, h, k);
      }
      if (s) {
        const p = u === "y" ? "top" : "left", w = u === "y" ? "bottom" : "right", b = g + d[p], k = g - d[w];
        g = Yl(b, g, k);
      }
      const m = o.fn({
        ...e,
        [f]: h,
        [u]: g
      });
      return {
        ...m,
        data: {
          x: m.x - r,
          y: m.y - n
        }
      };
    }
  };
};
function nm(t6) {
  const e = Yt(t6);
  let r = parseFloat(e.width) || 0, n = parseFloat(e.height) || 0;
  const a = ut(t6), i = a ? t6.offsetWidth : r, s = a ? t6.offsetHeight : n, o = Fs(r) !== i || Fs(n) !== s;
  return o && (r = i, n = s), {
    width: r,
    height: n,
    $: o
  };
}
function Xc(t6) {
  return Ce(t6) ? t6 : t6.contextElement;
}
function Zn(t6) {
  const e = Xc(t6);
  if (!ut(e))
    return hr(1);
  const r = e.getBoundingClientRect(), {
    width: n,
    height: a,
    $: i
  } = nm(e);
  let s = (i ? Fs(r.width) : r.width) / n, o = (i ? Fs(r.height) : r.height) / a;
  return (!s || !Number.isFinite(s)) && (s = 1), (!o || !Number.isFinite(o)) && (o = 1), {
    x: s,
    y: o
  };
}
const zD = /* @__PURE__ */ hr(0);
function am(t6) {
  const e = Dt(t6);
  return !zc() || !e.visualViewport ? zD : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function jD(t6, e, r) {
  return e === void 0 && (e = false), !r || e && r !== Dt(t6) ? false : e;
}
function Rn(t6, e, r, n) {
  e === void 0 && (e = false), r === void 0 && (r = false);
  const a = t6.getBoundingClientRect(), i = Xc(t6);
  let s = hr(1);
  e && (n ? Ce(n) && (s = Zn(n)) : s = Zn(t6));
  const o = jD(i, r, n) ? am(i) : hr(0);
  let l = (a.left + o.x) / s.x, c = (a.top + o.y) / s.y, d = a.width / s.x, u = a.height / s.y;
  if (i) {
    const f = Dt(i), h = n && Ce(n) ? Dt(n) : n;
    let g = f, m = Hl(g);
    for (; m && n && h !== g; ) {
      const p = Zn(m), w = m.getBoundingClientRect(), b = Yt(m), k = w.left + (m.clientLeft + parseFloat(b.paddingLeft)) * p.x, v = w.top + (m.clientTop + parseFloat(b.paddingTop)) * p.y;
      l *= p.x, c *= p.y, d *= p.x, u *= p.y, l += k, c += v, g = Dt(m), m = Hl(g);
    }
  }
  return $s({
    width: d,
    height: u,
    x: l,
    y: c
  });
}
function Gc(t6, e) {
  const r = wo(t6).scrollLeft;
  return e ? e.left + r : Rn(vr(t6)).left + r;
}
function im(t6, e, r) {
  r === void 0 && (r = false);
  const n = t6.getBoundingClientRect(), a = n.left + e.scrollLeft - (r ? 0 : (
    // RTL <body> scrollbar.
    Gc(t6, n)
  )), i = n.top + e.scrollTop;
  return {
    x: a,
    y: i
  };
}
function HD(t6) {
  let {
    elements: e,
    rect: r,
    offsetParent: n,
    strategy: a
  } = t6;
  const i = a === "fixed", s = vr(n), o = e ? xo(e.floating) : false;
  if (n === s || o && i)
    return r;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = hr(1);
  const d = hr(0), u = ut(n);
  if ((u || !u && !i) && ((An(n) !== "body" || wi(s)) && (l = wo(n)), ut(n))) {
    const h = Rn(n);
    c = Zn(n), d.x = h.x + n.clientLeft, d.y = h.y + n.clientTop;
  }
  const f = s && !u && !i ? im(s, l, true) : hr(0);
  return {
    width: r.width * c.x,
    height: r.height * c.y,
    x: r.x * c.x - l.scrollLeft * c.x + d.x + f.x,
    y: r.y * c.y - l.scrollTop * c.y + d.y + f.y
  };
}
function BD(t6) {
  return Array.from(t6.getClientRects());
}
function YD(t6) {
  const e = vr(t6), r = wo(t6), n = t6.ownerDocument.body, a = Dn(e.scrollWidth, e.clientWidth, n.scrollWidth, n.clientWidth), i = Dn(e.scrollHeight, e.clientHeight, n.scrollHeight, n.clientHeight);
  let s = -r.scrollLeft + Gc(t6);
  const o = -r.scrollTop;
  return Yt(n).direction === "rtl" && (s += Dn(e.clientWidth, n.clientWidth) - a), {
    width: a,
    height: i,
    x: s,
    y: o
  };
}
function VD(t6, e) {
  const r = Dt(t6), n = vr(t6), a = r.visualViewport;
  let i = n.clientWidth, s = n.clientHeight, o = 0, l = 0;
  if (a) {
    i = a.width, s = a.height;
    const c = zc();
    (!c || c && e === "fixed") && (o = a.offsetLeft, l = a.offsetTop);
  }
  return {
    width: i,
    height: s,
    x: o,
    y: l
  };
}
function qD(t6, e) {
  const r = Rn(t6, true, e === "fixed"), n = r.top + t6.clientTop, a = r.left + t6.clientLeft, i = ut(t6) ? Zn(t6) : hr(1), s = t6.clientWidth * i.x, o = t6.clientHeight * i.y, l = a * i.x, c = n * i.y;
  return {
    width: s,
    height: o,
    x: l,
    y: c
  };
}
function Qf(t6, e, r) {
  let n;
  if (e === "viewport")
    n = VD(t6, r);
  else if (e === "document")
    n = YD(vr(t6));
  else if (Ce(e))
    n = qD(e, r);
  else {
    const a = am(t6);
    n = {
      x: e.x - a.x,
      y: e.y - a.y,
      width: e.width,
      height: e.height
    };
  }
  return $s(n);
}
function sm(t6, e) {
  const r = Tr(t6);
  return r === e || !Ce(r) || Gr(r) ? false : Yt(r).position === "fixed" || sm(r, e);
}
function UD(t6, e) {
  const r = e.get(t6);
  if (r)
    return r;
  let n = Ur(t6, [], false).filter((o) => Ce(o) && An(o) !== "body"), a = null;
  const i = Yt(t6).position === "fixed";
  let s = i ? Tr(t6) : t6;
  for (; Ce(s) && !Gr(s); ) {
    const o = Yt(s), l = $c(s);
    !l && o.position === "fixed" && (a = null), (i ? !l && !a : !l && o.position === "static" && !!a && ["absolute", "fixed"].includes(a.position) || wi(s) && !l && sm(t6, s)) ? n = n.filter((d) => d !== s) : a = o, s = Tr(s);
  }
  return e.set(t6, n), n;
}
function XD(t6) {
  let {
    element: e,
    boundary: r,
    rootBoundary: n,
    strategy: a
  } = t6;
  const s = [...r === "clippingAncestors" ? xo(e) ? [] : UD(e, this._c) : [].concat(r), n], o = s[0], l = s.reduce((c, d) => {
    const u = Qf(e, d, a);
    return c.top = Dn(u.top, c.top), c.right = la(u.right, c.right), c.bottom = la(u.bottom, c.bottom), c.left = Dn(u.left, c.left), c;
  }, Qf(e, o, a));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function GD(t6) {
  const {
    width: e,
    height: r
  } = nm(t6);
  return {
    width: e,
    height: r
  };
}
function KD(t6, e, r) {
  const n = ut(e), a = vr(e), i = r === "fixed", s = Rn(t6, true, i, e);
  let o = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = hr(0);
  if (n || !n && !i)
    if ((An(e) !== "body" || wi(a)) && (o = wo(e)), n) {
      const f = Rn(e, true, i, e);
      l.x = f.x + e.clientLeft, l.y = f.y + e.clientTop;
    } else a && (l.x = Gc(a));
  const c = a && !n && !i ? im(a, o) : hr(0), d = s.left + o.scrollLeft - l.x - c.x, u = s.top + o.scrollTop - l.y - c.y;
  return {
    x: d,
    y: u,
    width: s.width,
    height: s.height
  };
}
function nl(t6) {
  return Yt(t6).position === "static";
}
function Jf(t6, e) {
  if (!ut(t6) || Yt(t6).position === "fixed")
    return null;
  if (e)
    return e(t6);
  let r = t6.offsetParent;
  return vr(t6) === r && (r = r.ownerDocument.body), r;
}
function om(t6, e) {
  const r = Dt(t6);
  if (xo(t6))
    return r;
  if (!ut(t6)) {
    let a = Tr(t6);
    for (; a && !Gr(a); ) {
      if (Ce(a) && !nl(a))
        return a;
      a = Tr(a);
    }
    return r;
  }
  let n = Jf(t6, e);
  for (; n && vD(n) && nl(n); )
    n = Jf(n, e);
  return n && Gr(n) && nl(n) && !$c(n) ? r : n || xD(t6) || r;
}
const QD = async function(t6) {
  const e = this.getOffsetParent || om, r = this.getDimensions, n = await r(t6.floating);
  return {
    reference: KD(t6.reference, await e(t6.floating), t6.strategy),
    floating: {
      x: 0,
      y: 0,
      width: n.width,
      height: n.height
    }
  };
};
function JD(t6) {
  return Yt(t6).direction === "rtl";
}
const ZD = {
  convertOffsetParentRelativeRectToViewportRelativeRect: HD,
  getDocumentElement: vr,
  getClippingRect: XD,
  getOffsetParent: om,
  getElementRects: QD,
  getClientRects: BD,
  getDimensions: GD,
  getScale: Zn,
  isElement: Ce,
  isRTL: JD
};
function lm(t6, e) {
  return t6.x === e.x && t6.y === e.y && t6.width === e.width && t6.height === e.height;
}
function eM(t6, e) {
  let r = null, n;
  const a = vr(t6);
  function i() {
    var o;
    clearTimeout(n), (o = r) == null || o.disconnect(), r = null;
  }
  function s(o, l) {
    o === void 0 && (o = false), l === void 0 && (l = 1), i();
    const c = t6.getBoundingClientRect(), {
      left: d,
      top: u,
      width: f,
      height: h
    } = c;
    if (o || e(), !f || !h)
      return;
    const g = Xn(u), m = Xn(a.clientWidth - (d + f)), p = Xn(a.clientHeight - (u + h)), w = Xn(d), k = {
      rootMargin: -g + "px " + -m + "px " + -p + "px " + -w + "px",
      threshold: Dn(0, la(1, l)) || 1
    };
    let v = true;
    function x(_) {
      const T = _[0].intersectionRatio;
      if (T !== l) {
        if (!v)
          return s();
        T ? s(false, T) : n = setTimeout(() => {
          s(false, 1e-7);
        }, 1e3);
      }
      T === 1 && !lm(c, t6.getBoundingClientRect()) && s(), v = false;
    }
    try {
      r = new IntersectionObserver(x, {
        ...k,
        // Handle <iframe>s
        root: a.ownerDocument
      });
    } catch {
      r = new IntersectionObserver(x, k);
    }
    r.observe(t6);
  }
  return s(true), i;
}
function cm(t6, e, r, n) {
  n === void 0 && (n = {});
  const {
    ancestorScroll: a = true,
    ancestorResize: i = true,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: o = typeof IntersectionObserver == "function",
    animationFrame: l = false
  } = n, c = Xc(t6), d = a || i ? [...c ? Ur(c) : [], ...Ur(e)] : [];
  d.forEach((w) => {
    a && w.addEventListener("scroll", r, {
      passive: true
    }), i && w.addEventListener("resize", r);
  });
  const u = c && o ? eM(c, r) : null;
  let f = -1, h = null;
  s && (h = new ResizeObserver((w) => {
    let [b] = w;
    b && b.target === c && h && (h.unobserve(e), cancelAnimationFrame(f), f = requestAnimationFrame(() => {
      var k;
      (k = h) == null || k.observe(e);
    })), r();
  }), c && !l && h.observe(c), h.observe(e));
  let g, m = l ? Rn(t6) : null;
  l && p();
  function p() {
    const w = Rn(t6);
    m && !lm(m, w) && r(), m = w, g = requestAnimationFrame(p);
  }
  return r(), () => {
    var w;
    d.forEach((b) => {
      a && b.removeEventListener("scroll", r), i && b.removeEventListener("resize", r);
    }), u == null || u(), (w = h) == null || w.disconnect(), h = null, l && cancelAnimationFrame(g);
  };
}
const tM = WD, rM = AD, nM = $D, aM = FD, Zf = ND, iM = (t6, e, r) => {
  const n = /* @__PURE__ */ new Map(), a = {
    platform: ZD,
    ...r
  }, i = {
    ...a.platform,
    _c: n
  };
  return RD(t6, e, {
    ...a,
    platform: i
  });
};
var hs = typeof document < "u" ? reactExports.useLayoutEffect : reactExports.useEffect;
function zs(t6, e) {
  if (t6 === e)
    return true;
  if (typeof t6 != typeof e)
    return false;
  if (typeof t6 == "function" && t6.toString() === e.toString())
    return true;
  let r, n, a;
  if (t6 && e && typeof t6 == "object") {
    if (Array.isArray(t6)) {
      if (r = t6.length, r !== e.length) return false;
      for (n = r; n-- !== 0; )
        if (!zs(t6[n], e[n]))
          return false;
      return true;
    }
    if (a = Object.keys(t6), r = a.length, r !== Object.keys(e).length)
      return false;
    for (n = r; n-- !== 0; )
      if (!{}.hasOwnProperty.call(e, a[n]))
        return false;
    for (n = r; n-- !== 0; ) {
      const i = a[n];
      if (!(i === "_owner" && t6.$$typeof) && !zs(t6[i], e[i]))
        return false;
    }
    return true;
  }
  return t6 !== t6 && e !== e;
}
function dm(t6) {
  return typeof window > "u" ? 1 : (t6.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function eh(t6, e) {
  const r = dm(t6);
  return Math.round(e * r) / r;
}
function al(t6) {
  const e = reactExports.useRef(t6);
  return hs(() => {
    e.current = t6;
  }), e;
}
function sM(t6) {
  t6 === void 0 && (t6 = {});
  const {
    placement: e = "bottom",
    strategy: r = "absolute",
    middleware: n = [],
    platform: a,
    elements: {
      reference: i,
      floating: s
    } = {},
    transform: o = true,
    whileElementsMounted: l,
    open: c
  } = t6, [d, u] = reactExports.useState({
    x: 0,
    y: 0,
    strategy: r,
    placement: e,
    middlewareData: {},
    isPositioned: false
  }), [f, h] = reactExports.useState(n);
  zs(f, n) || h(n);
  const [g, m] = reactExports.useState(null), [p, w] = reactExports.useState(null), b = reactExports.useCallback((U) => {
    U !== _.current && (_.current = U, m(U));
  }, []), k = reactExports.useCallback((U) => {
    U !== T.current && (T.current = U, w(U));
  }, []), v = i || g, x = s || p, _ = reactExports.useRef(null), T = reactExports.useRef(null), S = reactExports.useRef(d), C = l != null, D = al(l), z = al(a), A = al(c), L = reactExports.useCallback(() => {
    if (!_.current || !T.current)
      return;
    const U = {
      placement: e,
      strategy: r,
      middleware: f
    };
    z.current && (U.platform = z.current), iM(_.current, T.current, U).then((J) => {
      const E = {
        ...J,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: A.current !== false
      };
      M.current && !zs(S.current, E) && (S.current = E, reactDomExports.flushSync(() => {
        u(E);
      }));
    });
  }, [f, e, r, z, A]);
  hs(() => {
    c === false && S.current.isPositioned && (S.current.isPositioned = false, u((U) => ({
      ...U,
      isPositioned: false
    })));
  }, [c]);
  const M = reactExports.useRef(false);
  hs(() => (M.current = true, () => {
    M.current = false;
  }), []), hs(() => {
    if (v && (_.current = v), x && (T.current = x), v && x) {
      if (D.current)
        return D.current(v, x, L);
      L();
    }
  }, [v, x, L, D, C]);
  const I = reactExports.useMemo(() => ({
    reference: _,
    floating: T,
    setReference: b,
    setFloating: k
  }), [b, k]), W = reactExports.useMemo(() => ({
    reference: v,
    floating: x
  }), [v, x]), B = reactExports.useMemo(() => {
    const U = {
      position: r,
      left: 0,
      top: 0
    };
    if (!W.floating)
      return U;
    const J = eh(W.floating, d.x), E = eh(W.floating, d.y);
    return o ? {
      ...U,
      transform: "translate(" + J + "px, " + E + "px)",
      ...dm(W.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: r,
      left: J,
      top: E
    };
  }, [r, o, W.floating, d.x, d.y]);
  return reactExports.useMemo(() => ({
    ...d,
    update: L,
    refs: I,
    elements: W,
    floatingStyles: B
  }), [d, L, I, W, B]);
}
const oM = (t6) => {
  function e(r) {
    return {}.hasOwnProperty.call(r, "current");
  }
  return {
    name: "arrow",
    options: t6,
    fn(r) {
      const {
        element: n,
        padding: a
      } = typeof t6 == "function" ? t6(r) : t6;
      return n && e(n) ? n.current != null ? Zf({
        element: n.current,
        padding: a
      }).fn(r) : {} : n ? Zf({
        element: n,
        padding: a
      }).fn(r) : {};
    }
  };
}, lM = (t6, e) => ({
  ...tM(t6),
  options: [t6, e]
}), cM = (t6, e) => ({
  ...nM(t6),
  options: [t6, e]
}), dM = (t6, e) => ({
  ...aM(t6),
  options: [t6, e]
}), uM = (t6, e) => ({
  ...rM(t6),
  options: [t6, e]
}), fM = (t6, e) => ({
  ...oM(t6),
  options: [t6, e]
});
/*!
* tabbable 6.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
var hM = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"], js = /* @__PURE__ */ hM.join(","), um = typeof Element > "u", ca = um ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector, Hs = !um && Element.prototype.getRootNode ? function(t6) {
  var e;
  return t6 == null || (e = t6.getRootNode) === null || e === void 0 ? void 0 : e.call(t6);
} : function(t6) {
  return t6 == null ? void 0 : t6.ownerDocument;
}, Bs = function t2(e, r) {
  var n;
  r === void 0 && (r = true);
  var a = e == null || (n = e.getAttribute) === null || n === void 0 ? void 0 : n.call(e, "inert"), i = a === "" || a === "true", s = i || r && e && t2(e.parentNode);
  return s;
}, gM = function(e) {
  var r, n = e == null || (r = e.getAttribute) === null || r === void 0 ? void 0 : r.call(e, "contenteditable");
  return n === "" || n === "true";
}, mM = function(e, r, n) {
  if (Bs(e))
    return [];
  var a = Array.prototype.slice.apply(e.querySelectorAll(js));
  return r && ca.call(e, js) && a.unshift(e), a = a.filter(n), a;
}, pM = function t3(e, r, n) {
  for (var a = [], i = Array.from(e); i.length; ) {
    var s = i.shift();
    if (!Bs(s, false))
      if (s.tagName === "SLOT") {
        var o = s.assignedElements(), l = o.length ? o : s.children, c = t3(l, true, n);
        n.flatten ? a.push.apply(a, c) : a.push({
          scopeParent: s,
          candidates: c
        });
      } else {
        var d = ca.call(s, js);
        d && n.filter(s) && (r || !e.includes(s)) && a.push(s);
        var u = s.shadowRoot || // check for an undisclosed shadow
        typeof n.getShadowRoot == "function" && n.getShadowRoot(s), f = !Bs(u, false) && (!n.shadowRootFilter || n.shadowRootFilter(s));
        if (u && f) {
          var h = t3(u === true ? s.children : u.children, true, n);
          n.flatten ? a.push.apply(a, h) : a.push({
            scopeParent: s,
            candidates: h
          });
        } else
          i.unshift.apply(i, s.children);
      }
  }
  return a;
}, fm = function(e) {
  return !isNaN(parseInt(e.getAttribute("tabindex"), 10));
}, hm = function(e) {
  if (!e)
    throw new Error("No node provided");
  return e.tabIndex < 0 && (/^(AUDIO|VIDEO|DETAILS)$/.test(e.tagName) || gM(e)) && !fm(e) ? 0 : e.tabIndex;
}, bM = function(e, r) {
  var n = hm(e);
  return n < 0 && r && !fm(e) ? 0 : n;
}, yM = function(e, r) {
  return e.tabIndex === r.tabIndex ? e.documentOrder - r.documentOrder : e.tabIndex - r.tabIndex;
}, gm = function(e) {
  return e.tagName === "INPUT";
}, vM = function(e) {
  return gm(e) && e.type === "hidden";
}, xM = function(e) {
  var r = e.tagName === "DETAILS" && Array.prototype.slice.apply(e.children).some(function(n) {
    return n.tagName === "SUMMARY";
  });
  return r;
}, wM = function(e, r) {
  for (var n = 0; n < e.length; n++)
    if (e[n].checked && e[n].form === r)
      return e[n];
}, kM = function(e) {
  if (!e.name)
    return true;
  var r = e.form || Hs(e), n = function(o) {
    return r.querySelectorAll('input[type="radio"][name="' + o + '"]');
  }, a;
  if (typeof window < "u" && typeof window.CSS < "u" && typeof window.CSS.escape == "function")
    a = n(window.CSS.escape(e.name));
  else
    try {
      a = n(e.name);
    } catch (s) {
      return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", s.message), false;
    }
  var i = wM(a, e.form);
  return !i || i === e;
}, _M = function(e) {
  return gm(e) && e.type === "radio";
}, OM = function(e) {
  return _M(e) && !kM(e);
}, SM = function(e) {
  var r, n = e && Hs(e), a = (r = n) === null || r === void 0 ? void 0 : r.host, i = false;
  if (n && n !== e) {
    var s, o, l;
    for (i = !!((s = a) !== null && s !== void 0 && (o = s.ownerDocument) !== null && o !== void 0 && o.contains(a) || e != null && (l = e.ownerDocument) !== null && l !== void 0 && l.contains(e)); !i && a; ) {
      var c, d, u;
      n = Hs(a), a = (c = n) === null || c === void 0 ? void 0 : c.host, i = !!((d = a) !== null && d !== void 0 && (u = d.ownerDocument) !== null && u !== void 0 && u.contains(a));
    }
  }
  return i;
}, th = function(e) {
  var r = e.getBoundingClientRect(), n = r.width, a = r.height;
  return n === 0 && a === 0;
}, DM = function(e, r) {
  var n = r.displayCheck, a = r.getShadowRoot;
  if (getComputedStyle(e).visibility === "hidden")
    return true;
  var i = ca.call(e, "details>summary:first-of-type"), s = i ? e.parentElement : e;
  if (ca.call(s, "details:not([open]) *"))
    return true;
  if (!n || n === "full" || n === "legacy-full") {
    if (typeof a == "function") {
      for (var o = e; e; ) {
        var l = e.parentElement, c = Hs(e);
        if (l && !l.shadowRoot && a(l) === true)
          return th(e);
        e.assignedSlot ? e = e.assignedSlot : !l && c !== e.ownerDocument ? e = c.host : e = l;
      }
      e = o;
    }
    if (SM(e))
      return !e.getClientRects().length;
    if (n !== "legacy-full")
      return true;
  } else if (n === "non-zero-area")
    return th(e);
  return false;
}, MM = function(e) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(e.tagName))
    for (var r = e.parentElement; r; ) {
      if (r.tagName === "FIELDSET" && r.disabled) {
        for (var n = 0; n < r.children.length; n++) {
          var a = r.children.item(n);
          if (a.tagName === "LEGEND")
            return ca.call(r, "fieldset[disabled] *") ? true : !a.contains(e);
        }
        return true;
      }
      r = r.parentElement;
    }
  return false;
}, CM = function(e, r) {
  return !(r.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  Bs(r) || vM(r) || DM(r, e) || // For a details element with a summary, the summary element gets the focus
  xM(r) || MM(r));
}, Vl = function(e, r) {
  return !(OM(r) || hm(r) < 0 || !CM(e, r));
}, EM = function(e) {
  var r = parseInt(e.getAttribute("tabindex"), 10);
  return !!(isNaN(r) || r >= 0);
}, TM = function t4(e) {
  var r = [], n = [];
  return e.forEach(function(a, i) {
    var s = !!a.scopeParent, o = s ? a.scopeParent : a, l = bM(o, s), c = s ? t4(a.candidates) : o;
    l === 0 ? s ? r.push.apply(r, c) : r.push(o) : n.push({
      documentOrder: i,
      tabIndex: l,
      item: a,
      isScope: s,
      content: c
    });
  }), n.sort(yM).reduce(function(a, i) {
    return i.isScope ? a.push.apply(a, i.content) : a.push(i.content), a;
  }, []).concat(r);
}, _o = function(e, r) {
  r = r || {};
  var n;
  return r.getShadowRoot ? n = pM([e], r.includeContainer, {
    filter: Vl.bind(null, r),
    flatten: false,
    getShadowRoot: r.getShadowRoot,
    shadowRootFilter: EM
  }) : n = mM(e, r.includeContainer, Vl.bind(null, r)), TM(n);
}, PM = function(e, r) {
  if (r = r || {}, !e)
    throw new Error("No node provided");
  return ca.call(e, js) === false ? false : Vl(r, e);
};
function mm(t6) {
  return reactExports.useMemo(() => t6.every((e) => e == null) ? null : (e) => {
    t6.forEach((r) => {
      typeof r == "function" ? r(e) : r != null && (r.current = e);
    });
  }, t6);
}
const RM = reactExports.useInsertionEffect, NM = RM || ((t6) => t6());
function lr(t6) {
  const e = reactExports.useRef(() => {
  });
  return NM(() => {
    e.current = t6;
  }), reactExports.useCallback(function() {
    for (var r = arguments.length, n = new Array(r), a = 0; a < r; a++)
      n[a] = arguments[a];
    return e.current == null ? void 0 : e.current(...n);
  }, []);
}
const Kc = "ArrowUp", ki = "ArrowDown", da = "ArrowLeft", ba = "ArrowRight";
function Gi(t6, e, r) {
  return Math.floor(t6 / e) !== r;
}
function Qa(t6, e) {
  return e < 0 || e >= t6.current.length;
}
function il(t6, e) {
  return gt(t6, {
    disabledIndices: e
  });
}
function rh(t6, e) {
  return gt(t6, {
    decrement: true,
    startingIndex: t6.current.length,
    disabledIndices: e
  });
}
function gt(t6, e) {
  let {
    startingIndex: r = -1,
    decrement: n = false,
    disabledIndices: a,
    amount: i = 1
  } = e === void 0 ? {} : e;
  const s = t6.current, o = a ? (c) => a.includes(c) : (c) => {
    const d = s[c];
    return d == null || d.hasAttribute("disabled") || d.getAttribute("aria-disabled") === "true";
  };
  let l = r;
  do
    l += n ? -i : i;
  while (l >= 0 && l <= s.length - 1 && o(l));
  return l;
}
function IM(t6, e) {
  let {
    event: r,
    orientation: n,
    loop: a,
    cols: i,
    disabledIndices: s,
    minIndex: o,
    maxIndex: l,
    prevIndex: c,
    stopEvent: d = false
  } = e, u = c;
  if (r.key === Kc) {
    if (d && st(r), c === -1)
      u = l;
    else if (u = gt(t6, {
      startingIndex: u,
      amount: i,
      decrement: true,
      disabledIndices: s
    }), a && (c - i < o || u < 0)) {
      const f = c % i, h = l % i, g = l - (h - f);
      h === f ? u = l : u = h > f ? g : g - i;
    }
    Qa(t6, u) && (u = c);
  }
  if (r.key === ki && (d && st(r), c === -1 ? u = o : (u = gt(t6, {
    startingIndex: c,
    amount: i,
    disabledIndices: s
  }), a && c + i > l && (u = gt(t6, {
    startingIndex: c % i - i,
    amount: i,
    disabledIndices: s
  }))), Qa(t6, u) && (u = c)), n === "both") {
    const f = Xn(c / i);
    r.key === ba && (d && st(r), c % i !== i - 1 ? (u = gt(t6, {
      startingIndex: c,
      disabledIndices: s
    }), a && Gi(u, i, f) && (u = gt(t6, {
      startingIndex: c - c % i - 1,
      disabledIndices: s
    }))) : a && (u = gt(t6, {
      startingIndex: c - c % i - 1,
      disabledIndices: s
    })), Gi(u, i, f) && (u = c)), r.key === da && (d && st(r), c % i !== 0 ? (u = gt(t6, {
      startingIndex: c,
      disabledIndices: s,
      decrement: true
    }), a && Gi(u, i, f) && (u = gt(t6, {
      startingIndex: c + (i - c % i),
      decrement: true,
      disabledIndices: s
    }))) : a && (u = gt(t6, {
      startingIndex: c + (i - c % i),
      decrement: true,
      disabledIndices: s
    })), Gi(u, i, f) && (u = c));
    const h = Xn(l / i) === f;
    Qa(t6, u) && (a && h ? u = r.key === da ? l : gt(t6, {
      startingIndex: c - c % i - 1,
      disabledIndices: s
    }) : u = c);
  }
  return u;
}
function AM(t6, e, r) {
  const n = [];
  let a = 0;
  return t6.forEach((i, s) => {
    let {
      width: o,
      height: l
    } = i;
    let c = false;
    for (r && (a = 0); !c; ) {
      const d = [];
      for (let u = 0; u < o; u++)
        for (let f = 0; f < l; f++)
          d.push(a + u + f * e);
      a % e + o <= e && d.every((u) => n[u] == null) ? (d.forEach((u) => {
        n[u] = s;
      }), c = true) : a++;
    }
  }), [...n];
}
function FM(t6, e, r, n, a) {
  if (t6 === -1) return -1;
  const i = r.indexOf(t6);
  switch (a) {
    case "tl":
      return i;
    case "tr":
      return i + e[t6].width - 1;
    case "bl":
      return i + (e[t6].height - 1) * n;
    case "br":
      return r.lastIndexOf(t6);
  }
}
function LM(t6, e) {
  return e.flatMap((r, n) => t6.includes(r) ? [n] : []);
}
let nh = 0;
function Dr(t6, e) {
  e === void 0 && (e = {});
  const {
    preventScroll: r = false,
    cancelPrevious: n = true,
    sync: a = false
  } = e;
  n && cancelAnimationFrame(nh);
  const i = () => t6 == null ? void 0 : t6.focus({
    preventScroll: r
  });
  a ? i() : nh = requestAnimationFrame(i);
}
var Re = typeof document < "u" ? reactExports.useLayoutEffect : reactExports.useEffect;
function WM(t6, e) {
  const r = t6.compareDocumentPosition(e);
  return r & Node.DOCUMENT_POSITION_FOLLOWING || r & Node.DOCUMENT_POSITION_CONTAINED_BY ? -1 : r & Node.DOCUMENT_POSITION_PRECEDING || r & Node.DOCUMENT_POSITION_CONTAINS ? 1 : 0;
}
function $M(t6, e) {
  if (t6.size !== e.size)
    return false;
  for (const [r, n] of t6.entries())
    if (n !== e.get(r))
      return false;
  return true;
}
const pm = /* @__PURE__ */ reactExports.createContext({
  register: () => {
  },
  unregister: () => {
  },
  map: /* @__PURE__ */ new Map(),
  elementsRef: {
    current: []
  }
});
function zM(t6) {
  let {
    children: e,
    elementsRef: r,
    labelsRef: n
  } = t6;
  const [a, i] = reactExports.useState(() => /* @__PURE__ */ new Map()), s = reactExports.useCallback((l) => {
    i((c) => new Map(c).set(l, null));
  }, []), o = reactExports.useCallback((l) => {
    i((c) => {
      const d = new Map(c);
      return d.delete(l), d;
    });
  }, []);
  return Re(() => {
    const l = new Map(a);
    Array.from(l.keys()).sort(WM).forEach((d, u) => {
      l.set(d, u);
    }), $M(a, l) || i(l);
  }, [a]), /* @__PURE__ */ reactExports.createElement(pm.Provider, {
    value: reactExports.useMemo(() => ({
      register: s,
      unregister: o,
      map: a,
      elementsRef: r,
      labelsRef: n
    }), [s, o, a, r, n])
  }, e);
}
function jM(t6) {
  let {
    label: e
  } = t6 === void 0 ? {} : t6;
  const [r, n] = reactExports.useState(null), a = reactExports.useRef(null), {
    register: i,
    unregister: s,
    map: o,
    elementsRef: l,
    labelsRef: c
  } = reactExports.useContext(pm), d = reactExports.useCallback((u) => {
    if (a.current = u, r !== null && (l.current[r] = u, c)) {
      var f;
      const h = e !== void 0;
      c.current[r] = h ? e : (f = u == null ? void 0 : u.textContent) != null ? f : null;
    }
  }, [r, l, c, e]);
  return Re(() => {
    const u = a.current;
    if (u)
      return i(u), () => {
        s(u);
      };
  }, [i, s]), Re(() => {
    const u = a.current ? o.get(a.current) : null;
    u != null && n(u);
  }, [o]), reactExports.useMemo(() => ({
    ref: d,
    index: r ?? -1
  }), [r, d]);
}
function fi() {
  return fi = Object.assign ? Object.assign.bind() : function(t6) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (t6[n] = r[n]);
    }
    return t6;
  }, fi.apply(this, arguments);
}
let sl = false, HM = 0;
const ah = () => "floating-ui-" + HM++;
function BM() {
  const [t6, e] = reactExports.useState(() => sl ? ah() : void 0);
  return Re(() => {
    t6 == null && e(ah());
  }, []), reactExports.useEffect(() => {
    sl || (sl = true);
  }, []), t6;
}
const YM = reactExports.useId, Oo = YM || BM;
function VM() {
  const t6 = /* @__PURE__ */ new Map();
  return {
    emit(e, r) {
      var n;
      (n = t6.get(e)) == null || n.forEach((a) => a(r));
    },
    on(e, r) {
      t6.set(e, [...t6.get(e) || [], r]);
    },
    off(e, r) {
      var n;
      t6.set(e, ((n = t6.get(e)) == null ? void 0 : n.filter((a) => a !== r)) || []);
    }
  };
}
const qM = /* @__PURE__ */ reactExports.createContext(null), UM = /* @__PURE__ */ reactExports.createContext(null), So = () => {
  var t6;
  return ((t6 = reactExports.useContext(qM)) == null ? void 0 : t6.id) || null;
}, _i = () => reactExports.useContext(UM);
function Nn(t6) {
  return "data-floating-ui-" + t6;
}
function mr(t6) {
  const e = reactExports.useRef(t6);
  return Re(() => {
    e.current = t6;
  }), e;
}
const ih = /* @__PURE__ */ Nn("safe-polygon");
function ol(t6, e, r) {
  return r && !As(r) ? 0 : typeof t6 == "number" ? t6 : t6 == null ? void 0 : t6[e];
}
function XM(t6, e) {
  e === void 0 && (e = {});
  const {
    open: r,
    onOpenChange: n,
    dataRef: a,
    events: i,
    elements: {
      domReference: s,
      floating: o
    },
    refs: l
  } = t6, {
    enabled: c = true,
    delay: d = 0,
    handleClose: u = null,
    mouseOnly: f = false,
    restMs: h = 0,
    move: g = true
  } = e, m = _i(), p = So(), w = mr(u), b = mr(d), k = reactExports.useRef(), v = reactExports.useRef(), x = reactExports.useRef(), _ = reactExports.useRef(), T = reactExports.useRef(true), S = reactExports.useRef(false), C = reactExports.useRef(() => {
  }), D = reactExports.useCallback(() => {
    var M;
    const I = (M = a.current.openEvent) == null ? void 0 : M.type;
    return (I == null ? void 0 : I.includes("mouse")) && I !== "mousedown";
  }, [a]);
  reactExports.useEffect(() => {
    if (!c)
      return;
    function M(I) {
      let {
        open: W
      } = I;
      W || (clearTimeout(v.current), clearTimeout(_.current), T.current = true);
    }
    return i.on("openchange", M), () => {
      i.off("openchange", M);
    };
  }, [c, i]), reactExports.useEffect(() => {
    if (!c || !w.current || !r)
      return;
    function M(W) {
      D() && n(false, W, "hover");
    }
    const I = yt(o).documentElement;
    return I.addEventListener("mouseleave", M), () => {
      I.removeEventListener("mouseleave", M);
    };
  }, [o, r, n, c, w, D]);
  const z = reactExports.useCallback(function(M, I, W) {
    I === void 0 && (I = true), W === void 0 && (W = "hover");
    const B = ol(b.current, "close", k.current);
    B && !x.current ? (clearTimeout(v.current), v.current = setTimeout(() => n(false, M, W), B)) : I && (clearTimeout(v.current), n(false, M, W));
  }, [b, n]), A = reactExports.useCallback(() => {
    C.current(), x.current = void 0;
  }, []), L = reactExports.useCallback(() => {
    if (S.current) {
      const M = yt(l.floating.current).body;
      M.style.pointerEvents = "", M.removeAttribute(ih), S.current = false;
    }
  }, [l]);
  return reactExports.useEffect(() => {
    if (!c)
      return;
    function M() {
      return a.current.openEvent ? ["click", "mousedown"].includes(a.current.openEvent.type) : false;
    }
    function I(U) {
      if (clearTimeout(v.current), T.current = false, f && !As(k.current) || h > 0 && ol(b.current, "open") === 0)
        return;
      const J = ol(b.current, "open", k.current);
      J ? v.current = setTimeout(() => {
        n(true, U, "hover");
      }, J) : n(true, U, "hover");
    }
    function W(U) {
      if (M())
        return;
      C.current();
      const J = yt(o);
      if (clearTimeout(_.current), w.current) {
        r || clearTimeout(v.current), x.current = w.current({
          ...t6,
          tree: m,
          x: U.clientX,
          y: U.clientY,
          onClose() {
            L(), A(), z(U, true, "safe-polygon");
          }
        });
        const j = x.current;
        J.addEventListener("mousemove", j), C.current = () => {
          J.removeEventListener("mousemove", j);
        };
        return;
      }
      (k.current === "touch" ? !Ge(o, U.relatedTarget) : true) && z(U);
    }
    function B(U) {
      M() || w.current == null || w.current({
        ...t6,
        tree: m,
        x: U.clientX,
        y: U.clientY,
        onClose() {
          L(), A(), z(U);
        }
      })(U);
    }
    if (Ce(s)) {
      const U = s;
      return r && U.addEventListener("mouseleave", B), o == null || o.addEventListener("mouseleave", B), g && U.addEventListener("mousemove", I, {
        once: true
      }), U.addEventListener("mouseenter", I), U.addEventListener("mouseleave", W), () => {
        r && U.removeEventListener("mouseleave", B), o == null || o.removeEventListener("mouseleave", B), g && U.removeEventListener("mousemove", I), U.removeEventListener("mouseenter", I), U.removeEventListener("mouseleave", W);
      };
    }
  }, [s, o, c, t6, f, h, g, z, A, L, n, r, m, b, w, a]), Re(() => {
    var M;
    if (c && r && (M = w.current) != null && M.__options.blockPointerEvents && D()) {
      const W = yt(o).body;
      if (W.setAttribute(ih, ""), W.style.pointerEvents = "none", S.current = true, Ce(s) && o) {
        var I;
        const B = s, U = m == null || (I = m.nodesRef.current.find((J) => J.id === p)) == null || (I = I.context) == null ? void 0 : I.elements.floating;
        return U && (U.style.pointerEvents = ""), B.style.pointerEvents = "auto", o.style.pointerEvents = "auto", () => {
          B.style.pointerEvents = "", o.style.pointerEvents = "";
        };
      }
    }
  }, [c, r, p, o, s, m, w, D]), Re(() => {
    r || (k.current = void 0, A(), L());
  }, [r, A, L]), reactExports.useEffect(() => () => {
    A(), clearTimeout(v.current), clearTimeout(_.current), L();
  }, [c, s, A, L]), reactExports.useMemo(() => {
    if (!c)
      return {};
    function M(I) {
      k.current = I.pointerType;
    }
    return {
      reference: {
        onPointerDown: M,
        onPointerEnter: M,
        onMouseMove(I) {
          r || h === 0 || (clearTimeout(_.current), _.current = setTimeout(() => {
            T.current || n(true, I.nativeEvent, "hover");
          }, h));
        }
      },
      floating: {
        onMouseEnter() {
          clearTimeout(v.current);
        },
        onMouseLeave(I) {
          z(I.nativeEvent, false);
        }
      }
    };
  }, [c, h, r, n, z]);
}
function GM(t6, e) {
  var r;
  let n = [], a = (r = t6.find((i) => i.id === e)) == null ? void 0 : r.parentId;
  for (; a; ) {
    const i = t6.find((s) => s.id === a);
    a = i == null ? void 0 : i.parentId, i && (n = n.concat(i));
  }
  return n;
}
function Mn(t6, e) {
  let r = t6.filter((a) => {
    var i;
    return a.parentId === e && ((i = a.context) == null ? void 0 : i.open);
  }), n = r;
  for (; n.length; )
    n = t6.filter((a) => {
      var i;
      return (i = n) == null ? void 0 : i.some((s) => {
        var o;
        return a.parentId === s.id && ((o = a.context) == null ? void 0 : o.open);
      });
    }), r = r.concat(n);
  return r;
}
function KM(t6, e) {
  let r, n = -1;
  function a(i, s) {
    s > n && (r = i, n = s), Mn(t6, i).forEach((l) => {
      a(l.id, s + 1);
    });
  }
  return a(e, 0), t6.find((i) => i.id === r);
}
let jn = /* @__PURE__ */ new WeakMap(), Ki = /* @__PURE__ */ new WeakSet(), Qi = {}, ll = 0;
const QM = () => typeof HTMLElement < "u" && "inert" in HTMLElement.prototype, bm = (t6) => t6 && (t6.host || bm(t6.parentNode)), JM = (t6, e) => e.map((r) => {
  if (t6.contains(r))
    return r;
  const n = bm(r);
  return t6.contains(n) ? n : null;
}).filter((r) => r != null);
function ZM(t6, e, r, n) {
  const a = "data-floating-ui-inert", i = n ? "inert" : r ? "aria-hidden" : null, s = JM(e, t6), o = /* @__PURE__ */ new Set(), l = new Set(s), c = [];
  Qi[a] || (Qi[a] = /* @__PURE__ */ new WeakMap());
  const d = Qi[a];
  s.forEach(u), f(e), o.clear();
  function u(h) {
    !h || o.has(h) || (o.add(h), h.parentNode && u(h.parentNode));
  }
  function f(h) {
    !h || l.has(h) || Array.prototype.forEach.call(h.children, (g) => {
      if (o.has(g))
        f(g);
      else {
        const m = i ? g.getAttribute(i) : null, p = m !== null && m !== "false", w = (jn.get(g) || 0) + 1, b = (d.get(g) || 0) + 1;
        jn.set(g, w), d.set(g, b), c.push(g), w === 1 && p && Ki.add(g), b === 1 && g.setAttribute(a, ""), !p && i && g.setAttribute(i, "true");
      }
    });
  }
  return ll++, () => {
    c.forEach((h) => {
      const g = (jn.get(h) || 0) - 1, m = (d.get(h) || 0) - 1;
      jn.set(h, g), d.set(h, m), g || (!Ki.has(h) && i && h.removeAttribute(i), Ki.delete(h)), m || h.removeAttribute(a);
    }), ll--, ll || (jn = /* @__PURE__ */ new WeakMap(), jn = /* @__PURE__ */ new WeakMap(), Ki = /* @__PURE__ */ new WeakSet(), Qi = {});
  };
}
function sh(t6, e, r) {
  e === void 0 && (e = false), r === void 0 && (r = false);
  const n = yt(t6[0]).body;
  return ZM(t6.concat(Array.from(n.querySelectorAll("[aria-live]"))), n, e, r);
}
const hi = () => ({
  getShadowRoot: true,
  displayCheck: (
    // JSDOM does not support the `tabbable` library. To solve this we can
    // check if `ResizeObserver` is a real function (not polyfilled), which
    // determines if the current environment is JSDOM-like.
    typeof ResizeObserver == "function" && ResizeObserver.toString().includes("[native code]") ? "full" : "none"
  )
});
function ym(t6, e) {
  const r = _o(t6, hi());
  e === "prev" && r.reverse();
  const n = r.indexOf(or(yt(t6)));
  return r.slice(n + 1)[0];
}
function vm() {
  return ym(document.body, "next");
}
function xm() {
  return ym(document.body, "prev");
}
function Ja(t6, e) {
  const r = e || t6.currentTarget, n = t6.relatedTarget;
  return !n || !Ge(r, n);
}
function e2(t6) {
  _o(t6, hi()).forEach((r) => {
    r.dataset.tabindex = r.getAttribute("tabindex") || "", r.setAttribute("tabindex", "-1");
  });
}
function t22(t6) {
  t6.querySelectorAll("[data-tabindex]").forEach((r) => {
    const n = r.dataset.tabindex;
    delete r.dataset.tabindex, n ? r.setAttribute("tabindex", n) : r.removeAttribute("tabindex");
  });
}
const Qc = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "fixed",
  whiteSpace: "nowrap",
  width: "1px",
  top: 0,
  left: 0
};
let r2;
function oh(t6) {
  t6.key === "Tab" && (t6.target, clearTimeout(r2));
}
const Ys = /* @__PURE__ */ reactExports.forwardRef(function(e, r) {
  const [n, a] = reactExports.useState();
  Re(() => (Bc() && a("button"), document.addEventListener("keydown", oh), () => {
    document.removeEventListener("keydown", oh);
  }), []);
  const i = {
    ref: r,
    tabIndex: 0,
    // Role is only for VoiceOver
    role: n,
    "aria-hidden": n ? void 0 : true,
    [Nn("focus-guard")]: "",
    style: Qc
  };
  return /* @__PURE__ */ reactExports.createElement("span", fi({}, e, i));
}), wm = /* @__PURE__ */ reactExports.createContext(null), lh = /* @__PURE__ */ Nn("portal");
function n2(t6) {
  let {
    id: e,
    root: r
  } = t6 === void 0 ? {} : t6;
  const [n, a] = reactExports.useState(null), i = Oo(), s = km(), o = reactExports.useRef(null);
  return Re(() => () => {
    n == null || n.remove(), queueMicrotask(() => {
      o.current = null;
    });
  }, [n]), Re(() => {
    if (o.current) return;
    const l = e ? document.getElementById(e) : null;
    if (!l) return;
    const c = document.createElement("div");
    c.id = i, c.setAttribute(lh, ""), l.appendChild(c), o.current = c, a(c);
  }, [e, i]), Re(() => {
    if (o.current) return;
    let l = r || (s == null ? void 0 : s.portalNode);
    l && !Ce(l) && (l = l.current), l = l || document.body;
    let c = null;
    e && (c = document.createElement("div"), c.id = e, l.appendChild(c));
    const d = document.createElement("div");
    d.id = i, d.setAttribute(lh, ""), l = c || l, l.appendChild(d), o.current = d, a(d);
  }, [e, r, i, s]), n;
}
function a2(t6) {
  let {
    children: e,
    id: r,
    root: n = null,
    preserveTabOrder: a = true
  } = t6;
  const i = n2({
    id: r,
    root: n
  }), [s, o] = reactExports.useState(null), l = reactExports.useRef(null), c = reactExports.useRef(null), d = reactExports.useRef(null), u = reactExports.useRef(null), f = (
    // The FocusManager and therefore floating element are currently open/
    // rendered.
    !!s && // Guards are only for non-modal focus management.
    !s.modal && // Don't render if unmount is transitioning.
    s.open && a && !!(n || i)
  );
  return reactExports.useEffect(() => {
    if (!i || !a || s != null && s.modal)
      return;
    function h(g) {
      i && Ja(g) && (g.type === "focusin" ? t22 : e2)(i);
    }
    return i.addEventListener("focusin", h, true), i.addEventListener("focusout", h, true), () => {
      i.removeEventListener("focusin", h, true), i.removeEventListener("focusout", h, true);
    };
  }, [i, a, s == null ? void 0 : s.modal]), /* @__PURE__ */ reactExports.createElement(wm.Provider, {
    value: reactExports.useMemo(() => ({
      preserveTabOrder: a,
      beforeOutsideRef: l,
      afterOutsideRef: c,
      beforeInsideRef: d,
      afterInsideRef: u,
      portalNode: i,
      setFocusManagerState: o
    }), [a, i])
  }, f && i && /* @__PURE__ */ reactExports.createElement(Ys, {
    "data-type": "outside",
    ref: l,
    onFocus: (h) => {
      if (Ja(h, i)) {
        var g;
        (g = d.current) == null || g.focus();
      } else {
        const m = xm() || (s == null ? void 0 : s.refs.domReference.current);
        m == null || m.focus();
      }
    }
  }), f && i && /* @__PURE__ */ reactExports.createElement("span", {
    "aria-owns": i.id,
    style: Qc
  }), i && /* @__PURE__ */ reactDomExports.createPortal(e, i), f && i && /* @__PURE__ */ reactExports.createElement(Ys, {
    "data-type": "outside",
    ref: c,
    onFocus: (h) => {
      if (Ja(h, i)) {
        var g;
        (g = u.current) == null || g.focus();
      } else {
        const m = vm() || (s == null ? void 0 : s.refs.domReference.current);
        m == null || m.focus(), s != null && s.closeOnFocusOut && (s == null || s.onOpenChange(false, h.nativeEvent));
      }
    }
  }));
}
const km = () => reactExports.useContext(wm), i2 = 20;
let pn = [];
function cl(t6) {
  pn = pn.filter((r) => r.isConnected);
  let e = t6;
  if (!(!e || An(e) === "body")) {
    if (!PM(e, hi())) {
      const r = _o(e, hi())[0];
      if (!r) return;
      e = r;
    }
    pn.push(e), pn.length > i2 && (pn = pn.slice(-20));
  }
}
function ch() {
  return pn.slice().reverse().find((t6) => t6.isConnected);
}
const s2 = /* @__PURE__ */ reactExports.forwardRef(function(e, r) {
  return /* @__PURE__ */ reactExports.createElement("button", fi({}, e, {
    type: "button",
    ref: r,
    tabIndex: -1,
    style: Qc
  }));
});
function _m(t6) {
  const {
    context: e,
    children: r,
    disabled: n = false,
    order: a = ["content"],
    guards: i = true,
    initialFocus: s = 0,
    returnFocus: o = true,
    modal: l = true,
    visuallyHiddenDismiss: c = false,
    closeOnFocusOut: d = true
  } = t6, {
    open: u,
    refs: f,
    nodeId: h,
    onOpenChange: g,
    events: m,
    dataRef: p,
    elements: {
      domReference: w,
      floating: b
    }
  } = e, k = typeof s == "number" && s < 0, v = Z0(w) && k, x = QM() ? i : true, _ = mr(a), T = mr(s), S = mr(o), C = _i(), D = km(), z = reactExports.useRef(null), A = reactExports.useRef(null), L = reactExports.useRef(false), M = reactExports.useRef(false), I = D != null, W = reactExports.useCallback(function(E) {
    return E === void 0 && (E = b), E ? _o(E, hi()) : [];
  }, [b]), B = reactExports.useCallback((E) => {
    const j = W(E);
    return _.current.map((N) => w && N === "reference" ? w : b && N === "floating" ? b : j).filter(Boolean).flat();
  }, [w, b, _, W]);
  reactExports.useEffect(() => {
    if (n || !l) return;
    function E(N) {
      if (N.key === "Tab") {
        Ge(b, or(yt(b))) && W().length === 0 && !v && st(N);
        const R = B(), P = Br(N);
        _.current[0] === "reference" && P === w && (st(N), N.shiftKey ? Dr(R[R.length - 1]) : Dr(R[1])), _.current[1] === "floating" && P === b && N.shiftKey && (st(N), Dr(R[0]));
      }
    }
    const j = yt(b);
    return j.addEventListener("keydown", E), () => {
      j.removeEventListener("keydown", E);
    };
  }, [n, w, b, l, _, v, W, B]), reactExports.useEffect(() => {
    if (n || !d) return;
    function E() {
      M.current = true, setTimeout(() => {
        M.current = false;
      });
    }
    function j(N) {
      const R = N.relatedTarget;
      queueMicrotask(() => {
        const P = !(Ge(w, R) || Ge(b, R) || Ge(R, b) || Ge(D == null ? void 0 : D.portalNode, R) || R != null && R.hasAttribute(Nn("focus-guard")) || C && (Mn(C.nodesRef.current, h).find((O) => {
          var F, X;
          return Ge((F = O.context) == null ? void 0 : F.elements.floating, R) || Ge((X = O.context) == null ? void 0 : X.elements.domReference, R);
        }) || GM(C.nodesRef.current, h).find((O) => {
          var F, X;
          return ((F = O.context) == null ? void 0 : F.elements.floating) === R || ((X = O.context) == null ? void 0 : X.elements.domReference) === R;
        })));
        R && P && !M.current && // Fix React 18 Strict Mode returnFocus due to double rendering.
        R !== ch() && (L.current = true, g(false, N));
      });
    }
    if (b && ut(w))
      return w.addEventListener("focusout", j), w.addEventListener("pointerdown", E), !l && b.addEventListener("focusout", j), () => {
        w.removeEventListener("focusout", j), w.removeEventListener("pointerdown", E), !l && b.removeEventListener("focusout", j);
      };
  }, [n, w, b, l, h, C, D, g, d]), reactExports.useEffect(() => {
    var E;
    if (n) return;
    const j = Array.from((D == null || (E = D.portalNode) == null ? void 0 : E.querySelectorAll("[" + Nn("portal") + "]")) || []);
    if (b) {
      const N = [b, ...j, z.current, A.current, _.current.includes("reference") || v ? w : null].filter((P) => P != null), R = l || v ? sh(N, x, !x) : sh(N);
      return () => {
        R();
      };
    }
  }, [n, w, b, l, _, D, v, x]), Re(() => {
    if (n || !b) return;
    const E = yt(b), j = or(E);
    queueMicrotask(() => {
      const N = B(b), R = T.current, P = (typeof R == "number" ? N[R] : R.current) || b, O = Ge(b, j);
      !k && !O && u && Dr(P, {
        preventScroll: P === b
      });
    });
  }, [n, u, b, k, B, T]), Re(() => {
    if (n || !b) return;
    let E = false;
    const j = yt(b), N = or(j), R = p.current;
    cl(N);
    function P(O) {
      let {
        reason: F,
        event: X,
        nested: q
      } = O;
      F === "escape-key" && f.domReference.current && cl(f.domReference.current), F === "hover" && X.type === "mouseleave" && (L.current = true), F === "outside-press" && (q ? (L.current = false, E = true) : L.current = !(Q0(X) || Hc(X)));
    }
    return m.on("openchange", P), () => {
      m.off("openchange", P);
      const O = or(j), F = Ge(b, O) || C && Mn(C.nodesRef.current, h).some((G) => {
        var Z;
        return Ge((Z = G.context) == null ? void 0 : Z.elements.floating, O);
      });
      (F || R.openEvent && ["click", "mousedown"].includes(R.openEvent.type)) && f.domReference.current && cl(f.domReference.current);
      const q = ch();
      S.current && !L.current && ut(q) && // If the focus moved somewhere else after mount, avoid returning focus
      // since it likely entered a different element which should be
      // respected: https://github.com/floating-ui/floating-ui/issues/2607
      (!(q !== O && O !== j.body) || F) && Dr(q, {
        // When dismissing nested floating elements, by the time the rAF has
        // executed, the menus will all have been unmounted. When they try
        // to get focused, the calls get ignored — leaving the root
        // reference focused as desired.
        cancelPrevious: false,
        preventScroll: E
      });
    };
  }, [n, b, S, p, f, m, C, h]), Re(() => {
    if (!(n || !D))
      return D.setFocusManagerState({
        modal: l,
        closeOnFocusOut: d,
        open: u,
        onOpenChange: g,
        refs: f
      }), () => {
        D.setFocusManagerState(null);
      };
  }, [n, D, l, u, g, f, d]), Re(() => {
    if (n || !b || typeof MutationObserver != "function" || k)
      return;
    const E = () => {
      const N = b.getAttribute("tabindex");
      _.current.includes("floating") || or(yt(b)) !== f.domReference.current && W().length === 0 ? N !== "0" && b.setAttribute("tabindex", "0") : N !== "-1" && b.setAttribute("tabindex", "-1");
    };
    E();
    const j = new MutationObserver(E);
    return j.observe(b, {
      childList: true,
      subtree: true,
      attributes: true
    }), () => {
      j.disconnect();
    };
  }, [n, b, f, _, W, k]);
  function U(E) {
    return n || !c || !l ? null : /* @__PURE__ */ reactExports.createElement(s2, {
      ref: E === "start" ? z : A,
      onClick: (j) => g(false, j.nativeEvent)
    }, typeof c == "string" ? c : "Dismiss");
  }
  const J = !n && x && (I || l);
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, J && /* @__PURE__ */ reactExports.createElement(Ys, {
    "data-type": "inside",
    ref: D == null ? void 0 : D.beforeInsideRef,
    onFocus: (E) => {
      if (l) {
        const N = B();
        Dr(a[0] === "reference" ? N[0] : N[N.length - 1]);
      } else if (D != null && D.preserveTabOrder && D.portalNode)
        if (L.current = false, Ja(E, D.portalNode)) {
          const N = vm() || w;
          N == null || N.focus();
        } else {
          var j;
          (j = D.beforeOutsideRef.current) == null || j.focus();
        }
    }
  }), !v && U("start"), r, U("end"), J && /* @__PURE__ */ reactExports.createElement(Ys, {
    "data-type": "inside",
    ref: D == null ? void 0 : D.afterInsideRef,
    onFocus: (E) => {
      if (l)
        Dr(B()[0]);
      else if (D != null && D.preserveTabOrder && D.portalNode)
        if (d && (L.current = true), Ja(E, D.portalNode)) {
          const N = xm() || w;
          N == null || N.focus();
        } else {
          var j;
          (j = D.afterOutsideRef.current) == null || j.focus();
        }
    }
  }));
}
const dl = /* @__PURE__ */ new Set(), o2 = /* @__PURE__ */ reactExports.forwardRef(function(e, r) {
  let {
    lockScroll: n = false,
    ...a
  } = e;
  const i = Oo();
  return Re(() => {
    if (!n) return;
    dl.add(i);
    const s = /iP(hone|ad|od)|iOS/.test(jc()), o = document.body.style, c = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft ? "paddingLeft" : "paddingRight", d = window.innerWidth - document.documentElement.clientWidth, u = o.left ? parseFloat(o.left) : window.pageXOffset, f = o.top ? parseFloat(o.top) : window.pageYOffset;
    if (o.overflow = "hidden", d && (o[c] = d + "px"), s) {
      var h, g;
      const m = ((h = window.visualViewport) == null ? void 0 : h.offsetLeft) || 0, p = ((g = window.visualViewport) == null ? void 0 : g.offsetTop) || 0;
      Object.assign(o, {
        position: "fixed",
        top: -(f - Math.floor(p)) + "px",
        left: -(u - Math.floor(m)) + "px",
        right: "0"
      });
    }
    return () => {
      dl.delete(i), dl.size === 0 && (Object.assign(o, {
        overflow: "",
        [c]: ""
      }), s && (Object.assign(o, {
        position: "",
        top: "",
        left: "",
        right: ""
      }), window.scrollTo(u, f)));
    };
  }, [i, n]), /* @__PURE__ */ reactExports.createElement("div", fi({
    ref: r
  }, a, {
    style: {
      position: "fixed",
      overflow: "auto",
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...a.style
    }
  }));
});
function dh(t6) {
  return ut(t6.target) && t6.target.tagName === "BUTTON";
}
function uh(t6) {
  return Yc(t6);
}
function Om(t6, e) {
  e === void 0 && (e = {});
  const {
    open: r,
    onOpenChange: n,
    dataRef: a,
    elements: {
      domReference: i
    }
  } = t6, {
    enabled: s = true,
    event: o = "click",
    toggle: l = true,
    ignoreMouse: c = false,
    keyboardHandlers: d = true
  } = e, u = reactExports.useRef(), f = reactExports.useRef(false);
  return reactExports.useMemo(() => s ? {
    reference: {
      onPointerDown(h) {
        u.current = h.pointerType;
      },
      onMouseDown(h) {
        h.button === 0 && (As(u.current, true) && c || o !== "click" && (r && l && (!a.current.openEvent || a.current.openEvent.type === "mousedown") ? n(false, h.nativeEvent, "click") : (h.preventDefault(), n(true, h.nativeEvent, "click"))));
      },
      onClick(h) {
        if (o === "mousedown" && u.current) {
          u.current = void 0;
          return;
        }
        As(u.current, true) && c || (r && l && (!a.current.openEvent || a.current.openEvent.type === "click") ? n(false, h.nativeEvent, "click") : n(true, h.nativeEvent, "click"));
      },
      onKeyDown(h) {
        u.current = void 0, !(h.defaultPrevented || !d || dh(h)) && (h.key === " " && !uh(i) && (h.preventDefault(), f.current = true), h.key === "Enter" && n(!(r && l), h.nativeEvent, "click"));
      },
      onKeyUp(h) {
        h.defaultPrevented || !d || dh(h) || uh(i) || h.key === " " && f.current && (f.current = false, n(!(r && l), h.nativeEvent, "click"));
      }
    }
  } : {}, [s, a, o, c, d, i, l, r, n]);
}
const l2 = {
  pointerdown: "onPointerDown",
  mousedown: "onMouseDown",
  click: "onClick"
}, c2 = {
  pointerdown: "onPointerDownCapture",
  mousedown: "onMouseDownCapture",
  click: "onClickCapture"
}, fh = (t6) => {
  var e, r;
  return {
    escapeKey: typeof t6 == "boolean" ? t6 : (e = t6 == null ? void 0 : t6.escapeKey) != null ? e : false,
    outsidePress: typeof t6 == "boolean" ? t6 : (r = t6 == null ? void 0 : t6.outsidePress) != null ? r : true
  };
};
function Sm(t6, e) {
  e === void 0 && (e = {});
  const {
    open: r,
    onOpenChange: n,
    nodeId: a,
    elements: {
      reference: i,
      domReference: s,
      floating: o
    },
    dataRef: l
  } = t6, {
    enabled: c = true,
    escapeKey: d = true,
    outsidePress: u = true,
    outsidePressEvent: f = "pointerdown",
    referencePress: h = false,
    referencePressEvent: g = "pointerdown",
    ancestorScroll: m = false,
    bubbles: p,
    capture: w
  } = e, b = _i(), k = lr(typeof u == "function" ? u : () => false), v = typeof u == "function" ? k : u, x = reactExports.useRef(false), _ = reactExports.useRef(false), {
    escapeKey: T,
    outsidePress: S
  } = fh(p), {
    escapeKey: C,
    outsidePress: D
  } = fh(w), z = lr((I) => {
    if (!r || !c || !d || I.key !== "Escape")
      return;
    const W = b ? Mn(b.nodesRef.current, a) : [];
    if (!T && (I.stopPropagation(), W.length > 0)) {
      let B = true;
      if (W.forEach((U) => {
        var J;
        if ((J = U.context) != null && J.open && !U.context.dataRef.current.__escapeKeyBubbles) {
          B = false;
          return;
        }
      }), !B)
        return;
    }
    n(false, kD(I) ? I.nativeEvent : I, "escape-key");
  }), A = lr((I) => {
    var W;
    const B = () => {
      var U;
      z(I), (U = Br(I)) == null || U.removeEventListener("keydown", B);
    };
    (W = Br(I)) == null || W.addEventListener("keydown", B);
  }), L = lr((I) => {
    const W = x.current;
    x.current = false;
    const B = _.current;
    if (_.current = false, f === "click" && B || W || typeof v == "function" && !v(I))
      return;
    const U = Br(I), J = "[" + Nn("inert") + "]", E = yt(o).querySelectorAll(J);
    let j = Ce(U) ? U : null;
    for (; j && !Gr(j); ) {
      const P = Tr(j);
      if (Gr(P) || !Ce(P))
        break;
      j = P;
    }
    if (E.length && Ce(U) && !_D(U) && // Clicked on a direct ancestor (e.g. FloatingOverlay).
    !Ge(U, o) && // If the target root element contains none of the markers, then the
    // element was injected after the floating element rendered.
    Array.from(E).every((P) => !Ge(j, P)))
      return;
    if (ut(U) && o) {
      const P = U.clientWidth > 0 && U.scrollWidth > U.clientWidth, O = U.clientHeight > 0 && U.scrollHeight > U.clientHeight;
      let F = O && I.offsetX > U.clientWidth;
      if (O && Yt(U).direction === "rtl" && (F = I.offsetX <= U.offsetWidth - U.clientWidth), F || P && I.offsetY > U.clientHeight)
        return;
    }
    const N = b && Mn(b.nodesRef.current, a).some((P) => {
      var O;
      return rl(I, (O = P.context) == null ? void 0 : O.elements.floating);
    });
    if (rl(I, o) || rl(I, s) || N)
      return;
    const R = b ? Mn(b.nodesRef.current, a) : [];
    if (R.length > 0) {
      let P = true;
      if (R.forEach((O) => {
        var F;
        if ((F = O.context) != null && F.open && !O.context.dataRef.current.__outsidePressBubbles) {
          P = false;
          return;
        }
      }), !P)
        return;
    }
    n(false, I, "outside-press");
  }), M = lr((I) => {
    var W;
    const B = () => {
      var U;
      L(I), (U = Br(I)) == null || U.removeEventListener(f, B);
    };
    (W = Br(I)) == null || W.addEventListener(f, B);
  });
  return reactExports.useEffect(() => {
    if (!r || !c)
      return;
    l.current.__escapeKeyBubbles = T, l.current.__outsidePressBubbles = S;
    function I(U) {
      n(false, U, "ancestor-scroll");
    }
    const W = yt(o);
    d && W.addEventListener("keydown", C ? A : z, C), v && W.addEventListener(f, D ? M : L, D);
    let B = [];
    return m && (Ce(s) && (B = Ur(s)), Ce(o) && (B = B.concat(Ur(o))), !Ce(i) && i && i.contextElement && (B = B.concat(Ur(i.contextElement)))), B = B.filter((U) => {
      var J;
      return U !== ((J = W.defaultView) == null ? void 0 : J.visualViewport);
    }), B.forEach((U) => {
      U.addEventListener("scroll", I, {
        passive: true
      });
    }), () => {
      d && W.removeEventListener("keydown", C ? A : z, C), v && W.removeEventListener(f, D ? M : L, D), B.forEach((U) => {
        U.removeEventListener("scroll", I);
      });
    };
  }, [l, o, s, i, d, v, f, r, n, m, c, T, S, z, C, A, L, D, M]), reactExports.useEffect(() => {
    x.current = false;
  }, [v, f]), reactExports.useMemo(() => c ? {
    reference: {
      onKeyDown: z,
      [l2[g]]: (I) => {
        h && n(false, I.nativeEvent, "reference-press");
      }
    },
    floating: {
      onKeyDown: z,
      onMouseDown() {
        _.current = true;
      },
      onMouseUp() {
        _.current = true;
      },
      [c2[f]]: () => {
        x.current = true;
      }
    }
  } : {}, [c, h, f, g, n, z]);
}
function Dm(t6) {
  var e;
  t6 === void 0 && (t6 = {});
  const {
    open: r = false,
    onOpenChange: n,
    nodeId: a
  } = t6;
  const [l, c] = reactExports.useState(null), d = ((e = t6.elements) == null ? void 0 : e.reference) || l, u = sM(t6), f = _i(), h = So() != null, g = lr((S, C, D) => {
    S && (p.current.openEvent = C), w.emit("openchange", {
      open: S,
      event: C,
      reason: D,
      nested: h
    }), n == null || n(S, C, D);
  }), m = reactExports.useRef(null), p = reactExports.useRef({}), w = reactExports.useState(() => VM())[0], b = Oo(), k = reactExports.useCallback((S) => {
    const C = Ce(S) ? {
      getBoundingClientRect: () => S.getBoundingClientRect(),
      contextElement: S
    } : S;
    u.refs.setReference(C);
  }, [u.refs]), v = reactExports.useCallback((S) => {
    (Ce(S) || S === null) && (m.current = S, c(S)), (Ce(u.refs.reference.current) || u.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    S !== null && !Ce(S)) && u.refs.setReference(S);
  }, [u.refs]), x = reactExports.useMemo(() => ({
    ...u.refs,
    setReference: v,
    setPositionReference: k,
    domReference: m
  }), [u.refs, v, k]), _ = reactExports.useMemo(() => ({
    ...u.elements,
    domReference: d
  }), [u.elements, d]), T = reactExports.useMemo(() => ({
    ...u,
    refs: x,
    elements: _,
    dataRef: p,
    nodeId: a,
    floatingId: b,
    events: w,
    open: r,
    onOpenChange: g
  }), [u, a, b, w, r, g, x, _]);
  return Re(() => {
    const S = f == null ? void 0 : f.nodesRef.current.find((C) => C.id === a);
    S && (S.context = T);
  }), reactExports.useMemo(() => ({
    ...u,
    context: T,
    refs: x,
    elements: _
  }), [u, x, _, T]);
}
function d2(t6, e) {
  e === void 0 && (e = {});
  const {
    open: r,
    onOpenChange: n,
    events: a,
    refs: i,
    elements: {
      domReference: s
    }
  } = t6, {
    enabled: o = true,
    visibleOnly: l = true
  } = e, c = reactExports.useRef(false), d = reactExports.useRef(), u = reactExports.useRef(true);
  return reactExports.useEffect(() => {
    if (!o)
      return;
    const f = Dt(s);
    function h() {
      !r && ut(s) && s === or(yt(s)) && (c.current = true);
    }
    function g() {
      u.current = true;
    }
    return f.addEventListener("blur", h), f.addEventListener("keydown", g, true), () => {
      f.removeEventListener("blur", h), f.removeEventListener("keydown", g, true);
    };
  }, [s, r, o]), reactExports.useEffect(() => {
    if (!o)
      return;
    function f(h) {
      let {
        reason: g
      } = h;
      (g === "reference-press" || g === "escape-key") && (c.current = true);
    }
    return a.on("openchange", f), () => {
      a.off("openchange", f);
    };
  }, [a, o]), reactExports.useEffect(() => () => {
    clearTimeout(d.current);
  }, []), reactExports.useMemo(() => o ? {
    reference: {
      onPointerDown(f) {
        Hc(f.nativeEvent) || (u.current = false);
      },
      onMouseLeave() {
        c.current = false;
      },
      onFocus(f) {
        if (c.current) return;
        const h = Br(f.nativeEvent);
        if (l && Ce(h))
          try {
            if (Bc() && J0()) throw Error();
            if (!h.matches(":focus-visible")) return;
          } catch {
            if (!u.current && !Yc(h))
              return;
          }
        n(true, f.nativeEvent, "focus");
      },
      onBlur(f) {
        c.current = false;
        const h = f.relatedTarget, g = Ce(h) && h.hasAttribute(Nn("focus-guard")) && h.getAttribute("data-type") === "outside";
        d.current = window.setTimeout(() => {
          const m = or(s ? s.ownerDocument : document);
          !h && m === s || Ge(i.floating.current, m) || Ge(s, m) || g || n(false, f.nativeEvent, "focus");
        });
      }
    }
  } : {}, [o, l, s, i, n]);
}
const hh = "active", gh = "selected";
function ul(t6, e, r) {
  const n = /* @__PURE__ */ new Map(), a = r === "item";
  let i = t6;
  if (a && t6) {
    const {
      [hh]: s,
      [gh]: o,
      ...l
    } = t6;
    i = l;
  }
  return {
    ...r === "floating" && {
      tabIndex: -1
    },
    ...i,
    ...e.map((s) => {
      const o = s ? s[r] : null;
      return typeof o == "function" ? t6 ? o(t6) : null : o;
    }).concat(t6).reduce((s, o) => (o && Object.entries(o).forEach((l) => {
      let [c, d] = l;
      if (!(a && [hh, gh].includes(c)))
        if (c.indexOf("on") === 0) {
          if (n.has(c) || n.set(c, []), typeof d == "function") {
            var u;
            (u = n.get(c)) == null || u.push(d), s[c] = function() {
              for (var f, h = arguments.length, g = new Array(h), m = 0; m < h; m++)
                g[m] = arguments[m];
              return (f = n.get(c)) == null ? void 0 : f.map((p) => p(...g)).find((p) => p !== void 0);
            };
          }
        } else
          s[c] = d;
    }), s), {})
  };
}
function Mm(t6) {
  t6 === void 0 && (t6 = []);
  const e = t6, r = reactExports.useCallback((i) => ul(i, t6, "reference"), e), n = reactExports.useCallback((i) => ul(i, t6, "floating"), e), a = reactExports.useCallback(
    (i) => ul(i, t6, "item"),
    // Granularly check for `item` changes, because the `getItemProps` getter
    // should be as referentially stable as possible since it may be passed as
    // a prop to many components. All `item` key values must therefore be
    // memoized.
    t6.map((i) => i == null ? void 0 : i.item)
  );
  return reactExports.useMemo(() => ({
    getReferenceProps: r,
    getFloatingProps: n,
    getItemProps: a
  }), [r, n, a]);
}
let mh = false;
function Do(t6, e, r) {
  switch (t6) {
    case "vertical":
      return e;
    case "horizontal":
      return r;
    default:
      return e || r;
  }
}
function ph(t6, e) {
  return Do(e, t6 === Kc || t6 === ki, t6 === da || t6 === ba);
}
function fl(t6, e, r) {
  return Do(e, t6 === ki, r ? t6 === da : t6 === ba) || t6 === "Enter" || t6 === " " || t6 === "";
}
function u2(t6, e, r) {
  return Do(e, r ? t6 === da : t6 === ba, t6 === ki);
}
function bh(t6, e, r) {
  return Do(e, r ? t6 === ba : t6 === da, t6 === Kc);
}
function f2(t6, e) {
  const {
    open: r,
    onOpenChange: n,
    refs: a,
    elements: {
      domReference: i,
      floating: s
    }
  } = t6, {
    listRef: o,
    activeIndex: l,
    onNavigate: c = () => {
    },
    enabled: d = true,
    selectedIndex: u = null,
    allowEscape: f = false,
    loop: h = false,
    nested: g = false,
    rtl: m = false,
    virtual: p = false,
    focusItemOnOpen: w = "auto",
    focusItemOnHover: b = true,
    openOnArrowKeyDown: k = true,
    disabledIndices: v = void 0,
    orientation: x = "vertical",
    cols: _ = 1,
    scrollItemIntoView: T = true,
    virtualItemRef: S,
    itemSizes: C,
    dense: D = false
  } = e;
  const z = So(), A = _i(), L = lr(c), M = reactExports.useRef(w), I = reactExports.useRef(u ?? -1), W = reactExports.useRef(null), B = reactExports.useRef(true), U = reactExports.useRef(L), J = reactExports.useRef(!!s), E = reactExports.useRef(false), j = reactExports.useRef(false), N = mr(v), R = mr(r), P = mr(T), [O, F] = reactExports.useState(), [X, q] = reactExports.useState(), G = lr(function(H, ae, re) {
    re === void 0 && (re = false);
    const le = H.current[ae.current];
    le && (p ? (F(le.id), A == null || A.events.emit("virtualfocus", le), S && (S.current = le)) : Dr(le, {
      preventScroll: true,
      // Mac Safari does not move the virtual cursor unless the focus call
      // is sync. However, for the very first focus call, we need to wait
      // for the position to be ready in order to prevent unwanted
      // scrolling. This means the virtual cursor will not move to the first
      // item when first opening the floating element, but will on
      // subsequent calls. `preventScroll` is supported in modern Safari,
      // so we can use that instead.
      // iOS Safari must be async or the first item will not be focused.
      sync: J0() && Bc() ? mh || E.current : false
    }), requestAnimationFrame(() => {
      const fe = P.current;
      fe && le && (re || !B.current) && (le.scrollIntoView == null || le.scrollIntoView(typeof fe == "boolean" ? {
        block: "nearest",
        inline: "nearest"
      } : fe));
    }));
  });
  Re(() => {
    document.createElement("div").focus({
      get preventScroll() {
        return mh = true, false;
      }
    });
  }, []), Re(() => {
    d && (r && s ? M.current && u != null && (j.current = true, I.current = u, L(u)) : J.current && (I.current = -1, U.current(null)));
  }, [d, r, s, u, L]), Re(() => {
    if (d && r && s)
      if (l == null) {
        if (E.current = false, u != null)
          return;
        if (J.current && (I.current = -1, G(o, I)), !J.current && M.current && (W.current != null || M.current === true && W.current == null)) {
          let H = 0;
          const ae = () => {
            o.current[0] == null ? (H < 2 && (H ? requestAnimationFrame : queueMicrotask)(ae), H++) : (I.current = W.current == null || fl(W.current, x, m) || g ? il(o, N.current) : rh(o, N.current), W.current = null, L(I.current));
          };
          ae();
        }
      } else Qa(o, l) || (I.current = l, G(o, I, j.current), j.current = false);
  }, [d, r, s, l, u, g, o, x, m, L, G, N]), Re(() => {
    var H;
    if (!d || s || !A || p || !J.current)
      return;
    const ae = A.nodesRef.current, re = (H = ae.find((de) => de.id === z)) == null || (H = H.context) == null ? void 0 : H.elements.floating, le = or(yt(s)), fe = ae.some((de) => de.context && Ge(de.context.elements.floating, le));
    re && !fe && B.current && re.focus({
      preventScroll: true
    });
  }, [d, s, A, z, p]), Re(() => {
    if (!d || !A || !p || z) return;
    function H(ae) {
      q(ae.id), S && (S.current = ae);
    }
    return A.events.on("virtualfocus", H), () => {
      A.events.off("virtualfocus", H);
    };
  }, [d, A, p, z, S]), Re(() => {
    U.current = L, J.current = !!s;
  }), Re(() => {
    r || (W.current = null);
  }, [r]);
  const Z = l != null, ne = reactExports.useMemo(() => {
    function H(re) {
      if (!r) return;
      const le = o.current.indexOf(re);
      le !== -1 && L(le);
    }
    return {
      onFocus(re) {
        let {
          currentTarget: le
        } = re;
        H(le);
      },
      onClick: (re) => {
        let {
          currentTarget: le
        } = re;
        return le.focus({
          preventScroll: true
        });
      },
      // Safari
      ...b && {
        onMouseMove(re) {
          let {
            currentTarget: le
          } = re;
          H(le);
        },
        onPointerLeave(re) {
          let {
            pointerType: le
          } = re;
          !B.current || le === "touch" || (I.current = -1, G(o, I), L(null), p || Dr(a.floating.current, {
            preventScroll: true
          }));
        }
      }
    };
  }, [r, a, G, b, o, L, p]);
  return reactExports.useMemo(() => {
    if (!d)
      return {};
    const H = N.current;
    function ae(ie) {
      if (B.current = false, E.current = true, !R.current && ie.currentTarget === a.floating.current)
        return;
      if (g && bh(ie.key, x, m)) {
        st(ie), n(false, ie.nativeEvent, "list-navigation"), ut(i) && !p && i.focus();
        return;
      }
      const $e = I.current, ge = il(o, H), Fe = rh(o, H);
      if (ie.key === "Home" && (st(ie), I.current = ge, L(I.current)), ie.key === "End" && (st(ie), I.current = Fe, L(I.current)), _ > 1) {
        const je = C || Array.from({
          length: o.current.length
        }, () => ({
          width: 1,
          height: 1
        })), Ye = AM(je, _, D), Et = Ye.findIndex((Pt) => Pt != null && !(H != null && H.includes(Pt))), Tt = Ye.reduce((Pt, Wr, Rt) => Wr != null && !(H != null && H.includes(Wr)) ? Rt : Pt, -1);
        if (I.current = Ye[IM({
          current: Ye.map((Pt) => Pt != null ? o.current[Pt] : null)
        }, {
          event: ie,
          orientation: x,
          loop: h,
          cols: _,
          // treat undefined (empty grid spaces) as disabled indices so we
          // don't end up in them
          disabledIndices: LM([...H || [], void 0], Ye),
          minIndex: Et,
          maxIndex: Tt,
          prevIndex: FM(
            I.current,
            je,
            Ye,
            _,
            // use a corner matching the edge closest to the direction
            // we're moving in so we don't end up in the same item. Prefer
            // top/left over bottom/right.
            ie.key === ki ? "bl" : ie.key === ba ? "tr" : "tl"
          ),
          stopEvent: true
        })], L(I.current), x === "both")
          return;
      }
      if (ph(ie.key, x)) {
        if (st(ie), r && !p && or(ie.currentTarget.ownerDocument) === ie.currentTarget) {
          I.current = fl(ie.key, x, m) ? ge : Fe, L(I.current);
          return;
        }
        fl(ie.key, x, m) ? h ? I.current = $e >= Fe ? f && $e !== o.current.length ? -1 : ge : gt(o, {
          startingIndex: $e,
          disabledIndices: H
        }) : I.current = Math.min(Fe, gt(o, {
          startingIndex: $e,
          disabledIndices: H
        })) : h ? I.current = $e <= ge ? f && $e !== -1 ? o.current.length : Fe : gt(o, {
          startingIndex: $e,
          decrement: true,
          disabledIndices: H
        }) : I.current = Math.max(ge, gt(o, {
          startingIndex: $e,
          decrement: true,
          disabledIndices: H
        })), Qa(o, I.current) ? L(null) : L(I.current);
      }
    }
    function re(ie) {
      w === "auto" && Q0(ie.nativeEvent) && (M.current = true);
    }
    function le(ie) {
      M.current = w, w === "auto" && Hc(ie.nativeEvent) && (M.current = true);
    }
    const fe = p && r && Z && {
      "aria-activedescendant": X || O
    }, de = o.current.find((ie) => (ie == null ? void 0 : ie.id) === O);
    return {
      reference: {
        ...fe,
        onKeyDown(ie) {
          B.current = false;
          const $e = ie.key.indexOf("Arrow") === 0, ge = u2(ie.key, x, m), Fe = bh(ie.key, x, m), je = ph(ie.key, x), Ye = (g ? ge : je) || ie.key === "Enter" || ie.key.trim() === "";
          if (p && r) {
            const Wr = A == null ? void 0 : A.nodesRef.current.find((Pi) => Pi.parentId == null), Rt = A && Wr ? KM(A.nodesRef.current, Wr.id) : null;
            if ($e && Rt && S) {
              const Pi = new KeyboardEvent("keydown", {
                key: ie.key,
                bubbles: true
              });
              if (ge || Fe) {
                var Et, Tt;
                const xy = ((Et = Rt.context) == null ? void 0 : Et.elements.domReference) === ie.currentTarget, Ld = Fe && !xy ? (Tt = Rt.context) == null ? void 0 : Tt.elements.domReference : ge ? de : null;
                Ld && (st(ie), Ld.dispatchEvent(Pi), q(void 0));
              }
              if (je && Rt.context && Rt.context.open && Rt.parentId && ie.currentTarget !== Rt.context.elements.domReference) {
                var Pt;
                st(ie), (Pt = Rt.context.elements.domReference) == null || Pt.dispatchEvent(Pi);
                return;
              }
            }
            return ae(ie);
          }
          if (!(!r && !k && $e)) {
            if (Ye && (W.current = g && je ? null : ie.key), g) {
              ge && (st(ie), r ? (I.current = il(o, H), L(I.current)) : n(true, ie.nativeEvent, "list-navigation"));
              return;
            }
            je && (u != null && (I.current = u), st(ie), !r && k ? n(true, ie.nativeEvent, "list-navigation") : ae(ie), r && L(I.current));
          }
        },
        onFocus() {
          r && L(null);
        },
        onPointerDown: le,
        onMouseDown: re,
        onClick: re
      },
      floating: {
        "aria-orientation": x === "both" ? void 0 : x,
        ...!Z0(i) && fe,
        onKeyDown: ae,
        onPointerMove() {
          B.current = true;
        }
      },
      item: ne
    };
  }, [i, a, O, X, N, R, o, d, x, m, p, r, Z, g, u, k, f, _, h, w, L, n, ne, A, S, C, D]);
}
const h2 = /* @__PURE__ */ new Map([["select", "listbox"], ["combobox", "listbox"], ["label", false]]);
function Cm(t6, e) {
  var r;
  e === void 0 && (e = {});
  const {
    open: n,
    floatingId: a
  } = t6, {
    enabled: i = true,
    role: s = "dialog"
  } = e, o = (r = h2.get(s)) != null ? r : s, l = Oo(), d = So() != null;
  return reactExports.useMemo(() => {
    if (!i) return {};
    const u = {
      id: a,
      ...o && {
        role: o
      }
    };
    return o === "tooltip" || s === "label" ? {
      reference: {
        ["aria-" + (s === "label" ? "labelledby" : "describedby")]: n ? a : void 0
      },
      floating: u
    } : {
      reference: {
        "aria-expanded": n ? "true" : "false",
        "aria-haspopup": o === "alertdialog" ? "dialog" : o,
        "aria-controls": n ? a : void 0,
        ...o === "listbox" && {
          role: "combobox"
        },
        ...o === "menu" && {
          id: l
        },
        ...o === "menu" && d && {
          role: "menuitem"
        },
        ...s === "select" && {
          "aria-autocomplete": "none"
        },
        ...s === "combobox" && {
          "aria-autocomplete": "list"
        }
      },
      floating: {
        ...u,
        ...o === "menu" && {
          "aria-labelledby": l
        }
      },
      item(f) {
        let {
          active: h,
          selected: g
        } = f;
        const m = {
          role: "option",
          ...h && {
            id: a + "-option"
          }
        };
        switch (s) {
          case "select":
            return {
              ...m,
              "aria-selected": h && g
            };
          case "combobox":
            return {
              ...m,
              ...h && {
                "aria-selected": true
              }
            };
        }
        return {};
      }
    };
  }, [i, s, o, n, a, l, d]);
}
function g2(t6, e) {
  var r;
  const {
    open: n,
    dataRef: a
  } = t6, {
    listRef: i,
    activeIndex: s,
    onMatch: o,
    onTypingChange: l,
    enabled: c = true,
    findMatch: d = null,
    resetMs: u = 750,
    ignoreKeys: f = [],
    selectedIndex: h = null
  } = e, g = reactExports.useRef(), m = reactExports.useRef(""), p = reactExports.useRef((r = h ?? s) != null ? r : -1), w = reactExports.useRef(null), b = lr(o), k = lr(l), v = mr(d), x = mr(f);
  return Re(() => {
    n && (clearTimeout(g.current), w.current = null, m.current = "");
  }, [n]), Re(() => {
    if (n && m.current === "") {
      var _;
      p.current = (_ = h ?? s) != null ? _ : -1;
    }
  }, [n, h, s]), reactExports.useMemo(() => {
    if (!c)
      return {};
    function _(C) {
      C ? a.current.typing || (a.current.typing = C, k(C)) : a.current.typing && (a.current.typing = C, k(C));
    }
    function T(C, D, z) {
      const A = v.current ? v.current(D, z) : D.find((L) => (L == null ? void 0 : L.toLocaleLowerCase().indexOf(z.toLocaleLowerCase())) === 0);
      return A ? C.indexOf(A) : -1;
    }
    function S(C) {
      const D = i.current;
      if (m.current.length > 0 && m.current[0] !== " " && (T(D, D, m.current) === -1 ? _(false) : C.key === " " && st(C)), D == null || x.current.includes(C.key) || // Character key.
      C.key.length !== 1 || // Modifier key.
      C.ctrlKey || C.metaKey || C.altKey)
        return;
      n && C.key !== " " && (st(C), _(true)), D.every((M) => {
        var I, W;
        return M ? ((I = M[0]) == null ? void 0 : I.toLocaleLowerCase()) !== ((W = M[1]) == null ? void 0 : W.toLocaleLowerCase()) : true;
      }) && m.current === C.key && (m.current = "", p.current = w.current), m.current += C.key, clearTimeout(g.current), g.current = setTimeout(() => {
        m.current = "", p.current = w.current, _(false);
      }, u);
      const A = p.current, L = T(D, [...D.slice((A || 0) + 1), ...D.slice(0, (A || 0) + 1)], m.current);
      L !== -1 ? (b(L), w.current = L) : C.key !== " " && (m.current = "", _(false));
    }
    return {
      reference: {
        onKeyDown: S
      },
      floating: {
        onKeyDown: S,
        onKeyUp(C) {
          C.key === " " && _(false);
        }
      }
    };
  }, [c, n, a, i, u, x, v, b, k]);
}
function yh(t6, e) {
  const [r, n] = t6;
  let a = false;
  const i = e.length;
  for (let s = 0, o = i - 1; s < i; o = s++) {
    const [l, c] = e[s] || [0, 0], [d, u] = e[o] || [0, 0];
    c >= n != u >= n && r <= (d - l) * (n - c) / (u - c) + l && (a = !a);
  }
  return a;
}
function m2(t6, e) {
  return t6[0] >= e.x && t6[0] <= e.x + e.width && t6[1] >= e.y && t6[1] <= e.y + e.height;
}
function p2(t6) {
  t6 === void 0 && (t6 = {});
  const {
    buffer: e = 0.5,
    blockPointerEvents: r = false,
    requireIntent: n = true
  } = t6;
  let a, i = false, s = null, o = null, l = performance.now();
  function c(u, f) {
    const h = performance.now(), g = h - l;
    if (s === null || o === null || g === 0)
      return s = u, o = f, l = h, null;
    const m = u - s, p = f - o, b = Math.sqrt(m * m + p * p) / g;
    return s = u, o = f, l = h, b;
  }
  const d = (u) => {
    let {
      x: f,
      y: h,
      placement: g,
      elements: m,
      onClose: p,
      nodeId: w,
      tree: b
    } = u;
    return function(v) {
      function x() {
        clearTimeout(a), p();
      }
      if (clearTimeout(a), !m.domReference || !m.floating || g == null || f == null || h == null)
        return;
      const {
        clientX: _,
        clientY: T
      } = v, S = [_, T], C = Br(v), D = v.type === "mouseleave", z = Ge(m.floating, C), A = Ge(m.domReference, C), L = m.domReference.getBoundingClientRect(), M = m.floating.getBoundingClientRect(), I = g.split("-")[0], W = f > M.right - M.width / 2, B = h > M.bottom - M.height / 2, U = m2(S, L), J = M.width > L.width, E = M.height > L.height, j = (J ? L : M).left, N = (J ? L : M).right, R = (E ? L : M).top, P = (E ? L : M).bottom;
      if (z && (i = true, !D))
        return;
      if (A && (i = false), A && !D) {
        i = true;
        return;
      }
      if (D && Ce(v.relatedTarget) && Ge(m.floating, v.relatedTarget) || b && Mn(b.nodesRef.current, w).some((X) => {
        let {
          context: q
        } = X;
        return q == null ? void 0 : q.open;
      }))
        return;
      if (I === "top" && h >= L.bottom - 1 || I === "bottom" && h <= L.top + 1 || I === "left" && f >= L.right - 1 || I === "right" && f <= L.left + 1)
        return x();
      let O = [];
      switch (I) {
        case "top":
          O = [[j, L.top + 1], [j, M.bottom - 1], [N, M.bottom - 1], [N, L.top + 1]];
          break;
        case "bottom":
          O = [[j, M.top + 1], [j, L.bottom - 1], [N, L.bottom - 1], [N, M.top + 1]];
          break;
        case "left":
          O = [[M.right - 1, P], [M.right - 1, R], [L.left + 1, R], [L.left + 1, P]];
          break;
        case "right":
          O = [[L.right - 1, P], [L.right - 1, R], [M.left + 1, R], [M.left + 1, P]];
          break;
      }
      function F(X) {
        let [q, G] = X;
        switch (I) {
          case "top": {
            const Z = [J ? q + e / 2 : W ? q + e * 4 : q - e * 4, G + e + 1], ne = [J ? q - e / 2 : W ? q + e * 4 : q - e * 4, G + e + 1], H = [[M.left, W || J ? M.bottom - e : M.top], [M.right, W ? J ? M.bottom - e : M.top : M.bottom - e]];
            return [Z, ne, ...H];
          }
          case "bottom": {
            const Z = [J ? q + e / 2 : W ? q + e * 4 : q - e * 4, G - e], ne = [J ? q - e / 2 : W ? q + e * 4 : q - e * 4, G - e], H = [[M.left, W || J ? M.top + e : M.bottom], [M.right, W ? J ? M.top + e : M.bottom : M.top + e]];
            return [Z, ne, ...H];
          }
          case "left": {
            const Z = [q + e + 1, E ? G + e / 2 : B ? G + e * 4 : G - e * 4], ne = [q + e + 1, E ? G - e / 2 : B ? G + e * 4 : G - e * 4];
            return [...[[B || E ? M.right - e : M.left, M.top], [B ? E ? M.right - e : M.left : M.right - e, M.bottom]], Z, ne];
          }
          case "right": {
            const Z = [q - e, E ? G + e / 2 : B ? G + e * 4 : G - e * 4], ne = [q - e, E ? G - e / 2 : B ? G + e * 4 : G - e * 4], H = [[B || E ? M.left + e : M.right, M.top], [B ? E ? M.left + e : M.right : M.left + e, M.bottom]];
            return [Z, ne, ...H];
          }
        }
      }
      if (!yh([_, T], O)) {
        if (i && !U)
          return x();
        if (!D && n) {
          const X = c(v.clientX, v.clientY);
          if (X !== null && X < 0.1)
            return x();
        }
        yh([_, T], F([f, h])) ? !i && n && (a = window.setTimeout(x, 40)) : x();
      }
    };
  };
  return d.__options = {
    blockPointerEvents: r
  }, d;
}
const b2 = ({
  arrowRef: t6,
  placement: e
}) => {
  const r = [];
  return r.push(lM(8)), r.push(e === "auto" ? uM() : dM()), r.push(cM({ padding: 8 })), t6 != null && t6.current && r.push(fM({ element: t6.current })), r;
}, y2 = ({ placement: t6 }) => t6 === "auto" ? void 0 : t6, v2 = ({ placement: t6 }) => ({
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
})[t6.split("-")[0]], Em = ({
  open: t6,
  arrowRef: e,
  placement: r = "top",
  setOpen: n
}) => Dm({
  placement: y2({ placement: r }),
  open: t6,
  onOpenChange: n,
  whileElementsMounted: cm,
  middleware: b2({ placement: r, arrowRef: e })
}), Tm = ({
  context: t6,
  trigger: e,
  role: r = "tooltip",
  interactions: n = []
}) => Mm([
  Om(t6, { enabled: e === "click" }),
  XM(t6, {
    enabled: e === "hover",
    handleClose: p2()
  }),
  Sm(t6),
  Cm(t6, { role: r }),
  ...n
]), Pm = reactExports.createContext(void 0);
function Jc() {
  const t6 = reactExports.useContext(Pm);
  if (!t6)
    throw new Error("useDropdownContext should be used within the DropdownContext provider!");
  return t6;
}
const Zc = ({ className: t6, theme: e = {}, ...r }) => {
  const { theme: n } = Jc(), a = e.divider ?? n.floating.divider;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: Y(a, t6), ...r });
}, Rm = ({ children: t6, className: e, theme: r = {}, ...n }) => {
  const { theme: a } = Jc(), i = r.header ?? a.floating.header;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: Y(i, e), ...n, children: t6 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Zc, {})
  ] });
}, Nm = reactExports.forwardRef(
  ({ children: t6, className: e, icon: r, onClick: n, theme: a = {}, ...i }, s) => {
    const { ref: o, index: l } = jM({ label: typeof t6 == "string" ? t6 : void 0 }), c = mm([s, o]), { theme: d, activeIndex: u, dismissOnClick: f, getItemProps: h, handleSelect: g } = Jc(), m = u === l, p = te(d.floating.item, a), w = i;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("li", { role: "menuitem", className: p.container, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Ac,
      {
        ref: c,
        className: Y(p.base, e),
        ...w,
        ...h({
          onClick: () => {
            n == null || n(), f && g(null);
          }
        }),
        tabIndex: m ? 0 : -1,
        children: [
          r && /* @__PURE__ */ jsxRuntimeExports.jsx(r, { className: p.icon }),
          t6
        ]
      }
    ) });
  }
);
Nm.displayName = "DropdownItem";
const x2 = {
  top: TO,
  right: p0,
  bottom: m0,
  left: EO
}, w2 = ({
  refs: t6,
  children: e,
  inline: r,
  theme: n,
  disabled: a,
  setButtonWidth: i,
  getReferenceProps: s,
  renderTrigger: o,
  ...l
}) => {
  const c = t6.reference, d = s();
  if (reactExports.useEffect(() => {
    c.current && (i == null || i(c.current.clientWidth));
  }, [c, i]), o) {
    const u = o(n);
    return reactExports.cloneElement(u, { ref: t6.setReference, disabled: a, ...d, ...u.props });
  }
  return r ? /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", ref: t6.setReference, className: n == null ? void 0 : n.inlineWrapper, disabled: a, ...d, children: e }) : /* @__PURE__ */ jsxRuntimeExports.jsx(F0, { ...l, disabled: a, type: "button", ref: t6.setReference, ...d, children: e });
}, Im = ({
  children: t6,
  className: e,
  dismissOnClick: r = true,
  theme: n = {},
  renderTrigger: a,
  ...i
}) => {
  const [s, o] = reactExports.useState(false), [l, c] = reactExports.useState(null), [d, u] = reactExports.useState(null), [f, h] = reactExports.useState(void 0), g = reactExports.useRef([]), m = reactExports.useRef([]), p = te(ue().dropdown, n), w = i, b = i["data-testid"] || "flowbite-dropdown-target", {
    placement: k = i.inline ? "bottom-start" : "bottom",
    trigger: v = "click",
    label: x,
    inline: _,
    arrowIcon: T = true,
    ...S
  } = w, C = reactExports.useCallback((E) => {
    u(E), o(false);
  }, []), D = reactExports.useCallback(
    (E) => {
      s ? c(E) : C(E);
    },
    [s, C]
  ), { context: z, floatingStyles: A, refs: L } = Em({
    open: s,
    setOpen: o,
    placement: k
  }), M = f2(z, {
    listRef: g,
    activeIndex: l,
    selectedIndex: d,
    onNavigate: c
  }), I = g2(z, {
    listRef: m,
    activeIndex: l,
    selectedIndex: d,
    onMatch: D
  }), { getReferenceProps: W, getFloatingProps: B, getItemProps: U } = Tm({
    context: z,
    role: "menu",
    trigger: v,
    interactions: [M, I]
  }), J = reactExports.useMemo(() => {
    const [E] = k.split("-");
    return x2[E] ?? m0;
  }, [k]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Pm.Provider, { value: { theme: p, activeIndex: l, dismissOnClick: r, getItemProps: U, handleSelect: C }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      w2,
      {
        ...S,
        refs: L,
        inline: _,
        theme: p,
        "data-testid": b,
        className: Y(p.floating.target, S.className),
        setButtonWidth: h,
        getReferenceProps: W,
        renderTrigger: a,
        children: [
          x,
          T && /* @__PURE__ */ jsxRuntimeExports.jsx(J, { className: p.arrowIcon })
        ]
      }
    ),
    s && /* @__PURE__ */ jsxRuntimeExports.jsx(_m, { context: z, modal: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: L.setFloating,
        style: { ...A, minWidth: f },
        "data-testid": "flowbite-dropdown",
        "aria-expanded": s,
        ...B({
          className: Y(
            p.floating.base,
            p.floating.animation,
            "duration-100",
            !s && p.floating.hidden,
            p.floating.style.auto,
            e
          )
        }),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(zM, { elementsRef: g, labelsRef: m, children: /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: p.content, tabIndex: -1, children: t6 }) })
      }
    ) })
  ] });
};
Im.displayName = "Dropdown";
Rm.displayName = "Dropdown.Header";
Zc.displayName = "Dropdown.Divider";
Object.assign(Im, {
  Item: Nm,
  Header: Rm,
  Divider: Zc
});
const Am = reactExports.forwardRef(
  ({ className: t6, color: e = "gray", helperText: r, sizing: n = "md", theme: a = {}, ...i }, s) => {
    const o = te(ue().fileInput, a);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: Y(o.root.base, t6), children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: o.field.base, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          className: Y(
            o.field.input.base,
            o.field.input.colors[e],
            o.field.input.sizes[n]
          ),
          ...i,
          type: "file",
          ref: s
        }
      ) }) }),
      r && /* @__PURE__ */ jsxRuntimeExports.jsx(vi, { color: e, children: r })
    ] });
  }
);
Am.displayName = "FileInput";
const k2 = reactExports.forwardRef(
  ({
    label: t6,
    helperText: e,
    color: r = "default",
    sizing: n = "md",
    variant: a,
    disabled: i = false,
    theme: s = {},
    className: o,
    ...l
  }, c) => {
    const d = reactExports.useId(), u = te(ue().floatingLabel, s);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: Y("relative", a === "standard" ? "z-0" : ""), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            id: l.id ? l.id : "floatingLabel" + d,
            "aria-describedby": "outlined_success_help",
            className: Y(u.input[r][a][n], o),
            placeholder: " ",
            "data-testid": "floating-label",
            disabled: i,
            ...l,
            ref: c
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "label",
          {
            htmlFor: l.id ? l.id : "floatingLabel" + d,
            className: Y(u.label[r][a][n], o),
            children: t6
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { id: "outlined_helper_text" + d, className: Y(u.helperText[r], o), children: e })
    ] });
  }
);
k2.displayName = "FloatingLabel";
const Fm = ({
  alt: t6,
  className: e,
  children: r,
  href: n,
  name: a,
  src: i,
  theme: s = {},
  ...o
}) => {
  const l = te(ue().footer.brand, s);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: n ? /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { "data-testid": "flowbite-footer-brand", href: n, className: Y(l.base, e), ...o, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { alt: t6, src: i, className: l.img }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { "data-testid": "flowbite-footer-brand-span", className: l.span, children: a }),
    r
  ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
    "img",
    {
      alt: t6,
      "data-testid": "flowbite-footer-brand",
      src: i,
      className: Y(l.img, e),
      ...o
    }
  ) });
}, Lm = ({
  by: t6,
  className: e,
  href: r,
  theme: n = {},
  year: a,
  ...i
}) => {
  const s = te(ue().footer.copyright, n);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { "data-testid": "flowbite-footer-copyright", className: Y(s.base, e), ...i, children: [
    "© ",
    a,
    r ? /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: r, className: s.href, children: t6 }) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { "data-testid": "flowbite-footer-copyright-span", className: s.span, children: t6 })
  ] });
}, Wm = ({ className: t6, theme: e = {}, ...r }) => {
  const n = te(ue().footer.divider, e);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { "data-testid": "footer-divider", className: Y(n.base, t6), ...r });
}, $m = ({
  ariaLabel: t6,
  className: e,
  href: r,
  icon: n,
  theme: a = {},
  ...i
}) => {
  const s = te(ue().footer.icon, a);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: r ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    "a",
    {
      "aria-label": t6,
      "data-testid": "flowbite-footer-icon",
      href: r,
      className: Y(s.base, e),
      ...i,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(n, { className: s.size })
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(n, { "data-testid": "flowbite-footer-icon", className: s.size, ...i }) });
}, zm = ({
  as: t6 = "a",
  children: e,
  className: r,
  href: n,
  theme: a = {},
  ...i
}) => {
  const s = te(ue().footer.groupLink.link, a);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: Y(s.base, r), children: /* @__PURE__ */ jsxRuntimeExports.jsx(t6, { href: n, className: s.href, ...i, children: e }) });
}, jm = ({
  children: t6,
  className: e,
  col: r = false,
  theme: n = {},
  ...a
}) => {
  const i = te(ue().footer.groupLink, n);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { "data-testid": "footer-groupLink", className: Y(i.base, r && i.col, e), ...a, children: t6 });
}, Hm = ({
  as: t6 = "h2",
  className: e,
  theme: r = {},
  title: n,
  ...a
}) => {
  const i = te(ue().footer.title, r);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(t6, { "data-testid": "flowbite-footer-title", className: Y(i.base, e), ...a, children: n });
}, Bm = ({
  bgDark: t6 = false,
  children: e,
  className: r,
  container: n = false,
  theme: a = {},
  ...i
}) => {
  const s = te(ue().footer, a);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "footer",
    {
      "data-testid": "flowbite-footer",
      className: Y(s.root.base, t6 && s.root.bgDark, n && s.root.container, r),
      ...i,
      children: e
    }
  );
};
Bm.displayName = "Footer";
Lm.displayName = "Footer.Copyright";
zm.displayName = "Footer.Link";
Fm.displayName = "Footer.Brand";
jm.displayName = "Footer.LinkGroup";
$m.displayName = "Footer.Icon";
Hm.displayName = "Footer.Title";
Wm.displayName = "Footer.Divider";
Object.assign(Bm, {
  Copyright: Lm,
  Link: zm,
  LinkGroup: jm,
  Brand: Fm,
  Icon: $m,
  Title: Hm,
  Divider: Wm
});
const Ym = ({
  children: t6,
  className: e,
  color: r = "default",
  disabled: n = false,
  theme: a = {},
  value: i,
  ...s
}) => {
  const o = te(ue().label, a);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "label",
    {
      className: Y(o.root.base, o.root.colors[r], n && o.root.disabled, e),
      "data-testid": "flowbite-label",
      ...s,
      children: i ?? t6 ?? ""
    }
  );
};
Ym.displayName = "Label";
const Vm = ({ children: t6, className: e, icon: r, theme: n = {}, ...a }) => {
  const i = te(ue().list.item, n);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: Y(i.withIcon[r ? "on" : "off"], e), ...a, children: [
    r && /* @__PURE__ */ jsxRuntimeExports.jsx(r, { className: Y(i.icon) }),
    t6
  ] });
}, qm = ({
  children: t6,
  className: e,
  unstyled: r,
  nested: n,
  ordered: a,
  horizontal: i,
  theme: s = {},
  ...o
}) => {
  const l = te(ue().list, s);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    a ? "ol" : "ul",
    {
      className: Y(
        l.root.base,
        l.root.ordered[a ? "on" : "off"],
        r && l.root.unstyled,
        n && l.root.nested,
        i && l.root.horizontal,
        e
      ),
      ...o,
      children: t6
    }
  );
};
qm.displayName = "List";
Vm.displayName = "List.Item";
Object.assign(qm, { Item: Vm });
const Um = ({
  active: t6,
  children: e,
  className: r,
  href: n,
  icon: a,
  onClick: i,
  theme: s = {},
  disabled: o,
  ...l
}) => {
  const c = te(ue().listGroup.item, s), d = typeof n < "u", u = d ? "a" : "button";
  return /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: Y(c.base, r), children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    u,
    {
      href: n,
      onClick: i,
      type: d ? void 0 : "button",
      disabled: o,
      className: Y(
        c.link.active[t6 ? "on" : "off"],
        c.link.disabled[o ? "on" : "off"],
        c.link.base,
        c.link.href[d ? "on" : "off"]
      ),
      ...l,
      children: [
        a && /* @__PURE__ */ jsxRuntimeExports.jsx(a, { "aria-hidden": true, "data-testid": "flowbite-list-group-item-icon", className: c.link.icon }),
        e
      ]
    }
  ) });
}, Xm = ({ children: t6, className: e, theme: r = {}, ...n }) => {
  const a = te(ue().listGroup, r);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: Y(a.root.base, e), ...n, children: t6 });
};
Xm.displayName = "ListGroup";
Um.displayName = "ListGroup.Item";
Object.assign(Xm, {
  Item: Um
});
const Gm = reactExports.createContext(void 0);
function ed() {
  const t6 = reactExports.useContext(Gm);
  if (!t6)
    throw new Error("useModalContext should be used within the ModalContext provider!");
  return t6;
}
const Km = ({ children: t6, className: e, theme: r = {}, ...n }) => {
  const { theme: a, popup: i } = ed(), s = te(a.body, r);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: Y(s.base, i && [s.popup], e), ...n, children: t6 });
}, Qm = ({ children: t6, className: e, theme: r = {}, ...n }) => {
  const { theme: a, popup: i } = ed(), s = te(a.footer, r);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: Y(s.base, !i && s.popup, e), ...n, children: t6 });
}, Jm = ({
  as: t6 = "h3",
  children: e,
  className: r,
  theme: n = {},
  id: a,
  ...i
}) => {
  const s = reactExports.useId(), o = a || s, { theme: l, popup: c, onClose: d, setHeaderId: u } = ed(), f = te(l.header, n);
  return reactExports.useLayoutEffect(() => (u(o), () => u(void 0)), [o, u]), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: Y(f.base, c && f.popup, r), ...i, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(t6, { id: o, className: f.title, children: e }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("button", { "aria-label": "Close", className: f.close.base, type: "button", onClick: d, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PO, { "aria-hidden": true, className: f.close.icon }) })
  ] });
}, Zm = reactExports.forwardRef(
  ({
    children: t6,
    className: e,
    dismissible: r = false,
    onClose: n,
    popup: a,
    position: i = "center",
    root: s,
    show: o,
    size: l = "2xl",
    theme: c = {},
    initialFocus: d,
    ...u
  }, f) => {
    const [h, g] = reactExports.useState(void 0), m = te(ue().modal, c), { context: p } = Dm({
      open: o,
      onOpenChange: () => n && n()
    }), w = mm([p.refs.setFloating, f]), b = Om(p), k = Sm(p, { outsidePressEvent: "mousedown", enabled: r }), v = Cm(p), { getFloatingProps: x } = Mm([b, k, v]);
    return o ? /* @__PURE__ */ jsxRuntimeExports.jsx(Gm.Provider, { value: { theme: m, popup: a, onClose: n, setHeaderId: g }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(a2, { root: s, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      o2,
      {
        lockScroll: true,
        "data-testid": "modal-overlay",
        className: Y(
          m.root.base,
          m.root.positions[i],
          o ? m.root.show.on : m.root.show.off,
          e
        ),
        ...u,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(_m, { context: p, initialFocus: d, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            ref: w,
            ...x(u),
            "aria-labelledby": h,
            className: Y(m.content.base, m.root.sizes[l]),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: m.content.inner, children: t6 })
          }
        ) })
      }
    ) }) }) : null;
  }
);
Zm.displayName = "Modal";
Jm.displayName = "Modal.Header";
Km.displayName = "Modal.Body";
Qm.displayName = "Modal.Footer";
Object.assign(Zm, {
  Header: Jm,
  Body: Km,
  Footer: Qm
});
const ep = reactExports.createContext(void 0);
function Mo() {
  const t6 = reactExports.useContext(ep);
  if (!t6)
    throw new Error("useNavBarContext should be used within the NavbarContext provider!");
  return t6;
}
const tp = ({
  as: t6 = "a",
  children: e,
  className: r,
  theme: n = {},
  ...a
}) => {
  const { theme: i } = Mo(), s = te(i.brand, n);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(t6, { className: Y(s.base, r), ...a, children: e });
}, rp = ({ children: t6, className: e, theme: r = {}, ...n }) => {
  const { theme: a, isOpen: i } = Mo(), s = te(a.collapse, r);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      "data-testid": "flowbite-navbar-collapse",
      className: Y(s.base, s.hidden[i ? "off" : "on"], e),
      ...n,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: s.list, children: t6 })
    }
  );
}, np = ({
  active: t6,
  as: e = "a",
  disabled: r,
  children: n,
  className: a,
  theme: i = {},
  onClick: s,
  ...o
}) => {
  const { theme: l, setIsOpen: c } = Mo(), d = te(l.link, i), u = (f) => {
    c(false), s == null || s(f);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    e,
    {
      className: Y(
        d.base,
        t6 && d.active.on,
        !t6 && !r && d.active.off,
        d.disabled[r ? "on" : "off"],
        a
      ),
      onClick: u,
      ...o,
      children: n
    }
  ) });
}, ap = ({
  barIcon: t6 = jy,
  className: e,
  theme: r = {},
  ...n
}) => {
  const { theme: a, isOpen: i, setIsOpen: s } = Mo(), o = te(a.toggle, r);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "button",
    {
      "data-testid": "flowbite-navbar-toggle",
      onClick: () => {
        s(!i);
      },
      className: Y(o.base, e),
      ...n,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "sr-only", children: "Open main menu" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(t6, { "aria-hidden": true, className: o.icon })
      ]
    }
  );
}, ip = ({
  border: t6,
  children: e,
  className: r,
  fluid: n = false,
  menuOpen: a,
  rounded: i,
  theme: s = {},
  ...o
}) => {
  const [l, c] = reactExports.useState(a), d = te(ue().navbar, s);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ep.Provider, { value: { theme: d, isOpen: l, setIsOpen: c }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "nav",
    {
      className: Y(
        d.root.base,
        d.root.bordered[t6 ? "on" : "off"],
        d.root.rounded[i ? "on" : "off"],
        r
      ),
      ...o,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: Y(d.root.inner.base, d.root.inner.fluid[n ? "on" : "off"]), children: e })
    }
  ) });
};
ip.displayName = "Navbar";
tp.displayName = "Navbar.Brand";
rp.displayName = "Navbar.Collapse";
np.displayName = "Navbar.Link";
ap.displayName = "Navbar.Toggle";
Object.assign(ip, {
  Brand: tp,
  Collapse: rp,
  Link: np,
  Toggle: ap
});
const _2 = (t6, e) => t6 >= e ? [] : [...Array(e - t6 + 1).keys()].map((r) => r + t6), td = ({
  active: t6,
  children: e,
  className: r,
  onClick: n,
  theme: a = {},
  ...i
}) => {
  const s = te(ue().pagination, a);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      type: "button",
      className: Y(t6 && s.pages.selector.active, r),
      onClick: n,
      ...i,
      children: e
    }
  );
};
td.displayName = "Pagination.Button";
const Ul = ({
  children: t6,
  className: e,
  onClick: r,
  theme: n = {},
  disabled: a = false,
  ...i
}) => {
  const s = te(ue().pagination, n);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      type: "button",
      className: Y(a && s.pages.selector.disabled, e),
      disabled: a,
      onClick: r,
      ...i,
      children: t6
    }
  );
};
Ul.displayName = "Pagination.Navigation";
const sp = ({
  className: t6,
  currentPage: e,
  layout: r = "pagination",
  nextLabel: n = "Next",
  onPageChange: a,
  previousLabel: i = "Previous",
  renderPaginationButton: s = (u) => /* @__PURE__ */ jsxRuntimeExports.jsx(td, { ...u }),
  showIcons: o = false,
  theme: l = {},
  totalPages: c,
  ...d
}) => {
  const u = te(ue().pagination, l), f = Math.min(Math.max(r === "pagination" ? e + 2 : e + 4, 5), c), h = Math.max(1, f - 4), g = () => {
    a(Math.min(e + 1, c));
  }, m = () => {
    a(Math.max(e - 1, 1));
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("nav", { className: Y(u.base, t6), ...d, children: [
    r === "table" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: u.layout.table.base, children: [
      "Showing ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: u.layout.table.span, children: h }),
      " to ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: u.layout.table.span, children: f }),
      " of ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: u.layout.table.span, children: c }),
      " Entries"
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: u.pages.base, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Ul,
        {
          className: Y(u.pages.previous.base, o && u.pages.showIcon),
          onClick: m,
          disabled: e === 1,
          children: [
            o && /* @__PURE__ */ jsxRuntimeExports.jsx(h0, { "aria-hidden": true, className: u.pages.previous.icon }),
            i
          ]
        }
      ) }),
      r === "pagination" && _2(h, f).map((p) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { "aria-current": p === e ? "page" : void 0, children: s({
        className: Y(u.pages.selector.base, e === p && u.pages.selector.active),
        active: p === e,
        onClick: () => a(p),
        children: p
      }) }, p)),
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Ul,
        {
          className: Y(u.pages.next.base, o && u.pages.showIcon),
          onClick: g,
          disabled: e === c,
          children: [
            n,
            o && /* @__PURE__ */ jsxRuntimeExports.jsx(g0, { "aria-hidden": true, className: u.pages.next.icon })
          ]
        }
      ) })
    ] })
  ] });
};
sp.displayName = "Pagination";
Object.assign(sp, {
  Button: td
});
const O2 = reactExports.forwardRef(
  ({ className: t6, theme: e = {}, ...r }, n) => {
    const a = te(ue().radio, e);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("input", { ref: n, type: "radio", className: Y(a.root.base, t6), ...r });
  }
);
O2.displayName = "Radio";
const S2 = reactExports.forwardRef(
  ({ className: t6, sizing: e = "md", theme: r = {}, ...n }, a) => {
    const i = te(ue().rangeSlider, r);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { "data-testid": "flowbite-range-slider", className: Y(i.root.base, t6), children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: i.field.base, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        ref: a,
        type: "range",
        className: Y(i.field.input.base, i.field.input.sizes[e]),
        ...n
      }
    ) }) }) });
  }
);
S2.displayName = "RangeSlider";
const op = ({
  children: t6,
  className: e,
  percentFilled: r = 0,
  theme: n = {},
  ...a
}) => {
  const i = te(ue().ratingAdvanced, n);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: Y(i.base, e), ...a, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: i.label, children: t6 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: i.progress.base, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: i.progress.fill,
        "data-testid": "flowbite-rating-fill",
        style: { width: `${r}%` }
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: i.progress.label, children: `${r}%` })
  ] });
}, lp = reactExports.createContext(void 0);
function D2() {
  const t6 = reactExports.useContext(lp);
  if (!t6)
    throw new Error("useRatingContext should be used within the RatingContext provider!");
  return t6;
}
const cp = ({
  className: t6,
  filled: e = true,
  starIcon: r = MO,
  theme: n = {},
  ...a
}) => {
  const { theme: i, size: s = "sm" } = D2(), o = te(i.star, n);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    r,
    {
      "data-testid": "flowbite-rating-star",
      className: Y(o.sizes[s], o[e ? "filled" : "empty"], t6),
      ...a
    }
  );
}, dp = ({ children: t6, className: e, size: r = "sm", theme: n = {}, ...a }) => {
  const i = te(ue().rating, n);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(lp.Provider, { value: { theme: i, size: r }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: Y(i.root.base, e), ...a, children: t6 }) });
};
dp.displayName = "Rating";
cp.displayName = "Rating.Star";
op.displayName = "Rating.Advanced";
Object.assign(dp, {
  Star: cp,
  Advanced: op
});
const M2 = reactExports.forwardRef(
  ({
    addon: t6,
    children: e,
    className: r,
    color: n = "gray",
    helperText: a,
    icon: i,
    shadow: s,
    sizing: o = "md",
    theme: l = {},
    ...c
  }, d) => {
    const u = te(ue().select, l);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: Y(u.base, r), children: [
      t6 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: u.addon, children: t6 }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: u.field.base, children: [
        i && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: u.field.icon.base, children: /* @__PURE__ */ jsxRuntimeExports.jsx(i, { className: u.field.icon.svg }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "select",
          {
            className: Y(
              u.field.select.base,
              u.field.select.colors[n],
              u.field.select.sizes[o],
              u.field.select.withIcon[i ? "on" : "off"],
              u.field.select.withAddon[t6 ? "on" : "off"],
              u.field.select.withShadow[s ? "on" : "off"]
            ),
            ...c,
            ref: d,
            children: e
          }
        ),
        a && /* @__PURE__ */ jsxRuntimeExports.jsx(vi, { color: n, children: a })
      ] })
    ] });
  }
);
M2.displayName = "Select";
const C2 = ({
  animation: t6 = "duration-300",
  arrow: e = true,
  children: r,
  className: n,
  content: a,
  placement: i = "top",
  style: s = "dark",
  theme: o,
  trigger: l = "hover",
  minWidth: c,
  ...d
}) => {
  const u = reactExports.useRef(null), [f, h] = reactExports.useState(false), g = Em({
    open: f,
    placement: i,
    arrowRef: u,
    setOpen: h
  }), {
    context: m,
    middlewareData: { arrow: { x: p, y: w } = {} },
    refs: b,
    strategy: k,
    update: v,
    x,
    y: _
  } = g, T = d2(m), { getFloatingProps: S, getReferenceProps: C } = Tm({
    context: m,
    role: "tooltip",
    trigger: l,
    interactions: [T]
  });
  return reactExports.useEffect(() => {
    if (b.reference.current && b.floating.current && f)
      return cm(b.reference.current, b.floating.current, v);
  }, [f, b.floating, b.reference, v]), /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: b.setReference,
        className: o.target,
        "data-testid": "flowbite-tooltip-target",
        ...C(),
        children: r
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        ref: b.setFloating,
        "data-testid": "flowbite-tooltip",
        ...S({
          className: Y(
            o.base,
            t6 && `${o.animation} ${t6}`,
            !f && o.hidden,
            o.style[s],
            n
          ),
          style: {
            position: k,
            top: _ ?? " ",
            left: x ?? " ",
            minWidth: c
          },
          ...d
        }),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: o.content, children: a }),
          e && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: Y(
                o.arrow.base,
                s === "dark" && o.arrow.style.dark,
                s === "light" && o.arrow.style.light,
                s === "auto" && o.arrow.style.auto
              ),
              "data-testid": "flowbite-tooltip-arrow",
              ref: u,
              style: {
                top: w ?? " ",
                left: p ?? " ",
                right: " ",
                bottom: " ",
                [v2({ placement: g.placement })]: o.arrow.placement
              },
              children: " "
            }
          )
        ]
      }
    )
  ] });
}, rd = ({
  animation: t6 = "duration-300",
  arrow: e = true,
  children: r,
  className: n,
  content: a,
  placement: i = "top",
  style: s = "dark",
  theme: o = {},
  trigger: l = "hover",
  ...c
}) => {
  const d = te(ue().tooltip, o);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    C2,
    {
      animation: t6,
      arrow: e,
      content: a,
      placement: i,
      style: s,
      theme: d,
      trigger: l,
      className: n,
      ...c,
      children: r
    }
  );
};
rd.displayName = "Tooltip";
const up = reactExports.createContext(void 0);
function ya() {
  const t6 = reactExports.useContext(up);
  if (!t6)
    throw new Error("useSidebarContext should be used within the SidebarContext provider!");
  return t6;
}
const nd = reactExports.createContext(void 0);
function E2() {
  const t6 = reactExports.useContext(nd);
  if (!t6)
    throw new Error("useSidebarItemContext should be used within the SidebarItemContext provider!");
  return t6;
}
const fp = ({
  children: t6,
  className: e,
  icon: r,
  label: n,
  chevronIcon: a = f0,
  renderChevronIcon: i,
  open: s = false,
  theme: o = {},
  ...l
}) => {
  const c = reactExports.useId(), [d, u] = reactExports.useState(s), { theme: f, isCollapsed: h } = ya(), g = te(f.collapse, o);
  return reactExports.useEffect(() => u(s), [s]), /* @__PURE__ */ jsxRuntimeExports.jsxs(({ children: p }) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: h && !d ? /* @__PURE__ */ jsxRuntimeExports.jsx(rd, { content: n, placement: "right", children: p }) : p }), { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        id: `flowbite-sidebar-collapse-${c}`,
        onClick: () => u(!d),
        title: n,
        type: "button",
        className: Y(g.button, e),
        ...l,
        children: [
          r && /* @__PURE__ */ jsxRuntimeExports.jsx(
            r,
            {
              "aria-hidden": true,
              "data-testid": "flowbite-sidebar-collapse-icon",
              className: Y(g.icon.base, g.icon.open[d ? "on" : "off"])
            }
          ),
          h ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "sr-only", children: n }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { "data-testid": "flowbite-sidebar-collapse-label", className: g.label.base, children: n }),
            i ? i(g, d) : /* @__PURE__ */ jsxRuntimeExports.jsx(
              a,
              {
                "aria-hidden": true,
                className: Y(g.label.icon.base, g.label.icon.open[d ? "on" : "off"])
              }
            )
          ] })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { "aria-labelledby": `flowbite-sidebar-collapse-${c}`, hidden: !d, className: g.list, children: /* @__PURE__ */ jsxRuntimeExports.jsx(nd.Provider, { value: { isInsideCollapse: true }, children: t6 }) })
  ] });
};
fp.displayName = "Sidebar.Collapse";
const hp = ({
  children: t6,
  color: e = "info",
  className: r,
  theme: n = {},
  ...a
}) => {
  const { theme: i, isCollapsed: s } = ya(), o = te(i.cta, n);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      "data-testid": "sidebar-cta",
      hidden: s,
      className: Y(o.base, o.color[e], r),
      ...a,
      children: t6
    }
  );
};
hp.displayName = "Sidebar.CTA";
const T2 = ({ id: t6, theme: e, isCollapsed: r, tooltipChildren: n, children: a, ...i }) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { ...i, children: r ? /* @__PURE__ */ jsxRuntimeExports.jsx(
  rd,
  {
    content: /* @__PURE__ */ jsxRuntimeExports.jsx(gp, { id: t6, theme: e, children: n }),
    placement: "right",
    children: a
  }
) : a }), gp = ({ id: t6, theme: e, children: r }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "span",
  {
    "data-testid": "flowbite-sidebar-item-content",
    id: `flowbite-sidebar-item-${t6}`,
    className: Y(e.content.base),
    children: r
  }
), mp = reactExports.forwardRef(
  ({
    active: t6,
    as: e = "a",
    children: r,
    className: n,
    icon: a,
    label: i,
    labelColor: s = "info",
    theme: o = {},
    ...l
  }, c) => {
    var m, p, w, b;
    const d = reactExports.useId(), { theme: u, isCollapsed: f } = ya(), { isInsideCollapse: h } = E2(), g = te(u.item, o);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(T2, { theme: g, className: g.listItem, id: d, isCollapsed: f, tooltipChildren: r, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      e,
      {
        "aria-labelledby": `flowbite-sidebar-item-${d}`,
        ref: c,
        className: Y(
          g.base,
          t6 && g.active,
          !f && h && ((m = g.collapsed) == null ? void 0 : m.insideCollapse),
          n
        ),
        ...l,
        children: [
          a && /* @__PURE__ */ jsxRuntimeExports.jsx(
            a,
            {
              "aria-hidden": true,
              "data-testid": "flowbite-sidebar-item-icon",
              className: Y((p = g.icon) == null ? void 0 : p.base, t6 && ((w = g.icon) == null ? void 0 : w.active))
            }
          ),
          f && !a && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: (b = g.collapsed) == null ? void 0 : b.noIcon, children: r.charAt(0).toLocaleUpperCase() ?? "?" }),
          !f && /* @__PURE__ */ jsxRuntimeExports.jsx(gp, { id: d, theme: g, children: r }),
          !f && i && /* @__PURE__ */ jsxRuntimeExports.jsx(P0, { color: s, "data-testid": "flowbite-sidebar-label", hidden: f, className: g.label, children: i })
        ]
      }
    ) });
  }
);
mp.displayName = "Sidebar.Item";
const pp = ({
  children: t6,
  className: e,
  theme: r = {},
  ...n
}) => {
  const { theme: a } = ya(), i = te(a.itemGroup, r);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { "data-testid": "flowbite-sidebar-item-group", className: Y(i.base, e), ...n, children: /* @__PURE__ */ jsxRuntimeExports.jsx(nd.Provider, { value: { isInsideCollapse: false }, children: t6 }) });
};
pp.displayName = "Sidebar.ItemGroup";
const bp = ({ children: t6, className: e, theme: r = {}, ...n }) => {
  const { theme: a } = ya(), i = te(a.items, r);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: Y(i.base, e), "data-testid": "flowbite-sidebar-items", ...n, children: t6 });
};
bp.displayName = "Sidebar.Items";
const yp = ({
  children: t6,
  className: e,
  href: r,
  img: n,
  imgAlt: a = "",
  theme: i = {},
  ...s
}) => {
  const o = reactExports.useId(), { theme: l, isCollapsed: c } = ya(), d = te(l.logo, i);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "a",
    {
      "aria-labelledby": `flowbite-sidebar-logo-${o}`,
      href: r,
      className: Y(d.base, e),
      ...s,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { alt: a, src: n, className: d.img }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: d.collapsed[c ? "on" : "off"], id: `flowbite-sidebar-logo-${o}`, children: t6 })
      ]
    }
  );
};
yp.displayName = "Sidebar.Logo";
const vp = ({
  children: t6,
  as: e = "nav",
  collapseBehavior: r = "collapse",
  collapsed: n = false,
  theme: a = {},
  className: i,
  ...s
}) => {
  const o = te(ue().sidebar, a);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(up.Provider, { value: { theme: o, isCollapsed: n }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    e,
    {
      "aria-label": "Sidebar",
      hidden: n && r === "hide",
      className: Y(o.root.base, o.root.collapsed[n ? "on" : "off"], i),
      ...s,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: o.root.inner, children: t6 })
    }
  ) });
};
vp.displayName = "Sidebar";
Object.assign(vp, {
  Collapse: fp,
  CTA: hp,
  Item: mp,
  Items: bp,
  ItemGroup: pp,
  Logo: yp
});
const xp = reactExports.createContext(void 0);
function P2() {
  const t6 = reactExports.useContext(xp);
  if (!t6)
    throw new Error("useTableBodyContext should be used within the TableBodyContext provider!");
  return t6;
}
const wp = reactExports.createContext(void 0);
function ad() {
  const t6 = reactExports.useContext(wp);
  if (!t6)
    throw new Error("useTableContext should be used within the TableContext provider!");
  return t6;
}
const kp = reactExports.forwardRef(
  ({ children: t6, className: e, theme: r = {}, ...n }, a) => {
    const { theme: i } = ad(), s = te(i.body, r);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(xp.Provider, { value: { theme: s }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { className: Y(s.base, e), ref: a, ...n, children: t6 }) });
  }
);
kp.displayName = "Table.Body";
const _p = reactExports.forwardRef(
  ({ children: t6, className: e, theme: r = {}, ...n }, a) => {
    const { theme: i } = P2(), s = te(i.cell, r);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: Y(s.base, e), ref: a, ...n, children: t6 });
  }
);
_p.displayName = "Table.Cell";
const Op = reactExports.createContext(void 0);
function R2() {
  const t6 = reactExports.useContext(Op);
  if (!t6)
    throw new Error("useTableHeadContext should be used within the TableHeadContext provider!");
  return t6;
}
const Sp = reactExports.forwardRef(
  ({ children: t6, className: e, theme: r = {}, ...n }, a) => {
    const { theme: i } = ad(), s = te(i.head, r);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Op.Provider, { value: { theme: s }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { className: Y(s.base, e), ref: a, ...n, children: /* @__PURE__ */ jsxRuntimeExports.jsx("tr", { children: t6 }) }) });
  }
);
Sp.displayName = "Table.Head";
const Dp = reactExports.forwardRef(
  ({ children: t6, className: e, theme: r = {}, ...n }, a) => {
    const { theme: i } = R2(), s = te(i.cell, r);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: Y(s.base, e), ref: a, ...n, children: t6 });
  }
);
Dp.displayName = "Table.HeadCell";
const Mp = reactExports.forwardRef(
  ({ children: t6, className: e, theme: r = {}, ...n }, a) => {
    const { theme: i, hoverable: s, striped: o } = ad(), l = te(i.row, r);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "tr",
      {
        ref: a,
        "data-testid": "table-row-element",
        className: Y(l.base, o && l.striped, s && l.hovered, e),
        ...n,
        children: t6
      }
    );
  }
);
Mp.displayName = "Table.Row";
const Cp = reactExports.forwardRef(
  ({ children: t6, className: e, striped: r, hoverable: n, theme: a = {}, ...i }, s) => {
    const o = te(ue().table, a);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { "data-testid": "table-element", className: Y(o.root.wrapper), children: /* @__PURE__ */ jsxRuntimeExports.jsxs(wp.Provider, { value: { theme: o, striped: r, hoverable: n }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: Y(o.root.shadow, e) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("table", { className: Y(o.root.base, e), ...i, ref: s, children: t6 })
    ] }) });
  }
);
Cp.displayName = "Table";
const Hn = Object.assign(Cp, {
  Head: Sp,
  Body: kp,
  Row: Mp,
  Cell: _p,
  HeadCell: Dp
}), Gn = ({ children: t6, className: e }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: e, children: t6 });
Gn.displayName = "Tabs.Item";
const Ep = reactExports.forwardRef(
  ({ children: t6, className: e, onActiveTabChange: r, style: n = "default", theme: a = {}, ...i }, s) => {
    const o = te(ue().tabs, a), l = reactExports.useId(), c = reactExports.useMemo(
      () => reactExports.Children.map(
        reactExports.Children.toArray(t6),
        ({ props: v }) => v
      ),
      [t6]
    ), d = reactExports.useRef([]), [u, f] = reactExports.useState(
      Math.max(
        0,
        c.findIndex((v) => v.active)
      )
    ), [h, g] = reactExports.useState(-1), m = (v) => {
      f(v), r && r(v);
    }, p = ({ target: v }) => {
      m(v), g(v);
    }, w = ({ event: v, target: x }) => {
      v.key === "ArrowLeft" && g(Math.max(0, h - 1)), v.key === "ArrowRight" && g(Math.min(c.length - 1, h + 1)), v.key === "Enter" && (m(x), g(x));
    }, b = o.tablist.tabitem.styles[n], k = o.tabitemcontainer.styles[n];
    return reactExports.useEffect(() => {
      var v;
      (v = d.current[h]) == null || v.focus();
    }, [h]), reactExports.useImperativeHandle(s, () => ({
      setActiveTab: m
    })), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: Y(o.base, e), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          "aria-label": "Tabs",
          role: "tablist",
          className: Y(o.tablist.base, o.tablist.styles[n], e),
          ...i,
          children: c.map((v, x) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              type: "button",
              "aria-controls": `${l}-tabpanel-${x}`,
              "aria-selected": x === u,
              className: Y(
                o.tablist.tabitem.base,
                b.base,
                x === u && b.active.on,
                x !== u && !v.disabled && b.active.off
              ),
              disabled: v.disabled,
              id: `${l}-tab-${x}`,
              onClick: () => p({ target: x }),
              onKeyDown: (_) => w({ event: _, target: x }),
              ref: (_) => d.current[x] = _,
              role: "tab",
              tabIndex: x === h ? 0 : -1,
              style: { zIndex: x === h ? 2 : 1 },
              children: [
                v.icon && /* @__PURE__ */ jsxRuntimeExports.jsx(v.icon, { className: o.tablist.tabitem.icon }),
                v.title
              ]
            },
            x
          ))
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: Y(o.tabitemcontainer.base, k), children: c.map((v, x) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          "aria-labelledby": `${l}-tab-${x}`,
          className: o.tabpanel,
          hidden: x !== u,
          id: `${l}-tabpanel-${x}`,
          role: "tabpanel",
          tabIndex: 0,
          children: v.children
        },
        x
      )) })
    ] });
  }
);
Ep.displayName = "Tabs";
Object.assign(Ep, {
  Item: Gn
}); const I2 = reactExports.forwardRef(
  ({ className: t6, color: e = "gray", helperText: r, shadow: n, theme: a = {}, ...i }, s) => {
    const o = te(ue().textarea, a);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "textarea",
        {
          ref: s,
          className: Y(o.base, o.colors[e], o.withShadow[n ? "on" : "off"], t6),
          ...i
        }
      ),
      r && /* @__PURE__ */ jsxRuntimeExports.jsx(vi, { color: e, children: r })
    ] });
  }
);
I2.displayName = "Textarea";
const Tp = reactExports.createContext(void 0);
function id() {
  const t6 = reactExports.useContext(Tp);
  if (!t6)
    throw new Error("useTimelineContentContext should be used within the TimelineContentContext provider!");
  return t6;
}
const Pp = ({ children: t6, className: e, theme: r = {}, ...n }) => {
  const { theme: a } = id(), i = te(a.body, r);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: Y(i.base, e), ...n, children: t6 });
}, Rp = reactExports.createContext(void 0);
function sd() {
  const t6 = reactExports.useContext(Rp);
  if (!t6)
    throw new Error("useTimelineContext should be used within the TimelineContext provider!");
  return t6;
}
const Np = reactExports.createContext(void 0);
function Ip() {
  const t6 = reactExports.useContext(Np);
  if (!t6)
    throw new Error("useTimelineItemContext should be used within the TimelineItemContext provider!");
  return t6;
}
const Ap = ({
  children: t6,
  className: e,
  theme: r = {},
  ...n
}) => {
  const { horizontal: a } = sd(), { theme: i } = Ip(), s = te(i.content, r);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Tp.Provider, { value: { theme: s }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { "data-testid": "timeline-content", className: Y(a && s.root.base, e), ...n, children: t6 }) });
}, Fp = ({ children: t6, className: e, theme: r = {}, ...n }) => {
  const { theme: a, horizontal: i } = sd(), s = te(a.item, r);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Np.Provider, { value: { theme: s }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "li",
    {
      "data-testid": "timeline-item",
      className: Y(i && s.root.horizontal, !i && s.root.vertical, e),
      ...n,
      children: t6
    }
  ) });
}, Lp = ({
  children: t6,
  className: e,
  icon: r,
  theme: n = {},
  ...a
}) => {
  const { horizontal: i } = sd(), { theme: s } = Ip(), o = te(s.point, n);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      "data-testid": "timeline-point",
      className: Y(i && o.horizontal, !i && o.vertical, e),
      ...a,
      children: [
        t6,
        r ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: Y(o.marker.icon.wrapper), children: /* @__PURE__ */ jsxRuntimeExports.jsx(r, { "aria-hidden": true, className: Y(o.marker.icon.base) }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: Y(i && o.marker.base.horizontal, !i && o.marker.base.vertical)
          }
        ),
        i && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: Y(o.line) })
      ]
    }
  );
}, Wp = ({ children: t6, className: e, theme: r = {}, ...n }) => {
  const { theme: a } = id(), i = te(a.time, r);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("time", { className: Y(i.base, e), ...n, children: t6 });
}, $p = ({
  as: t6 = "h3",
  children: e,
  className: r,
  theme: n = {},
  ...a
}) => {
  const { theme: i } = id(), s = te(i.title, n);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(t6, { className: Y(s.base, r), ...a, children: e });
}, zp = ({
  children: t6,
  className: e,
  horizontal: r,
  theme: n = {},
  ...a
}) => {
  const i = te(ue().timeline, n);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Rp.Provider, { value: { theme: i, horizontal: r }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "ol",
    {
      "data-testid": "timeline-component",
      className: Y(
        r && i.root.direction.horizontal,
        !r && i.root.direction.vertical,
        e
      ),
      ...a,
      children: t6
    }
  ) });
};
zp.displayName = "Timeline";
Fp.displayName = "Timeline.Item";
Lp.displayName = "Timeline.Point";
Ap.displayName = "Timeline.Content";
Wp.displayName = "Timeline.Time";
$p.displayName = "Timeline.Title";
Pp.displayName = "Timeline.Body";
Object.assign(zp, {
  Item: Fp,
  Point: Lp,
  Content: Ap,
  Time: Wp,
  Title: $p,
  Body: Pp
});
const jp = reactExports.createContext(void 0);
function A2() {
  const t6 = reactExports.useContext(jp);
  if (!t6)
    throw new Error("useToastContext should be used within the ToastContext provider!");
  return t6;
}
const Hp = ({
  className: t6,
  onClick: e,
  theme: r = {},
  xIcon: n = CO,
  onDismiss: a,
  ...i
}) => {
  const { theme: s, duration: o, isClosed: l, isRemoved: c, setIsClosed: d, setIsRemoved: u } = A2(), f = te(s.toggle, r);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      "aria-label": "Close",
      onClick: (g) => {
        if (e && e(g), a) {
          a();
          return;
        }
        d(!l), setTimeout(() => u(!c), o);
      },
      type: "button",
      className: Y(f.base, t6),
      ...i,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(n, { "aria-hidden": true, className: f.icon })
    }
  );
}, F2 = {
  75: "duration-75",
  100: "duration-100",
  150: "duration-150",
  200: "duration-200",
  300: "duration-300",
  500: "duration-500",
  700: "duration-700",
  1e3: "duration-1000"
}, Bp = ({ children: t6, className: e, duration: r = 300, theme: n = {}, ...a }) => {
  const [i, s] = reactExports.useState(false), [o, l] = reactExports.useState(false), c = te(ue().toast, n);
  return o ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(jp.Provider, { value: { theme: c, duration: r, isClosed: i, isRemoved: o, setIsClosed: s, setIsRemoved: l }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      "data-testid": "flowbite-toast",
      role: "alert",
      className: Y(c.root.base, F2[r], i && c.root.closed, e),
      ...a,
      children: t6
    }
  ) });
};
Bp.displayName = "Toast";
Hp.displayName = "Toast.Toggle";
Object.assign(Bp, {
  Toggle: Hp
});
const L2 = reactExports.forwardRef(
  ({
    checked: t6,
    className: e,
    color: r = "blue",
    sizing: n = "md",
    disabled: a,
    label: i,
    name: s,
    onChange: o,
    theme: l = {},
    ...c
  }, d) => {
    const u = reactExports.useId(), f = te(ue().toggleSwitch, l), h = () => o(!t6), g = () => {
      h();
    }, m = (p) => {
      p.code == "Enter" && p.preventDefault();
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      s && t6 ? /* @__PURE__ */ jsxRuntimeExports.jsx("input", { ref: d, checked: t6, hidden: true, name: s, readOnly: true, type: "checkbox", className: "sr-only" }) : null,
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          "aria-checked": t6,
          "aria-labelledby": `${u}-flowbite-toggleswitch-label`,
          disabled: a,
          id: `${u}-flowbite-toggleswitch`,
          onClick: g,
          onKeyDown: m,
          role: "switch",
          tabIndex: 0,
          type: "button",
          className: Y(f.root.base, f.root.active[a ? "off" : "on"], e),
          ...c,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                "data-testid": "flowbite-toggleswitch-toggle",
                className: Y(
                  f.toggle.base,
                  f.toggle.checked[t6 ? "on" : "off"],
                  t6 && f.toggle.checked.color[r],
                  f.toggle.sizes[n]
                )
              }
            ),
            i != null && i.length ? /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                "data-testid": "flowbite-toggleswitch-label",
                id: `${u}-flowbite-toggleswitch-label`,
                className: f.root.label,
                children: i
              }
            ) : null
          ]
        }
      )
    ] });
  }
);
L2.displayName = "ToggleSwitch";
const W2 = ({
  currentPage: t6,
  totalPages: e,
  onPageChange: r
}) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center gap-4", children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      onClick: () => r(t6 - 1),
      disabled: t6 === 1,
      className: "p-2 text-gray-500 hover:text-gray-700 disabled:cursor-not-allowed disabled:opacity-50",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(h0, { className: "h-5 w-5" })
    }
  ),
  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-sm text-gray-700", children: [
    t6,
    " de ",
    e
  ] }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      onClick: () => r(t6 + 1),
      disabled: t6 === e,
      className: "p-2 text-gray-500 hover:text-gray-700 disabled:cursor-not-allowed disabled:opacity-50",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(g0, { className: "h-5 w-5" })
    }
  )
] });
function $2({
  label: t6,
  checked: e = false,
  disabled: r = false,
  onChange: n
}) {
  const [a, i] = reactExports.useState(e);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "label",
      {
        className: `inline-flex items-center ${r ? "cursor-not-allowed opacity-60" : "cursor-pointer"}`,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "checkbox",
              className: "peer sr-only",
              checked: a,
              onChange: (o) => {
                if (r) return;
                const l = o.target.checked;
                i(l), n == null || n(l);
              },
              disabled: r
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: `peer relative h-6 w-11 rounded-full bg-gray-200 
          after:absolute after:start-[2px] 
          after:top-0.5 after:h-5 
          after:w-5 after:rounded-full 
          after:border after:border-gray-300 
          after:bg-white after:transition-all after:content-[''] 
          peer-checked:bg-blue-600 peer-checked:after:translate-x-full peer-checked:after:border-white 
          peer-focus:ring-4 peer-focus:ring-blue-300 dark:border-gray-600 
          dark:bg-gray-700 dark:peer-checked:bg-blue-600 
          dark:peer-focus:ring-blue-800 rtl:peer-checked:after:-translate-x-full`
            }
          )
        ]
      }
    ),
    t6 && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        className: `text-sm ${r ? "text-gray-500" : "text-gray-700"}`,
        children: t6
      }
    )
  ] });
}
const YN = ({
  columns: t6,
  data: e,
  showSearch: r = false,
  itemsPerPage: n = 5,
  title: a,
  onToggleChange: i
}) => {
  const [s, o] = reactExports.useState(""), [l, c] = reactExports.useState(1), [d, u] = reactExports.useState(null), f = reactExports.useMemo(() => d ? [...e].sort((b, k) => {
    const v = b[d.key], x = k[d.key];
    return v == null || x == null ? 0 : typeof v == "string" && typeof x == "string" ? d.direction === "asc" ? v.localeCompare(x) : x.localeCompare(v) : d.direction === "asc" ? Number(v) - Number(x) : Number(x) - Number(v);
  }) : e, [e, d]), h = reactExports.useMemo(() => s.trim() ? f.filter(
    (b) => t6.some((k) => {
      const v = b[k.relation];
      return v != null && String(v).toLowerCase().includes(s.toLowerCase().trim());
    })
  ) : f, [f, s, t6]), g = reactExports.useMemo(() => {
    const b = (l - 1) * n, k = b + n;
    return h.slice(b, k);
  }, [h, l, n]), m = Math.ceil(h.length / n), p = (b) => {
    u((k) => !k || k.key !== b ? { key: b, direction: "asc" } : {
      key: b,
      direction: k.direction === "asc" ? "desc" : "asc"
    });
  }, w = (b, k) => {
    const v = k[b.relation];
    if (b.isToggle) {
      const x = !!v;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          $2,
          {
            checked: x,
            onChange: (_) => i == null ? void 0 : i({
              rowId: k.id,
              checked: _,
              row: k,
              columnKey: b.relation
            }),
            disabled: false
          }
        ),
        b.toggleText && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-gray-600", children: x ? b.toggleText.active : b.toggleText.inactive })
      ] });
    }
    return b.cell ? b.cell(k) : v != null ? String(v) : "";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-4 flex items-center justify-between", children: a && /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-xl font-bold", children: a }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4 flex", children: [
      r && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-1/2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Lc,
        {
          rightIcon: SO,
          placeholder: "Buscar",
          value: s,
          onChange: (b) => o(b.target.value)
        }
      ) }),
      m > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex w-full justify-end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        W2,
        {
          currentPage: l,
          totalPages: m,
          onPageChange: c
        }
      ) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "overflow-x-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Hn, { striped: true, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Hn.Head, { children: t6.map((b, k) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        Hn.HeadCell,
        {
          className: "cursor-pointer",
          onClick: () => b.sortable !== false && p(b.relation),
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
            b.header,
            b.sortable !== false && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: (d == null ? void 0 : d.key) === b.relation ? d.direction === "asc" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Yf, { className: "size-4" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(DO, { className: "size-4" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Yf, { className: "size-4 opacity-50" }) })
          ] })
        },
        k
      )) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("hr", {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Hn.Body, { className: "divide-y", children: g.map((b) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        Hn.Row,
        {
          className: "bg-white dark:border-gray-700 dark:bg-gray-800",
          children: t6.map((k, v) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            Hn.Cell,
            {
              className: "whitespace-nowrap font-medium text-gray-900 dark:text-white",
              children: w(k, b)
            },
            `${b.id}-${v}`
          ))
        },
        b.id
      )) })
    ] }) })
  ] });
}, vh = {
  "m-image-container": "layoutOutside-module__m-image-container__sCvFu",
  "m-image": "layoutOutside-module__m-image__kZHyH"
}, VN = () => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-32", children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    Cn,
    {
      classIm: "mx-auto",
      src: "https://ftp.mathilde-ads.com/151-41415c0c026df82dbb391c09db474cfa.png",
      alt: "Logo Mathilde ads",
      width: 400,
      height: 250
    }
  ),
  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: vh["m-image-container"], children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Cn,
    {
      classIm: vh["m-image"],
      src: "https://ftp.mathilde-ads.com/151-3f28d319ba5adbe318c58ef38b858e50.png",
      alt: "Logo Mathilde ads",
      width: 400,
      height: 300
    }
  ) })
] }), qN = ({
  onOpenModal: t6,
  checked: e,
  onChange: r,
  label: n,
  ...a
}) => {
  const i = () => {
    e || t6(), r(false);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-5", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: ps["checkbox-container"], children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        type: "checkbox",
        ...a,
        checked: e,
        onChange: i,
        required: true
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: ps.checkmark }),
    n && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: n })
  ] }) });
}, z2 = ({
  validations: t6
}) => {
  const e = ({ isValid: n }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "svg",
    {
      className: `me-2 h-3.5 w-3.5 ${n ? "text-green-500 dark:text-green-400" : "text-gray-500 dark:text-gray-400"} shrink-0`,
      "aria-hidden": "true",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      viewBox: "0 0 20 20",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10 .5a9.5 9.5 0 1 0 9.5 9.5A9.51 9.51 0 0 0 10 .5Zm3.707 8.207-4 4a1 1 0 0 1-1.414 0l-2-2a1 1 0 0 1 1.414-1.414L9 10.586l3.293-3.293a1 1 0 0 1 1.414 1.414Z" })
    }
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "mb-3 max-w-md list-inside space-y-1 text-sm text-gray-500 dark:text-gray-400", children: [
    { key: "hasMinLength", text: "Debe ser minimo de 8 caracteres" },
    { key: "hasNumber", text: "Debe tener minimo un numero" },
    { key: "hasUpperCase", text: "Debe tener minimo una letra mayuscula" },
    { key: "hasLowerCase", text: "Debe tener minimo una letra minuscula" },
    { key: "hasSpecialChar", text: "Debe tener minimo un caracter especial" }
  ].map(({ key: n, text: a }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex items-center", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(e, { isValid: t6[n] }),
    a
  ] }, n)) });
}, j2 = () => {
  const [t6, e] = reactExports.useState(""), [r, n] = reactExports.useState(""), [a, i] = reactExports.useState({
    hasMinLength: false,
    hasNumber: false,
    hasUpperCase: false,
    hasLowerCase: false,
    hasSpecialChar: false
  });
  reactExports.useEffect(() => {
    i({
      hasMinLength: t6.length >= 8,
      hasNumber: /\d/.test(t6),
      hasUpperCase: /[A-Z]/.test(t6),
      hasLowerCase: /[a-z]/.test(t6),
      hasSpecialChar: /[!@#$%^&*(),.?":{}|<>]/.test(t6)
    });
  }, [t6]);
  const s = () => t6.trim() && r.trim() && t6 === r && Object.values(a).every((l) => l);
  return {
    password: t6,
    setPassword: e,
    confirmPassword: r,
    setConfirmPassword: n,
    showError: () => !s() && t6.trim() && r.trim(),
    validations: a
  };
}, UN = ({ formik: t6 }) => {
  const {
    password: e,
    setPassword: r,
    confirmPassword: n,
    setConfirmPassword: a,
    validations: i
  } = j2();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "block", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        zd,
        {
          placeholder: "Contraseña",
          value: e,
          onChange: (s) => {
            r(s.target.value), t6.setFieldValue("password", s.target.value);
          },
          onBlur: t6.handleBlur("password")
        }
      ),
      t6.errors.password && t6.touched.password && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "my-2 text-sm text-red-500", children: String(t6.errors.password) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "block", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        zd,
        {
          placeholder: "Confirmar contraseña",
          value: n,
          onChange: (s) => {
            a(s.target.value), t6.setFieldValue("confirmPassword", s.target.value);
          },
          onBlur: t6.handleBlur("confirmPassword")
        }
      ),
      t6.errors.confirmPassword && t6.touched.confirmPassword && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "my-2 text-sm text-red-500", children: String(t6.errors.confirmPassword) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(z2, { validations: i })
  ] });
}, XN = ({ items: t6 }) => {
  const [e, r] = reactExports.useState([]), n = (i) => {
    r(
      (s) => s.includes(i) ? s.filter((o) => o !== i) : [...s, i]
    );
  }, a = (i, s = 0) => /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "list-none space-y-2", children: i.map((o) => {
    const l = o.subItems && o.subItems.length > 0, c = e.includes(o.id);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "li",
      {
        className: `
              ${s > 0 ? "ml-7" : ""}
            `,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 py-1", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex min-w-[48px] items-center gap-1", children: [
              l && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => n(o.id),
                  className: "rounded-full p-1 transition-transform duration-200 hover:bg-gray-100",
                  children: c ? /* @__PURE__ */ jsxRuntimeExports.jsx(By, { className: "text-sm text-gray-500" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Hy, { className: "text-sm text-gray-500" })
                }
              ),
              !l && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[28px]" }),
              " ",
              o.icon && /* @__PURE__ */ jsxRuntimeExports.jsx(
                o.icon,
                {
                  className: `text-lg ${o.isActive ? "text-blue-700 dark:text-blue-500" : "text-gray-600"}`
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "a",
              {
                href: o.href,
                className: `
                    flex-grow transition-colors duration-200
                    ${o.isActive ? "font-medium text-blue-700 dark:text-blue-500" : "text-gray-700 hover:text-blue-600 dark:text-gray-300"}
                  `,
                children: o.title
              }
            )
          ] }),
          l && c && a(o.subItems || [], s + 1)
        ]
      },
      o.id
    );
  }) });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("nav", { id: "TableOfContents", children: a(t6) });
}, xh = {
  "image/*": "Imágenes (JPG, PNG, GIF, etc.)",
  "application/pdf": "Documentos PDF",
  "application/msword": "Documentos Word (.doc)",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": "Documentos Word (.docx)",
  "application/vnd.ms-excel": "Hojas de cálculo Excel (.xls)",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": "Hojas de cálculo Excel (.xlsx)",
  "application/vnd.ms-powerpoint": "Presentaciones PowerPoint (.ppt)",
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": "Presentaciones PowerPoint (.pptx)",
  "text/csv": "Archivos CSV",
  "application/json": "Archivos JSON",
  "application/xml": "Archivos XML"
}, GN = ({
  onChange: t6,
  accept: e = "application/pdf",
  maxSize: r = 10,
  // 10MB por defecto
  multiple: n = false,
  helperText: a = ""
}) => {
  const [i, s] = reactExports.useState(false), o = Array.isArray(e) ? e.join(",") : e, l = () => Array.isArray(e) ? e.map((g) => xh[g] || g).join(", ") : xh[e] || e, c = reactExports.useCallback((g) => {
    g.preventDefault(), g.stopPropagation(), s(true);
  }, []), d = reactExports.useCallback((g) => {
    g.preventDefault(), g.stopPropagation(), s(false);
  }, []), u = reactExports.useCallback(
    (g) => {
      g.preventDefault(), g.stopPropagation(), s(false);
      const m = Array.from(g.dataTransfer.files);
      m.length > 0 && h(m);
    },
    [e, r, n, t6]
  ), f = reactExports.useCallback(
    (g) => {
      const m = Array.from(g.target.files || []);
      m.length > 0 && h(m);
    },
    [e, r, n, t6]
  ), h = reactExports.useCallback(
    (g) => {
      if (!n && g.length > 1) {
        alert("Solo se permite un archivo");
        return;
      }
      const m = g.filter((w) => Array.isArray(e) ? e.some((b) => b === "image/*" ? w.type.startsWith("image/") : w.type === b) : e === "image/*" ? w.type.startsWith("image/") : w.type === e);
      if (m.length === 0) {
        alert(
          `Tipo de archivo no permitido. Tipos permitidos: ${l()}`
        );
        return;
      }
      const p = m.filter(
        (w) => w.size <= r * 1024 * 1024
      );
      p.length !== m.length && alert(`Algunos archivos exceden el tamaño máximo de ${r}MB`), p.length > 0 && (t6 == null || t6(p));
    },
    [e, r, n, t6]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex w-full items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Ym,
    {
      htmlFor: "dropzone-file",
      className: `flex h-64 w-full cursor-pointer flex-col items-center justify-center rounded-lg border-2 border-dashed ${i ? "border-blue-500 bg-blue-50" : "border-gray-300 bg-gray-50"} hover:bg-gray-100 dark:border-gray-600 dark:bg-gray-700 dark:hover:border-gray-500 dark:hover:bg-gray-600`,
      onDragOver: c,
      onDragLeave: d,
      onDrop: u,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-2/4 items-center justify-center pb-6 pt-5", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Cn,
            {
              classIm: "mr-3",
              src: "https://ftp.mathilde-ads.com/151-e44e2ee2d56e5997506c6365eb4d87d3.svg",
              alt: "icon dropzone",
              width: 74,
              height: 74
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "mb-2 text-sm font-light text-gray-400 dark:text-gray-400", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-gray-500", children: "Arrastra" }),
              " el feed de datos de tu campaña o",
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-gray-500", children: "selecciona el archivo de tu computadora" }),
              " ",
              a
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs text-gray-500 dark:text-gray-400", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-semibold", children: "Tipos permitidos:" }),
              " ",
              l(),
              " |",
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-semibold", children: "Tamaño máximo:" }),
              " ",
              r,
              " MB"
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Am,
          {
            id: "dropzone-file",
            className: "hidden",
            onChange: f,
            accept: o,
            multiple: n
          }
        )
      ]
    }
  ) });
};
function H2(t6) {
  return We({ attr: { version: "1.1", viewBox: "0 0 16 16" }, child: [{ tag: "path", attr: { d: "M2 5v10c0 0.55 0.45 1 1 1h9c0.55 0 1-0.45 1-1v-10h-11zM5 14h-1v-7h1v7zM7 14h-1v-7h1v7zM9 14h-1v-7h1v7zM11 14h-1v-7h1v7z" }, child: [] }, { tag: "path", attr: { d: "M13.25 2h-3.25v-1.25c0-0.412-0.338-0.75-0.75-0.75h-3.5c-0.412 0-0.75 0.338-0.75 0.75v1.25h-3.25c-0.413 0-0.75 0.337-0.75 0.75v1.25h13v-1.25c0-0.413-0.338-0.75-0.75-0.75zM9 2h-3v-0.987h3v0.987z" }, child: [] }] })(t6);
}
const B2 = (t6) => {
  const e = Math.floor(Math.log(t6) / Math.log(1024)), r = ["Bytes", "KB", "MB", "GB", "TB"];
  return `${(t6 / Math.pow(1024, e)).toFixed(2)} ${r[e]}`;
}, KN = ({ files: t6, onDelete: e }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "list-disc", children: t6.map((r, n) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "div",
  {
    className: "mb-5 flex w-full items-center justify-between rounded-lg border-2 border-dashed border-gray-300 bg-gray-50 p-4 hover:bg-gray-100 dark:border-gray-600 dark:bg-gray-700 dark:hover:border-gray-500 dark:hover:bg-gray-600",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Cn,
          {
            classIm: "mr-3",
            src: "https://ftp.mathilde-ads.com/151-1dcc25481e8c72ed21c720c94adfdec6.svg",
            alt: "icon dropzone",
            width: 50
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "text-base font-semibold text-gray-700", children: r.name })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mx-4 flex items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "flex text-sm", children: B2(r.size) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          H2,
          {
            className: "ml-2 cursor-pointer text-4xl text-gray-400",
            onClick: () => e(r)
          }
        )
      ] })
    ]
  },
  n
)) }) }), QN = ({ description: t6 = "" }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center justify-center", children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    "img",
    {
      src: "https://ftp.mathilde-ads.com/151-82821df9d4f7bd2662418d3147880fba.svg",
      alt: t6.replace(/<[^>]*>/g, "")
    }
  ),
  t6 && /* @__PURE__ */ jsxRuntimeExports.jsx(
    "p",
    {
      className: "text-center",
      dangerouslySetInnerHTML: { __html: t6 }
    }
  )
] });
var Yp = {}, Oi = {}, Xl = { exports: {} };
var gl, Sh;
function od() {
  if (Sh) return gl;
  Sh = 1;
  var t6 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return gl = t6, gl;
}
var yl, Eh;
function G2() {
  if (Eh) return yl;
  Eh = 1;
  var t6 = od();
  function e() {
  }
  function r() {
  }
  return r.resetWarningCache = e, yl = function() {
    function n(s, o, l, c, d, u) {
      if (u !== t6) {
        var f = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw f.name = "Invariant Violation", f;
      }
    }
    n.isRequired = n;
    function a() {
      return n;
    }
    var i = {
      array: n,
      bigint: n,
      bool: n,
      func: n,
      number: n,
      object: n,
      string: n,
      symbol: n,
      any: n,
      arrayOf: a,
      element: n,
      elementType: n,
      instanceOf: a,
      node: n,
      objectOf: a,
      oneOf: a,
      oneOfType: a,
      shape: a,
      exact: a,
      checkPropTypes: r,
      resetWarningCache: e
    };
    return i.PropTypes = i, i;
  }, yl;
}
Xl.exports = G2()();
var Ar = Xl.exports, Si = {}, Rr = {};
const Up = 7, Vs = 365.2425, Di = 6048e5, Xp = 864e5, Nr = 6e4, Fn = 36e5, ld = 1e3, Th = 525600, Kn = 43200, qs = 1440, Gp = 60, Kp = 3, Qp = 12, Jp = 4, Co = 3600, cd = 60, dd = Co * 24, J2 = dd * 7, Zp = dd * Vs, eb = Zp / 12, Z2 = eb * 3, Ph = Symbol.for("constructDateFrom");
function se(t6, e) {
  return typeof t6 == "function" ? t6(e) : t6 && typeof t6 == "object" && Ph in t6 ? t6[Ph](e) : t6 instanceof Date ? new t6.constructor(e) : new Date(e);
}
function V$1(t6, e) {
  return se(e || t6, t6);
}
function Wt(t6, e, r) {
  const n = V$1(t6, r == null ? void 0 : r.in);
  return isNaN(e) ? se((r == null ? void 0 : r.in) || t6, NaN) : (e && n.setDate(n.getDate() + e), n);
}
function Mi(t6, e, r) {
  const n = V$1(t6, r == null ? void 0 : r.in);
  if (isNaN(e)) return se((r == null ? void 0 : r.in) || t6, NaN);
  if (!e)
    return n;
  const a = n.getDate(), i = se((r == null ? void 0 : r.in) || t6, n.getTime());
  i.setMonth(n.getMonth() + e + 1, 0);
  const s = i.getDate();
  return a >= s ? i : (n.setFullYear(
    i.getFullYear(),
    i.getMonth(),
    a
  ), n);
}
function Vn(t6, e, r) {
  const {
    years: n = 0,
    months: a = 0,
    weeks: i = 0,
    days: s = 0,
    hours: o = 0,
    minutes: l = 0,
    seconds: c = 0
  } = e, d = V$1(t6, r == null ? void 0 : r.in), u = a || n ? Mi(d, a + n * 12) : d, f = s || i ? Wt(u, s + i * 7) : u, h = l + o * 60, m = (c + h * 60) * 1e3;
  return se((r == null ? void 0 : r.in) || t6, +f + m);
}
function tb(t6, e) {
  return V$1(t6, e == null ? void 0 : e.in).getDay() === 6;
}
function rb(t6, e) {
  return V$1(t6, e == null ? void 0 : e.in).getDay() === 0;
}
function ea(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in).getDay();
  return r === 0 || r === 6;
}
function nb(t6, e, r) {
  const n = V$1(t6, r == null ? void 0 : r.in), a = ea(n, r);
  if (isNaN(e)) return se(r == null ? void 0 : r.in, NaN);
  const i = n.getHours(), s = e < 0 ? -1 : 1, o = Math.trunc(e / 5);
  n.setDate(n.getDate() + o * 7);
  let l = Math.abs(e % 5);
  for (; l > 0; )
    n.setDate(n.getDate() + s), ea(n, r) || (l -= 1);
  return a && ea(n, r) && e !== 0 && (tb(n, r) && n.setDate(n.getDate() + (s < 0 ? 2 : -1)), rb(n, r) && n.setDate(n.getDate() + (s < 0 ? 1 : -2))), n.setHours(i), n;
}
function Eo(t6, e, r) {
  return se((r == null ? void 0 : r.in) || t6, +V$1(t6) + e);
}
function ab(t6, e, r) {
  return Eo(t6, e * Fn, r);
}
let ib = {};
function vt() {
  return ib;
}
function eC(t6) {
  ib = t6;
}
function dt(t6, e) {
  var o, l, c, d;
  const r = vt(), n = (e == null ? void 0 : e.weekStartsOn) ?? ((l = (o = e == null ? void 0 : e.locale) == null ? void 0 : o.options) == null ? void 0 : l.weekStartsOn) ?? r.weekStartsOn ?? ((d = (c = r.locale) == null ? void 0 : c.options) == null ? void 0 : d.weekStartsOn) ?? 0, a = V$1(t6, e == null ? void 0 : e.in), i = a.getDay(), s = (i < n ? 7 : 0) + i - n;
  return a.setDate(a.getDate() - s), a.setHours(0, 0, 0, 0), a;
}
function Jt(t6, e) {
  return dt(t6, { ...e, weekStartsOn: 1 });
}
function Kr(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in), n = r.getFullYear(), a = se(r, 0);
  a.setFullYear(n + 1, 0, 4), a.setHours(0, 0, 0, 0);
  const i = Jt(a), s = se(r, 0);
  s.setFullYear(n, 0, 4), s.setHours(0, 0, 0, 0);
  const o = Jt(s);
  return r.getTime() >= i.getTime() ? n + 1 : r.getTime() >= o.getTime() ? n : n - 1;
}
function Ct(t6) {
  const e = V$1(t6), r = new Date(
    Date.UTC(
      e.getFullYear(),
      e.getMonth(),
      e.getDate(),
      e.getHours(),
      e.getMinutes(),
      e.getSeconds(),
      e.getMilliseconds()
    )
  );
  return r.setUTCFullYear(e.getFullYear()), +t6 - +r;
}
function Ee(t6, ...e) {
  const r = se.bind(
    null,
    t6 || e.find((n) => typeof n == "object")
  );
  return e.map(r);
}
function ua(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in);
  return r.setHours(0, 0, 0, 0), r;
}
function pr(t6, e, r) {
  const [n, a] = Ee(
    r == null ? void 0 : r.in,
    t6,
    e
  ), i = ua(n), s = ua(a), o = +i - Ct(i), l = +s - Ct(s);
  return Math.round((o - l) / Xp);
}
function Qr(t6, e) {
  const r = Kr(t6, e), n = se((e == null ? void 0 : e.in) || t6, 0);
  return n.setFullYear(r, 0, 4), n.setHours(0, 0, 0, 0), Jt(n);
}
function sb(t6, e, r) {
  let n = V$1(t6, r == null ? void 0 : r.in);
  const a = pr(
    n,
    Qr(n, r)
  ), i = se((r == null ? void 0 : r.in) || t6, 0);
  return i.setFullYear(e, 0, 4), i.setHours(0, 0, 0, 0), n = Qr(i), n.setDate(n.getDate() + a), n;
}
function ob(t6, e, r) {
  return sb(t6, Kr(t6, r) + e, r);
}
function ud(t6, e, r) {
  const n = V$1(t6, r == null ? void 0 : r.in);
  return n.setTime(n.getTime() + e * Nr), n;
}
function fd(t6, e, r) {
  return Mi(t6, e * 3, r);
}
function lb(t6, e, r) {
  return Eo(t6, e * 1e3, r);
}
function To(t6, e, r) {
  return Wt(t6, e * 7, r);
}
function cb(t6, e, r) {
  return Mi(t6, e * 12, r);
}
function tC(t6, e, r) {
  const [n, a] = [
    +V$1(t6.start, r == null ? void 0 : r.in),
    +V$1(t6.end, r == null ? void 0 : r.in)
  ].sort((o, l) => o - l), [i, s] = [
    +V$1(e.start, r == null ? void 0 : r.in),
    +V$1(e.end, r == null ? void 0 : r.in)
  ].sort((o, l) => o - l);
  return r != null && r.inclusive ? n <= s && i <= a : n < s && i < a;
}
function db(t6, e) {
  let r, n = e == null ? void 0 : e.in;
  return t6.forEach((a) => {
    !n && typeof a == "object" && (n = se.bind(null, a));
    const i = V$1(a, n);
    (!r || r < i || isNaN(+i)) && (r = i);
  }), se(n, r || NaN);
}
function ub(t6, e) {
  let r, n = e == null ? void 0 : e.in;
  return t6.forEach((a) => {
    !n && typeof a == "object" && (n = se.bind(null, a));
    const i = V$1(a, n);
    (!r || r > i || isNaN(+i)) && (r = i);
  }), se(n, r || NaN);
}
function rC(t6, e, r) {
  const [n, a, i] = Ee(
    r == null ? void 0 : r.in,
    t6,
    e.start,
    e.end
  );
  return ub([db([n, a], r), i], r);
}
function fb(t6, e) {
  const r = +V$1(t6);
  if (isNaN(r)) return NaN;
  let n, a;
  return e.forEach((i, s) => {
    const o = V$1(i);
    if (isNaN(+o)) {
      n = NaN, a = NaN;
      return;
    }
    const l = Math.abs(r - +o);
    (n == null || l < a) && (n = s, a = l);
  }), n;
}
function nC(t6, e, r) {
  const [n, ...a] = Ee(
    r == null ? void 0 : r.in,
    t6,
    ...e
  ), i = fb(n, a);
  if (typeof i == "number" && isNaN(i))
    return se(n, NaN);
  if (i !== void 0) return a[i];
}
function br(t6, e) {
  const r = +V$1(t6) - +V$1(e);
  return r < 0 ? -1 : r > 0 ? 1 : r;
}
function aC(t6, e) {
  const r = +V$1(t6) - +V$1(e);
  return r > 0 ? -1 : r < 0 ? 1 : r;
}
function Je(t6) {
  return se(t6, Date.now());
}
function iC(t6) {
  const e = Math.trunc(t6 / Up);
  return e === 0 ? 0 : e;
}
function Ci(t6, e, r) {
  const [n, a] = Ee(
    r == null ? void 0 : r.in,
    t6,
    e
  );
  return +ua(n) == +ua(a);
}
function hb(t6) {
  return t6 instanceof Date || typeof t6 == "object" && Object.prototype.toString.call(t6) === "[object Date]";
}
function Ir(t6) {
  return !(!hb(t6) && typeof t6 != "number" || isNaN(+V$1(t6)));
}
function sC(t6, e, r) {
  const [n, a] = Ee(
    r == null ? void 0 : r.in,
    t6,
    e
  );
  if (!Ir(n) || !Ir(a)) return NaN;
  const i = pr(n, a), s = i < 0 ? -1 : 1, o = Math.trunc(i / 7);
  let l = o * 5, c = Wt(a, o * 7);
  for (; !Ci(n, c); )
    l += ea(c, r) ? 0 : s, c = Wt(c, s);
  return l === 0 ? 0 : l;
}
function gb(t6, e, r) {
  const [n, a] = Ee(
    r == null ? void 0 : r.in,
    t6,
    e
  );
  return Kr(n, r) - Kr(a, r);
}
function oC(t6, e, r) {
  const [n, a] = Ee(
    r == null ? void 0 : r.in,
    t6,
    e
  ), i = Jt(n), s = Jt(a), o = +i - Ct(i), l = +s - Ct(s);
  return Math.round((o - l) / Di);
}
function Us(t6, e, r) {
  const [n, a] = Ee(
    r == null ? void 0 : r.in,
    t6,
    e
  ), i = n.getFullYear() - a.getFullYear(), s = n.getMonth() - a.getMonth();
  return i * 12 + s;
}
function Gl(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in);
  return Math.trunc(r.getMonth() / 3) + 1;
}
function gs(t6, e, r) {
  const [n, a] = Ee(
    r == null ? void 0 : r.in,
    t6,
    e
  ), i = n.getFullYear() - a.getFullYear(), s = Gl(n) - Gl(a);
  return i * 4 + s;
}
function Xs(t6, e, r) {
  const [n, a] = Ee(
    r == null ? void 0 : r.in,
    t6,
    e
  ), i = dt(n, r), s = dt(a, r), o = +i - Ct(i), l = +s - Ct(s);
  return Math.round((o - l) / Di);
}
function Za(t6, e, r) {
  const [n, a] = Ee(
    r == null ? void 0 : r.in,
    t6,
    e
  );
  return n.getFullYear() - a.getFullYear();
}
function hd(t6, e, r) {
  const [n, a] = Ee(
    r == null ? void 0 : r.in,
    t6,
    e
  ), i = Rh(n, a), s = Math.abs(
    pr(n, a)
  );
  n.setDate(n.getDate() - i * s);
  const o = +(Rh(n, a) === -i), l = i * (s - o);
  return l === 0 ? 0 : l;
}
function Rh(t6, e) {
  const r = t6.getFullYear() - e.getFullYear() || t6.getMonth() - e.getMonth() || t6.getDate() - e.getDate() || t6.getHours() - e.getHours() || t6.getMinutes() - e.getMinutes() || t6.getSeconds() - e.getSeconds() || t6.getMilliseconds() - e.getMilliseconds();
  return r < 0 ? -1 : r > 0 ? 1 : r;
}
function tn(t6) {
  return (e) => {
    const n = (t6 ? Math[t6] : Math.trunc)(e);
    return n === 0 ? 0 : n;
  };
}
function Gs(t6, e, r) {
  const [n, a] = Ee(
    r == null ? void 0 : r.in,
    t6,
    e
  ), i = (+n - +a) / Fn;
  return tn(r == null ? void 0 : r.roundingMethod)(i);
}
function mb(t6, e, r) {
  return ob(t6, -e, r);
}
function lC(t6, e, r) {
  const [n, a] = Ee(
    r == null ? void 0 : r.in,
    t6,
    e
  ), i = br(n, a), s = Math.abs(
    gb(n, a, r)
  ), o = mb(n, i * s, r), l = +(br(o, a) === -i), c = i * (s - l);
  return c === 0 ? 0 : c;
}
function gd(t6, e) {
  return +V$1(t6) - +V$1(e);
}
function Ks(t6, e, r) {
  const n = gd(t6, e) / Nr;
  return tn(r == null ? void 0 : r.roundingMethod)(n);
}
function md(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in);
  return r.setHours(23, 59, 59, 999), r;
}
function pd(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in), n = r.getMonth();
  return r.setFullYear(r.getFullYear(), n + 1, 0), r.setHours(23, 59, 59, 999), r;
}
function pb(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in);
  return +md(r, e) == +pd(r, e);
}
function Po(t6, e, r) {
  const [n, a, i] = Ee(
    r == null ? void 0 : r.in,
    t6,
    t6,
    e
  ), s = br(a, i), o = Math.abs(
    Us(a, i)
  );
  if (o < 1) return 0;
  a.getMonth() === 1 && a.getDate() > 27 && a.setDate(30), a.setMonth(a.getMonth() - s * o);
  let l = br(a, i) === -s;
  pb(n) && o === 1 && br(n, i) === 1 && (l = false);
  const c = s * (o - +l);
  return c === 0 ? 0 : c;
}
function cC(t6, e, r) {
  const n = Po(t6, e, r) / 3;
  return tn(r == null ? void 0 : r.roundingMethod)(n);
}
function ta(t6, e, r) {
  const n = gd(t6, e) / 1e3;
  return tn(r == null ? void 0 : r.roundingMethod)(n);
}
function dC(t6, e, r) {
  const n = hd(t6, e, r) / 7;
  return tn(r == null ? void 0 : r.roundingMethod)(n);
}
function bb(t6, e, r) {
  const [n, a] = Ee(
    r == null ? void 0 : r.in,
    t6,
    e
  ), i = br(n, a), s = Math.abs(Za(n, a));
  n.setFullYear(1584), a.setFullYear(1584);
  const o = br(n, a) === -i, l = i * (s - +o);
  return l === 0 ? 0 : l;
}
function Fr(t6, e) {
  const [r, n] = Ee(t6, e.start, e.end);
  return { start: r, end: n };
}
function yb(t6, e) {
  const { start: r, end: n } = Fr(e == null ? void 0 : e.in, t6);
  let a = +r > +n;
  const i = a ? +r : +n, s = a ? n : r;
  s.setHours(0, 0, 0, 0);
  let o = (e == null ? void 0 : e.step) ?? 1;
  if (!o) return [];
  o < 0 && (o = -o, a = !a);
  const l = [];
  for (; +s <= i; )
    l.push(se(r, s)), s.setDate(s.getDate() + o), s.setHours(0, 0, 0, 0);
  return a ? l.reverse() : l;
}
function uC(t6, e) {
  const { start: r, end: n } = Fr(e == null ? void 0 : e.in, t6);
  let a = +r > +n;
  const i = a ? +r : +n, s = a ? n : r;
  s.setMinutes(0, 0, 0);
  let o = (e == null ? void 0 : e.step) ?? 1;
  if (!o) return [];
  o < 0 && (o = -o, a = !a);
  const l = [];
  for (; +s <= i; )
    l.push(se(r, s)), s.setHours(s.getHours() + o);
  return a ? l.reverse() : l;
}
function fC(t6, e) {
  const { start: r, end: n } = Fr(e == null ? void 0 : e.in, t6);
  r.setSeconds(0, 0);
  let a = +r > +n;
  const i = a ? +r : +n;
  let s = a ? n : r, o = (e == null ? void 0 : e.step) ?? 1;
  if (!o) return [];
  o < 0 && (o = -o, a = !a);
  const l = [];
  for (; +s <= i; )
    l.push(se(r, s)), s = ud(s, o);
  return a ? l.reverse() : l;
}
function hC(t6, e) {
  const { start: r, end: n } = Fr(e == null ? void 0 : e.in, t6);
  let a = +r > +n;
  const i = a ? +r : +n, s = a ? n : r;
  s.setHours(0, 0, 0, 0), s.setDate(1);
  let o = (e == null ? void 0 : e.step) ?? 1;
  if (!o) return [];
  o < 0 && (o = -o, a = !a);
  const l = [];
  for (; +s <= i; )
    l.push(se(r, s)), s.setMonth(s.getMonth() + o);
  return a ? l.reverse() : l;
}
function kn(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in), n = r.getMonth(), a = n - n % 3;
  return r.setMonth(a, 1), r.setHours(0, 0, 0, 0), r;
}
function gC(t6, e) {
  const { start: r, end: n } = Fr(e == null ? void 0 : e.in, t6);
  let a = +r > +n;
  const i = a ? +kn(r) : +kn(n);
  let s = kn(a ? n : r), o = (e == null ? void 0 : e.step) ?? 1;
  if (!o) return [];
  o < 0 && (o = -o, a = !a);
  const l = [];
  for (; +s <= i; )
    l.push(se(r, s)), s = fd(s, o);
  return a ? l.reverse() : l;
}
function mC(t6, e) {
  const { start: r, end: n } = Fr(e == null ? void 0 : e.in, t6);
  let a = +r > +n;
  const i = dt(a ? n : r, e), s = dt(a ? r : n, e);
  i.setHours(15), s.setHours(15);
  const o = +s.getTime();
  let l = i, c = (e == null ? void 0 : e.step) ?? 1;
  if (!c) return [];
  c < 0 && (c = -c, a = !a);
  const d = [];
  for (; +l <= o; )
    l.setHours(0), d.push(se(r, l)), l = To(l, c), l.setHours(15);
  return a ? d.reverse() : d;
}
function bd(t6, e) {
  const { start: r, end: n } = Fr(e == null ? void 0 : e.in, t6), a = yb({ start: r, end: n }, e), i = [];
  let s = 0;
  for (; s < a.length; ) {
    const o = a[s++];
    ea(o) && i.push(se(r, o));
  }
  return i;
}
function Ro(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in);
  return r.setDate(1), r.setHours(0, 0, 0, 0), r;
}
function pC(t6, e) {
  const r = Ro(t6, e), n = pd(t6, e);
  return bd({ start: r, end: n }, e);
}
function vb(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in), n = r.getFullYear();
  return r.setFullYear(n + 1, 0, 0), r.setHours(23, 59, 59, 999), r;
}
function yd(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in);
  return r.setFullYear(r.getFullYear(), 0, 1), r.setHours(0, 0, 0, 0), r;
}
function bC(t6, e) {
  const r = yd(t6, e), n = vb(t6, e);
  return bd({ start: r, end: n }, e);
}
function yC(t6, e) {
  const { start: r, end: n } = Fr(e == null ? void 0 : e.in, t6);
  let a = +r > +n;
  const i = a ? +r : +n, s = a ? n : r;
  s.setHours(0, 0, 0, 0), s.setMonth(0, 1);
  let o = (e == null ? void 0 : e.step) ?? 1;
  if (!o) return [];
  o < 0 && (o = -o, a = !a);
  const l = [];
  for (; +s <= i; )
    l.push(se(r, s)), s.setFullYear(s.getFullYear() + o);
  return a ? l.reverse() : l;
}
function vC(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in), n = r.getFullYear(), a = 9 + Math.floor(n / 10) * 10;
  return r.setFullYear(a, 11, 31), r.setHours(23, 59, 59, 999), r;
}
function xC(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in);
  return r.setMinutes(59, 59, 999), r;
}
function xb(t6, e) {
  var o, l, c, d;
  const r = vt(), n = (e == null ? void 0 : e.weekStartsOn) ?? ((l = (o = e == null ? void 0 : e.locale) == null ? void 0 : o.options) == null ? void 0 : l.weekStartsOn) ?? r.weekStartsOn ?? ((d = (c = r.locale) == null ? void 0 : c.options) == null ? void 0 : d.weekStartsOn) ?? 0, a = V$1(t6, e == null ? void 0 : e.in), i = a.getDay(), s = (i < n ? -7 : 0) + 6 - (i - n);
  return a.setDate(a.getDate() + s), a.setHours(23, 59, 59, 999), a;
}
function wC(t6, e) {
  return xb(t6, { ...e, weekStartsOn: 1 });
}
function kC(t6, e) {
  const r = Kr(t6, e), n = se((e == null ? void 0 : e.in) || t6, 0);
  n.setFullYear(r + 1, 0, 4), n.setHours(0, 0, 0, 0);
  const a = Jt(n, e);
  return a.setMilliseconds(a.getMilliseconds() - 1), a;
}
function _C(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in);
  return r.setSeconds(59, 999), r;
}
function OC(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in), n = r.getMonth(), a = n - n % 3 + 3;
  return r.setMonth(a, 0), r.setHours(23, 59, 59, 999), r;
}
function SC(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in);
  return r.setMilliseconds(999), r;
}
function DC(t6) {
  return md(Date.now(), t6);
}
function MC(t6) {
  const e = Je(t6 == null ? void 0 : t6.in), r = e.getFullYear(), n = e.getMonth(), a = e.getDate(), i = Je(t6 == null ? void 0 : t6.in);
  return i.setFullYear(r, n, a + 1), i.setHours(23, 59, 59, 999), t6 != null && t6.in ? t6.in(i) : i;
}
function CC(t6) {
  const e = Je(t6 == null ? void 0 : t6.in), r = se(t6 == null ? void 0 : t6.in, 0);
  return r.setFullYear(e.getFullYear(), e.getMonth(), e.getDate() - 1), r.setHours(23, 59, 59, 999), r;
}
const EC = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
}, TC = (t6, e, r) => {
  let n;
  const a = EC[t6];
  return typeof a == "string" ? n = a : e === 1 ? n = a.one : n = a.other.replace("{{count}}", e.toString()), r != null && r.addSuffix ? r.comparison && r.comparison > 0 ? "in " + n : n + " ago" : n;
};
function vl(t6) {
  return (e = {}) => {
    const r = e.width ? String(e.width) : t6.defaultWidth;
    return t6.formats[r] || t6.formats[t6.defaultWidth];
  };
}
const PC = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
}, RC = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
}, NC = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
}, IC = {
  date: vl({
    formats: PC,
    defaultWidth: "full"
  }),
  time: vl({
    formats: RC,
    defaultWidth: "full"
  }),
  dateTime: vl({
    formats: NC,
    defaultWidth: "full"
  })
}, AC = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
}, FC = (t6, e, r, n) => AC[t6];
function Ta(t6) {
  return (e, r) => {
    const n = r != null && r.context ? String(r.context) : "standalone";
    let a;
    if (n === "formatting" && t6.formattingValues) {
      const s = t6.defaultFormattingWidth || t6.defaultWidth, o = r != null && r.width ? String(r.width) : s;
      a = t6.formattingValues[o] || t6.formattingValues[s];
    } else {
      const s = t6.defaultWidth, o = r != null && r.width ? String(r.width) : t6.defaultWidth;
      a = t6.values[o] || t6.values[s];
    }
    const i = t6.argumentCallback ? t6.argumentCallback(e) : e;
    return a[i];
  };
}
const LC = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
}, WC = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
}, $C = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
}, zC = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
}, jC = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
}, HC = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
}, BC = (t6, e) => {
  const r = Number(t6), n = r % 100;
  if (n > 20 || n < 10)
    switch (n % 10) {
      case 1:
        return r + "st";
      case 2:
        return r + "nd";
      case 3:
        return r + "rd";
    }
  return r + "th";
}, YC = {
  ordinalNumber: BC,
  era: Ta({
    values: LC,
    defaultWidth: "wide"
  }),
  quarter: Ta({
    values: WC,
    defaultWidth: "wide",
    argumentCallback: (t6) => t6 - 1
  }),
  month: Ta({
    values: $C,
    defaultWidth: "wide"
  }),
  day: Ta({
    values: zC,
    defaultWidth: "wide"
  }),
  dayPeriod: Ta({
    values: jC,
    defaultWidth: "wide",
    formattingValues: HC,
    defaultFormattingWidth: "wide"
  })
};
function Pa(t6) {
  return (e, r = {}) => {
    const n = r.width, a = n && t6.matchPatterns[n] || t6.matchPatterns[t6.defaultMatchWidth], i = e.match(a);
    if (!i)
      return null;
    const s = i[0], o = n && t6.parsePatterns[n] || t6.parsePatterns[t6.defaultParseWidth], l = Array.isArray(o) ? qC(o, (u) => u.test(s)) : (
      // [TODO] -- I challenge you to fix the type
      VC(o, (u) => u.test(s))
    );
    let c;
    c = t6.valueCallback ? t6.valueCallback(l) : l, c = r.valueCallback ? (
      // [TODO] -- I challenge you to fix the type
      r.valueCallback(c)
    ) : c;
    const d = e.slice(s.length);
    return { value: c, rest: d };
  };
}
function VC(t6, e) {
  for (const r in t6)
    if (Object.prototype.hasOwnProperty.call(t6, r) && e(t6[r]))
      return r;
}
function qC(t6, e) {
  for (let r = 0; r < t6.length; r++)
    if (e(t6[r]))
      return r;
}
function UC(t6) {
  return (e, r = {}) => {
    const n = e.match(t6.matchPattern);
    if (!n) return null;
    const a = n[0], i = e.match(t6.parsePattern);
    if (!i) return null;
    let s = t6.valueCallback ? t6.valueCallback(i[0]) : i[0];
    s = r.valueCallback ? r.valueCallback(s) : s;
    const o = e.slice(a.length);
    return { value: s, rest: o };
  };
}
const XC = /^(\d+)(th|st|nd|rd)?/i, GC = /\d+/i, KC = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
}, QC = {
  any: [/^b/i, /^(a|c)/i]
}, JC = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
}, ZC = {
  any: [/1/i, /2/i, /3/i, /4/i]
}, eE = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
}, tE = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
}, rE = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
}, nE = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
}, aE = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
}, iE = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
}, sE = {
  ordinalNumber: UC({
    matchPattern: XC,
    parsePattern: GC,
    valueCallback: (t6) => parseInt(t6, 10)
  }),
  era: Pa({
    matchPatterns: KC,
    defaultMatchWidth: "wide",
    parsePatterns: QC,
    defaultParseWidth: "any"
  }),
  quarter: Pa({
    matchPatterns: JC,
    defaultMatchWidth: "wide",
    parsePatterns: ZC,
    defaultParseWidth: "any",
    valueCallback: (t6) => t6 + 1
  }),
  month: Pa({
    matchPatterns: eE,
    defaultMatchWidth: "wide",
    parsePatterns: tE,
    defaultParseWidth: "any"
  }),
  day: Pa({
    matchPatterns: rE,
    defaultMatchWidth: "wide",
    parsePatterns: nE,
    defaultParseWidth: "any"
  }),
  dayPeriod: Pa({
    matchPatterns: aE,
    defaultMatchWidth: "any",
    parsePatterns: iE,
    defaultParseWidth: "any"
  })
}, va = {
  code: "en-US",
  formatDistance: TC,
  formatLong: IC,
  formatRelative: FC,
  localize: YC,
  match: sE,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
function wb(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in);
  return pr(r, yd(r)) + 1;
}
function vd(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in), n = +Jt(r) - +Qr(r);
  return Math.round(n / Di) + 1;
}
function No(t6, e) {
  var d, u, f, h;
  const r = V$1(t6, e == null ? void 0 : e.in), n = r.getFullYear(), a = vt(), i = (e == null ? void 0 : e.firstWeekContainsDate) ?? ((u = (d = e == null ? void 0 : e.locale) == null ? void 0 : d.options) == null ? void 0 : u.firstWeekContainsDate) ?? a.firstWeekContainsDate ?? ((h = (f = a.locale) == null ? void 0 : f.options) == null ? void 0 : h.firstWeekContainsDate) ?? 1, s = se((e == null ? void 0 : e.in) || t6, 0);
  s.setFullYear(n + 1, 0, i), s.setHours(0, 0, 0, 0);
  const o = dt(s, e), l = se((e == null ? void 0 : e.in) || t6, 0);
  l.setFullYear(n, 0, i), l.setHours(0, 0, 0, 0);
  const c = dt(l, e);
  return +r >= +o ? n + 1 : +r >= +c ? n : n - 1;
}
function Qs(t6, e) {
  var o, l, c, d;
  const r = vt(), n = (e == null ? void 0 : e.firstWeekContainsDate) ?? ((l = (o = e == null ? void 0 : e.locale) == null ? void 0 : o.options) == null ? void 0 : l.firstWeekContainsDate) ?? r.firstWeekContainsDate ?? ((d = (c = r.locale) == null ? void 0 : c.options) == null ? void 0 : d.firstWeekContainsDate) ?? 1, a = No(t6, e), i = se((e == null ? void 0 : e.in) || t6, 0);
  return i.setFullYear(a, 0, n), i.setHours(0, 0, 0, 0), dt(i, e);
}
function xd(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in), n = +dt(r, e) - +Qs(r, e);
  return Math.round(n / Di) + 1;
}
function oe(t6, e) {
  const r = t6 < 0 ? "-" : "", n = Math.abs(t6).toString().padStart(e, "0");
  return r + n;
}
const ir = {
  // Year
  y(t6, e) {
    const r = t6.getFullYear(), n = r > 0 ? r : 1 - r;
    return oe(e === "yy" ? n % 100 : n, e.length);
  },
  // Month
  M(t6, e) {
    const r = t6.getMonth();
    return e === "M" ? String(r + 1) : oe(r + 1, 2);
  },
  // Day of the month
  d(t6, e) {
    return oe(t6.getDate(), e.length);
  },
  // AM or PM
  a(t6, e) {
    const r = t6.getHours() / 12 >= 1 ? "pm" : "am";
    switch (e) {
      case "a":
      case "aa":
        return r.toUpperCase();
      case "aaa":
        return r;
      case "aaaaa":
        return r[0];
      case "aaaa":
      default:
        return r === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h(t6, e) {
    return oe(t6.getHours() % 12 || 12, e.length);
  },
  // Hour [0-23]
  H(t6, e) {
    return oe(t6.getHours(), e.length);
  },
  // Minute
  m(t6, e) {
    return oe(t6.getMinutes(), e.length);
  },
  // Second
  s(t6, e) {
    return oe(t6.getSeconds(), e.length);
  },
  // Fraction of second
  S(t6, e) {
    const r = e.length, n = t6.getMilliseconds(), a = Math.trunc(
      n * Math.pow(10, r - 3)
    );
    return oe(a, e.length);
  }
}, Bn = {
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
}, Kl = {
  // Era
  G: function(t6, e, r) {
    const n = t6.getFullYear() > 0 ? 1 : 0;
    switch (e) {
      case "G":
      case "GG":
      case "GGG":
        return r.era(n, { width: "abbreviated" });
      case "GGGGG":
        return r.era(n, { width: "narrow" });
      case "GGGG":
      default:
        return r.era(n, { width: "wide" });
    }
  },
  // Year
  y: function(t6, e, r) {
    if (e === "yo") {
      const n = t6.getFullYear(), a = n > 0 ? n : 1 - n;
      return r.ordinalNumber(a, { unit: "year" });
    }
    return ir.y(t6, e);
  },
  // Local week-numbering year
  Y: function(t6, e, r, n) {
    const a = No(t6, n), i = a > 0 ? a : 1 - a;
    if (e === "YY") {
      const s = i % 100;
      return oe(s, 2);
    }
    return e === "Yo" ? r.ordinalNumber(i, { unit: "year" }) : oe(i, e.length);
  },
  // ISO week-numbering year
  R: function(t6, e) {
    const r = Kr(t6);
    return oe(r, e.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(t6, e) {
    const r = t6.getFullYear();
    return oe(r, e.length);
  },
  // Quarter
  Q: function(t6, e, r) {
    const n = Math.ceil((t6.getMonth() + 1) / 3);
    switch (e) {
      case "Q":
        return String(n);
      case "QQ":
        return oe(n, 2);
      case "Qo":
        return r.ordinalNumber(n, { unit: "quarter" });
      case "QQQ":
        return r.quarter(n, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return r.quarter(n, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return r.quarter(n, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(t6, e, r) {
    const n = Math.ceil((t6.getMonth() + 1) / 3);
    switch (e) {
      case "q":
        return String(n);
      case "qq":
        return oe(n, 2);
      case "qo":
        return r.ordinalNumber(n, { unit: "quarter" });
      case "qqq":
        return r.quarter(n, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return r.quarter(n, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return r.quarter(n, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(t6, e, r) {
    const n = t6.getMonth();
    switch (e) {
      case "M":
      case "MM":
        return ir.M(t6, e);
      case "Mo":
        return r.ordinalNumber(n + 1, { unit: "month" });
      case "MMM":
        return r.month(n, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return r.month(n, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return r.month(n, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone month
  L: function(t6, e, r) {
    const n = t6.getMonth();
    switch (e) {
      case "L":
        return String(n + 1);
      case "LL":
        return oe(n + 1, 2);
      case "Lo":
        return r.ordinalNumber(n + 1, { unit: "month" });
      case "LLL":
        return r.month(n, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return r.month(n, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return r.month(n, { width: "wide", context: "standalone" });
    }
  },
  // Local week of year
  w: function(t6, e, r, n) {
    const a = xd(t6, n);
    return e === "wo" ? r.ordinalNumber(a, { unit: "week" }) : oe(a, e.length);
  },
  // ISO week of year
  I: function(t6, e, r) {
    const n = vd(t6);
    return e === "Io" ? r.ordinalNumber(n, { unit: "week" }) : oe(n, e.length);
  },
  // Day of the month
  d: function(t6, e, r) {
    return e === "do" ? r.ordinalNumber(t6.getDate(), { unit: "date" }) : ir.d(t6, e);
  },
  // Day of year
  D: function(t6, e, r) {
    const n = wb(t6);
    return e === "Do" ? r.ordinalNumber(n, { unit: "dayOfYear" }) : oe(n, e.length);
  },
  // Day of week
  E: function(t6, e, r) {
    const n = t6.getDay();
    switch (e) {
      case "E":
      case "EE":
      case "EEE":
        return r.day(n, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return r.day(n, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return r.day(n, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return r.day(n, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(t6, e, r, n) {
    const a = t6.getDay(), i = (a - n.weekStartsOn + 8) % 7 || 7;
    switch (e) {
      case "e":
        return String(i);
      case "ee":
        return oe(i, 2);
      case "eo":
        return r.ordinalNumber(i, { unit: "day" });
      case "eee":
        return r.day(a, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return r.day(a, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return r.day(a, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return r.day(a, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(t6, e, r, n) {
    const a = t6.getDay(), i = (a - n.weekStartsOn + 8) % 7 || 7;
    switch (e) {
      case "c":
        return String(i);
      case "cc":
        return oe(i, e.length);
      case "co":
        return r.ordinalNumber(i, { unit: "day" });
      case "ccc":
        return r.day(a, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return r.day(a, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return r.day(a, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return r.day(a, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(t6, e, r) {
    const n = t6.getDay(), a = n === 0 ? 7 : n;
    switch (e) {
      case "i":
        return String(a);
      case "ii":
        return oe(a, e.length);
      case "io":
        return r.ordinalNumber(a, { unit: "day" });
      case "iii":
        return r.day(n, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return r.day(n, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return r.day(n, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return r.day(n, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(t6, e, r) {
    const a = t6.getHours() / 12 >= 1 ? "pm" : "am";
    switch (e) {
      case "a":
      case "aa":
        return r.dayPeriod(a, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return r.dayPeriod(a, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return r.dayPeriod(a, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return r.dayPeriod(a, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(t6, e, r) {
    const n = t6.getHours();
    let a;
    switch (n === 12 ? a = Bn.noon : n === 0 ? a = Bn.midnight : a = n / 12 >= 1 ? "pm" : "am", e) {
      case "b":
      case "bb":
        return r.dayPeriod(a, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return r.dayPeriod(a, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return r.dayPeriod(a, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return r.dayPeriod(a, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(t6, e, r) {
    const n = t6.getHours();
    let a;
    switch (n >= 17 ? a = Bn.evening : n >= 12 ? a = Bn.afternoon : n >= 4 ? a = Bn.morning : a = Bn.night, e) {
      case "B":
      case "BB":
      case "BBB":
        return r.dayPeriod(a, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return r.dayPeriod(a, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return r.dayPeriod(a, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(t6, e, r) {
    if (e === "ho") {
      let n = t6.getHours() % 12;
      return n === 0 && (n = 12), r.ordinalNumber(n, { unit: "hour" });
    }
    return ir.h(t6, e);
  },
  // Hour [0-23]
  H: function(t6, e, r) {
    return e === "Ho" ? r.ordinalNumber(t6.getHours(), { unit: "hour" }) : ir.H(t6, e);
  },
  // Hour [0-11]
  K: function(t6, e, r) {
    const n = t6.getHours() % 12;
    return e === "Ko" ? r.ordinalNumber(n, { unit: "hour" }) : oe(n, e.length);
  },
  // Hour [1-24]
  k: function(t6, e, r) {
    let n = t6.getHours();
    return n === 0 && (n = 24), e === "ko" ? r.ordinalNumber(n, { unit: "hour" }) : oe(n, e.length);
  },
  // Minute
  m: function(t6, e, r) {
    return e === "mo" ? r.ordinalNumber(t6.getMinutes(), { unit: "minute" }) : ir.m(t6, e);
  },
  // Second
  s: function(t6, e, r) {
    return e === "so" ? r.ordinalNumber(t6.getSeconds(), { unit: "second" }) : ir.s(t6, e);
  },
  // Fraction of second
  S: function(t6, e) {
    return ir.S(t6, e);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(t6, e, r) {
    const n = t6.getTimezoneOffset();
    if (n === 0)
      return "Z";
    switch (e) {
      case "X":
        return Ih(n);
      case "XXXX":
      case "XX":
        return bn(n);
      case "XXXXX":
      case "XXX":
      default:
        return bn(n, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(t6, e, r) {
    const n = t6.getTimezoneOffset();
    switch (e) {
      case "x":
        return Ih(n);
      case "xxxx":
      case "xx":
        return bn(n);
      case "xxxxx":
      case "xxx":
      default:
        return bn(n, ":");
    }
  },
  // Timezone (GMT)
  O: function(t6, e, r) {
    const n = t6.getTimezoneOffset();
    switch (e) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + Nh(n, ":");
      case "OOOO":
      default:
        return "GMT" + bn(n, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(t6, e, r) {
    const n = t6.getTimezoneOffset();
    switch (e) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + Nh(n, ":");
      case "zzzz":
      default:
        return "GMT" + bn(n, ":");
    }
  },
  // Seconds timestamp
  t: function(t6, e, r) {
    const n = Math.trunc(+t6 / 1e3);
    return oe(n, e.length);
  },
  // Milliseconds timestamp
  T: function(t6, e, r) {
    return oe(+t6, e.length);
  }
};
function Nh(t6, e = "") {
  const r = t6 > 0 ? "-" : "+", n = Math.abs(t6), a = Math.trunc(n / 60), i = n % 60;
  return i === 0 ? r + String(a) : r + String(a) + e + oe(i, 2);
}
function Ih(t6, e) {
  return t6 % 60 === 0 ? (t6 > 0 ? "-" : "+") + oe(Math.abs(t6) / 60, 2) : bn(t6, e);
}
function bn(t6, e = "") {
  const r = t6 > 0 ? "-" : "+", n = Math.abs(t6), a = oe(Math.trunc(n / 60), 2), i = oe(n % 60, 2);
  return r + a + e + i;
}
const Ah = (t6, e) => {
  switch (t6) {
    case "P":
      return e.date({ width: "short" });
    case "PP":
      return e.date({ width: "medium" });
    case "PPP":
      return e.date({ width: "long" });
    case "PPPP":
    default:
      return e.date({ width: "full" });
  }
}, kb = (t6, e) => {
  switch (t6) {
    case "p":
      return e.time({ width: "short" });
    case "pp":
      return e.time({ width: "medium" });
    case "ppp":
      return e.time({ width: "long" });
    case "pppp":
    default:
      return e.time({ width: "full" });
  }
}, oE = (t6, e) => {
  const r = t6.match(/(P+)(p+)?/) || [], n = r[1], a = r[2];
  if (!a)
    return Ah(t6, e);
  let i;
  switch (n) {
    case "P":
      i = e.dateTime({ width: "short" });
      break;
    case "PP":
      i = e.dateTime({ width: "medium" });
      break;
    case "PPP":
      i = e.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      i = e.dateTime({ width: "full" });
      break;
  }
  return i.replace("{{date}}", Ah(n, e)).replace("{{time}}", kb(a, e));
}, Js = {
  p: kb,
  P: oE
}, lE = /^D+$/, cE = /^Y+$/, dE = ["D", "DD", "YY", "YYYY"];
function _b(t6) {
  return lE.test(t6);
}
function Ob(t6) {
  return cE.test(t6);
}
function Ql(t6, e, r) {
  const n = uE(t6, e, r);
  if (console.warn(n), dE.includes(t6)) throw new RangeError(n);
}
function uE(t6, e, r) {
  const n = t6[0] === "Y" ? "years" : "days of the month";
  return `Use \`${t6.toLowerCase()}\` instead of \`${t6}\` (in \`${e}\`) for formatting ${n} to the input \`${r}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}
const fE = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, hE = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, gE = /^'([^]*?)'?$/, mE = /''/g, pE = /[a-zA-Z]/;
function Zs(t6, e, r) {
  var d, u, f, h, g, m, p, w;
  const n = vt(), a = (r == null ? void 0 : r.locale) ?? n.locale ?? va, i = (r == null ? void 0 : r.firstWeekContainsDate) ?? ((u = (d = r == null ? void 0 : r.locale) == null ? void 0 : d.options) == null ? void 0 : u.firstWeekContainsDate) ?? n.firstWeekContainsDate ?? ((h = (f = n.locale) == null ? void 0 : f.options) == null ? void 0 : h.firstWeekContainsDate) ?? 1, s = (r == null ? void 0 : r.weekStartsOn) ?? ((m = (g = r == null ? void 0 : r.locale) == null ? void 0 : g.options) == null ? void 0 : m.weekStartsOn) ?? n.weekStartsOn ?? ((w = (p = n.locale) == null ? void 0 : p.options) == null ? void 0 : w.weekStartsOn) ?? 0, o = V$1(t6, r == null ? void 0 : r.in);
  if (!Ir(o))
    throw new RangeError("Invalid time value");
  let l = e.match(hE).map((b) => {
    const k = b[0];
    if (k === "p" || k === "P") {
      const v = Js[k];
      return v(b, a.formatLong);
    }
    return b;
  }).join("").match(fE).map((b) => {
    if (b === "''")
      return { isToken: false, value: "'" };
    const k = b[0];
    if (k === "'")
      return { isToken: false, value: bE(b) };
    if (Kl[k])
      return { isToken: true, value: b };
    if (k.match(pE))
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + k + "`"
      );
    return { isToken: false, value: b };
  });
  a.localize.preprocessor && (l = a.localize.preprocessor(o, l));
  const c = {
    firstWeekContainsDate: i,
    weekStartsOn: s,
    locale: a
  };
  return l.map((b) => {
    if (!b.isToken) return b.value;
    const k = b.value;
    (!(r != null && r.useAdditionalWeekYearTokens) && Ob(k) || !(r != null && r.useAdditionalDayOfYearTokens) && _b(k)) && Ql(k, e, String(t6));
    const v = Kl[k[0]];
    return v(o, k, a.localize, c);
  }).join("");
}
function bE(t6) {
  const e = t6.match(gE);
  return e ? e[1].replace(mE, "'") : t6;
}
function Sb(t6, e, r) {
  const n = vt(), a = (r == null ? void 0 : r.locale) ?? n.locale ?? va, i = 2520, s = br(t6, e);
  if (isNaN(s)) throw new RangeError("Invalid time value");
  const o = Object.assign({}, r, {
    addSuffix: r == null ? void 0 : r.addSuffix,
    comparison: s
  }), [l, c] = Ee(
    r == null ? void 0 : r.in,
    ...s > 0 ? [e, t6] : [t6, e]
  ), d = ta(c, l), u = (Ct(c) - Ct(l)) / 1e3, f = Math.round((d - u) / 60);
  let h;
  if (f < 2)
    return r != null && r.includeSeconds ? d < 5 ? a.formatDistance("lessThanXSeconds", 5, o) : d < 10 ? a.formatDistance("lessThanXSeconds", 10, o) : d < 20 ? a.formatDistance("lessThanXSeconds", 20, o) : d < 40 ? a.formatDistance("halfAMinute", 0, o) : d < 60 ? a.formatDistance("lessThanXMinutes", 1, o) : a.formatDistance("xMinutes", 1, o) : f === 0 ? a.formatDistance("lessThanXMinutes", 1, o) : a.formatDistance("xMinutes", f, o);
  if (f < 45)
    return a.formatDistance("xMinutes", f, o);
  if (f < 90)
    return a.formatDistance("aboutXHours", 1, o);
  if (f < qs) {
    const g = Math.round(f / 60);
    return a.formatDistance("aboutXHours", g, o);
  } else {
    if (f < i)
      return a.formatDistance("xDays", 1, o);
    if (f < Kn) {
      const g = Math.round(f / qs);
      return a.formatDistance("xDays", g, o);
    } else if (f < Kn * 2)
      return h = Math.round(f / Kn), a.formatDistance("aboutXMonths", h, o);
  }
  if (h = Po(c, l), h < 12) {
    const g = Math.round(f / Kn);
    return a.formatDistance("xMonths", g, o);
  } else {
    const g = h % 12, m = Math.trunc(h / 12);
    return g < 3 ? a.formatDistance("aboutXYears", m, o) : g < 9 ? a.formatDistance("overXYears", m, o) : a.formatDistance("almostXYears", m + 1, o);
  }
}
function Db(t6, e, r) {
  const n = vt(), a = (r == null ? void 0 : r.locale) ?? n.locale ?? va, i = br(t6, e);
  if (isNaN(i))
    throw new RangeError("Invalid time value");
  const s = Object.assign({}, r, {
    addSuffix: r == null ? void 0 : r.addSuffix,
    comparison: i
  }), [o, l] = Ee(
    r == null ? void 0 : r.in,
    ...i > 0 ? [e, t6] : [t6, e]
  ), c = tn((r == null ? void 0 : r.roundingMethod) ?? "round"), d = l.getTime() - o.getTime(), u = d / Nr, f = Ct(l) - Ct(o), h = (d - f) / Nr, g = r == null ? void 0 : r.unit;
  let m;
  if (g ? m = g : u < 1 ? m = "second" : u < 60 ? m = "minute" : u < qs ? m = "hour" : h < Kn ? m = "day" : h < Th ? m = "month" : m = "year", m === "second") {
    const p = c(d / 1e3);
    return a.formatDistance("xSeconds", p, s);
  } else if (m === "minute") {
    const p = c(u);
    return a.formatDistance("xMinutes", p, s);
  } else if (m === "hour") {
    const p = c(u / 60);
    return a.formatDistance("xHours", p, s);
  } else if (m === "day") {
    const p = c(h / qs);
    return a.formatDistance("xDays", p, s);
  } else if (m === "month") {
    const p = c(h / Kn);
    return p === 12 && g !== "month" ? a.formatDistance("xYears", 1, s) : a.formatDistance("xMonths", p, s);
  } else {
    const p = c(h / Th);
    return a.formatDistance("xYears", p, s);
  }
}
function yE(t6, e) {
  return Sb(t6, Je(t6), e);
}
function vE(t6, e) {
  return Db(t6, Je(t6), e);
}
const xE = [
  "years",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds"
];
function wE(t6, e) {
  const r = vt(), n = (e == null ? void 0 : e.locale) ?? r.locale ?? va, a = (e == null ? void 0 : e.format) ?? xE, i = (e == null ? void 0 : e.zero) ?? false, s = (e == null ? void 0 : e.delimiter) ?? " ";
  return n.formatDistance ? a.reduce((l, c) => {
    const d = `x${c.replace(/(^.)/, (f) => f.toUpperCase())}`, u = t6[c];
    return u !== void 0 && (i || t6[c]) ? l.concat(n.formatDistance(d, u)) : l;
  }, []).join(s) : "";
}
function kE(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in);
  if (isNaN(+r))
    throw new RangeError("Invalid time value");
  const n = (e == null ? void 0 : e.format) ?? "extended", a = (e == null ? void 0 : e.representation) ?? "complete";
  let i = "", s = "";
  const o = n === "extended" ? "-" : "", l = n === "extended" ? ":" : "";
  if (a !== "time") {
    const c = oe(r.getDate(), 2), d = oe(r.getMonth() + 1, 2);
    i = `${oe(r.getFullYear(), 4)}${o}${d}${o}${c}`;
  }
  if (a !== "date") {
    const c = r.getTimezoneOffset();
    if (c !== 0) {
      const m = Math.abs(c), p = oe(Math.trunc(m / 60), 2), w = oe(m % 60, 2);
      s = `${c < 0 ? "+" : "-"}${p}:${w}`;
    } else
      s = "Z";
    const d = oe(r.getHours(), 2), u = oe(r.getMinutes(), 2), f = oe(r.getSeconds(), 2), h = i === "" ? "" : "T", g = [d, u, f].join(l);
    i = `${i}${h}${g}${s}`;
  }
  return i;
}
function _E(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in);
  if (!Ir(r))
    throw new RangeError("Invalid time value");
  const n = (e == null ? void 0 : e.format) ?? "extended", a = (e == null ? void 0 : e.representation) ?? "complete";
  let i = "";
  const s = n === "extended" ? "-" : "", o = n === "extended" ? ":" : "";
  if (a !== "time") {
    const l = oe(r.getDate(), 2), c = oe(r.getMonth() + 1, 2);
    i = `${oe(r.getFullYear(), 4)}${s}${c}${s}${l}`;
  }
  if (a !== "date") {
    const l = oe(r.getHours(), 2), c = oe(r.getMinutes(), 2), d = oe(r.getSeconds(), 2);
    i = `${i}${i === "" ? "" : " "}${l}${o}${c}${o}${d}`;
  }
  return i;
}
function OE(t6) {
  const {
    years: e = 0,
    months: r = 0,
    days: n = 0,
    hours: a = 0,
    minutes: i = 0,
    seconds: s = 0
  } = t6;
  return `P${e}Y${r}M${n}DT${a}H${i}M${s}S`;
}
function SE(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in);
  if (!Ir(r))
    throw new RangeError("Invalid time value");
  const n = (e == null ? void 0 : e.fractionDigits) ?? 0, a = oe(r.getDate(), 2), i = oe(r.getMonth() + 1, 2), s = r.getFullYear(), o = oe(r.getHours(), 2), l = oe(r.getMinutes(), 2), c = oe(r.getSeconds(), 2);
  let d = "";
  if (n > 0) {
    const h = r.getMilliseconds(), g = Math.trunc(
      h * Math.pow(10, n - 3)
    );
    d = "." + oe(g, n);
  }
  let u = "";
  const f = r.getTimezoneOffset();
  if (f !== 0) {
    const h = Math.abs(f), g = oe(Math.trunc(h / 60), 2), m = oe(h % 60, 2);
    u = `${f < 0 ? "+" : "-"}${g}:${m}`;
  } else
    u = "Z";
  return `${s}-${i}-${a}T${o}:${l}:${c}${d}${u}`;
}
const DE = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ME = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
function CE(t6) {
  const e = V$1(t6);
  if (!Ir(e))
    throw new RangeError("Invalid time value");
  const r = DE[e.getUTCDay()], n = oe(e.getUTCDate(), 2), a = ME[e.getUTCMonth()], i = e.getUTCFullYear(), s = oe(e.getUTCHours(), 2), o = oe(e.getUTCMinutes(), 2), l = oe(e.getUTCSeconds(), 2);
  return `${r}, ${n} ${a} ${i} ${s}:${o}:${l} GMT`;
}
function EE(t6, e, r) {
  var u, f, h, g;
  const [n, a] = Ee(r == null ? void 0 : r.in, t6, e), i = vt(), s = (r == null ? void 0 : r.locale) ?? i.locale ?? va, o = (r == null ? void 0 : r.weekStartsOn) ?? ((f = (u = r == null ? void 0 : r.locale) == null ? void 0 : u.options) == null ? void 0 : f.weekStartsOn) ?? i.weekStartsOn ?? ((g = (h = i.locale) == null ? void 0 : h.options) == null ? void 0 : g.weekStartsOn) ?? 0, l = pr(n, a);
  if (isNaN(l))
    throw new RangeError("Invalid time value");
  let c;
  l < -6 ? c = "other" : l < -1 ? c = "lastWeek" : l < 0 ? c = "yesterday" : l < 1 ? c = "today" : l < 2 ? c = "tomorrow" : l < 7 ? c = "nextWeek" : c = "other";
  const d = s.formatRelative(c, n, a, {
    locale: s,
    weekStartsOn: o
  });
  return Zs(n, d, { locale: s, weekStartsOn: o });
}
function TE(t6, e) {
  return V$1(t6 * 1e3, e == null ? void 0 : e.in);
}
function Mb(t6, e) {
  return V$1(t6, e == null ? void 0 : e.in).getDate();
}
function Io(t6, e) {
  return V$1(t6, e == null ? void 0 : e.in).getDay();
}
function Cb(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in), n = r.getFullYear(), a = r.getMonth(), i = se(r, 0);
  return i.setFullYear(n, a + 1, 0), i.setHours(0, 0, 0, 0), i.getDate();
}
function Eb(t6, e) {
  const n = V$1(t6, e == null ? void 0 : e.in).getFullYear();
  return n % 400 === 0 || n % 4 === 0 && n % 100 !== 0;
}
function PE(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in);
  return Number.isNaN(+r) ? NaN : Eb(r) ? 366 : 365;
}
function RE(t6, e) {
  const n = V$1(t6, e == null ? void 0 : e.in).getFullYear();
  return Math.floor(n / 10) * 10;
}
function Tb() {
  return Object.assign({}, vt());
}
function NE(t6, e) {
  return V$1(t6, e == null ? void 0 : e.in).getHours();
}
function Pb(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in).getDay();
  return r === 0 ? 7 : r;
}
function IE(t6, e) {
  const r = Qr(t6, e), a = +Qr(To(r, 60)) - +r;
  return Math.round(a / Di);
}
function AE(t6) {
  return V$1(t6).getMilliseconds();
}
function FE(t6, e) {
  return V$1(t6, e == null ? void 0 : e.in).getMinutes();
}
function LE(t6, e) {
  return V$1(t6, e == null ? void 0 : e.in).getMonth();
}
function WE(t6, e) {
  const [r, n] = [
    +V$1(t6.start),
    +V$1(t6.end)
  ].sort((u, f) => u - f), [a, i] = [
    +V$1(e.start),
    +V$1(e.end)
  ].sort((u, f) => u - f);
  if (!(r < i && a < n)) return 0;
  const o = a < r ? r : a, l = o - Ct(o), c = i > n ? n : i, d = c - Ct(c);
  return Math.ceil((d - l) / Xp);
}
function $E(t6) {
  return V$1(t6).getSeconds();
}
function zE(t6) {
  return +V$1(t6);
}
function jE(t6) {
  return Math.trunc(+V$1(t6) / 1e3);
}
function HE(t6, e) {
  var l, c, d, u;
  const r = vt(), n = (e == null ? void 0 : e.weekStartsOn) ?? ((c = (l = e == null ? void 0 : e.locale) == null ? void 0 : l.options) == null ? void 0 : c.weekStartsOn) ?? r.weekStartsOn ?? ((u = (d = r.locale) == null ? void 0 : d.options) == null ? void 0 : u.weekStartsOn) ?? 0, a = Mb(V$1(t6, e == null ? void 0 : e.in));
  if (isNaN(a)) return NaN;
  const i = Io(Ro(t6, e));
  let s = n - i;
  s <= 0 && (s += 7);
  const o = a - s;
  return Math.ceil(o / 7) + 1;
}
function Rb(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in), n = r.getMonth();
  return r.setFullYear(r.getFullYear(), n + 1, 0), r.setHours(0, 0, 0, 0), V$1(r, e == null ? void 0 : e.in);
}
function BE(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in);
  return Xs(
    Rb(r, e),
    Ro(r, e),
    e
  ) + 1;
}
function YE(t6, e) {
  return V$1(t6, e == null ? void 0 : e.in).getFullYear();
}
function VE(t6) {
  return Math.trunc(t6 * Fn);
}
function qE(t6) {
  return Math.trunc(t6 * Gp);
}
function UE(t6) {
  return Math.trunc(t6 * Co);
}
function XE(t6, e, r) {
  const [n, a] = Ee(r == null ? void 0 : r.in, t6, e);
  if (isNaN(+n)) throw new TypeError("Start date is invalid");
  if (isNaN(+a)) throw new TypeError("End date is invalid");
  if (r != null && r.assertPositive && +n > +a)
    throw new TypeError("End date must be after start date");
  return { start: n, end: a };
}
function GE(t6, e) {
  const { start: r, end: n } = Fr(e == null ? void 0 : e.in, t6), a = {}, i = bb(n, r);
  i && (a.years = i);
  const s = Vn(r, { years: a.years }), o = Po(n, s);
  o && (a.months = o);
  const l = Vn(s, { months: a.months }), c = hd(n, l);
  c && (a.days = c);
  const d = Vn(l, { days: a.days }), u = Gs(n, d);
  u && (a.hours = u);
  const f = Vn(d, { hours: a.hours }), h = Ks(n, f);
  h && (a.minutes = h);
  const g = Vn(f, { minutes: a.minutes }), m = ta(n, g);
  return m && (a.seconds = m), a;
}
function KE(t6, e, r) {
  let n;
  return QE(e) ? n = e : r = e, new Intl.DateTimeFormat(r == null ? void 0 : r.locale, n).format(
    V$1(t6)
  );
}
function QE(t6) {
  return t6 !== void 0 && !("locale" in t6);
}
function JE(t6, e, r) {
  let n = 0, a;
  const [i, s] = Ee(
    r == null ? void 0 : r.in,
    t6,
    e
  );
  if (r != null && r.unit)
    a = r == null ? void 0 : r.unit, a === "second" ? n = ta(i, s) : a === "minute" ? n = Ks(i, s) : a === "hour" ? n = Gs(i, s) : a === "day" ? n = pr(i, s) : a === "week" ? n = Xs(i, s) : a === "month" ? n = Us(i, s) : a === "quarter" ? n = gs(i, s) : a === "year" && (n = Za(i, s));
  else {
    const l = ta(i, s);
    Math.abs(l) < cd ? (n = ta(i, s), a = "second") : Math.abs(l) < Co ? (n = Ks(i, s), a = "minute") : Math.abs(l) < dd && Math.abs(pr(i, s)) < 1 ? (n = Gs(i, s), a = "hour") : Math.abs(l) < J2 && (n = pr(i, s)) && Math.abs(n) < 7 ? a = "day" : Math.abs(l) < eb ? (n = Xs(i, s), a = "week") : Math.abs(l) < Z2 ? (n = Us(i, s), a = "month") : Math.abs(l) < Zp && gs(i, s) < 4 ? (n = gs(i, s), a = "quarter") : (n = Za(i, s), a = "year");
  }
  return new Intl.RelativeTimeFormat(r == null ? void 0 : r.locale, {
    numeric: "auto",
    ...r
  }).format(n, a);
}
function ZE(t6, e) {
  return +V$1(t6) > +V$1(e);
}
function eT(t6, e) {
  return +V$1(t6) < +V$1(e);
}
function tT(t6, e) {
  return +V$1(t6) == +V$1(e);
}
function rT(t6, e, r) {
  const n = new Date(t6, e, r);
  return n.getFullYear() === t6 && n.getMonth() === e && n.getDate() === r;
}
function nT(t6, e) {
  return V$1(t6, e == null ? void 0 : e.in).getDate() === 1;
}
function aT(t6, e) {
  return V$1(t6, e == null ? void 0 : e.in).getDay() === 5;
}
function iT(t6) {
  return +V$1(t6) > Date.now();
}
function Nb(t6, e) {
  const r = sT(e) ? new e(0) : se(e, 0);
  return r.setFullYear(t6.getFullYear(), t6.getMonth(), t6.getDate()), r.setHours(
    t6.getHours(),
    t6.getMinutes(),
    t6.getSeconds(),
    t6.getMilliseconds()
  ), r;
}
function sT(t6) {
  var e;
  return typeof t6 == "function" && ((e = t6.prototype) == null ? void 0 : e.constructor) === t6;
}
const oT = 10;
class Ib {
  constructor() {
    K(this, "subPriority", 0);
  }
  validate(e, r) {
    return true;
  }
}
class lT extends Ib {
  constructor(e, r, n, a, i) {
    super(), this.value = e, this.validateValue = r, this.setValue = n, this.priority = a, i && (this.subPriority = i);
  }
  validate(e, r) {
    return this.validateValue(e, this.value, r);
  }
  set(e, r, n) {
    return this.setValue(e, r, this.value, n);
  }
}
class cT extends Ib {
  constructor(r, n) {
    super();
    K(this, "priority", oT);
    K(this, "subPriority", -1);
    this.context = r || ((a) => se(n, a));
  }
  set(r, n) {
    return n.timestampIsSet ? r : se(r, Nb(r, this.context));
  }
}
class xe {
  run(e, r, n, a) {
    const i = this.parse(e, r, n, a);
    return i ? {
      setter: new lT(
        i.value,
        this.validate,
        this.set,
        this.priority,
        this.subPriority
      ),
      rest: i.rest
    } : null;
  }
  validate(e, r, n) {
    return true;
  }
}
class dT extends xe {
  constructor() {
    super(...arguments);
    K(this, "priority", 140);
    K(this, "incompatibleTokens", ["R", "u", "t", "T"]);
  }
  parse(r, n, a) {
    switch (n) {
      case "G":
      case "GG":
      case "GGG":
        return a.era(r, { width: "abbreviated" }) || a.era(r, { width: "narrow" });
      case "GGGGG":
        return a.era(r, { width: "narrow" });
      case "GGGG":
      default:
        return a.era(r, { width: "wide" }) || a.era(r, { width: "abbreviated" }) || a.era(r, { width: "narrow" });
    }
  }
  set(r, n, a) {
    return n.era = a, r.setFullYear(a, 0, 1), r.setHours(0, 0, 0, 0), r;
  }
}
const qe = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/
  // 0 to 9999, -0 to -9999
}, cr = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function Ue(t6, e) {
  return t6 && {
    value: e(t6.value),
    rest: t6.rest
  };
}
function ze(t6, e) {
  const r = e.match(t6);
  return r ? {
    value: parseInt(r[0], 10),
    rest: e.slice(r[0].length)
  } : null;
}
function dr(t6, e) {
  const r = e.match(t6);
  if (!r)
    return null;
  if (r[0] === "Z")
    return {
      value: 0,
      rest: e.slice(1)
    };
  const n = r[1] === "+" ? 1 : -1, a = r[2] ? parseInt(r[2], 10) : 0, i = r[3] ? parseInt(r[3], 10) : 0, s = r[5] ? parseInt(r[5], 10) : 0;
  return {
    value: n * (a * Fn + i * Nr + s * ld),
    rest: e.slice(r[0].length)
  };
}
function Ab(t6) {
  return ze(qe.anyDigitsSigned, t6);
}
function Be(t6, e) {
  switch (t6) {
    case 1:
      return ze(qe.singleDigit, e);
    case 2:
      return ze(qe.twoDigits, e);
    case 3:
      return ze(qe.threeDigits, e);
    case 4:
      return ze(qe.fourDigits, e);
    default:
      return ze(new RegExp("^\\d{1," + t6 + "}"), e);
  }
}
function eo(t6, e) {
  switch (t6) {
    case 1:
      return ze(qe.singleDigitSigned, e);
    case 2:
      return ze(qe.twoDigitsSigned, e);
    case 3:
      return ze(qe.threeDigitsSigned, e);
    case 4:
      return ze(qe.fourDigitsSigned, e);
    default:
      return ze(new RegExp("^-?\\d{1," + t6 + "}"), e);
  }
}
function wd(t6) {
  switch (t6) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function Fb(t6, e) {
  const r = e > 0, n = r ? e : 1 - e;
  let a;
  if (n <= 50)
    a = t6 || 100;
  else {
    const i = n + 50, s = Math.trunc(i / 100) * 100, o = t6 >= i % 100;
    a = t6 + s - (o ? 100 : 0);
  }
  return r ? a : 1 - a;
}
function Lb(t6) {
  return t6 % 400 === 0 || t6 % 4 === 0 && t6 % 100 !== 0;
}
class uT extends xe {
  constructor() {
    super(...arguments);
    K(this, "priority", 130);
    K(this, "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(r, n, a) {
    const i = (s) => ({
      year: s,
      isTwoDigitYear: n === "yy"
    });
    switch (n) {
      case "y":
        return Ue(Be(4, r), i);
      case "yo":
        return Ue(
          a.ordinalNumber(r, {
            unit: "year"
          }),
          i
        );
      default:
        return Ue(Be(n.length, r), i);
    }
  }
  validate(r, n) {
    return n.isTwoDigitYear || n.year > 0;
  }
  set(r, n, a) {
    const i = r.getFullYear();
    if (a.isTwoDigitYear) {
      const o = Fb(
        a.year,
        i
      );
      return r.setFullYear(o, 0, 1), r.setHours(0, 0, 0, 0), r;
    }
    const s = !("era" in n) || n.era === 1 ? a.year : 1 - a.year;
    return r.setFullYear(s, 0, 1), r.setHours(0, 0, 0, 0), r;
  }
}
class fT extends xe {
  constructor() {
    super(...arguments);
    K(this, "priority", 130);
    K(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T"
    ]);
  }
  parse(r, n, a) {
    const i = (s) => ({
      year: s,
      isTwoDigitYear: n === "YY"
    });
    switch (n) {
      case "Y":
        return Ue(Be(4, r), i);
      case "Yo":
        return Ue(
          a.ordinalNumber(r, {
            unit: "year"
          }),
          i
        );
      default:
        return Ue(Be(n.length, r), i);
    }
  }
  validate(r, n) {
    return n.isTwoDigitYear || n.year > 0;
  }
  set(r, n, a, i) {
    const s = No(r, i);
    if (a.isTwoDigitYear) {
      const l = Fb(
        a.year,
        s
      );
      return r.setFullYear(
        l,
        0,
        i.firstWeekContainsDate
      ), r.setHours(0, 0, 0, 0), dt(r, i);
    }
    const o = !("era" in n) || n.era === 1 ? a.year : 1 - a.year;
    return r.setFullYear(o, 0, i.firstWeekContainsDate), r.setHours(0, 0, 0, 0), dt(r, i);
  }
}
class hT extends xe {
  constructor() {
    super(...arguments);
    K(this, "priority", 130);
    K(this, "incompatibleTokens", [
      "G",
      "y",
      "Y",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(r, n) {
    return eo(n === "R" ? 4 : n.length, r);
  }
  set(r, n, a) {
    const i = se(r, 0);
    return i.setFullYear(a, 0, 4), i.setHours(0, 0, 0, 0), Jt(i);
  }
}
class gT extends xe {
  constructor() {
    super(...arguments);
    K(this, "priority", 130);
    K(this, "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(r, n) {
    return eo(n === "u" ? 4 : n.length, r);
  }
  set(r, n, a) {
    return r.setFullYear(a, 0, 1), r.setHours(0, 0, 0, 0), r;
  }
}
class mT extends xe {
  constructor() {
    super(...arguments);
    K(this, "priority", 120);
    K(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(r, n, a) {
    switch (n) {
      case "Q":
      case "QQ":
        return Be(n.length, r);
      case "Qo":
        return a.ordinalNumber(r, { unit: "quarter" });
      case "QQQ":
        return a.quarter(r, {
          width: "abbreviated",
          context: "formatting"
        }) || a.quarter(r, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQQ":
        return a.quarter(r, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return a.quarter(r, {
          width: "wide",
          context: "formatting"
        }) || a.quarter(r, {
          width: "abbreviated",
          context: "formatting"
        }) || a.quarter(r, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  validate(r, n) {
    return n >= 1 && n <= 4;
  }
  set(r, n, a) {
    return r.setMonth((a - 1) * 3, 1), r.setHours(0, 0, 0, 0), r;
  }
}
class pT extends xe {
  constructor() {
    super(...arguments);
    K(this, "priority", 120);
    K(this, "incompatibleTokens", [
      "Y",
      "R",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(r, n, a) {
    switch (n) {
      case "q":
      case "qq":
        return Be(n.length, r);
      case "qo":
        return a.ordinalNumber(r, { unit: "quarter" });
      case "qqq":
        return a.quarter(r, {
          width: "abbreviated",
          context: "standalone"
        }) || a.quarter(r, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqqq":
        return a.quarter(r, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return a.quarter(r, {
          width: "wide",
          context: "standalone"
        }) || a.quarter(r, {
          width: "abbreviated",
          context: "standalone"
        }) || a.quarter(r, {
          width: "narrow",
          context: "standalone"
        });
    }
  }
  validate(r, n) {
    return n >= 1 && n <= 4;
  }
  set(r, n, a) {
    return r.setMonth((a - 1) * 3, 1), r.setHours(0, 0, 0, 0), r;
  }
}
class bT extends xe {
  constructor() {
    super(...arguments);
    K(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "L",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
    K(this, "priority", 110);
  }
  parse(r, n, a) {
    const i = (s) => s - 1;
    switch (n) {
      case "M":
        return Ue(
          ze(qe.month, r),
          i
        );
      case "MM":
        return Ue(Be(2, r), i);
      case "Mo":
        return Ue(
          a.ordinalNumber(r, {
            unit: "month"
          }),
          i
        );
      case "MMM":
        return a.month(r, {
          width: "abbreviated",
          context: "formatting"
        }) || a.month(r, { width: "narrow", context: "formatting" });
      case "MMMMM":
        return a.month(r, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return a.month(r, { width: "wide", context: "formatting" }) || a.month(r, {
          width: "abbreviated",
          context: "formatting"
        }) || a.month(r, { width: "narrow", context: "formatting" });
    }
  }
  validate(r, n) {
    return n >= 0 && n <= 11;
  }
  set(r, n, a) {
    return r.setMonth(a, 1), r.setHours(0, 0, 0, 0), r;
  }
}
class yT extends xe {
  constructor() {
    super(...arguments);
    K(this, "priority", 110);
    K(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(r, n, a) {
    const i = (s) => s - 1;
    switch (n) {
      case "L":
        return Ue(
          ze(qe.month, r),
          i
        );
      case "LL":
        return Ue(Be(2, r), i);
      case "Lo":
        return Ue(
          a.ordinalNumber(r, {
            unit: "month"
          }),
          i
        );
      case "LLL":
        return a.month(r, {
          width: "abbreviated",
          context: "standalone"
        }) || a.month(r, { width: "narrow", context: "standalone" });
      case "LLLLL":
        return a.month(r, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return a.month(r, { width: "wide", context: "standalone" }) || a.month(r, {
          width: "abbreviated",
          context: "standalone"
        }) || a.month(r, { width: "narrow", context: "standalone" });
    }
  }
  validate(r, n) {
    return n >= 0 && n <= 11;
  }
  set(r, n, a) {
    return r.setMonth(a, 1), r.setHours(0, 0, 0, 0), r;
  }
}
function Wb(t6, e, r) {
  const n = V$1(t6, r == null ? void 0 : r.in), a = xd(n, r) - e;
  return n.setDate(n.getDate() - a * 7), V$1(n, r == null ? void 0 : r.in);
}
class vT extends xe {
  constructor() {
    super(...arguments);
    K(this, "priority", 100);
    K(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T"
    ]);
  }
  parse(r, n, a) {
    switch (n) {
      case "w":
        return ze(qe.week, r);
      case "wo":
        return a.ordinalNumber(r, { unit: "week" });
      default:
        return Be(n.length, r);
    }
  }
  validate(r, n) {
    return n >= 1 && n <= 53;
  }
  set(r, n, a, i) {
    return dt(Wb(r, a, i), i);
  }
}
function $b(t6, e, r) {
  const n = V$1(t6, r == null ? void 0 : r.in), a = vd(n, r) - e;
  return n.setDate(n.getDate() - a * 7), n;
}
class xT extends xe {
  constructor() {
    super(...arguments);
    K(this, "priority", 100);
    K(this, "incompatibleTokens", [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(r, n, a) {
    switch (n) {
      case "I":
        return ze(qe.week, r);
      case "Io":
        return a.ordinalNumber(r, { unit: "week" });
      default:
        return Be(n.length, r);
    }
  }
  validate(r, n) {
    return n >= 1 && n <= 53;
  }
  set(r, n, a) {
    return Jt($b(r, a));
  }
}
const wT = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], kT = [
  31,
  29,
  31,
  30,
  31,
  30,
  31,
  31,
  30,
  31,
  30,
  31
];
class _T extends xe {
  constructor() {
    super(...arguments);
    K(this, "priority", 90);
    K(this, "subPriority", 1);
    K(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(r, n, a) {
    switch (n) {
      case "d":
        return ze(qe.date, r);
      case "do":
        return a.ordinalNumber(r, { unit: "date" });
      default:
        return Be(n.length, r);
    }
  }
  validate(r, n) {
    const a = r.getFullYear(), i = Lb(a), s = r.getMonth();
    return i ? n >= 1 && n <= kT[s] : n >= 1 && n <= wT[s];
  }
  set(r, n, a) {
    return r.setDate(a), r.setHours(0, 0, 0, 0), r;
  }
}
class OT extends xe {
  constructor() {
    super(...arguments);
    K(this, "priority", 90);
    K(this, "subpriority", 1);
    K(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "E",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(r, n, a) {
    switch (n) {
      case "D":
      case "DD":
        return ze(qe.dayOfYear, r);
      case "Do":
        return a.ordinalNumber(r, { unit: "date" });
      default:
        return Be(n.length, r);
    }
  }
  validate(r, n) {
    const a = r.getFullYear();
    return Lb(a) ? n >= 1 && n <= 366 : n >= 1 && n <= 365;
  }
  set(r, n, a) {
    return r.setMonth(0, a), r.setHours(0, 0, 0, 0), r;
  }
}
function Ao(t6, e, r) {
  var u, f, h, g;
  const n = vt(), a = (r == null ? void 0 : r.weekStartsOn) ?? ((f = (u = r == null ? void 0 : r.locale) == null ? void 0 : u.options) == null ? void 0 : f.weekStartsOn) ?? n.weekStartsOn ?? ((g = (h = n.locale) == null ? void 0 : h.options) == null ? void 0 : g.weekStartsOn) ?? 0, i = V$1(t6, r == null ? void 0 : r.in), s = i.getDay(), l = (e % 7 + 7) % 7, c = 7 - a, d = e < 0 || e > 6 ? e - (s + c) % 7 : (l + c) % 7 - (s + c) % 7;
  return Wt(i, d, r);
}
class ST extends xe {
  constructor() {
    super(...arguments);
    K(this, "priority", 90);
    K(this, "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
  }
  parse(r, n, a) {
    switch (n) {
      case "E":
      case "EE":
      case "EEE":
        return a.day(r, {
          width: "abbreviated",
          context: "formatting"
        }) || a.day(r, { width: "short", context: "formatting" }) || a.day(r, { width: "narrow", context: "formatting" });
      case "EEEEE":
        return a.day(r, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return a.day(r, { width: "short", context: "formatting" }) || a.day(r, { width: "narrow", context: "formatting" });
      case "EEEE":
      default:
        return a.day(r, { width: "wide", context: "formatting" }) || a.day(r, {
          width: "abbreviated",
          context: "formatting"
        }) || a.day(r, { width: "short", context: "formatting" }) || a.day(r, { width: "narrow", context: "formatting" });
    }
  }
  validate(r, n) {
    return n >= 0 && n <= 6;
  }
  set(r, n, a, i) {
    return r = Ao(r, a, i), r.setHours(0, 0, 0, 0), r;
  }
}
class DT extends xe {
  constructor() {
    super(...arguments);
    K(this, "priority", 90);
    K(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "c",
      "t",
      "T"
    ]);
  }
  parse(r, n, a, i) {
    const s = (o) => {
      const l = Math.floor((o - 1) / 7) * 7;
      return (o + i.weekStartsOn + 6) % 7 + l;
    };
    switch (n) {
      case "e":
      case "ee":
        return Ue(Be(n.length, r), s);
      case "eo":
        return Ue(
          a.ordinalNumber(r, {
            unit: "day"
          }),
          s
        );
      case "eee":
        return a.day(r, {
          width: "abbreviated",
          context: "formatting"
        }) || a.day(r, { width: "short", context: "formatting" }) || a.day(r, { width: "narrow", context: "formatting" });
      case "eeeee":
        return a.day(r, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return a.day(r, { width: "short", context: "formatting" }) || a.day(r, { width: "narrow", context: "formatting" });
      case "eeee":
      default:
        return a.day(r, { width: "wide", context: "formatting" }) || a.day(r, {
          width: "abbreviated",
          context: "formatting"
        }) || a.day(r, { width: "short", context: "formatting" }) || a.day(r, { width: "narrow", context: "formatting" });
    }
  }
  validate(r, n) {
    return n >= 0 && n <= 6;
  }
  set(r, n, a, i) {
    return r = Ao(r, a, i), r.setHours(0, 0, 0, 0), r;
  }
}
class MT extends xe {
  constructor() {
    super(...arguments);
    K(this, "priority", 90);
    K(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "e",
      "t",
      "T"
    ]);
  }
  parse(r, n, a, i) {
    const s = (o) => {
      const l = Math.floor((o - 1) / 7) * 7;
      return (o + i.weekStartsOn + 6) % 7 + l;
    };
    switch (n) {
      case "c":
      case "cc":
        return Ue(Be(n.length, r), s);
      case "co":
        return Ue(
          a.ordinalNumber(r, {
            unit: "day"
          }),
          s
        );
      case "ccc":
        return a.day(r, {
          width: "abbreviated",
          context: "standalone"
        }) || a.day(r, { width: "short", context: "standalone" }) || a.day(r, { width: "narrow", context: "standalone" });
      case "ccccc":
        return a.day(r, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return a.day(r, { width: "short", context: "standalone" }) || a.day(r, { width: "narrow", context: "standalone" });
      case "cccc":
      default:
        return a.day(r, { width: "wide", context: "standalone" }) || a.day(r, {
          width: "abbreviated",
          context: "standalone"
        }) || a.day(r, { width: "short", context: "standalone" }) || a.day(r, { width: "narrow", context: "standalone" });
    }
  }
  validate(r, n) {
    return n >= 0 && n <= 6;
  }
  set(r, n, a, i) {
    return r = Ao(r, a, i), r.setHours(0, 0, 0, 0), r;
  }
}
function zb(t6, e, r) {
  const n = V$1(t6, r == null ? void 0 : r.in), a = Pb(n, r), i = e - a;
  return Wt(n, i, r);
}
class CT extends xe {
  constructor() {
    super(...arguments);
    K(this, "priority", 90);
    K(this, "incompatibleTokens", [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "E",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(r, n, a) {
    const i = (s) => s === 0 ? 7 : s;
    switch (n) {
      case "i":
      case "ii":
        return Be(n.length, r);
      case "io":
        return a.ordinalNumber(r, { unit: "day" });
      case "iii":
        return Ue(
          a.day(r, {
            width: "abbreviated",
            context: "formatting"
          }) || a.day(r, {
            width: "short",
            context: "formatting"
          }) || a.day(r, {
            width: "narrow",
            context: "formatting"
          }),
          i
        );
      case "iiiii":
        return Ue(
          a.day(r, {
            width: "narrow",
            context: "formatting"
          }),
          i
        );
      case "iiiiii":
        return Ue(
          a.day(r, {
            width: "short",
            context: "formatting"
          }) || a.day(r, {
            width: "narrow",
            context: "formatting"
          }),
          i
        );
      case "iiii":
      default:
        return Ue(
          a.day(r, {
            width: "wide",
            context: "formatting"
          }) || a.day(r, {
            width: "abbreviated",
            context: "formatting"
          }) || a.day(r, {
            width: "short",
            context: "formatting"
          }) || a.day(r, {
            width: "narrow",
            context: "formatting"
          }),
          i
        );
    }
  }
  validate(r, n) {
    return n >= 1 && n <= 7;
  }
  set(r, n, a) {
    return r = zb(r, a), r.setHours(0, 0, 0, 0), r;
  }
}
class ET extends xe {
  constructor() {
    super(...arguments);
    K(this, "priority", 80);
    K(this, "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
  }
  parse(r, n, a) {
    switch (n) {
      case "a":
      case "aa":
      case "aaa":
        return a.dayPeriod(r, {
          width: "abbreviated",
          context: "formatting"
        }) || a.dayPeriod(r, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaaa":
        return a.dayPeriod(r, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return a.dayPeriod(r, {
          width: "wide",
          context: "formatting"
        }) || a.dayPeriod(r, {
          width: "abbreviated",
          context: "formatting"
        }) || a.dayPeriod(r, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(r, n, a) {
    return r.setHours(wd(a), 0, 0, 0), r;
  }
}
class TT extends xe {
  constructor() {
    super(...arguments);
    K(this, "priority", 80);
    K(this, "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
  }
  parse(r, n, a) {
    switch (n) {
      case "b":
      case "bb":
      case "bbb":
        return a.dayPeriod(r, {
          width: "abbreviated",
          context: "formatting"
        }) || a.dayPeriod(r, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbbb":
        return a.dayPeriod(r, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return a.dayPeriod(r, {
          width: "wide",
          context: "formatting"
        }) || a.dayPeriod(r, {
          width: "abbreviated",
          context: "formatting"
        }) || a.dayPeriod(r, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(r, n, a) {
    return r.setHours(wd(a), 0, 0, 0), r;
  }
}
class PT extends xe {
  constructor() {
    super(...arguments);
    K(this, "priority", 80);
    K(this, "incompatibleTokens", ["a", "b", "t", "T"]);
  }
  parse(r, n, a) {
    switch (n) {
      case "B":
      case "BB":
      case "BBB":
        return a.dayPeriod(r, {
          width: "abbreviated",
          context: "formatting"
        }) || a.dayPeriod(r, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBBB":
        return a.dayPeriod(r, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return a.dayPeriod(r, {
          width: "wide",
          context: "formatting"
        }) || a.dayPeriod(r, {
          width: "abbreviated",
          context: "formatting"
        }) || a.dayPeriod(r, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(r, n, a) {
    return r.setHours(wd(a), 0, 0, 0), r;
  }
}
class RT extends xe {
  constructor() {
    super(...arguments);
    K(this, "priority", 70);
    K(this, "incompatibleTokens", ["H", "K", "k", "t", "T"]);
  }
  parse(r, n, a) {
    switch (n) {
      case "h":
        return ze(qe.hour12h, r);
      case "ho":
        return a.ordinalNumber(r, { unit: "hour" });
      default:
        return Be(n.length, r);
    }
  }
  validate(r, n) {
    return n >= 1 && n <= 12;
  }
  set(r, n, a) {
    const i = r.getHours() >= 12;
    return i && a < 12 ? r.setHours(a + 12, 0, 0, 0) : !i && a === 12 ? r.setHours(0, 0, 0, 0) : r.setHours(a, 0, 0, 0), r;
  }
}
class NT extends xe {
  constructor() {
    super(...arguments);
    K(this, "priority", 70);
    K(this, "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
  }
  parse(r, n, a) {
    switch (n) {
      case "H":
        return ze(qe.hour23h, r);
      case "Ho":
        return a.ordinalNumber(r, { unit: "hour" });
      default:
        return Be(n.length, r);
    }
  }
  validate(r, n) {
    return n >= 0 && n <= 23;
  }
  set(r, n, a) {
    return r.setHours(a, 0, 0, 0), r;
  }
}
class IT extends xe {
  constructor() {
    super(...arguments);
    K(this, "priority", 70);
    K(this, "incompatibleTokens", ["h", "H", "k", "t", "T"]);
  }
  parse(r, n, a) {
    switch (n) {
      case "K":
        return ze(qe.hour11h, r);
      case "Ko":
        return a.ordinalNumber(r, { unit: "hour" });
      default:
        return Be(n.length, r);
    }
  }
  validate(r, n) {
    return n >= 0 && n <= 11;
  }
  set(r, n, a) {
    return r.getHours() >= 12 && a < 12 ? r.setHours(a + 12, 0, 0, 0) : r.setHours(a, 0, 0, 0), r;
  }
}
class AT extends xe {
  constructor() {
    super(...arguments);
    K(this, "priority", 70);
    K(this, "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
  }
  parse(r, n, a) {
    switch (n) {
      case "k":
        return ze(qe.hour24h, r);
      case "ko":
        return a.ordinalNumber(r, { unit: "hour" });
      default:
        return Be(n.length, r);
    }
  }
  validate(r, n) {
    return n >= 1 && n <= 24;
  }
  set(r, n, a) {
    const i = a <= 24 ? a % 24 : a;
    return r.setHours(i, 0, 0, 0), r;
  }
}
class FT extends xe {
  constructor() {
    super(...arguments);
    K(this, "priority", 60);
    K(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(r, n, a) {
    switch (n) {
      case "m":
        return ze(qe.minute, r);
      case "mo":
        return a.ordinalNumber(r, { unit: "minute" });
      default:
        return Be(n.length, r);
    }
  }
  validate(r, n) {
    return n >= 0 && n <= 59;
  }
  set(r, n, a) {
    return r.setMinutes(a, 0, 0), r;
  }
}
class LT extends xe {
  constructor() {
    super(...arguments);
    K(this, "priority", 50);
    K(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(r, n, a) {
    switch (n) {
      case "s":
        return ze(qe.second, r);
      case "so":
        return a.ordinalNumber(r, { unit: "second" });
      default:
        return Be(n.length, r);
    }
  }
  validate(r, n) {
    return n >= 0 && n <= 59;
  }
  set(r, n, a) {
    return r.setSeconds(a, 0), r;
  }
}
class WT extends xe {
  constructor() {
    super(...arguments);
    K(this, "priority", 30);
    K(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(r, n) {
    const a = (i) => Math.trunc(i * Math.pow(10, -n.length + 3));
    return Ue(Be(n.length, r), a);
  }
  set(r, n, a) {
    return r.setMilliseconds(a), r;
  }
}
class $T extends xe {
  constructor() {
    super(...arguments);
    K(this, "priority", 10);
    K(this, "incompatibleTokens", ["t", "T", "x"]);
  }
  parse(r, n) {
    switch (n) {
      case "X":
        return dr(
          cr.basicOptionalMinutes,
          r
        );
      case "XX":
        return dr(cr.basic, r);
      case "XXXX":
        return dr(
          cr.basicOptionalSeconds,
          r
        );
      case "XXXXX":
        return dr(
          cr.extendedOptionalSeconds,
          r
        );
      case "XXX":
      default:
        return dr(cr.extended, r);
    }
  }
  set(r, n, a) {
    return n.timestampIsSet ? r : se(
      r,
      r.getTime() - Ct(r) - a
    );
  }
}
class zT extends xe {
  constructor() {
    super(...arguments);
    K(this, "priority", 10);
    K(this, "incompatibleTokens", ["t", "T", "X"]);
  }
  parse(r, n) {
    switch (n) {
      case "x":
        return dr(
          cr.basicOptionalMinutes,
          r
        );
      case "xx":
        return dr(cr.basic, r);
      case "xxxx":
        return dr(
          cr.basicOptionalSeconds,
          r
        );
      case "xxxxx":
        return dr(
          cr.extendedOptionalSeconds,
          r
        );
      case "xxx":
      default:
        return dr(cr.extended, r);
    }
  }
  set(r, n, a) {
    return n.timestampIsSet ? r : se(
      r,
      r.getTime() - Ct(r) - a
    );
  }
}
class jT extends xe {
  constructor() {
    super(...arguments);
    K(this, "priority", 40);
    K(this, "incompatibleTokens", "*");
  }
  parse(r) {
    return Ab(r);
  }
  set(r, n, a) {
    return [se(r, a * 1e3), { timestampIsSet: true }];
  }
}
class HT extends xe {
  constructor() {
    super(...arguments);
    K(this, "priority", 20);
    K(this, "incompatibleTokens", "*");
  }
  parse(r) {
    return Ab(r);
  }
  set(r, n, a) {
    return [se(r, a), { timestampIsSet: true }];
  }
}
const jb = {
  G: new dT(),
  y: new uT(),
  Y: new fT(),
  R: new hT(),
  u: new gT(),
  Q: new mT(),
  q: new pT(),
  M: new bT(),
  L: new yT(),
  w: new vT(),
  I: new xT(),
  d: new _T(),
  D: new OT(),
  E: new ST(),
  e: new DT(),
  c: new MT(),
  i: new CT(),
  a: new ET(),
  b: new TT(),
  B: new PT(),
  h: new RT(),
  H: new NT(),
  K: new IT(),
  k: new AT(),
  m: new FT(),
  s: new LT(),
  S: new WT(),
  X: new $T(),
  x: new zT(),
  t: new jT(),
  T: new HT()
}, BT = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, YT = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, VT = /^'([^]*?)'?$/, qT = /''/g, UT = /\S/, XT = /[a-zA-Z]/;
function Hb(t6, e, r, n) {
  var p, w, b, k, v, x, _, T;
  const a = () => se((n == null ? void 0 : n.in) || r, NaN), i = Tb(), s = (n == null ? void 0 : n.locale) ?? i.locale ?? va, o = (n == null ? void 0 : n.firstWeekContainsDate) ?? ((w = (p = n == null ? void 0 : n.locale) == null ? void 0 : p.options) == null ? void 0 : w.firstWeekContainsDate) ?? i.firstWeekContainsDate ?? ((k = (b = i.locale) == null ? void 0 : b.options) == null ? void 0 : k.firstWeekContainsDate) ?? 1, l = (n == null ? void 0 : n.weekStartsOn) ?? ((x = (v = n == null ? void 0 : n.locale) == null ? void 0 : v.options) == null ? void 0 : x.weekStartsOn) ?? i.weekStartsOn ?? ((T = (_ = i.locale) == null ? void 0 : _.options) == null ? void 0 : T.weekStartsOn) ?? 0;
  if (!e)
    return t6 ? a() : V$1(r, n == null ? void 0 : n.in);
  const c = {
    firstWeekContainsDate: o,
    weekStartsOn: l,
    locale: s
  }, d = [new cT(n == null ? void 0 : n.in, r)], u = e.match(YT).map((S) => {
    const C = S[0];
    if (C in Js) {
      const D = Js[C];
      return D(S, s.formatLong);
    }
    return S;
  }).join("").match(BT), f = [];
  for (let S of u) {
    !(n != null && n.useAdditionalWeekYearTokens) && Ob(S) && Ql(S, e, t6), !(n != null && n.useAdditionalDayOfYearTokens) && _b(S) && Ql(S, e, t6);
    const C = S[0], D = jb[C];
    if (D) {
      const { incompatibleTokens: z } = D;
      if (Array.isArray(z)) {
        const L = f.find(
          (M) => z.includes(M.token) || M.token === C
        );
        if (L)
          throw new RangeError(
            `The format string mustn't contain \`${L.fullToken}\` and \`${S}\` at the same time`
          );
      } else if (D.incompatibleTokens === "*" && f.length > 0)
        throw new RangeError(
          `The format string mustn't contain \`${S}\` and any other token at the same time`
        );
      f.push({ token: C, fullToken: S });
      const A = D.run(
        t6,
        S,
        s.match,
        c
      );
      if (!A)
        return a();
      d.push(A.setter), t6 = A.rest;
    } else {
      if (C.match(XT))
        throw new RangeError(
          "Format string contains an unescaped latin alphabet character `" + C + "`"
        );
      if (S === "''" ? S = "'" : C === "'" && (S = GT(S)), t6.indexOf(S) === 0)
        t6 = t6.slice(S.length);
      else
        return a();
    }
  }
  if (t6.length > 0 && UT.test(t6))
    return a();
  const h = d.map((S) => S.priority).sort((S, C) => C - S).filter((S, C, D) => D.indexOf(S) === C).map(
    (S) => d.filter((C) => C.priority === S).sort((C, D) => D.subPriority - C.subPriority)
  ).map((S) => S[0]);
  let g = V$1(r, n == null ? void 0 : n.in);
  if (isNaN(+g)) return a();
  const m = {};
  for (const S of h) {
    if (!S.validate(g, c))
      return a();
    const C = S.set(g, m, c);
    Array.isArray(C) ? (g = C[0], Object.assign(m, C[1])) : g = C;
  }
  return g;
}
function GT(t6) {
  return t6.match(VT)[1].replace(qT, "'");
}
function KT(t6, e, r) {
  return Ir(Hb(t6, e, /* @__PURE__ */ new Date(), r));
}
function QT(t6, e) {
  return V$1(t6, e == null ? void 0 : e.in).getDay() === 1;
}
function JT(t6) {
  return +V$1(t6) < Date.now();
}
function Jl(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in);
  return r.setMinutes(0, 0, 0), r;
}
function Bb(t6, e, r) {
  const [n, a] = Ee(
    r == null ? void 0 : r.in,
    t6,
    e
  );
  return +Jl(n) == +Jl(a);
}
function kd(t6, e, r) {
  const [n, a] = Ee(
    r == null ? void 0 : r.in,
    t6,
    e
  );
  return +dt(n, r) == +dt(a, r);
}
function Yb(t6, e, r) {
  return kd(t6, e, { ...r, weekStartsOn: 1 });
}
function ZT(t6, e, r) {
  const [n, a] = Ee(
    r == null ? void 0 : r.in,
    t6,
    e
  );
  return +Qr(n) == +Qr(a);
}
function Zl(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in);
  return r.setSeconds(0, 0), r;
}
function Vb(t6, e) {
  return +Zl(t6) == +Zl(e);
}
function qb(t6, e, r) {
  const [n, a] = Ee(
    r == null ? void 0 : r.in,
    t6,
    e
  );
  return n.getFullYear() === a.getFullYear() && n.getMonth() === a.getMonth();
}
function Ub(t6, e, r) {
  const [n, a] = Ee(
    r == null ? void 0 : r.in,
    t6,
    e
  );
  return +kn(n) == +kn(a);
}
function ec(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in);
  return r.setMilliseconds(0), r;
}
function Xb(t6, e) {
  return +ec(t6) == +ec(e);
}
function Gb(t6, e, r) {
  const [n, a] = Ee(
    r == null ? void 0 : r.in,
    t6,
    e
  );
  return n.getFullYear() === a.getFullYear();
}
function eP(t6, e) {
  return Bb(
    V$1(t6, e == null ? void 0 : e.in),
    Je((e == null ? void 0 : e.in) || t6)
  );
}
function tP(t6, e) {
  return Yb(
    se((e == null ? void 0 : e.in) || t6, t6),
    Je((e == null ? void 0 : e.in) || t6)
  );
}
function rP(t6) {
  return Vb(t6, Je(t6));
}
function nP(t6, e) {
  return qb(
    se((e == null ? void 0 : e.in) || t6, t6),
    Je((e == null ? void 0 : e.in) || t6)
  );
}
function aP(t6, e) {
  return Ub(
    se((e == null ? void 0 : e.in) || t6, t6),
    Je((e == null ? void 0 : e.in) || t6)
  );
}
function iP(t6) {
  return Xb(t6, Je(t6));
}
function sP(t6, e) {
  return kd(
    se((e == null ? void 0 : e.in) || t6, t6),
    Je((e == null ? void 0 : e.in) || t6),
    e
  );
}
function oP(t6, e) {
  return Gb(
    se((e == null ? void 0 : e.in) || t6, t6),
    Je((e == null ? void 0 : e.in) || t6)
  );
}
function lP(t6, e) {
  return V$1(t6, e == null ? void 0 : e.in).getDay() === 4;
}
function cP(t6, e) {
  return Ci(
    se((e == null ? void 0 : e.in) || t6, t6),
    Je((e == null ? void 0 : e.in) || t6)
  );
}
function dP(t6, e) {
  return Ci(
    t6,
    Wt(Je((e == null ? void 0 : e.in) || t6), 1),
    e
  );
}
function uP(t6, e) {
  return V$1(t6, e == null ? void 0 : e.in).getDay() === 2;
}
function fP(t6, e) {
  return V$1(t6, e == null ? void 0 : e.in).getDay() === 3;
}
function hP(t6, e, r) {
  const n = +V$1(t6, r == null ? void 0 : r.in), [a, i] = [
    +V$1(e.start, r == null ? void 0 : r.in),
    +V$1(e.end, r == null ? void 0 : r.in)
  ].sort((s, o) => s - o);
  return n >= a && n <= i;
}
function Fo(t6, e, r) {
  return Wt(t6, -e, r);
}
function gP(t6, e) {
  return Ci(
    se((e == null ? void 0 : e.in) || t6, t6),
    Fo(Je((e == null ? void 0 : e.in) || t6), 1)
  );
}
function mP(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in), n = r.getFullYear(), a = 9 + Math.floor(n / 10) * 10;
  return r.setFullYear(a + 1, 0, 0), r.setHours(0, 0, 0, 0), V$1(r, e == null ? void 0 : e.in);
}
function Kb(t6, e) {
  var o, l, c, d;
  const r = vt(), n = (e == null ? void 0 : e.weekStartsOn) ?? ((l = (o = e == null ? void 0 : e.locale) == null ? void 0 : o.options) == null ? void 0 : l.weekStartsOn) ?? r.weekStartsOn ?? ((d = (c = r.locale) == null ? void 0 : c.options) == null ? void 0 : d.weekStartsOn) ?? 0, a = V$1(t6, e == null ? void 0 : e.in), i = a.getDay(), s = (i < n ? -7 : 0) + 6 - (i - n);
  return a.setHours(0, 0, 0, 0), a.setDate(a.getDate() + s), a;
}
function pP(t6, e) {
  return Kb(t6, { ...e, weekStartsOn: 1 });
}
function bP(t6, e) {
  const r = Kr(t6, e), n = se((e == null ? void 0 : e.in) || t6, 0);
  n.setFullYear(r + 1, 0, 4), n.setHours(0, 0, 0, 0);
  const a = Jt(n, e);
  return a.setDate(a.getDate() - 1), a;
}
function yP(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in), n = r.getMonth(), a = n - n % 3 + 3;
  return r.setMonth(a, 0), r.setHours(0, 0, 0, 0), r;
}
function vP(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in), n = r.getFullYear();
  return r.setFullYear(n + 1, 0, 0), r.setHours(0, 0, 0, 0), r;
}
const xP = /(\w)\1*|''|'(''|[^'])+('|$)|./g, wP = /^'([^]*?)'?$/, kP = /''/g, _P = /[a-zA-Z]/;
function OP(t6, e) {
  const r = V$1(t6);
  if (!Ir(r))
    throw new RangeError("Invalid time value");
  const n = e.match(xP);
  return n ? n.map((i) => {
    if (i === "''")
      return "'";
    const s = i[0];
    if (s === "'")
      return SP(i);
    const o = ir[s];
    if (o)
      return o(r, i);
    if (s.match(_P))
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + s + "`"
      );
    return i;
  }).join("") : "";
}
function SP(t6) {
  const e = t6.match(wP);
  return e ? e[1].replace(kP, "'") : t6;
}
function DP({
  years: t6,
  months: e,
  weeks: r,
  days: n,
  hours: a,
  minutes: i,
  seconds: s
}) {
  let o = 0;
  t6 && (o += t6 * Vs), e && (o += e * (Vs / 12)), r && (o += r * 7), n && (o += n);
  let l = o * 24 * 60 * 60;
  return a && (l += a * 60 * 60), i && (l += i * 60), s && (l += s), Math.trunc(l * 1e3);
}
function MP(t6) {
  const e = t6 / Fn;
  return Math.trunc(e);
}
function CP(t6) {
  const e = t6 / Nr;
  return Math.trunc(e);
}
function EP(t6) {
  const e = t6 / ld;
  return Math.trunc(e);
}
function TP(t6) {
  const e = t6 / Gp;
  return Math.trunc(e);
}
function PP(t6) {
  return Math.trunc(t6 * Nr);
}
function RP(t6) {
  return Math.trunc(t6 * cd);
}
function NP(t6) {
  const e = t6 / Kp;
  return Math.trunc(e);
}
function IP(t6) {
  const e = t6 / Qp;
  return Math.trunc(e);
}
function rn(t6, e, r) {
  let n = e - Io(t6, r);
  return n <= 0 && (n += 7), Wt(t6, n, r);
}
function AP(t6, e) {
  return rn(t6, 5, e);
}
function FP(t6, e) {
  return rn(t6, 1, e);
}
function LP(t6, e) {
  return rn(t6, 6, e);
}
function WP(t6, e) {
  return rn(t6, 0, e);
}
function $P(t6, e) {
  return rn(t6, 4, e);
}
function zP(t6, e) {
  return rn(t6, 2, e);
}
function jP(t6, e) {
  return rn(t6, 3, e);
}
function HP(t6, e) {
  const r = () => se(e == null ? void 0 : e.in, NaN), n = (e == null ? void 0 : e.additionalDigits) ?? 2, a = qP(t6);
  let i;
  if (a.date) {
    const c = UP(a.date, n);
    i = XP(c.restDateString, c.year);
  }
  if (!i || isNaN(+i)) return r();
  const s = +i;
  let o = 0, l;
  if (a.time && (o = GP(a.time), isNaN(o)))
    return r();
  if (a.timezone) {
    if (l = KP(a.timezone), isNaN(l)) return r();
  } else {
    const c = new Date(s + o), d = V$1(0, e == null ? void 0 : e.in);
    return d.setFullYear(
      c.getUTCFullYear(),
      c.getUTCMonth(),
      c.getUTCDate()
    ), d.setHours(
      c.getUTCHours(),
      c.getUTCMinutes(),
      c.getUTCSeconds(),
      c.getUTCMilliseconds()
    ), d;
  }
  return V$1(s + o + l, e == null ? void 0 : e.in);
}
const Zi = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
}, BP = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/, YP = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/, VP = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function qP(t6) {
  const e = {}, r = t6.split(Zi.dateTimeDelimiter);
  let n;
  if (r.length > 2)
    return e;
  if (/:/.test(r[0]) ? n = r[0] : (e.date = r[0], n = r[1], Zi.timeZoneDelimiter.test(e.date) && (e.date = t6.split(Zi.timeZoneDelimiter)[0], n = t6.substr(
    e.date.length,
    t6.length
  ))), n) {
    const a = Zi.timezone.exec(n);
    a ? (e.time = n.replace(a[1], ""), e.timezone = a[1]) : e.time = n;
  }
  return e;
}
function UP(t6, e) {
  const r = new RegExp(
    "^(?:(\\d{4}|[+-]\\d{" + (4 + e) + "})|(\\d{2}|[+-]\\d{" + (2 + e) + "})$)"
  ), n = t6.match(r);
  if (!n) return { year: NaN, restDateString: "" };
  const a = n[1] ? parseInt(n[1]) : null, i = n[2] ? parseInt(n[2]) : null;
  return {
    year: i === null ? a : i * 100,
    restDateString: t6.slice((n[1] || n[2]).length)
  };
}
function XP(t6, e) {
  if (e === null) return /* @__PURE__ */ new Date(NaN);
  const r = t6.match(BP);
  if (!r) return /* @__PURE__ */ new Date(NaN);
  const n = !!r[4], a = Ra(r[1]), i = Ra(r[2]) - 1, s = Ra(r[3]), o = Ra(r[4]), l = Ra(r[5]) - 1;
  if (n)
    return t5(e, o, l) ? QP(e, o, l) : /* @__PURE__ */ new Date(NaN);
  {
    const c = /* @__PURE__ */ new Date(0);
    return !ZP(e, i, s) || !e5(e, a) ? /* @__PURE__ */ new Date(NaN) : (c.setUTCFullYear(e, i, Math.max(a, s)), c);
  }
}
function Ra(t6) {
  return t6 ? parseInt(t6) : 1;
}
function GP(t6) {
  const e = t6.match(YP);
  if (!e) return NaN;
  const r = xl(e[1]), n = xl(e[2]), a = xl(e[3]);
  return r5(r, n, a) ? r * Fn + n * Nr + a * 1e3 : NaN;
}
function xl(t6) {
  return t6 && parseFloat(t6.replace(",", ".")) || 0;
}
function KP(t6) {
  if (t6 === "Z") return 0;
  const e = t6.match(VP);
  if (!e) return 0;
  const r = e[1] === "+" ? -1 : 1, n = parseInt(e[2]), a = e[3] && parseInt(e[3]) || 0;
  return n5(n, a) ? r * (n * Fn + a * Nr) : NaN;
}
function QP(t6, e, r) {
  const n = /* @__PURE__ */ new Date(0);
  n.setUTCFullYear(t6, 0, 4);
  const a = n.getUTCDay() || 7, i = (e - 1) * 7 + r + 1 - a;
  return n.setUTCDate(n.getUTCDate() + i), n;
}
const JP = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function Qb(t6) {
  return t6 % 400 === 0 || t6 % 4 === 0 && t6 % 100 !== 0;
}
function ZP(t6, e, r) {
  return e >= 0 && e <= 11 && r >= 1 && r <= (JP[e] || (Qb(t6) ? 29 : 28));
}
function e5(t6, e) {
  return e >= 1 && e <= (Qb(t6) ? 366 : 365);
}
function t5(t6, e, r) {
  return e >= 1 && e <= 53 && r >= 0 && r <= 6;
}
function r5(t6, e, r) {
  return t6 === 24 ? e === 0 && r === 0 : r >= 0 && r < 60 && e >= 0 && e < 60 && t6 >= 0 && t6 < 25;
}
function n5(t6, e) {
  return e >= 0 && e <= 59;
}
function a5(t6, e) {
  const r = t6.match(
    /(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})(?:\.(\d{0,7}))?(?:Z|(.)(\d{2}):?(\d{2})?)?/
  );
  return V$1(
    r ? Date.UTC(
      +r[1],
      +r[2] - 1,
      +r[3],
      +r[4] - (+r[9] || 0) * (r[8] == "-" ? -1 : 1),
      +r[5] - (+r[10] || 0) * (r[8] == "-" ? -1 : 1),
      +r[6],
      +((r[7] || "0") + "00").substring(0, 3)
    ) : NaN,
    e == null ? void 0 : e.in
  );
}
function nn(t6, e, r) {
  let n = Io(t6, r) - e;
  return n <= 0 && (n += 7), Fo(t6, n, r);
}
function i5(t6, e) {
  return nn(t6, 5, e);
}
function s5(t6, e) {
  return nn(t6, 1, e);
}
function o5(t6, e) {
  return nn(t6, 6, e);
}
function l5(t6, e) {
  return nn(t6, 0, e);
}
function c5(t6, e) {
  return nn(t6, 4, e);
}
function d5(t6, e) {
  return nn(t6, 2, e);
}
function u5(t6, e) {
  return nn(t6, 3, e);
}
function f5(t6) {
  return Math.trunc(t6 * Kp);
}
function h5(t6) {
  const e = t6 / Jp;
  return Math.trunc(e);
}
function g5(t6, e) {
  const r = (e == null ? void 0 : e.nearestTo) ?? 1;
  if (r < 1 || r > 12)
    return se((e == null ? void 0 : e.in) || t6, NaN);
  const n = V$1(t6, e == null ? void 0 : e.in), a = n.getMinutes() / 60, i = n.getSeconds() / 60 / 60, s = n.getMilliseconds() / 1e3 / 60 / 60, o = n.getHours() + a + i + s, l = (e == null ? void 0 : e.roundingMethod) ?? "round", d = tn(l)(o / r) * r;
  return n.setHours(d, 0, 0, 0), n;
}
function m5(t6, e) {
  const r = (e == null ? void 0 : e.nearestTo) ?? 1;
  if (r < 1 || r > 30) return se(t6, NaN);
  const n = V$1(t6, e == null ? void 0 : e.in), a = n.getSeconds() / 60, i = n.getMilliseconds() / 1e3 / 60, s = n.getMinutes() + a + i, o = (e == null ? void 0 : e.roundingMethod) ?? "round", c = tn(o)(s / r) * r;
  return n.setMinutes(c, 0, 0), n;
}
function p5(t6) {
  const e = t6 / Co;
  return Math.trunc(e);
}
function b5(t6) {
  return t6 * ld;
}
function y5(t6) {
  const e = t6 / cd;
  return Math.trunc(e);
}
function _d(t6, e, r) {
  const n = V$1(t6, r == null ? void 0 : r.in), a = n.getFullYear(), i = n.getDate(), s = se((r == null ? void 0 : r.in) || t6, 0);
  s.setFullYear(a, e, 15), s.setHours(0, 0, 0, 0);
  const o = Cb(s);
  return n.setMonth(e, Math.min(i, o)), n;
}
function v5(t6, e, r) {
  let n = V$1(t6, r == null ? void 0 : r.in);
  return isNaN(+n) ? se((r == null ? void 0 : r.in) || t6, NaN) : (e.year != null && n.setFullYear(e.year), e.month != null && (n = _d(n, e.month)), e.date != null && n.setDate(e.date), e.hours != null && n.setHours(e.hours), e.minutes != null && n.setMinutes(e.minutes), e.seconds != null && n.setSeconds(e.seconds), e.milliseconds != null && n.setMilliseconds(e.milliseconds), n);
}
function x5(t6, e, r) {
  const n = V$1(t6, r == null ? void 0 : r.in);
  return n.setDate(e), n;
}
function w5(t6, e, r) {
  const n = V$1(t6, r == null ? void 0 : r.in);
  return n.setMonth(0), n.setDate(e), n;
}
function k5(t6) {
  const e = {}, r = vt();
  for (const n in r)
    Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
  for (const n in t6)
    Object.prototype.hasOwnProperty.call(t6, n) && (t6[n] === void 0 ? delete e[n] : e[n] = t6[n]);
  eC(e);
}
function _5(t6, e, r) {
  const n = V$1(t6, r == null ? void 0 : r.in);
  return n.setHours(e), n;
}
function O5(t6, e, r) {
  const n = V$1(t6, r == null ? void 0 : r.in);
  return n.setMilliseconds(e), n;
}
function S5(t6, e, r) {
  const n = V$1(t6, r == null ? void 0 : r.in);
  return n.setMinutes(e), n;
}
function D5(t6, e, r) {
  const n = V$1(t6, r == null ? void 0 : r.in), a = Math.trunc(n.getMonth() / 3) + 1, i = e - a;
  return _d(n, n.getMonth() + i * 3);
}
function M5(t6, e, r) {
  const n = V$1(t6, r == null ? void 0 : r.in);
  return n.setSeconds(e), n;
}
function C5(t6, e, r) {
  var l, c, d, u;
  const n = vt(), a = (r == null ? void 0 : r.firstWeekContainsDate) ?? ((c = (l = r == null ? void 0 : r.locale) == null ? void 0 : l.options) == null ? void 0 : c.firstWeekContainsDate) ?? n.firstWeekContainsDate ?? ((u = (d = n.locale) == null ? void 0 : d.options) == null ? void 0 : u.firstWeekContainsDate) ?? 1, i = pr(
    V$1(t6, r == null ? void 0 : r.in),
    Qs(t6, r),
    r
  ), s = se((r == null ? void 0 : r.in) || t6, 0);
  s.setFullYear(e, 0, a), s.setHours(0, 0, 0, 0);
  const o = Qs(s, r);
  return o.setDate(o.getDate() + i), o;
}
function E5(t6, e, r) {
  const n = V$1(t6, r == null ? void 0 : r.in);
  return isNaN(+n) ? se((r == null ? void 0 : r.in) || t6, NaN) : (n.setFullYear(e), n);
}
function T5(t6, e) {
  const r = V$1(t6, e == null ? void 0 : e.in), n = r.getFullYear(), a = Math.floor(n / 10) * 10;
  return r.setFullYear(a, 0, 1), r.setHours(0, 0, 0, 0), r;
}
function P5(t6) {
  return ua(Date.now(), t6);
}
function R5(t6) {
  const e = Je(t6 == null ? void 0 : t6.in), r = e.getFullYear(), n = e.getMonth(), a = e.getDate(), i = se(t6 == null ? void 0 : t6.in, 0);
  return i.setFullYear(r, n, a + 1), i.setHours(0, 0, 0, 0), i;
}
function N5(t6) {
  const e = Je(t6 == null ? void 0 : t6.in), r = e.getFullYear(), n = e.getMonth(), a = e.getDate(), i = Je(t6 == null ? void 0 : t6.in);
  return i.setFullYear(r, n, a - 1), i.setHours(0, 0, 0, 0), i;
}
function Jb(t6, e, r) {
  return Mi(t6, -e, r);
}
function I5(t6, e, r) {
  const {
    years: n = 0,
    months: a = 0,
    weeks: i = 0,
    days: s = 0,
    hours: o = 0,
    minutes: l = 0,
    seconds: c = 0
  } = e, d = Jb(t6, a + n * 12, r), u = Fo(d, s + i * 7, r), f = l + o * 60, g = (c + f * 60) * 1e3;
  return se((r == null ? void 0 : r.in) || t6, +u - g);
}
function A5(t6, e, r) {
  return nb(t6, -e, r);
}
function F5(t6, e, r) {
  return ab(t6, -e, r);
}
function L5(t6, e, r) {
  return Eo(t6, -e, r);
}
function W5(t6, e, r) {
  return ud(t6, -e, r);
}
function $5(t6, e, r) {
  return fd(t6, -e, r);
}
function z5(t6, e, r) {
  return lb(t6, -e, r);
}
function j5(t6, e, r) {
  return To(t6, -e, r);
}
function H5(t6, e, r) {
  return cb(t6, -e, r);
}
function B5(t6) {
  return Math.trunc(t6 * Up);
}
function Y5(t6) {
  return Math.trunc(t6 * Vs);
}
function V5(t6) {
  return Math.trunc(t6 * Qp);
}
function q5(t6) {
  return Math.trunc(t6 * Jp);
}
const U5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  add: Vn,
  addBusinessDays: nb,
  addDays: Wt,
  addHours: ab,
  addISOWeekYears: ob,
  addMilliseconds: Eo,
  addMinutes: ud,
  addMonths: Mi,
  addQuarters: fd,
  addSeconds: lb,
  addWeeks: To,
  addYears: cb,
  areIntervalsOverlapping: tC,
  clamp: rC,
  closestIndexTo: fb,
  closestTo: nC,
  compareAsc: br,
  compareDesc: aC,
  constructFrom: se,
  constructNow: Je,
  daysToWeeks: iC,
  differenceInBusinessDays: sC,
  differenceInCalendarDays: pr,
  differenceInCalendarISOWeekYears: gb,
  differenceInCalendarISOWeeks: oC,
  differenceInCalendarMonths: Us,
  differenceInCalendarQuarters: gs,
  differenceInCalendarWeeks: Xs,
  differenceInCalendarYears: Za,
  differenceInDays: hd,
  differenceInHours: Gs,
  differenceInISOWeekYears: lC,
  differenceInMilliseconds: gd,
  differenceInMinutes: Ks,
  differenceInMonths: Po,
  differenceInQuarters: cC,
  differenceInSeconds: ta,
  differenceInWeeks: dC,
  differenceInYears: bb,
  eachDayOfInterval: yb,
  eachHourOfInterval: uC,
  eachMinuteOfInterval: fC,
  eachMonthOfInterval: hC,
  eachQuarterOfInterval: gC,
  eachWeekOfInterval: mC,
  eachWeekendOfInterval: bd,
  eachWeekendOfMonth: pC,
  eachWeekendOfYear: bC,
  eachYearOfInterval: yC,
  endOfDay: md,
  endOfDecade: vC,
  endOfHour: xC,
  endOfISOWeek: wC,
  endOfISOWeekYear: kC,
  endOfMinute: _C,
  endOfMonth: pd,
  endOfQuarter: OC,
  endOfSecond: SC,
  endOfToday: DC,
  endOfTomorrow: MC,
  endOfWeek: xb,
  endOfYear: vb,
  endOfYesterday: CC,
  format: Zs,
  formatDate: Zs,
  formatDistance: Sb,
  formatDistanceStrict: Db,
  formatDistanceToNow: yE,
  formatDistanceToNowStrict: vE,
  formatDuration: wE,
  formatISO: kE,
  formatISO9075: _E,
  formatISODuration: OE,
  formatRFC3339: SE,
  formatRFC7231: CE,
  formatRelative: EE,
  formatters: Kl,
  fromUnixTime: TE,
  getDate: Mb,
  getDay: Io,
  getDayOfYear: wb,
  getDaysInMonth: Cb,
  getDaysInYear: PE,
  getDecade: RE,
  getDefaultOptions: Tb,
  getHours: NE,
  getISODay: Pb,
  getISOWeek: vd,
  getISOWeekYear: Kr,
  getISOWeeksInYear: IE,
  getMilliseconds: AE,
  getMinutes: FE,
  getMonth: LE,
  getOverlappingDaysInIntervals: WE,
  getQuarter: Gl,
  getSeconds: $E,
  getTime: zE,
  getUnixTime: jE,
  getWeek: xd,
  getWeekOfMonth: HE,
  getWeekYear: No,
  getWeeksInMonth: BE,
  getYear: YE,
  hoursToMilliseconds: VE,
  hoursToMinutes: qE,
  hoursToSeconds: UE,
  interval: XE,
  intervalToDuration: GE,
  intlFormat: KE,
  intlFormatDistance: JE,
  isAfter: ZE,
  isBefore: eT,
  isDate: hb,
  isEqual: tT,
  isExists: rT,
  isFirstDayOfMonth: nT,
  isFriday: aT,
  isFuture: iT,
  isLastDayOfMonth: pb,
  isLeapYear: Eb,
  isMatch: KT,
  isMonday: QT,
  isPast: JT,
  isSameDay: Ci,
  isSameHour: Bb,
  isSameISOWeek: Yb,
  isSameISOWeekYear: ZT,
  isSameMinute: Vb,
  isSameMonth: qb,
  isSameQuarter: Ub,
  isSameSecond: Xb,
  isSameWeek: kd,
  isSameYear: Gb,
  isSaturday: tb,
  isSunday: rb,
  isThisHour: eP,
  isThisISOWeek: tP,
  isThisMinute: rP,
  isThisMonth: nP,
  isThisQuarter: aP,
  isThisSecond: iP,
  isThisWeek: sP,
  isThisYear: oP,
  isThursday: lP,
  isToday: cP,
  isTomorrow: dP,
  isTuesday: uP,
  isValid: Ir,
  isWednesday: fP,
  isWeekend: ea,
  isWithinInterval: hP,
  isYesterday: gP,
  lastDayOfDecade: mP,
  lastDayOfISOWeek: pP,
  lastDayOfISOWeekYear: bP,
  lastDayOfMonth: Rb,
  lastDayOfQuarter: yP,
  lastDayOfWeek: Kb,
  lastDayOfYear: vP,
  lightFormat: OP,
  lightFormatters: ir,
  longFormatters: Js,
  max: db,
  milliseconds: DP,
  millisecondsToHours: MP,
  millisecondsToMinutes: CP,
  millisecondsToSeconds: EP,
  min: ub,
  minutesToHours: TP,
  minutesToMilliseconds: PP,
  minutesToSeconds: RP,
  monthsToQuarters: NP,
  monthsToYears: IP,
  nextDay: rn,
  nextFriday: AP,
  nextMonday: FP,
  nextSaturday: LP,
  nextSunday: WP,
  nextThursday: $P,
  nextTuesday: zP,
  nextWednesday: jP,
  parse: Hb,
  parseISO: HP,
  parseJSON: a5,
  parsers: jb,
  previousDay: nn,
  previousFriday: i5,
  previousMonday: s5,
  previousSaturday: o5,
  previousSunday: l5,
  previousThursday: c5,
  previousTuesday: d5,
  previousWednesday: u5,
  quartersToMonths: f5,
  quartersToYears: h5,
  roundToNearestHours: g5,
  roundToNearestMinutes: m5,
  secondsToHours: p5,
  secondsToMilliseconds: b5,
  secondsToMinutes: y5,
  set: v5,
  setDate: x5,
  setDay: Ao,
  setDayOfYear: w5,
  setDefaultOptions: k5,
  setHours: _5,
  setISODay: zb,
  setISOWeek: $b,
  setISOWeekYear: sb,
  setMilliseconds: O5,
  setMinutes: S5,
  setMonth: _d,
  setQuarter: D5,
  setSeconds: M5,
  setWeek: Wb,
  setWeekYear: C5,
  setYear: E5,
  startOfDay: ua,
  startOfDecade: T5,
  startOfHour: Jl,
  startOfISOWeek: Jt,
  startOfISOWeekYear: Qr,
  startOfMinute: Zl,
  startOfMonth: Ro,
  startOfQuarter: kn,
  startOfSecond: ec,
  startOfToday: P5,
  startOfTomorrow: R5,
  startOfWeek: dt,
  startOfWeekYear: Qs,
  startOfYear: yd,
  startOfYesterday: N5,
  sub: I5,
  subBusinessDays: A5,
  subDays: Fo,
  subHours: F5,
  subISOWeekYears: mb,
  subMilliseconds: L5,
  subMinutes: W5,
  subMonths: Jb,
  subQuarters: $5,
  subSeconds: z5,
  subWeeks: j5,
  subYears: H5,
  toDate: V$1,
  transpose: Nb,
  weeksToDays: B5,
  yearsToDays: Y5,
  yearsToMonths: V5,
  yearsToQuarters: q5
}, Symbol.toStringTag, { value: "Module" })), Ln = /* @__PURE__ */ H0(U5);
Object.defineProperty(Rr, "__esModule", {
  value: true
});
Rr.rangeShape = Rr.default = void 0;
var dn = X5(React$1), me = Zb(Ar), wl = Zb(en), bt = Ln;
function Zb(t6) {
  return t6 && t6.__esModule ? t6 : { default: t6 };
}
function ey(t6) {
  if (typeof WeakMap != "function") return null;
  var e = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
  return (ey = function(n) {
    return n ? r : e;
  })(t6);
}
function X5(t6, e) {
  if (t6 && t6.__esModule) return t6;
  if (t6 === null || typeof t6 != "object" && typeof t6 != "function") return { default: t6 };
  var r = ey(e);
  if (r && r.has(t6)) return r.get(t6);
  var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var i in t6) if (i !== "default" && Object.prototype.hasOwnProperty.call(t6, i)) {
    var s = a ? Object.getOwnPropertyDescriptor(t6, i) : null;
    s && (s.get || s.set) ? Object.defineProperty(n, i, s) : n[i] = t6[i];
  }
  return n.default = t6, r && r.set(t6, n), n;
}
function tc() {
  return tc = Object.assign ? Object.assign.bind() : function(t6) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (t6[n] = r[n]);
    }
    return t6;
  }, tc.apply(this, arguments);
}
function Na(t6, e, r) {
  return e = G5(e), e in t6 ? Object.defineProperty(t6, e, { value: r, enumerable: true, configurable: true, writable: true }) : t6[e] = r, t6;
}
function G5(t6) {
  var e = K5(t6, "string");
  return typeof e == "symbol" ? e : String(e);
}
function K5(t6, e) {
  if (typeof t6 != "object" || !t6) return t6;
  var r = t6[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(t6, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t6);
}
class Od extends dn.Component {
  constructor(e, r) {
    super(e, r), Na(this, "handleKeyEvent", (n) => {
      const {
        day: a,
        onMouseDown: i,
        onMouseUp: s
      } = this.props;
      [
        13,
        32
        /* enter */
      ].includes(n.keyCode) && (n.type === "keydown" ? i(a) : s(a));
    }), Na(this, "handleMouseEvent", (n) => {
      const {
        day: a,
        disabled: i,
        onPreviewChange: s,
        onMouseEnter: o,
        onMouseDown: l,
        onMouseUp: c
      } = this.props, d = {};
      if (i) {
        s();
        return;
      }
      switch (n.type) {
        case "mouseenter":
          o(a), s(a), d.hover = true;
          break;
        case "blur":
        case "mouseleave":
          d.hover = false;
          break;
        case "mousedown":
          d.active = true, l(a);
          break;
        case "mouseup":
          n.stopPropagation(), d.active = false, c(a);
          break;
        case "focus":
          s(a);
          break;
      }
      Object.keys(d).length && this.setState(d);
    }), Na(this, "getClassNames", () => {
      const {
        isPassive: n,
        isToday: a,
        isWeekend: i,
        isStartOfWeek: s,
        isEndOfWeek: o,
        isStartOfMonth: l,
        isEndOfMonth: c,
        disabled: d,
        styles: u
      } = this.props;
      return (0, wl.default)(u.day, {
        [u.dayPassive]: n,
        [u.dayDisabled]: d,
        [u.dayToday]: a,
        [u.dayWeekend]: i,
        [u.dayStartOfWeek]: s,
        [u.dayEndOfWeek]: o,
        [u.dayStartOfMonth]: l,
        [u.dayEndOfMonth]: c,
        [u.dayHovered]: this.state.hover,
        [u.dayActive]: this.state.active
      });
    }), Na(this, "renderPreviewPlaceholder", () => {
      const {
        preview: n,
        day: a,
        styles: i
      } = this.props;
      if (!n) return null;
      const s = n.startDate ? (0, bt.endOfDay)(n.startDate) : null, o = n.endDate ? (0, bt.startOfDay)(n.endDate) : null, l = (!s || (0, bt.isAfter)(a, s)) && (!o || (0, bt.isBefore)(a, o)), c = !l && (0, bt.isSameDay)(a, s), d = !l && (0, bt.isSameDay)(a, o);
      return /* @__PURE__ */ dn.default.createElement("span", {
        className: (0, wl.default)({
          [i.dayStartPreview]: c,
          [i.dayInPreview]: l,
          [i.dayEndPreview]: d
        }),
        style: {
          color: n.color
        }
      });
    }), Na(this, "renderSelectionPlaceholders", () => {
      const {
        styles: n,
        ranges: a,
        day: i
      } = this.props;
      return this.props.displayMode === "date" ? (0, bt.isSameDay)(this.props.day, this.props.date) ? /* @__PURE__ */ dn.default.createElement("span", {
        className: n.selected,
        style: {
          color: this.props.color
        }
      }) : null : a.reduce((o, l) => {
        let c = l.startDate, d = l.endDate;
        c && d && (0, bt.isBefore)(d, c) && ([c, d] = [d, c]), c = c ? (0, bt.endOfDay)(c) : null, d = d ? (0, bt.startOfDay)(d) : null;
        const u = (!c || (0, bt.isAfter)(i, c)) && (!d || (0, bt.isBefore)(i, d)), f = !u && (0, bt.isSameDay)(i, c), h = !u && (0, bt.isSameDay)(i, d);
        return u || f || h ? [...o, {
          isStartEdge: f,
          isEndEdge: h,
          isInRange: u,
          ...l
        }] : o;
      }, []).map((o, l) => /* @__PURE__ */ dn.default.createElement("span", {
        key: l,
        className: (0, wl.default)({
          [n.startEdge]: o.isStartEdge,
          [n.endEdge]: o.isEndEdge,
          [n.inRange]: o.isInRange
        }),
        style: {
          color: o.color || this.props.color
        }
      }));
    }), this.state = {
      hover: false,
      active: false
    };
  }
  render() {
    const {
      dayContentRenderer: e
    } = this.props;
    return /* @__PURE__ */ dn.default.createElement("button", tc({
      type: "button",
      onMouseEnter: this.handleMouseEvent,
      onMouseLeave: this.handleMouseEvent,
      onFocus: this.handleMouseEvent,
      onMouseDown: this.handleMouseEvent,
      onMouseUp: this.handleMouseEvent,
      onBlur: this.handleMouseEvent,
      onPauseCapture: this.handleMouseEvent,
      onKeyDown: this.handleKeyEvent,
      onKeyUp: this.handleKeyEvent,
      className: this.getClassNames(this.props.styles)
    }, this.props.disabled || this.props.isPassive ? {
      tabIndex: -1
    } : {}, {
      style: {
        color: this.props.color
      }
    }), this.renderSelectionPlaceholders(), this.renderPreviewPlaceholder(), /* @__PURE__ */ dn.default.createElement("span", {
      className: this.props.styles.dayNumber
    }, (e == null ? void 0 : e(this.props.day)) || /* @__PURE__ */ dn.default.createElement("span", null, (0, bt.format)(this.props.day, this.props.dayDisplayFormat))));
  }
}
Od.defaultProps = {};
const Q5 = Rr.rangeShape = me.default.shape({
  startDate: me.default.object,
  endDate: me.default.object,
  color: me.default.string,
  key: me.default.string,
  autoFocus: me.default.bool,
  disabled: me.default.bool,
  showDateDisplay: me.default.bool
});
Od.propTypes = {
  day: me.default.object.isRequired,
  dayDisplayFormat: me.default.string,
  date: me.default.object,
  ranges: me.default.arrayOf(Q5),
  preview: me.default.shape({
    startDate: me.default.object,
    endDate: me.default.object,
    color: me.default.string
  }),
  onPreviewChange: me.default.func,
  previewColor: me.default.string,
  disabled: me.default.bool,
  isPassive: me.default.bool,
  isToday: me.default.bool,
  isWeekend: me.default.bool,
  isStartOfWeek: me.default.bool,
  isEndOfWeek: me.default.bool,
  isStartOfMonth: me.default.bool,
  isEndOfMonth: me.default.bool,
  color: me.default.string,
  displayMode: me.default.oneOf(["dateRange", "date"]),
  styles: me.default.object,
  onMouseDown: me.default.func,
  onMouseUp: me.default.func,
  onMouseEnter: me.default.func,
  dayContentRenderer: me.default.func
};
Rr.default = Od;
var Lo = {}, Lr = {};
Object.defineProperty(Lr, "__esModule", {
  value: true
});
Lr.calcFocusDate = eR;
Lr.findNextRangeIndex = tR;
Lr.generateStyles = nR;
Lr.getMonthDisplayRange = rR;
var J5 = Z5(en), Cr = Ln;
function Z5(t6) {
  return t6 && t6.__esModule ? t6 : { default: t6 };
}
function eR(t6, e) {
  const {
    shownDate: r,
    date: n,
    months: a,
    ranges: i,
    focusedRange: s,
    displayMode: o
  } = e;
  let l;
  if (o === "dateRange") {
    const d = i[s[0]] || {};
    l = {
      start: d.startDate,
      end: d.endDate
    };
  } else
    l = {
      start: n,
      end: n
    };
  l.start = (0, Cr.startOfMonth)(l.start || /* @__PURE__ */ new Date()), l.end = (0, Cr.endOfMonth)(l.end || l.start);
  const c = l.start || l.end || r || /* @__PURE__ */ new Date();
  return t6 ? (0, Cr.differenceInCalendarMonths)(l.start, l.end) > a ? t6 : c : r || c;
}
function tR(t6) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
  const r = t6.findIndex((n, a) => a > e && n.autoFocus !== false && !n.disabled);
  return r !== -1 ? r : t6.findIndex((n) => n.autoFocus !== false && !n.disabled);
}
function rR(t6, e, r) {
  const n = (0, Cr.startOfMonth)(t6, e), a = (0, Cr.endOfMonth)(t6, e), i = (0, Cr.startOfWeek)(n, e);
  let s = (0, Cr.endOfWeek)(a, e);
  return r && (0, Cr.differenceInCalendarDays)(s, i) <= 34 && (s = (0, Cr.addDays)(s, 7)), {
    start: i,
    end: s,
    startDateOfMonth: n,
    endDateOfMonth: a
  };
}
function nR(t6) {
  return t6.length ? t6.filter((r) => !!r).reduce((r, n) => (Object.keys(n).forEach((a) => {
    r[a] = (0, J5.default)(r[a], n[a]);
  }), r), {}) : {};
}
Object.defineProperty(Lo, "__esModule", {
  value: true
});
Lo.default = void 0;
var vn = ny(React$1), Te = iR(Ar), ty = ny(Rr), Xe = Ln, aR = Lr;
function iR(t6) {
  return t6 && t6.__esModule ? t6 : { default: t6 };
}
function ry(t6) {
  if (typeof WeakMap != "function") return null;
  var e = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
  return (ry = function(n) {
    return n ? r : e;
  })(t6);
}
function ny(t6, e) {
  if (t6 && t6.__esModule) return t6;
  if (t6 === null || typeof t6 != "object" && typeof t6 != "function") return { default: t6 };
  var r = ry(e);
  if (r && r.has(t6)) return r.get(t6);
  var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var i in t6) if (i !== "default" && Object.prototype.hasOwnProperty.call(t6, i)) {
    var s = a ? Object.getOwnPropertyDescriptor(t6, i) : null;
    s && (s.get || s.set) ? Object.defineProperty(n, i, s) : n[i] = t6[i];
  }
  return n.default = t6, r && r.set(t6, n), n;
}
function rc() {
  return rc = Object.assign ? Object.assign.bind() : function(t6) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (t6[n] = r[n]);
    }
    return t6;
  }, rc.apply(this, arguments);
}
function sR(t6, e, r) {
  const n = /* @__PURE__ */ new Date();
  return /* @__PURE__ */ vn.default.createElement("div", {
    className: t6.weekDays
  }, (0, Xe.eachDayOfInterval)({
    start: (0, Xe.startOfWeek)(n, e),
    end: (0, Xe.endOfWeek)(n, e)
  }).map((a, i) => /* @__PURE__ */ vn.default.createElement("span", {
    className: t6.weekDay,
    key: i
  }, (0, Xe.format)(a, r, e))));
}
class Sd extends vn.PureComponent {
  render() {
    const e = /* @__PURE__ */ new Date(), {
      displayMode: r,
      focusedRange: n,
      drag: a,
      styles: i,
      disabledDates: s,
      disabledDay: o
    } = this.props, l = this.props.minDate && (0, Xe.startOfDay)(this.props.minDate), c = this.props.maxDate && (0, Xe.endOfDay)(this.props.maxDate), d = (0, aR.getMonthDisplayRange)(this.props.month, this.props.dateOptions, this.props.fixedHeight);
    let u = this.props.ranges;
    if (r === "dateRange" && a.status) {
      let {
        startDate: h,
        endDate: g
      } = a.range;
      u = u.map((m, p) => p !== n[0] ? m : {
        ...m,
        startDate: h,
        endDate: g
      });
    }
    const f = this.props.showPreview && !a.disablePreview;
    return /* @__PURE__ */ vn.default.createElement("div", {
      className: i.month,
      style: this.props.style
    }, this.props.showMonthName ? /* @__PURE__ */ vn.default.createElement("div", {
      className: i.monthName
    }, (0, Xe.format)(this.props.month, this.props.monthDisplayFormat, this.props.dateOptions)) : null, this.props.showWeekDays && sR(i, this.props.dateOptions, this.props.weekdayDisplayFormat), /* @__PURE__ */ vn.default.createElement("div", {
      className: i.days,
      onMouseLeave: this.props.onMouseLeave
    }, (0, Xe.eachDayOfInterval)({
      start: d.start,
      end: d.end
    }).map((h, g) => {
      const m = (0, Xe.isSameDay)(h, d.startDateOfMonth), p = (0, Xe.isSameDay)(h, d.endDateOfMonth), w = l && (0, Xe.isBefore)(h, l) || c && (0, Xe.isAfter)(h, c), b = s.some((v) => (0, Xe.isSameDay)(v, h)), k = o(h);
      return /* @__PURE__ */ vn.default.createElement(ty.default, rc({}, this.props, {
        ranges: u,
        day: h,
        preview: f ? this.props.preview : null,
        isWeekend: (0, Xe.isWeekend)(h, this.props.dateOptions),
        isToday: (0, Xe.isSameDay)(h, e),
        isStartOfWeek: (0, Xe.isSameDay)(h, (0, Xe.startOfWeek)(h, this.props.dateOptions)),
        isEndOfWeek: (0, Xe.isSameDay)(h, (0, Xe.endOfWeek)(h, this.props.dateOptions)),
        isStartOfMonth: m,
        isEndOfMonth: p,
        key: g,
        disabled: w || b || k,
        isPassive: !(0, Xe.isWithinInterval)(h, {
          start: d.startDateOfMonth,
          end: d.endDateOfMonth
        }),
        styles: i,
        onMouseDown: this.props.onDragSelectionStart,
        onMouseUp: this.props.onDragSelectionEnd,
        onMouseEnter: this.props.onDragSelectionMove,
        dragRange: a.range,
        drag: a.status
      }));
    })));
  }
}
Sd.defaultProps = {};
Sd.propTypes = {
  style: Te.default.object,
  styles: Te.default.object,
  month: Te.default.object,
  drag: Te.default.object,
  dateOptions: Te.default.object,
  disabledDates: Te.default.array,
  disabledDay: Te.default.func,
  preview: Te.default.shape({
    startDate: Te.default.object,
    endDate: Te.default.object
  }),
  showPreview: Te.default.bool,
  displayMode: Te.default.oneOf(["dateRange", "date"]),
  minDate: Te.default.object,
  maxDate: Te.default.object,
  ranges: Te.default.arrayOf(ty.rangeShape),
  focusedRange: Te.default.arrayOf(Te.default.number),
  onDragSelectionStart: Te.default.func,
  onDragSelectionEnd: Te.default.func,
  onDragSelectionMove: Te.default.func,
  onMouseLeave: Te.default.func,
  monthDisplayFormat: Te.default.string,
  weekdayDisplayFormat: Te.default.string,
  dayDisplayFormat: Te.default.string,
  showWeekDays: Te.default.bool,
  showMonthName: Te.default.bool,
  fixedHeight: Te.default.bool
};
Lo.default = Sd;
var Wo = {};
Object.defineProperty(Wo, "__esModule", {
  value: true
});
Wo.default = void 0;
var es = lR(React$1), tr = ay(Ar), oR = ay(en), Ia = Ln;
function ay(t6) {
  return t6 && t6.__esModule ? t6 : { default: t6 };
}
function iy(t6) {
  if (typeof WeakMap != "function") return null;
  var e = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
  return (iy = function(n) {
    return n ? r : e;
  })(t6);
}
function lR(t6, e) {
  if (t6 && t6.__esModule) return t6;
  if (t6 === null || typeof t6 != "object" && typeof t6 != "function") return { default: t6 };
  var r = iy(e);
  if (r && r.has(t6)) return r.get(t6);
  var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var i in t6) if (i !== "default" && Object.prototype.hasOwnProperty.call(t6, i)) {
    var s = a ? Object.getOwnPropertyDescriptor(t6, i) : null;
    s && (s.get || s.set) ? Object.defineProperty(n, i, s) : n[i] = t6[i];
  }
  return n.default = t6, r && r.set(t6, n), n;
}
function kl(t6, e, r) {
  return e = cR(e), e in t6 ? Object.defineProperty(t6, e, { value: r, enumerable: true, configurable: true, writable: true }) : t6[e] = r, t6;
}
function cR(t6) {
  var e = dR(t6, "string");
  return typeof e == "symbol" ? e : String(e);
}
function dR(t6, e) {
  if (typeof t6 != "object" || !t6) return t6;
  var r = t6[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(t6, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t6);
}
class Dd extends es.PureComponent {
  constructor(e, r) {
    super(e, r), kl(this, "onKeyDown", (n) => {
      const {
        value: a
      } = this.state;
      n.key === "Enter" && this.update(a);
    }), kl(this, "onChange", (n) => {
      this.setState({
        value: n.target.value,
        changed: true,
        invalid: false
      });
    }), kl(this, "onBlur", () => {
      const {
        value: n
      } = this.state;
      this.update(n);
    }), this.state = {
      invalid: false,
      changed: false,
      value: this.formatDate(e)
    };
  }
  componentDidUpdate(e) {
    const {
      value: r
    } = e;
    (0, Ia.isEqual)(r, this.props.value) || this.setState({
      value: this.formatDate(this.props)
    });
  }
  formatDate(e) {
    let {
      value: r,
      dateDisplayFormat: n,
      dateOptions: a
    } = e;
    return r && (0, Ia.isValid)(r) ? (0, Ia.format)(r, n, a) : "";
  }
  update(e) {
    const {
      invalid: r,
      changed: n
    } = this.state;
    if (r || !n || !e)
      return;
    const {
      onChange: a,
      dateDisplayFormat: i,
      dateOptions: s
    } = this.props, o = (0, Ia.parse)(e, i, /* @__PURE__ */ new Date(), s);
    (0, Ia.isValid)(o) ? this.setState({
      changed: false
    }, () => a(o)) : this.setState({
      invalid: true
    });
  }
  render() {
    const {
      className: e,
      readOnly: r,
      placeholder: n,
      ariaLabel: a,
      disabled: i,
      onFocus: s
    } = this.props, {
      value: o,
      invalid: l
    } = this.state;
    return /* @__PURE__ */ es.default.createElement("span", {
      className: (0, oR.default)("rdrDateInput", e)
    }, /* @__PURE__ */ es.default.createElement("input", {
      readOnly: r,
      disabled: i,
      value: o,
      placeholder: n,
      "aria-label": a,
      onKeyDown: this.onKeyDown,
      onChange: this.onChange,
      onBlur: this.onBlur,
      onFocus: s
    }), l && /* @__PURE__ */ es.default.createElement("span", {
      className: "rdrWarning"
    }, "⚠"));
  }
}
Dd.propTypes = {
  value: tr.default.object,
  placeholder: tr.default.string,
  disabled: tr.default.bool,
  readOnly: tr.default.bool,
  dateOptions: tr.default.object,
  dateDisplayFormat: tr.default.string,
  ariaLabel: tr.default.string,
  className: tr.default.string,
  onFocus: tr.default.func.isRequired,
  onChange: tr.default.func.isRequired
};
Dd.defaultProps = {
  readOnly: true,
  disabled: false,
  dateDisplayFormat: "MMM D, YYYY"
};
Wo.default = Dd;
var sy = {};
(function(t6) {
  (function(e, r) {
    r(t6, React$1, _y);
  })(typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : ZS, function(e, r, n) {
    Object.defineProperty(e, "__esModule", {
      value: true
    }), e.default = void 0;
    function a(N) {
      "@babel/helpers - typeof";
      return a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(R) {
        return typeof R;
      } : function(R) {
        return R && typeof Symbol == "function" && R.constructor === Symbol && R !== Symbol.prototype ? "symbol" : typeof R;
      }, a(N);
    }
    function i(N, R) {
      if (!(N instanceof R)) throw new TypeError("Cannot call a class as a function");
    }
    function s(N, R) {
      for (var P = 0; P < R.length; P++) {
        var O = R[P];
        O.enumerable = O.enumerable || false, O.configurable = true, "value" in O && (O.writable = true), Object.defineProperty(N, b(O.key), O);
      }
    }
    function o(N, R, P) {
      return R && s(N.prototype, R), P && s(N, P), Object.defineProperty(N, "prototype", { writable: false }), N;
    }
    function l(N, R, P) {
      return R = f(R), c(N, u() ? Reflect.construct(R, P || [], f(N).constructor) : R.apply(N, P));
    }
    function c(N, R) {
      if (R && (a(R) == "object" || typeof R == "function")) return R;
      if (R !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
      return d(N);
    }
    function d(N) {
      if (N === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return N;
    }
    function u() {
      try {
        var N = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch {
      }
      return (u = function() {
        return !!N;
      })();
    }
    function f(N) {
      return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(R) {
        return R.__proto__ || Object.getPrototypeOf(R);
      }, f(N);
    }
    function h(N, R) {
      if (typeof R != "function" && R !== null) throw new TypeError("Super expression must either be null or a function");
      N.prototype = Object.create(R && R.prototype, { constructor: { value: N, writable: true, configurable: true } }), Object.defineProperty(N, "prototype", { writable: false }), R && g(N, R);
    }
    function g(N, R) {
      return g = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(P, O) {
        return P.__proto__ = O, P;
      }, g(N, R);
    }
    function m(N, R) {
      var P = Object.keys(N);
      if (Object.getOwnPropertySymbols) {
        var O = Object.getOwnPropertySymbols(N);
        R && (O = O.filter(function(F) {
          return Object.getOwnPropertyDescriptor(N, F).enumerable;
        })), P.push.apply(P, O);
      }
      return P;
    }
    function p(N) {
      for (var R = 1; R < arguments.length; R++) {
        var P = arguments[R] != null ? arguments[R] : {};
        R % 2 ? m(Object(P), true).forEach(function(O) {
          w(N, O, P[O]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(N, Object.getOwnPropertyDescriptors(P)) : m(Object(P)).forEach(function(O) {
          Object.defineProperty(N, O, Object.getOwnPropertyDescriptor(P, O));
        });
      }
      return N;
    }
    function w(N, R, P) {
      return (R = b(R)) in N ? Object.defineProperty(N, R, { value: P, enumerable: true, configurable: true, writable: true }) : N[R] = P, N;
    }
    function b(N) {
      var R = k(N, "string");
      return a(R) == "symbol" ? R : R + "";
    }
    function k(N, R) {
      if (a(N) != "object" || !N) return N;
      var P = N[Symbol.toPrimitive];
      if (P !== void 0) {
        var O = P.call(N, R);
        if (a(O) != "object") return O;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (R === "string" ? String : Number)(N);
    }
    var v = {
      x: "clientWidth",
      y: "clientHeight"
    }, x = {
      x: "clientTop",
      y: "clientLeft"
    }, _ = {
      x: "innerWidth",
      y: "innerHeight"
    }, T = {
      x: "offsetWidth",
      y: "offsetHeight"
    }, S = {
      x: "offsetLeft",
      y: "offsetTop"
    }, C = {
      x: "overflowX",
      y: "overflowY"
    }, D = {
      x: "scrollWidth",
      y: "scrollHeight"
    }, z = {
      x: "scrollLeft",
      y: "scrollTop"
    }, A = {
      x: "width",
      y: "height"
    }, L = function() {
    }, M = function() {
      if (typeof window > "u") return false;
      var N = false;
      try {
        document.createElement("div").addEventListener("test", L, {
          get passive() {
            return N = true, false;
          }
        });
      } catch {
      }
      return N;
    }() ? {
      passive: true
    } : false, I = "ReactList failed to reach a stable state.", W = 40, B = function(R, P) {
      for (var O in P) if (R[O] !== P[O]) return false;
      return true;
    }, U = function(R) {
      for (var P = R.props.axis, O = R.getEl(), F = C[P]; O = O.parentElement; )
        switch (window.getComputedStyle(O)[F]) {
          case "auto":
          case "scroll":
          case "overlay":
            return O;
        }
      return window;
    }, J = function(R) {
      var P = R.props.axis, O = R.scrollParent;
      return O === window ? window[_[P]] : O[v[P]];
    }, E = function(R, P) {
      var O = R.length, F = R.minSize, X = R.type, q = P.from, G = P.size, Z = P.itemsPerRow;
      G = Math.max(G, F);
      var ne = G % Z;
      return ne && (G += Z - ne), G > O && (G = O), q = X === "simple" || !q ? 0 : Math.max(Math.min(q, O - G), 0), (ne = q % Z) && (q -= ne, G += ne), q === P.from && G === P.size ? P : p(p({}, P), {}, {
        from: q,
        size: G
      });
    }, j = e.default = /* @__PURE__ */ function(N) {
      function R(P) {
        var O;
        return i(this, R), O = l(this, R, [P]), O.state = E(P, {
          itemsPerRow: 1,
          from: P.initialIndex,
          size: 0
        }), O.cache = {}, O.cachedScrollPosition = null, O.prevPrevState = {}, O.unstable = false, O.updateCounter = 0, O;
      }
      return h(R, N), o(R, [{
        key: "componentDidMount",
        value: function() {
          this.updateFrameAndClearCache = this.updateFrameAndClearCache.bind(this), window.addEventListener("resize", this.updateFrameAndClearCache), this.updateFrame(this.scrollTo.bind(this, this.props.initialIndex));
        }
      }, {
        key: "componentDidUpdate",
        value: function(O) {
          var F = this;
          if (this.props.axis !== O.axis && this.clearSizeCache(), !this.unstable) {
            if (++this.updateCounter > W)
              return this.unstable = true, console.error(I);
            this.updateCounterTimeoutId || (this.updateCounterTimeoutId = setTimeout(function() {
              F.updateCounter = 0, delete F.updateCounterTimeoutId;
            }, 0)), this.updateFrame();
          }
        }
      }, {
        key: "maybeSetState",
        value: function(O, F) {
          if (B(this.state, O)) return F();
          this.setState(O, F);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          window.removeEventListener("resize", this.updateFrameAndClearCache), this.scrollParent.removeEventListener("scroll", this.updateFrameAndClearCache, M), this.scrollParent.removeEventListener("mousewheel", L, M);
        }
      }, {
        key: "getOffset",
        value: function(O) {
          var F = this.props.axis, X = O[x[F]] || 0, q = S[F];
          do
            X += O[q] || 0;
          while (O = O.offsetParent);
          return X;
        }
      }, {
        key: "getEl",
        value: function() {
          return this.el || this.items;
        }
      }, {
        key: "getScrollPosition",
        value: function() {
          if (typeof this.cachedScrollPosition == "number")
            return this.cachedScrollPosition;
          var O = this.scrollParent, F = this.props.axis, X = z[F], q = O === window ? (
            // Firefox always returns document.body[scrollKey] as 0 and Chrome/Safari
            // always return document.documentElement[scrollKey] as 0, so take
            // whichever has a value.
            document.body[X] || document.documentElement[X]
          ) : O[X], G = this.getScrollSize() - this.props.scrollParentViewportSizeGetter(this), Z = Math.max(0, Math.min(q, G)), ne = this.getEl();
          return this.cachedScrollPosition = this.getOffset(O) + Z - this.getOffset(ne), this.cachedScrollPosition;
        }
      }, {
        key: "setScroll",
        value: function(O) {
          var F = this.scrollParent, X = this.props.axis;
          if (O += this.getOffset(this.getEl()), F === window) return window.scrollTo(0, O);
          O -= this.getOffset(this.scrollParent), F[z[X]] = O;
        }
      }, {
        key: "getScrollSize",
        value: function() {
          var O = this.scrollParent, F = document, X = F.body, q = F.documentElement, G = D[this.props.axis];
          return O === window ? Math.max(X[G], q[G]) : O[G];
        }
      }, {
        key: "hasDeterminateSize",
        value: function() {
          var O = this.props, F = O.itemSizeGetter, X = O.type;
          return X === "uniform" || F;
        }
      }, {
        key: "getStartAndEnd",
        value: function() {
          var O = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props.threshold, F = this.getScrollPosition(), X = Math.max(0, F - O), q = F + this.props.scrollParentViewportSizeGetter(this) + O;
          return this.hasDeterminateSize() && (q = Math.min(q, this.getSpaceBefore(this.props.length))), {
            start: X,
            end: q
          };
        }
      }, {
        key: "getItemSizeAndItemsPerRow",
        value: function() {
          var O = this.props, F = O.axis, X = O.useStaticSize, q = this.state, G = q.itemSize, Z = q.itemsPerRow;
          if (X && G && Z)
            return {
              itemSize: G,
              itemsPerRow: Z
            };
          var ne = this.items.children;
          if (!ne.length) return {};
          var H = ne[0], ae = H[T[F]], re = Math.abs(ae - G);
          if ((isNaN(re) || re >= 1) && (G = ae), !G) return {};
          var le = S[F], fe = H[le];
          Z = 1;
          for (var de = ne[Z]; de && de[le] === fe; de = ne[Z])
            ++Z;
          return {
            itemSize: G,
            itemsPerRow: Z
          };
        }
      }, {
        key: "clearSizeCache",
        value: function() {
          this.cachedScrollPosition = null;
        }
        // Called by 'scroll' and 'resize' events, clears scroll position cache.
      }, {
        key: "updateFrameAndClearCache",
        value: function(O) {
          return this.clearSizeCache(), this.updateFrame(O);
        }
      }, {
        key: "updateFrame",
        value: function(O) {
          switch (this.updateScrollParent(), typeof O != "function" && (O = L), this.props.type) {
            case "simple":
              return this.updateSimpleFrame(O);
            case "variable":
              return this.updateVariableFrame(O);
            case "uniform":
              return this.updateUniformFrame(O);
          }
        }
      }, {
        key: "updateScrollParent",
        value: function() {
          var O = this.scrollParent;
          this.scrollParent = this.props.scrollParentGetter(this), O !== this.scrollParent && (O && (O.removeEventListener("scroll", this.updateFrameAndClearCache), O.removeEventListener("mousewheel", L)), this.clearSizeCache(), this.scrollParent.addEventListener("scroll", this.updateFrameAndClearCache, M), this.scrollParent.addEventListener("mousewheel", L, M));
        }
      }, {
        key: "updateSimpleFrame",
        value: function(O) {
          var F = this.getStartAndEnd(), X = F.end, q = this.items.children, G = 0;
          if (q.length) {
            var Z = this.props.axis, ne = q[0], H = q[q.length - 1];
            G = this.getOffset(H) + H[T[Z]] - this.getOffset(ne);
          }
          if (G > X) return O();
          var ae = this.props, re = ae.pageSize, le = ae.length, fe = Math.min(this.state.size + re, le);
          this.maybeSetState({
            size: fe
          }, O);
        }
      }, {
        key: "updateVariableFrame",
        value: function(O) {
          this.props.itemSizeGetter || this.cacheSizes();
          for (var F = this.getStartAndEnd(), X = F.start, q = F.end, G = this.props, Z = G.length, ne = G.pageSize, H = 0, ae = 0, re = 0, le = Z - 1; ae < le; ) {
            var fe = this.getSizeOfItem(ae);
            if (fe == null || H + fe > X) break;
            H += fe, ++ae;
          }
          for (var de = Z - ae; re < de && H < q; ) {
            var ie = this.getSizeOfItem(ae + re);
            if (ie == null) {
              re = Math.min(re + ne, de);
              break;
            }
            H += ie, ++re;
          }
          this.maybeSetState(E(this.props, {
            from: ae,
            itemsPerRow: 1,
            size: re
          }), O);
        }
      }, {
        key: "updateUniformFrame",
        value: function(O) {
          var F = this.getItemSizeAndItemsPerRow(), X = F.itemSize, q = F.itemsPerRow;
          if (!X || !q) return O();
          var G = this.getStartAndEnd(), Z = G.start, ne = G.end, H = E(this.props, {
            from: Math.floor(Z / X) * q,
            size: (Math.ceil((ne - Z) / X) + 1) * q,
            itemsPerRow: q
          }), ae = H.from, re = H.size;
          return this.maybeSetState({
            itemsPerRow: q,
            from: ae,
            itemSize: X,
            size: re
          }, O);
        }
      }, {
        key: "getSpaceBefore",
        value: function(O) {
          var F = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          if (F[O] != null) return F[O];
          var X = this.state, q = X.itemSize, G = X.itemsPerRow;
          if (q)
            return F[O] = Math.floor(O / G) * q;
          for (var Z = O; Z > 0 && F[--Z] == null; ) ;
          for (var ne = F[Z] || 0, H = Z; H < O; ++H) {
            F[H] = ne;
            var ae = this.getSizeOfItem(H);
            if (ae == null) break;
            ne += ae;
          }
          return F[O] = ne;
        }
      }, {
        key: "cacheSizes",
        value: function() {
          for (var O = this.cache, F = this.state.from, X = this.items.children, q = T[this.props.axis], G = 0, Z = X.length; G < Z; ++G)
            O[F + G] = X[G][q];
        }
      }, {
        key: "getSizeOfItem",
        value: function(O) {
          var F = this.cache, X = this.items, q = this.props, G = q.axis, Z = q.itemSizeGetter, ne = q.itemSizeEstimator, H = q.type, ae = this.state, re = ae.from, le = ae.itemSize, fe = ae.size;
          if (le) return le;
          if (Z) return Z(O);
          if (O in F) return F[O];
          if (H === "simple" && O >= re && O < re + fe && X) {
            var de = X.children[O - re];
            if (de) return de[T[G]];
          }
          if (ne) return ne(O, F);
        }
      }, {
        key: "scrollTo",
        value: function(O) {
          O != null && this.setScroll(this.getSpaceBefore(O));
        }
      }, {
        key: "scrollAround",
        value: function(O) {
          var F = this.getScrollPosition(), X = this.getSpaceBefore(O), q = X - this.props.scrollParentViewportSizeGetter(this) + this.getSizeOfItem(O), G = Math.min(q, X), Z = Math.max(q, X);
          if (F <= G) return this.setScroll(G);
          if (F > Z) return this.setScroll(Z);
        }
      }, {
        key: "getVisibleRange",
        value: function() {
          for (var O = this.state, F = O.from, X = O.size, q = this.getStartAndEnd(0), G = q.start, Z = q.end, ne = {}, H, ae, re = F; re < F + X; ++re) {
            var le = this.getSpaceBefore(re, ne), fe = le + this.getSizeOfItem(re);
            H == null && fe > G && (H = re), H != null && le < Z && (ae = re);
          }
          return [H, ae];
        }
      }, {
        key: "renderItems",
        value: function() {
          for (var O = this, F = this.props, X = F.itemRenderer, q = F.itemsRenderer, G = this.state, Z = G.from, ne = G.size, H = [], ae = 0; ae < ne; ++ae) H.push(X(Z + ae, ae));
          return q(H, function(re) {
            return O.items = re;
          });
        }
      }, {
        key: "render",
        value: function() {
          var O = this, F = this.props, X = F.axis, q = F.length, G = F.type, Z = F.useTranslate3d, ne = this.state, H = ne.from, ae = ne.itemsPerRow, re = this.renderItems();
          if (G === "simple") return re;
          var le = {
            position: "relative"
          }, fe = {}, de = Math.ceil(q / ae) * ae, ie = this.getSpaceBefore(de, fe);
          ie && (le[A[X]] = ie, X === "x" && (le.overflowX = "hidden"));
          var $e = this.getSpaceBefore(H, fe), ge = X === "x" ? $e : 0, Fe = X === "y" ? $e : 0, je = Z ? "translate3d(".concat(ge, "px, ").concat(Fe, "px, 0)") : "translate(".concat(ge, "px, ").concat(Fe, "px)"), Ye = {
            msTransform: je,
            WebkitTransform: je,
            transform: je
          };
          return /* @__PURE__ */ (0, n.jsx)("div", {
            style: le,
            ref: function(Tt) {
              return O.el = Tt;
            },
            children: /* @__PURE__ */ (0, n.jsx)("div", {
              style: Ye,
              children: re
            })
          });
        }
      }], [{
        key: "getDerivedStateFromProps",
        value: function(O, F) {
          var X = E(O, F);
          return X === F ? null : X;
        }
      }]);
    }(r.Component);
    w(j, "displayName", "ReactList"), w(j, "defaultProps", {
      axis: "y",
      itemRenderer: function(R, P) {
        return /* @__PURE__ */ (0, n.jsx)("div", {
          children: R
        }, P);
      },
      itemsRenderer: function(R, P) {
        return /* @__PURE__ */ (0, n.jsx)("div", {
          ref: P,
          children: R
        });
      },
      length: 0,
      minSize: 1,
      pageSize: 10,
      scrollParentGetter: U,
      scrollParentViewportSizeGetter: J,
      threshold: 100,
      type: "simple",
      useStaticSize: false,
      useTranslate3d: false
    });
  });
})(sy);
function uR(t6, e) {
  if (t6 === e)
    return true;
  if (!t6 || !e)
    return false;
  var r = Object.keys(t6), n = Object.keys(e), a = r.length;
  if (n.length !== a)
    return false;
  for (var i = 0; i < a; i++) {
    var s = r[i];
    if (t6[s] !== e[s] || !Object.prototype.hasOwnProperty.call(e, s))
      return false;
  }
  return true;
}
function fR(t6, e) {
  if (t6 === e)
    return true;
  if (!t6 || !e)
    return false;
  var r = t6.length;
  if (e.length !== r)
    return false;
  for (var n = 0; n < r; n++)
    if (t6[n] !== e[n])
      return false;
  return true;
}
const hR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  shallowEqualArrays: fR,
  shallowEqualObjects: uR
}, Symbol.toStringTag, { value: "Module" })), gR = /* @__PURE__ */ H0(hR);
var Md = {}, Cd = {};
Cd.formatDistance = void 0;
const mR = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
}, pR = (t6, e, r) => {
  let n;
  const a = mR[t6];
  return typeof a == "string" ? n = a : e === 1 ? n = a.one : n = a.other.replace("{{count}}", e.toString()), r != null && r.addSuffix ? r.comparison && r.comparison > 0 ? "in " + n : n + " ago" : n;
};
Cd.formatDistance = pR;
var Ed = {}, oy = {};
oy.buildFormatLongFn = bR;
function bR(t6) {
  return (e = {}) => {
    const r = e.width ? String(e.width) : t6.defaultWidth;
    return t6.formats[r] || t6.formats[t6.defaultWidth];
  };
}
Ed.formatLong = void 0;
var _l = oy;
const yR = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
}, vR = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
}, xR = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
Ed.formatLong = {
  date: (0, _l.buildFormatLongFn)({
    formats: yR,
    defaultWidth: "full"
  }),
  time: (0, _l.buildFormatLongFn)({
    formats: vR,
    defaultWidth: "full"
  }),
  dateTime: (0, _l.buildFormatLongFn)({
    formats: xR,
    defaultWidth: "full"
  })
};
var Td = {};
Td.formatRelative = void 0;
const wR = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
}, kR = (t6, e, r, n) => wR[t6];
Td.formatRelative = kR;
var Pd = {}, ly = {};
ly.buildLocalizeFn = _R;
function _R(t6) {
  return (e, r) => {
    const n = r != null && r.context ? String(r.context) : "standalone";
    let a;
    if (n === "formatting" && t6.formattingValues) {
      const s = t6.defaultFormattingWidth || t6.defaultWidth, o = r != null && r.width ? String(r.width) : s;
      a = t6.formattingValues[o] || t6.formattingValues[s];
    } else {
      const s = t6.defaultWidth, o = r != null && r.width ? String(r.width) : t6.defaultWidth;
      a = t6.values[o] || t6.values[s];
    }
    const i = t6.argumentCallback ? t6.argumentCallback(e) : e;
    return a[i];
  };
}
Pd.localize = void 0;
var Aa = ly;
const OR = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
}, SR = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
}, DR = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
}, MR = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
}, CR = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
}, ER = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
}, TR = (t6, e) => {
  const r = Number(t6), n = r % 100;
  if (n > 20 || n < 10)
    switch (n % 10) {
      case 1:
        return r + "st";
      case 2:
        return r + "nd";
      case 3:
        return r + "rd";
    }
  return r + "th";
};
Pd.localize = {
  ordinalNumber: TR,
  era: (0, Aa.buildLocalizeFn)({
    values: OR,
    defaultWidth: "wide"
  }),
  quarter: (0, Aa.buildLocalizeFn)({
    values: SR,
    defaultWidth: "wide",
    argumentCallback: (t6) => t6 - 1
  }),
  month: (0, Aa.buildLocalizeFn)({
    values: DR,
    defaultWidth: "wide"
  }),
  day: (0, Aa.buildLocalizeFn)({
    values: MR,
    defaultWidth: "wide"
  }),
  dayPeriod: (0, Aa.buildLocalizeFn)({
    values: CR,
    defaultWidth: "wide",
    formattingValues: ER,
    defaultFormattingWidth: "wide"
  })
};
var Rd = {}, cy = {};
cy.buildMatchFn = PR;
function PR(t6) {
  return (e, r = {}) => {
    const n = r.width, a = n && t6.matchPatterns[n] || t6.matchPatterns[t6.defaultMatchWidth], i = e.match(a);
    if (!i)
      return null;
    const s = i[0], o = n && t6.parsePatterns[n] || t6.parsePatterns[t6.defaultParseWidth], l = Array.isArray(o) ? NR(o, (u) => u.test(s)) : (
      // [TODO] -- I challenge you to fix the type
      RR(o, (u) => u.test(s))
    );
    let c;
    c = t6.valueCallback ? t6.valueCallback(l) : l, c = r.valueCallback ? (
      // [TODO] -- I challenge you to fix the type
      r.valueCallback(c)
    ) : c;
    const d = e.slice(s.length);
    return { value: c, rest: d };
  };
}
function RR(t6, e) {
  for (const r in t6)
    if (Object.prototype.hasOwnProperty.call(t6, r) && e(t6[r]))
      return r;
}
function NR(t6, e) {
  for (let r = 0; r < t6.length; r++)
    if (e(t6[r]))
      return r;
}
var dy = {};
dy.buildMatchPatternFn = IR;
function IR(t6) {
  return (e, r = {}) => {
    const n = e.match(t6.matchPattern);
    if (!n) return null;
    const a = n[0], i = e.match(t6.parsePattern);
    if (!i) return null;
    let s = t6.valueCallback ? t6.valueCallback(i[0]) : i[0];
    s = r.valueCallback ? r.valueCallback(s) : s;
    const o = e.slice(a.length);
    return { value: s, rest: o };
  };
}
Rd.match = void 0;
var Fa = cy, AR = dy;
const FR = /^(\d+)(th|st|nd|rd)?/i, LR = /\d+/i, WR = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
}, $R = {
  any: [/^b/i, /^(a|c)/i]
}, zR = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
}, jR = {
  any: [/1/i, /2/i, /3/i, /4/i]
}, HR = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
}, BR = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
}, YR = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
}, VR = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
}, qR = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
}, UR = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
Rd.match = {
  ordinalNumber: (0, AR.buildMatchPatternFn)({
    matchPattern: FR,
    parsePattern: LR,
    valueCallback: (t6) => parseInt(t6, 10)
  }),
  era: (0, Fa.buildMatchFn)({
    matchPatterns: WR,
    defaultMatchWidth: "wide",
    parsePatterns: $R,
    defaultParseWidth: "any"
  }),
  quarter: (0, Fa.buildMatchFn)({
    matchPatterns: zR,
    defaultMatchWidth: "wide",
    parsePatterns: jR,
    defaultParseWidth: "any",
    valueCallback: (t6) => t6 + 1
  }),
  month: (0, Fa.buildMatchFn)({
    matchPatterns: HR,
    defaultMatchWidth: "wide",
    parsePatterns: BR,
    defaultParseWidth: "any"
  }),
  day: (0, Fa.buildMatchFn)({
    matchPatterns: YR,
    defaultMatchWidth: "wide",
    parsePatterns: VR,
    defaultParseWidth: "any"
  }),
  dayPeriod: (0, Fa.buildMatchFn)({
    matchPatterns: qR,
    defaultMatchWidth: "any",
    parsePatterns: UR,
    defaultParseWidth: "any"
  })
};
Md.enUS = void 0;
var XR = Cd, GR = Ed, KR = Td, QR = Pd, JR = Rd;
Md.enUS = {
  code: "en-US",
  formatDistance: XR.formatDistance,
  formatLong: GR.formatLong,
  formatRelative: KR.formatRelative,
  localize: QR.localize,
  match: JR.match,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
var Wn = {};
Object.defineProperty(Wn, "__esModule", {
  value: true
});
Wn.default = void 0;
Wn.default = {
  dateRangeWrapper: "rdrDateRangeWrapper",
  calendarWrapper: "rdrCalendarWrapper",
  dateDisplay: "rdrDateDisplay",
  dateDisplayItem: "rdrDateDisplayItem",
  dateDisplayItemActive: "rdrDateDisplayItemActive",
  monthAndYearWrapper: "rdrMonthAndYearWrapper",
  monthAndYearPickers: "rdrMonthAndYearPickers",
  nextPrevButton: "rdrNextPrevButton",
  month: "rdrMonth",
  weekDays: "rdrWeekDays",
  weekDay: "rdrWeekDay",
  days: "rdrDays",
  day: "rdrDay",
  dayNumber: "rdrDayNumber",
  dayPassive: "rdrDayPassive",
  dayToday: "rdrDayToday",
  dayStartOfWeek: "rdrDayStartOfWeek",
  dayEndOfWeek: "rdrDayEndOfWeek",
  daySelected: "rdrDaySelected",
  dayDisabled: "rdrDayDisabled",
  dayStartOfMonth: "rdrDayStartOfMonth",
  dayEndOfMonth: "rdrDayEndOfMonth",
  dayWeekend: "rdrDayWeekend",
  dayStartPreview: "rdrDayStartPreview",
  dayInPreview: "rdrDayInPreview",
  dayEndPreview: "rdrDayEndPreview",
  dayHovered: "rdrDayHovered",
  dayActive: "rdrDayActive",
  inRange: "rdrInRange",
  endEdge: "rdrEndEdge",
  startEdge: "rdrStartEdge",
  prevButton: "rdrPprevButton",
  nextButton: "rdrNextButton",
  selected: "rdrSelected",
  months: "rdrMonths",
  monthPicker: "rdrMonthPicker",
  yearPicker: "rdrYearPicker",
  dateDisplayWrapper: "rdrDateDisplayWrapper",
  definedRangesWrapper: "rdrDefinedRangesWrapper",
  staticRanges: "rdrStaticRanges",
  staticRange: "rdrStaticRange",
  inputRanges: "rdrInputRanges",
  inputRange: "rdrInputRange",
  inputRangeInput: "rdrInputRangeInput",
  dateRangePickerWrapper: "rdrDateRangePickerWrapper",
  staticRangeLabel: "rdrStaticRangeLabel",
  staticRangeSelected: "rdrStaticRangeSelected",
  monthName: "rdrMonthName",
  infiniteMonths: "rdrInfiniteMonths",
  monthsVertical: "rdrMonthsVertical",
  monthsHorizontal: "rdrMonthsHorizontal"
};
var $o = {};
Object.defineProperty($o, "__esModule", {
  value: true
});
$o.ariaLabelsShape = void 0;
var kr = ZR(Ar);
function ZR(t6) {
  return t6 && t6.__esModule ? t6 : { default: t6 };
}
$o.ariaLabelsShape = kr.default.shape({
  dateInput: kr.default.objectOf(kr.default.shape({
    startDate: kr.default.string,
    endDate: kr.default.string
  })),
  monthPicker: kr.default.string,
  yearPicker: kr.default.string,
  prevButton: kr.default.string,
  nextButton: kr.default.string
});
Object.defineProperty(Si, "__esModule", {
  value: true
});
Si.default = void 0;
var Me = sN(React$1), ce = xa(Ar), eN = Rr, Fh = xa(Lo), Lh = xa(Wo), ts = Lr, un = xa(en), tN = xa(sy), rN = gR, Ie = Ln, nN = Md, aN = xa(Wn), iN = $o;
function xa(t6) {
  return t6 && t6.__esModule ? t6 : { default: t6 };
}
function uy(t6) {
  if (typeof WeakMap != "function") return null;
  var e = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
  return (uy = function(n) {
    return n ? r : e;
  })(t6);
}
function sN(t6, e) {
  if (t6 && t6.__esModule) return t6;
  if (t6 === null || typeof t6 != "object" && typeof t6 != "function") return { default: t6 };
  var r = uy(e);
  if (r && r.has(t6)) return r.get(t6);
  var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var i in t6) if (i !== "default" && Object.prototype.hasOwnProperty.call(t6, i)) {
    var s = a ? Object.getOwnPropertyDescriptor(t6, i) : null;
    s && (s.get || s.set) ? Object.defineProperty(n, i, s) : n[i] = t6[i];
  }
  return n.default = t6, r && r.set(t6, n), n;
}
function to() {
  return to = Object.assign ? Object.assign.bind() : function(t6) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (t6[n] = r[n]);
    }
    return t6;
  }, to.apply(this, arguments);
}
function zt(t6, e, r) {
  return e = oN(e), e in t6 ? Object.defineProperty(t6, e, { value: r, enumerable: true, configurable: true, writable: true }) : t6[e] = r, t6;
}
function oN(t6) {
  var e = lN(t6, "string");
  return typeof e == "symbol" ? e : String(e);
}
function lN(t6, e) {
  if (typeof t6 != "object" || !t6) return t6;
  var r = t6[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(t6, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t6);
}
class fa extends Me.PureComponent {
  constructor(e, r) {
    var n;
    super(e, r), n = this, zt(this, "focusToDate", function(a) {
      let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : n.props, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      if (!i.scroll.enabled) {
        if (s && i.preventSnapRefocus) {
          const c = (0, Ie.differenceInCalendarMonths)(a, n.state.focusedDate), d = i.calendarFocus === "forwards" && c >= 0, u = i.calendarFocus === "backwards" && c <= 0;
          if ((d || u) && Math.abs(c) < i.months)
            return;
        }
        n.setState({
          focusedDate: a
        });
        return;
      }
      const o = (0, Ie.differenceInCalendarMonths)(a, i.minDate, n.dateOptions), l = n.list.getVisibleRange();
      s && l.includes(o) || (n.isFirstRender = true, n.list.scrollTo(o), n.setState({
        focusedDate: a
      }));
    }), zt(this, "updateShownDate", function() {
      let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : n.props;
      const i = a.scroll.enabled ? {
        ...a,
        months: n.list.getVisibleRange().length
      } : a, s = (0, ts.calcFocusDate)(n.state.focusedDate, i);
      n.focusToDate(s, i);
    }), zt(this, "updatePreview", (a) => {
      if (!a) {
        this.setState({
          preview: null
        });
        return;
      }
      const i = {
        startDate: a,
        endDate: a,
        color: this.props.color
      };
      this.setState({
        preview: i
      });
    }), zt(this, "changeShownDate", function(a) {
      let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "set";
      const {
        focusedDate: s
      } = n.state, {
        onShownDateChange: o,
        minDate: l,
        maxDate: c
      } = n.props, d = {
        monthOffset: () => (0, Ie.addMonths)(s, a),
        setMonth: () => (0, Ie.setMonth)(s, a),
        setYear: () => (0, Ie.setYear)(s, a),
        set: () => a
      }, u = (0, Ie.min)([(0, Ie.max)([d[i](), l]), c]);
      n.focusToDate(u, n.props, false), o && o(u);
    }), zt(this, "handleRangeFocusChange", (a, i) => {
      this.props.onRangeFocusChange && this.props.onRangeFocusChange([a, i]);
    }), zt(this, "handleScroll", () => {
      const {
        onShownDateChange: a,
        minDate: i
      } = this.props, {
        focusedDate: s
      } = this.state, {
        isFirstRender: o
      } = this, l = this.list.getVisibleRange();
      if (l[0] === void 0) return;
      const c = (0, Ie.addMonths)(i, l[0] || 0);
      !(0, Ie.isSameMonth)(c, s) && !o && (this.setState({
        focusedDate: c
      }), a && a(c)), this.isFirstRender = false;
    }), zt(this, "renderMonthAndYear", (a, i, s) => {
      const {
        showMonthArrow: o,
        minDate: l,
        maxDate: c,
        showMonthAndYearPickers: d,
        ariaLabels: u
      } = s, f = (c || fa.defaultProps.maxDate).getFullYear(), h = (l || fa.defaultProps.minDate).getFullYear(), g = this.styles;
      return /* @__PURE__ */ Me.default.createElement("div", {
        onMouseUp: (m) => m.stopPropagation(),
        className: g.monthAndYearWrapper
      }, o ? /* @__PURE__ */ Me.default.createElement("button", {
        type: "button",
        className: (0, un.default)(g.nextPrevButton, g.prevButton),
        onClick: () => i(-1, "monthOffset"),
        "aria-label": u.prevButton
      }, /* @__PURE__ */ Me.default.createElement("i", null)) : null, d ? /* @__PURE__ */ Me.default.createElement("span", {
        className: g.monthAndYearPickers
      }, /* @__PURE__ */ Me.default.createElement("span", {
        className: g.monthPicker
      }, /* @__PURE__ */ Me.default.createElement("select", {
        value: a.getMonth(),
        onChange: (m) => i(m.target.value, "setMonth"),
        "aria-label": u.monthPicker
      }, this.state.monthNames.map((m, p) => /* @__PURE__ */ Me.default.createElement("option", {
        key: p,
        value: p
      }, m)))), /* @__PURE__ */ Me.default.createElement("span", {
        className: g.monthAndYearDivider
      }), /* @__PURE__ */ Me.default.createElement("span", {
        className: g.yearPicker
      }, /* @__PURE__ */ Me.default.createElement("select", {
        value: a.getFullYear(),
        onChange: (m) => i(m.target.value, "setYear"),
        "aria-label": u.yearPicker
      }, new Array(f - h + 1).fill(f).map((m, p) => {
        const w = m - p;
        return /* @__PURE__ */ Me.default.createElement("option", {
          key: w,
          value: w
        }, w);
      })))) : /* @__PURE__ */ Me.default.createElement("span", {
        className: g.monthAndYearPickers
      }, this.state.monthNames[a.getMonth()], " ", a.getFullYear()), o ? /* @__PURE__ */ Me.default.createElement("button", {
        type: "button",
        className: (0, un.default)(g.nextPrevButton, g.nextButton),
        onClick: () => i(1, "monthOffset"),
        "aria-label": u.nextButton
      }, /* @__PURE__ */ Me.default.createElement("i", null)) : null);
    }), zt(this, "renderDateDisplay", () => {
      const {
        focusedRange: a,
        color: i,
        ranges: s,
        rangeColors: o,
        dateDisplayFormat: l,
        editableDateInputs: c,
        startDatePlaceholder: d,
        endDatePlaceholder: u,
        ariaLabels: f
      } = this.props, h = o[a[0]] || i, g = this.styles;
      return /* @__PURE__ */ Me.default.createElement("div", {
        className: g.dateDisplayWrapper
      }, s.map((m, p) => m.showDateDisplay === false || m.disabled && !m.showDateDisplay ? null : /* @__PURE__ */ Me.default.createElement("div", {
        className: g.dateDisplay,
        key: p,
        style: {
          color: m.color || h
        }
      }, /* @__PURE__ */ Me.default.createElement(Lh.default, {
        className: (0, un.default)(g.dateDisplayItem, {
          [g.dateDisplayItemActive]: a[0] === p && a[1] === 0
        }),
        readOnly: !c,
        disabled: m.disabled,
        value: m.startDate,
        placeholder: d,
        dateOptions: this.dateOptions,
        dateDisplayFormat: l,
        ariaLabel: f.dateInput && f.dateInput[m.key] && f.dateInput[m.key].startDate,
        onChange: this.onDragSelectionEnd,
        onFocus: () => this.handleRangeFocusChange(p, 0)
      }), /* @__PURE__ */ Me.default.createElement(Lh.default, {
        className: (0, un.default)(g.dateDisplayItem, {
          [g.dateDisplayItemActive]: a[0] === p && a[1] === 1
        }),
        readOnly: !c,
        disabled: m.disabled,
        value: m.endDate,
        placeholder: u,
        dateOptions: this.dateOptions,
        dateDisplayFormat: l,
        ariaLabel: f.dateInput && f.dateInput[m.key] && f.dateInput[m.key].endDate,
        onChange: this.onDragSelectionEnd,
        onFocus: () => this.handleRangeFocusChange(p, 1)
      }))));
    }), zt(this, "onDragSelectionStart", (a) => {
      const {
        onChange: i,
        dragSelectionEnabled: s
      } = this.props;
      s ? this.setState({
        drag: {
          status: true,
          range: {
            startDate: a,
            endDate: a
          },
          disablePreview: true
        }
      }) : i && i(a);
    }), zt(this, "onDragSelectionEnd", (a) => {
      const {
        updateRange: i,
        displayMode: s,
        onChange: o,
        dragSelectionEnabled: l
      } = this.props;
      if (!l) return;
      if (s === "date" || !this.state.drag.status) {
        o && o(a);
        return;
      }
      const c = {
        startDate: this.state.drag.range.startDate,
        endDate: a
      };
      s !== "dateRange" || (0, Ie.isSameDay)(c.startDate, a) ? this.setState({
        drag: {
          status: false,
          range: {}
        }
      }, () => o && o(a)) : this.setState({
        drag: {
          status: false,
          range: {}
        }
      }, () => {
        i && i(c);
      });
    }), zt(this, "onDragSelectionMove", (a) => {
      const {
        drag: i
      } = this.state;
      !i.status || !this.props.dragSelectionEnabled || this.setState({
        drag: {
          status: i.status,
          range: {
            startDate: i.range.startDate,
            endDate: a
          },
          disablePreview: true
        }
      });
    }), zt(this, "estimateMonthSize", (a, i) => {
      const {
        direction: s,
        minDate: o
      } = this.props, {
        scrollArea: l
      } = this.state;
      if (i && (this.listSizeCache = i, i[a]))
        return i[a];
      if (s === "horizontal") return l.monthWidth;
      const c = (0, Ie.addMonths)(o, a), {
        start: d,
        end: u
      } = (0, ts.getMonthDisplayRange)(c, this.dateOptions);
      return (0, Ie.differenceInDays)(u, d, this.dateOptions) + 1 > 7 * 5 ? l.longMonthHeight : l.monthHeight;
    }), this.dateOptions = {
      locale: e.locale
    }, e.weekStartsOn !== void 0 && (this.dateOptions.weekStartsOn = e.weekStartsOn), this.styles = (0, ts.generateStyles)([aN.default, e.classNames]), this.listSizeCache = {}, this.isFirstRender = true, this.state = {
      monthNames: this.getMonthNames(),
      focusedDate: (0, ts.calcFocusDate)(null, e),
      drag: {
        status: false,
        range: {
          startDate: null,
          endDate: null
        },
        disablePreview: false
      },
      scrollArea: this.calcScrollArea(e)
    };
  }
  getMonthNames() {
    return [...Array(12).keys()].map((e) => this.props.locale.localize.month(e));
  }
  calcScrollArea(e) {
    const {
      direction: r,
      months: n,
      scroll: a
    } = e;
    if (!a.enabled) return {
      enabled: false
    };
    const i = a.longMonthHeight || a.monthHeight;
    return r === "vertical" ? {
      enabled: true,
      monthHeight: a.monthHeight || 220,
      longMonthHeight: i || 260,
      calendarWidth: "auto",
      calendarHeight: (a.calendarHeight || i || 240) * n
    } : {
      enabled: true,
      monthWidth: a.monthWidth || 332,
      calendarWidth: (a.calendarWidth || a.monthWidth || 332) * n,
      monthHeight: i || 300,
      calendarHeight: i || 300
    };
  }
  componentDidMount() {
    this.props.scroll.enabled && setTimeout(() => this.focusToDate(this.state.focusedDate));
  }
  componentDidUpdate(e) {
    const n = {
      dateRange: "ranges",
      date: "date"
    }[this.props.displayMode];
    this.props[n] !== e[n] && this.updateShownDate(this.props), (e.locale !== this.props.locale || e.weekStartsOn !== this.props.weekStartsOn) && (this.dateOptions = {
      locale: this.props.locale
    }, this.props.weekStartsOn !== void 0 && (this.dateOptions.weekStartsOn = this.props.weekStartsOn), this.setState({
      monthNames: this.getMonthNames()
    })), (0, rN.shallowEqualObjects)(e.scroll, this.props.scroll) || this.setState({
      scrollArea: this.calcScrollArea(this.props)
    });
  }
  renderWeekdays() {
    const e = /* @__PURE__ */ new Date();
    return /* @__PURE__ */ Me.default.createElement("div", {
      className: this.styles.weekDays
    }, (0, Ie.eachDayOfInterval)({
      start: (0, Ie.startOfWeek)(e, this.dateOptions),
      end: (0, Ie.endOfWeek)(e, this.dateOptions)
    }).map((r, n) => /* @__PURE__ */ Me.default.createElement("span", {
      className: this.styles.weekDay,
      key: n
    }, (0, Ie.format)(r, this.props.weekdayDisplayFormat, this.dateOptions))));
  }
  render() {
    const {
      showDateDisplay: e,
      onPreviewChange: r,
      scroll: n,
      direction: a,
      disabledDates: i,
      disabledDay: s,
      maxDate: o,
      minDate: l,
      rangeColors: c,
      color: d,
      navigatorRenderer: u,
      className: f,
      preview: h
    } = this.props, {
      scrollArea: g,
      focusedDate: m
    } = this.state, p = a === "vertical", w = u || this.renderMonthAndYear, b = this.props.ranges.map((k, v) => ({
      ...k,
      color: k.color || c[v] || d
    }));
    return /* @__PURE__ */ Me.default.createElement("div", {
      className: (0, un.default)(this.styles.calendarWrapper, f),
      onMouseUp: () => this.setState({
        drag: {
          status: false,
          range: {}
        }
      }),
      onMouseLeave: () => {
        this.setState({
          drag: {
            status: false,
            range: {}
          }
        });
      }
    }, e && this.renderDateDisplay(), w(m, this.changeShownDate, this.props), n.enabled ? /* @__PURE__ */ Me.default.createElement("div", null, p && this.renderWeekdays(this.dateOptions), /* @__PURE__ */ Me.default.createElement("div", {
      className: (0, un.default)(this.styles.infiniteMonths, p ? this.styles.monthsVertical : this.styles.monthsHorizontal),
      onMouseLeave: () => r && r(),
      style: {
        width: g.calendarWidth + 11,
        height: g.calendarHeight + 11
      },
      onScroll: this.handleScroll
    }, /* @__PURE__ */ Me.default.createElement(tN.default, {
      length: (0, Ie.differenceInCalendarMonths)((0, Ie.endOfMonth)(o), (0, Ie.addDays)((0, Ie.startOfMonth)(l), -1), this.dateOptions),
      treshold: 500,
      type: "variable",
      ref: (k) => this.list = k,
      itemSizeEstimator: this.estimateMonthSize,
      axis: p ? "y" : "x",
      itemRenderer: (k, v) => {
        const x = (0, Ie.addMonths)(l, k);
        return /* @__PURE__ */ Me.default.createElement(Fh.default, to({}, this.props, {
          onPreviewChange: r || this.updatePreview,
          preview: h || this.state.preview,
          ranges: b,
          key: v,
          drag: this.state.drag,
          dateOptions: this.dateOptions,
          disabledDates: i,
          disabledDay: s,
          month: x,
          onDragSelectionStart: this.onDragSelectionStart,
          onDragSelectionEnd: this.onDragSelectionEnd,
          onDragSelectionMove: this.onDragSelectionMove,
          onMouseLeave: () => r && r(),
          styles: this.styles,
          style: p ? {
            height: this.estimateMonthSize(k)
          } : {
            height: g.monthHeight,
            width: this.estimateMonthSize(k)
          },
          showMonthName: true,
          showWeekDays: !p
        }));
      }
    }))) : /* @__PURE__ */ Me.default.createElement("div", {
      className: (0, un.default)(this.styles.months, p ? this.styles.monthsVertical : this.styles.monthsHorizontal)
    }, new Array(this.props.months).fill(null).map((k, v) => {
      let x = (0, Ie.addMonths)(this.state.focusedDate, v);
      return this.props.calendarFocus === "backwards" && (x = (0, Ie.subMonths)(this.state.focusedDate, this.props.months - 1 - v)), /* @__PURE__ */ Me.default.createElement(Fh.default, to({}, this.props, {
        onPreviewChange: r || this.updatePreview,
        preview: h || this.state.preview,
        ranges: b,
        key: v,
        drag: this.state.drag,
        dateOptions: this.dateOptions,
        disabledDates: i,
        disabledDay: s,
        month: x,
        onDragSelectionStart: this.onDragSelectionStart,
        onDragSelectionEnd: this.onDragSelectionEnd,
        onDragSelectionMove: this.onDragSelectionMove,
        onMouseLeave: () => r && r(),
        styles: this.styles,
        showWeekDays: !p || v === 0,
        showMonthName: !p || v > 0
      }));
    })));
  }
}
fa.defaultProps = {
  showMonthArrow: true,
  showMonthAndYearPickers: true,
  disabledDates: [],
  disabledDay: () => {
  },
  classNames: {},
  locale: nN.enUS,
  ranges: [],
  focusedRange: [0, 0],
  dateDisplayFormat: "MMM d, yyyy",
  monthDisplayFormat: "MMM yyyy",
  weekdayDisplayFormat: "E",
  dayDisplayFormat: "d",
  showDateDisplay: true,
  showPreview: true,
  displayMode: "date",
  months: 1,
  color: "#3d91ff",
  scroll: {
    enabled: false
  },
  direction: "vertical",
  maxDate: (0, Ie.addYears)(/* @__PURE__ */ new Date(), 20),
  minDate: (0, Ie.addYears)(/* @__PURE__ */ new Date(), -100),
  rangeColors: ["#3d91ff", "#3ecf8e", "#fed14c"],
  startDatePlaceholder: "Early",
  endDatePlaceholder: "Continuous",
  editableDateInputs: false,
  dragSelectionEnabled: true,
  fixedHeight: false,
  calendarFocus: "forwards",
  preventSnapRefocus: false,
  ariaLabels: {}
};
fa.propTypes = {
  showMonthArrow: ce.default.bool,
  showMonthAndYearPickers: ce.default.bool,
  disabledDates: ce.default.array,
  disabledDay: ce.default.func,
  minDate: ce.default.object,
  maxDate: ce.default.object,
  date: ce.default.object,
  onChange: ce.default.func,
  onPreviewChange: ce.default.func,
  onRangeFocusChange: ce.default.func,
  classNames: ce.default.object,
  locale: ce.default.object,
  shownDate: ce.default.object,
  onShownDateChange: ce.default.func,
  ranges: ce.default.arrayOf(eN.rangeShape),
  preview: ce.default.shape({
    startDate: ce.default.object,
    endDate: ce.default.object,
    color: ce.default.string
  }),
  dateDisplayFormat: ce.default.string,
  monthDisplayFormat: ce.default.string,
  weekdayDisplayFormat: ce.default.string,
  weekStartsOn: ce.default.number,
  dayDisplayFormat: ce.default.string,
  focusedRange: ce.default.arrayOf(ce.default.number),
  initialFocusedRange: ce.default.arrayOf(ce.default.number),
  months: ce.default.number,
  className: ce.default.string,
  showDateDisplay: ce.default.bool,
  showPreview: ce.default.bool,
  displayMode: ce.default.oneOf(["dateRange", "date"]),
  color: ce.default.string,
  updateRange: ce.default.func,
  scroll: ce.default.shape({
    enabled: ce.default.bool,
    monthHeight: ce.default.number,
    longMonthHeight: ce.default.number,
    monthWidth: ce.default.number,
    calendarWidth: ce.default.number,
    calendarHeight: ce.default.number
  }),
  direction: ce.default.oneOf(["vertical", "horizontal"]),
  startDatePlaceholder: ce.default.string,
  endDatePlaceholder: ce.default.string,
  navigatorRenderer: ce.default.func,
  rangeColors: ce.default.arrayOf(ce.default.string),
  editableDateInputs: ce.default.bool,
  dragSelectionEnabled: ce.default.bool,
  fixedHeight: ce.default.bool,
  calendarFocus: ce.default.string,
  preventSnapRefocus: ce.default.bool,
  ariaLabels: iN.ariaLabelsShape
};
Si.default = fa;
Object.defineProperty(Oi, "__esModule", {
  value: true
});
Oi.default = void 0;
var Wh = fN(React$1), Yn = zo(Ar), fy = zo(Si), cN = Rr, Ol = Lr, rr = Ln, dN = zo(en), uN = zo(Wn);
function zo(t6) {
  return t6 && t6.__esModule ? t6 : { default: t6 };
}
function hy(t6) {
  if (typeof WeakMap != "function") return null;
  var e = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
  return (hy = function(n) {
    return n ? r : e;
  })(t6);
}
function fN(t6, e) {
  if (t6 && t6.__esModule) return t6;
  if (t6 === null || typeof t6 != "object" && typeof t6 != "function") return { default: t6 };
  var r = hy(e);
  if (r && r.has(t6)) return r.get(t6);
  var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var i in t6) if (i !== "default" && Object.prototype.hasOwnProperty.call(t6, i)) {
    var s = a ? Object.getOwnPropertyDescriptor(t6, i) : null;
    s && (s.get || s.set) ? Object.defineProperty(n, i, s) : n[i] = t6[i];
  }
  return n.default = t6, r && r.set(t6, n), n;
}
function nc() {
  return nc = Object.assign ? Object.assign.bind() : function(t6) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (t6[n] = r[n]);
    }
    return t6;
  }, nc.apply(this, arguments);
}
function rs(t6, e, r) {
  return e = hN(e), e in t6 ? Object.defineProperty(t6, e, { value: r, enumerable: true, configurable: true, writable: true }) : t6[e] = r, t6;
}
function hN(t6) {
  var e = gN(t6, "string");
  return typeof e == "symbol" ? e : String(e);
}
function gN(t6, e) {
  if (typeof t6 != "object" || !t6) return t6;
  var r = t6[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(t6, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t6);
}
class Nd extends Wh.Component {
  constructor(e, r) {
    var n;
    super(e, r), n = this, rs(this, "calcNewSelection", function(a) {
      let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      const s = n.props.focusedRange || n.state.focusedRange, {
        ranges: o,
        onChange: l,
        maxDate: c,
        moveRangeOnFirstSelection: d,
        retainEndDateOnFirstSelection: u,
        disabledDates: f
      } = n.props, h = s[0], g = o[h];
      if (!g || !l) return {};
      let {
        startDate: m,
        endDate: p
      } = g;
      const w = /* @__PURE__ */ new Date();
      let b;
      if (!i)
        m = a.startDate, p = a.endDate;
      else if (s[1] === 0) {
        const x = (0, rr.differenceInCalendarDays)(p || w, m), _ = () => d ? (0, rr.addDays)(a, x) : u ? !p || (0, rr.isBefore)(a, p) ? p : a : a || w;
        m = a, p = _(), c && (p = (0, rr.min)([p, c])), b = [s[0], 1];
      } else
        p = a;
      let k = s[1] === 0;
      (0, rr.isBefore)(p, m) && (k = !k, [m, p] = [p, m]);
      const v = f.filter((x) => (0, rr.isWithinInterval)(x, {
        start: m,
        end: p
      }));
      return v.length > 0 && (k ? m = (0, rr.addDays)((0, rr.max)(v), 1) : p = (0, rr.addDays)((0, rr.min)(v), -1)), b || (b = [(0, Ol.findNextRangeIndex)(n.props.ranges, s[0]), 0]), {
        wasValid: !(v.length > 0),
        range: {
          startDate: m,
          endDate: p
        },
        nextFocusRange: b
      };
    }), rs(this, "setSelection", (a, i) => {
      const {
        onChange: s,
        ranges: o,
        onRangeFocusChange: l
      } = this.props, d = (this.props.focusedRange || this.state.focusedRange)[0], u = o[d];
      if (!u) return;
      const f = this.calcNewSelection(a, i);
      s({
        [u.key || `range${d + 1}`]: {
          ...u,
          ...f.range
        }
      }), this.setState({
        focusedRange: f.nextFocusRange,
        preview: null
      }), l && l(f.nextFocusRange);
    }), rs(this, "handleRangeFocusChange", (a) => {
      this.setState({
        focusedRange: a
      }), this.props.onRangeFocusChange && this.props.onRangeFocusChange(a);
    }), rs(this, "updatePreview", (a) => {
      var c;
      if (!a) {
        this.setState({
          preview: null
        });
        return;
      }
      const {
        rangeColors: i,
        ranges: s
      } = this.props, o = this.props.focusedRange || this.state.focusedRange, l = ((c = s[o[0]]) == null ? void 0 : c.color) || i[o[0]] || l;
      this.setState({
        preview: {
          ...a.range,
          color: l
        }
      });
    }), this.state = {
      focusedRange: e.initialFocusedRange || [(0, Ol.findNextRangeIndex)(e.ranges), 0],
      preview: null
    }, this.styles = (0, Ol.generateStyles)([uN.default, e.classNames]);
  }
  render() {
    return /* @__PURE__ */ Wh.default.createElement(fy.default, nc({
      focusedRange: this.state.focusedRange,
      onRangeFocusChange: this.handleRangeFocusChange,
      preview: this.state.preview,
      onPreviewChange: (e) => {
        this.updatePreview(e ? this.calcNewSelection(e) : null);
      }
    }, this.props, {
      displayMode: "dateRange",
      className: (0, dN.default)(this.styles.dateRangeWrapper, this.props.className),
      onChange: this.setSelection,
      updateRange: (e) => this.setSelection(e, false),
      ref: (e) => {
        this.calendar = e;
      }
    }));
  }
}
Nd.defaultProps = {
  classNames: {},
  ranges: [],
  moveRangeOnFirstSelection: false,
  retainEndDateOnFirstSelection: false,
  rangeColors: ["#3d91ff", "#3ecf8e", "#fed14c"],
  disabledDates: []
};
Nd.propTypes = {
  ...fy.default.propTypes,
  onChange: Yn.default.func,
  onRangeFocusChange: Yn.default.func,
  className: Yn.default.string,
  ranges: Yn.default.arrayOf(cN.rangeShape),
  moveRangeOnFirstSelection: Yn.default.bool,
  retainEndDateOnFirstSelection: Yn.default.bool
};
Oi.default = Nd;
var jo = {}, Ei = {}, Jr = {};
Object.defineProperty(Jr, "__esModule", {
  value: true
});
Jr.createStaticRanges = gy;
Jr.defaultStaticRanges = Jr.defaultInputRanges = void 0;
var Pe = Ln;
const nt = {
  startOfWeek: (0, Pe.startOfWeek)(/* @__PURE__ */ new Date()),
  endOfWeek: (0, Pe.endOfWeek)(/* @__PURE__ */ new Date()),
  startOfLastWeek: (0, Pe.startOfWeek)((0, Pe.addDays)(/* @__PURE__ */ new Date(), -7)),
  endOfLastWeek: (0, Pe.endOfWeek)((0, Pe.addDays)(/* @__PURE__ */ new Date(), -7)),
  startOfToday: (0, Pe.startOfDay)(/* @__PURE__ */ new Date()),
  endOfToday: (0, Pe.endOfDay)(/* @__PURE__ */ new Date()),
  startOfYesterday: (0, Pe.startOfDay)((0, Pe.addDays)(/* @__PURE__ */ new Date(), -1)),
  endOfYesterday: (0, Pe.endOfDay)((0, Pe.addDays)(/* @__PURE__ */ new Date(), -1)),
  startOfMonth: (0, Pe.startOfMonth)(/* @__PURE__ */ new Date()),
  endOfMonth: (0, Pe.endOfMonth)(/* @__PURE__ */ new Date()),
  startOfLastMonth: (0, Pe.startOfMonth)((0, Pe.addMonths)(/* @__PURE__ */ new Date(), -1)),
  endOfLastMonth: (0, Pe.endOfMonth)((0, Pe.addMonths)(/* @__PURE__ */ new Date(), -1))
}, mN = {
  range: {},
  isSelected(t6) {
    const e = this.range();
    return (0, Pe.isSameDay)(t6.startDate, e.startDate) && (0, Pe.isSameDay)(t6.endDate, e.endDate);
  }
};
function gy(t6) {
  return t6.map((e) => ({
    ...mN,
    ...e
  }));
}
Jr.defaultStaticRanges = gy([{
  label: "Today",
  range: () => ({
    startDate: nt.startOfToday,
    endDate: nt.endOfToday
  })
}, {
  label: "Yesterday",
  range: () => ({
    startDate: nt.startOfYesterday,
    endDate: nt.endOfYesterday
  })
}, {
  label: "This Week",
  range: () => ({
    startDate: nt.startOfWeek,
    endDate: nt.endOfWeek
  })
}, {
  label: "Last Week",
  range: () => ({
    startDate: nt.startOfLastWeek,
    endDate: nt.endOfLastWeek
  })
}, {
  label: "This Month",
  range: () => ({
    startDate: nt.startOfMonth,
    endDate: nt.endOfMonth
  })
}, {
  label: "Last Month",
  range: () => ({
    startDate: nt.startOfLastMonth,
    endDate: nt.endOfLastMonth
  })
}]);
Jr.defaultInputRanges = [{
  label: "days up to today",
  range(t6) {
    return {
      startDate: (0, Pe.addDays)(nt.startOfToday, (Math.max(Number(t6), 1) - 1) * -1),
      endDate: nt.endOfToday
    };
  },
  getCurrentValue(t6) {
    return (0, Pe.isSameDay)(t6.endDate, nt.endOfToday) ? t6.startDate ? (0, Pe.differenceInCalendarDays)(nt.endOfToday, t6.startDate) + 1 : "∞" : "-";
  }
}, {
  label: "days starting today",
  range(t6) {
    const e = /* @__PURE__ */ new Date();
    return {
      startDate: e,
      endDate: (0, Pe.addDays)(e, Math.max(Number(t6), 1) - 1)
    };
  },
  getCurrentValue(t6) {
    return (0, Pe.isSameDay)(t6.startDate, nt.startOfToday) ? t6.endDate ? (0, Pe.differenceInCalendarDays)(t6.endDate, nt.startOfToday) + 1 : "∞" : "-";
  }
}];
var Ho = {};
Object.defineProperty(Ho, "__esModule", {
  value: true
});
Ho.default = void 0;
var ns = bN(React$1), wt = pN(Ar);
function pN(t6) {
  return t6 && t6.__esModule ? t6 : { default: t6 };
}
function my(t6) {
  if (typeof WeakMap != "function") return null;
  var e = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
  return (my = function(n) {
    return n ? r : e;
  })(t6);
}
function bN(t6, e) {
  if (t6 && t6.__esModule) return t6;
  if (t6 === null || typeof t6 != "object" && typeof t6 != "function") return { default: t6 };
  var r = my(e);
  if (r && r.has(t6)) return r.get(t6);
  var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var i in t6) if (i !== "default" && Object.prototype.hasOwnProperty.call(t6, i)) {
    var s = a ? Object.getOwnPropertyDescriptor(t6, i) : null;
    s && (s.get || s.set) ? Object.defineProperty(n, i, s) : n[i] = t6[i];
  }
  return n.default = t6, r && r.set(t6, n), n;
}
function yN(t6, e, r) {
  return e = vN(e), e in t6 ? Object.defineProperty(t6, e, { value: r, enumerable: true, configurable: true, writable: true }) : t6[e] = r, t6;
}
function vN(t6) {
  var e = xN(t6, "string");
  return typeof e == "symbol" ? e : String(e);
}
function xN(t6, e) {
  if (typeof t6 != "object" || !t6) return t6;
  var r = t6[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(t6, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t6);
}
const $h = 0, zh = 99999;
class Id extends ns.Component {
  constructor(e, r) {
    super(e, r), yN(this, "onChange", (n) => {
      const {
        onChange: a
      } = this.props;
      let i = parseInt(n.target.value, 10);
      i = isNaN(i) ? 0 : Math.max(Math.min(zh, i), $h), a(i);
    });
  }
  shouldComponentUpdate(e) {
    const {
      value: r,
      label: n,
      placeholder: a
    } = this.props;
    return r !== e.value || n !== e.label || a !== e.placeholder;
  }
  render() {
    const {
      label: e,
      placeholder: r,
      value: n,
      styles: a,
      onBlur: i,
      onFocus: s
    } = this.props;
    return /* @__PURE__ */ ns.default.createElement("div", {
      className: a.inputRange
    }, /* @__PURE__ */ ns.default.createElement("input", {
      className: a.inputRangeInput,
      placeholder: r,
      value: n,
      min: $h,
      max: zh,
      onChange: this.onChange,
      onFocus: s,
      onBlur: i
    }), /* @__PURE__ */ ns.default.createElement("span", {
      className: a.inputRangeLabel
    }, e));
  }
}
Id.propTypes = {
  value: wt.default.oneOfType([wt.default.string, wt.default.number]),
  label: wt.default.oneOfType([wt.default.element, wt.default.node]).isRequired,
  placeholder: wt.default.string,
  styles: wt.default.shape({
    inputRange: wt.default.string,
    inputRangeInput: wt.default.string,
    inputRangeLabel: wt.default.string
  }).isRequired,
  onBlur: wt.default.func.isRequired,
  onFocus: wt.default.func.isRequired,
  onChange: wt.default.func.isRequired
};
Id.defaultProps = {
  value: "",
  placeholder: "-"
};
Ho.default = Id;
Object.defineProperty(Ei, "__esModule", {
  value: true
});
Ei.default = void 0;
var fn = _N(React$1), Nt = Bo(Ar), hn = Bo(Wn), jh = Jr, wN = Rr, kN = Bo(Ho), Hh = Bo(en);
function Bo(t6) {
  return t6 && t6.__esModule ? t6 : { default: t6 };
}
function py(t6) {
  if (typeof WeakMap != "function") return null;
  var e = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
  return (py = function(n) {
    return n ? r : e;
  })(t6);
}
function _N(t6, e) {
  if (t6 && t6.__esModule) return t6;
  if (t6 === null || typeof t6 != "object" && typeof t6 != "function") return { default: t6 };
  var r = py(e);
  if (r && r.has(t6)) return r.get(t6);
  var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var i in t6) if (i !== "default" && Object.prototype.hasOwnProperty.call(t6, i)) {
    var s = a ? Object.getOwnPropertyDescriptor(t6, i) : null;
    s && (s.get || s.set) ? Object.defineProperty(n, i, s) : n[i] = t6[i];
  }
  return n.default = t6, r && r.set(t6, n), n;
}
function ON(t6, e, r) {
  return e = SN(e), e in t6 ? Object.defineProperty(t6, e, { value: r, enumerable: true, configurable: true, writable: true }) : t6[e] = r, t6;
}
function SN(t6) {
  var e = DN(t6, "string");
  return typeof e == "symbol" ? e : String(e);
}
function DN(t6, e) {
  if (typeof t6 != "object" || !t6) return t6;
  var r = t6[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(t6, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t6);
}
class Ad extends fn.Component {
  constructor(e) {
    super(e), ON(this, "handleRangeChange", (r) => {
      const {
        onChange: n,
        ranges: a,
        focusedRange: i
      } = this.props, s = a[i[0]];
      !n || !s || n({
        [s.key || `range${i[0] + 1}`]: {
          ...s,
          ...r
        }
      });
    }), this.state = {
      rangeOffset: 0,
      focusedInput: -1
    };
  }
  getRangeOptionValue(e) {
    const {
      ranges: r = [],
      focusedRange: n = []
    } = this.props;
    if (typeof e.getCurrentValue != "function")
      return "";
    const a = r[n[0]] || {};
    return e.getCurrentValue(a) || "";
  }
  getSelectedRange(e, r) {
    const n = e.findIndex((i) => !i.startDate || !i.endDate || i.disabled ? false : r.isSelected(i));
    return {
      selectedRange: e[n],
      focusedRangeIndex: n
    };
  }
  render() {
    const {
      headerContent: e,
      footerContent: r,
      onPreviewChange: n,
      inputRanges: a,
      staticRanges: i,
      ranges: s,
      renderStaticRangeLabel: o,
      rangeColors: l,
      className: c
    } = this.props;
    return /* @__PURE__ */ fn.default.createElement("div", {
      className: (0, Hh.default)(hn.default.definedRangesWrapper, c)
    }, e, /* @__PURE__ */ fn.default.createElement("div", {
      className: hn.default.staticRanges
    }, i.map((d, u) => {
      const {
        selectedRange: f,
        focusedRangeIndex: h
      } = this.getSelectedRange(s, d);
      let g;
      return d.hasCustomRendering ? g = o(d) : g = d.label, /* @__PURE__ */ fn.default.createElement("button", {
        type: "button",
        className: (0, Hh.default)(hn.default.staticRange, {
          [hn.default.staticRangeSelected]: !!f
        }),
        style: {
          color: f ? f.color || l[h] : null
        },
        key: u,
        onClick: () => this.handleRangeChange(d.range(this.props)),
        onFocus: () => n && n(d.range(this.props)),
        onMouseOver: () => n && n(d.range(this.props)),
        onMouseLeave: () => {
          n && n();
        }
      }, /* @__PURE__ */ fn.default.createElement("span", {
        tabIndex: -1,
        className: hn.default.staticRangeLabel
      }, g));
    })), /* @__PURE__ */ fn.default.createElement("div", {
      className: hn.default.inputRanges
    }, a.map((d, u) => /* @__PURE__ */ fn.default.createElement(kN.default, {
      key: u,
      styles: hn.default,
      label: d.label,
      onFocus: () => this.setState({
        focusedInput: u,
        rangeOffset: 0
      }),
      onBlur: () => this.setState({
        rangeOffset: 0
      }),
      onChange: (f) => this.handleRangeChange(d.range(f, this.props)),
      value: this.getRangeOptionValue(d)
    }))), r);
  }
}
Ad.propTypes = {
  inputRanges: Nt.default.array,
  staticRanges: Nt.default.array,
  ranges: Nt.default.arrayOf(wN.rangeShape),
  focusedRange: Nt.default.arrayOf(Nt.default.number),
  onPreviewChange: Nt.default.func,
  onChange: Nt.default.func,
  footerContent: Nt.default.any,
  headerContent: Nt.default.any,
  rangeColors: Nt.default.arrayOf(Nt.default.string),
  className: Nt.default.string,
  renderStaticRangeLabel: Nt.default.func
};
Ad.defaultProps = {
  inputRanges: jh.defaultInputRanges,
  staticRanges: jh.defaultStaticRanges,
  ranges: [],
  rangeColors: ["#3d91ff", "#3ecf8e", "#fed14c"],
  focusedRange: [0, 0]
};
Ei.default = Ad;
Object.defineProperty(jo, "__esModule", {
  value: true
});
jo.default = void 0;
var as = TN(React$1), MN = Ti(Ar), by = Ti(Oi), yy = Ti(Ei), Bh = Lr, CN = Ti(en), EN = Ti(Wn);
function Ti(t6) {
  return t6 && t6.__esModule ? t6 : { default: t6 };
}
function vy(t6) {
  if (typeof WeakMap != "function") return null;
  var e = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
  return (vy = function(n) {
    return n ? r : e;
  })(t6);
}
function TN(t6, e) {
  if (t6 && t6.__esModule) return t6;
  if (t6 === null || typeof t6 != "object" && typeof t6 != "function") return { default: t6 };
  var r = vy(e);
  if (r && r.has(t6)) return r.get(t6);
  var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var i in t6) if (i !== "default" && Object.prototype.hasOwnProperty.call(t6, i)) {
    var s = a ? Object.getOwnPropertyDescriptor(t6, i) : null;
    s && (s.get || s.set) ? Object.defineProperty(n, i, s) : n[i] = t6[i];
  }
  return n.default = t6, r && r.set(t6, n), n;
}
function ro() {
  return ro = Object.assign ? Object.assign.bind() : function(t6) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (t6[n] = r[n]);
    }
    return t6;
  }, ro.apply(this, arguments);
}
let Fd = class extends as.Component {
  constructor(e) {
    super(e), this.state = {
      focusedRange: [(0, Bh.findNextRangeIndex)(e.ranges), 0]
    }, this.styles = (0, Bh.generateStyles)([EN.default, e.classNames]);
  }
  render() {
    const {
      focusedRange: e
    } = this.state;
    return /* @__PURE__ */ as.default.createElement("div", {
      className: (0, CN.default)(this.styles.dateRangePickerWrapper, this.props.className)
    }, /* @__PURE__ */ as.default.createElement(yy.default, ro({
      focusedRange: e,
      onPreviewChange: (r) => this.dateRange.updatePreview(r ? this.dateRange.calcNewSelection(r, typeof r == "string") : null)
    }, this.props, {
      range: this.props.ranges[e[0]],
      className: void 0
    })), /* @__PURE__ */ as.default.createElement(by.default, ro({
      onRangeFocusChange: (r) => this.setState({
        focusedRange: r
      }),
      focusedRange: e
    }, this.props, {
      ref: (r) => this.dateRange = r,
      className: void 0
    })));
  }
};
Fd.defaultProps = {};
Fd.propTypes = {
  ...by.default.propTypes,
  ...yy.default.propTypes,
  className: MN.default.string
};
jo.default = Fd;
(function(t6) {
  Object.defineProperty(t6, "__esModule", {
    value: true
  }), Object.defineProperty(t6, "Calendar", {
    enumerable: true,
    get: function() {
      return r.default;
    }
  }), Object.defineProperty(t6, "DateRange", {
    enumerable: true,
    get: function() {
      return e.default;
    }
  }), Object.defineProperty(t6, "DateRangePicker", {
    enumerable: true,
    get: function() {
      return n.default;
    }
  }), Object.defineProperty(t6, "DefinedRange", {
    enumerable: true,
    get: function() {
      return a.default;
    }
  }), Object.defineProperty(t6, "createStaticRanges", {
    enumerable: true,
    get: function() {
      return i.createStaticRanges;
    }
  }), Object.defineProperty(t6, "defaultInputRanges", {
    enumerable: true,
    get: function() {
      return i.defaultInputRanges;
    }
  }), Object.defineProperty(t6, "defaultStaticRanges", {
    enumerable: true,
    get: function() {
      return i.defaultStaticRanges;
    }
  });
  var e = s(Oi), r = s(Si), n = s(jo), a = s(Ei), i = Jr;
  function s(o) {
    return o && o.__esModule ? o : { default: o };
  }
})(Yp);
const _r = {
  "date-container": "dateRangePicker-module__date-container__jh9s-",
  "date-input": "dateRangePicker-module__date-input__xt4gs",
  "date-popup": "dateRangePicker-module__date-popup__TQHMh",
  "date-menu": "dateRangePicker-module__date-menu__Nv5nr",
  "date-menuItem": "dateRangePicker-module__date-menuItem__AYJ32",
  "date-menuItemActive": "dateRangePicker-module__date-menuItemActive__AzWJe",
  "date-menuItemCustom": "dateRangePicker-module__date-menuItemCustom__x1-M9",
  "date-calendar": "dateRangePicker-module__date-calendar__M10Iv"
}, PN = [
  { label: "Today", range: () => ({ startDate: /* @__PURE__ */ new Date(), endDate: /* @__PURE__ */ new Date() }) },
  { label: "Yesterday", range: () => {
    const t6 = /* @__PURE__ */ new Date();
    return t6.setDate(t6.getDate() - 1), { startDate: t6, endDate: t6 };
  } },
  { label: "Last 7 Days", range: () => ({ startDate: Wt(/* @__PURE__ */ new Date(), -6), endDate: /* @__PURE__ */ new Date() }) },
  { label: "Last 30 Days", range: () => ({ startDate: Wt(/* @__PURE__ */ new Date(), -29), endDate: /* @__PURE__ */ new Date() }) },
  { label: "This Month", range: () => {
    const t6 = /* @__PURE__ */ new Date();
    return { startDate: new Date(t6.getFullYear(), t6.getMonth(), 1), endDate: t6 };
  } },
  { label: "Last Month", range: () => {
    const t6 = /* @__PURE__ */ new Date(), e = new Date(t6.getFullYear(), t6.getMonth() - 1, 1), r = new Date(t6.getFullYear(), t6.getMonth(), 0);
    return { startDate: e, endDate: r };
  } }
], eI = ({
  value: t6,
  onChange: e,
  minData: r,
  maxData: n,
  quickRanges: a
}) => {
  const [i, s] = reactExports.useState([
    {
      startDate: /* @__PURE__ */ new Date(),
      endDate: Wt(/* @__PURE__ */ new Date(), 6),
      key: "selection"
    }
  ]), [o, l] = reactExports.useState(false), [c, d] = reactExports.useState(2), [u, f] = reactExports.useState({}), h = reactExports.useRef(null), g = reactExports.useRef(null), m = a ?? PN, p = t6 ? [{ ...t6, key: "selection" }] : i;
  reactExports.useEffect(() => {
    const v = () => {
      d(window.innerWidth < 900 ? 1 : 2);
    };
    return v(), window.addEventListener("resize", v), () => window.removeEventListener("resize", v);
  }, []), reactExports.useEffect(() => {
    if (o && g.current && h.current) {
      const v = g.current.getBoundingClientRect(), x = h.current.offsetWidth || 700, _ = window.innerWidth - v.left, T = v.right, S = {
        right: "auto",
        left: 0
      };
      _ < x && T > x && (S.right = 0, S.left = "auto"), window.innerWidth < x && (S.left = 0, S.right = 0, S.width = "100vw", S.maxWidth = "100vw"), f(S);
    }
  }, [o, c]);
  const w = (v) => {
    t6 || s([v.selection]), e == null || e(v.selection.startDate, v.selection.endDate);
  }, b = (v) => {
    const { startDate: x, endDate: _ } = v();
    t6 || s([{ startDate: x, endDate: _, key: "selection" }]), e == null || e(x, _), l(false);
  }, k = (v) => Zs(v, "dd, MMM yyyy");
  return reactExports.useEffect(() => {
    if (!o) return;
    const v = (x) => {
      h.current && !h.current.contains(x.target) && g.current && !g.current.contains(x.target) && l(false);
    };
    return document.addEventListener("mousedown", v), () => document.removeEventListener("mousedown", v);
  }, [o]), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: _r["date-container"], children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        ref: g,
        type: "text",
        readOnly: true,
        value: `${k(p[0].startDate)} - ${k(p[0].endDate)}`,
        onClick: () => l(!o),
        className: _r["date-input"]
      }
    ),
    o && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        ref: h,
        className: _r["date-popup"],
        style: u,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: _r["date-menu"], children: [
            m.map((v, x) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: _r["date-menuItem"] + (x === 2 ? " " + _r["date-menuItemActive"] : ""),
                onClick: () => b(v.range),
                children: v.label
              },
              v.label
            )),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: _r["date-menuItem"] + " " + _r["date-menuItemCustom"],
                onClick: () => l(false),
                children: "Custom Range"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: _r["date-calendar"], children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Yp.DateRange,
            {
              editableDateInputs: true,
              onChange: w,
              moveRangeOnFirstSelection: false,
              ranges: p,
              months: c,
              rangeColors: ["#6c3cff"],
              minDate: r,
              maxDate: n
            }
          ) })
        ]
      }
    )
  ] });
};

var isMergeableObject = function isMergeableObject(value) {
	return isNonNullObject(value)
		&& !isSpecial(value)
};

function isNonNullObject(value) {
	return !!value && typeof value === 'object'
}

function isSpecial(value) {
	var stringValue = Object.prototype.toString.call(value);

	return stringValue === '[object RegExp]'
		|| stringValue === '[object Date]'
		|| isReactElement(value)
}

// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

function isReactElement(value) {
	return value.$$typeof === REACT_ELEMENT_TYPE
}

function emptyTarget(val) {
	return Array.isArray(val) ? [] : {}
}

function cloneUnlessOtherwiseSpecified(value, options) {
	return (options.clone !== false && options.isMergeableObject(value))
		? deepmerge(emptyTarget(value), value, options)
		: value
}

function defaultArrayMerge(target, source, options) {
	return target.concat(source).map(function(element) {
		return cloneUnlessOtherwiseSpecified(element, options)
	})
}

function mergeObject(target, source, options) {
	var destination = {};
	if (options.isMergeableObject(target)) {
		Object.keys(target).forEach(function(key) {
			destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
		});
	}
	Object.keys(source).forEach(function(key) {
		if (!options.isMergeableObject(source[key]) || !target[key]) {
			destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
		} else {
			destination[key] = deepmerge(target[key], source[key], options);
		}
	});
	return destination
}

function deepmerge(target, source, options) {
	options = options || {};
	options.arrayMerge = options.arrayMerge || defaultArrayMerge;
	options.isMergeableObject = options.isMergeableObject || isMergeableObject;

	var sourceIsArray = Array.isArray(source);
	var targetIsArray = Array.isArray(target);
	var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

	if (!sourceAndTargetTypesMatch) {
		return cloneUnlessOtherwiseSpecified(source, options)
	} else if (sourceIsArray) {
		return options.arrayMerge(target, source, options)
	} else {
		return mergeObject(target, source, options)
	}
}

deepmerge.all = function deepmergeAll(array, options) {
	if (!Array.isArray(array)) {
		throw new Error('first argument should be an array')
	}

	return array.reduce(function(prev, next) {
		return deepmerge(prev, next, options)
	}, {})
};

var deepmerge_1 = deepmerge;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Built-in value references. */
var Symbol$1 = root.Symbol;

/** Used for built-in method references. */
var objectProto$d = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$a = objectProto$d.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$d.toString;

/** Built-in value references. */
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty$a.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$c = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto$c.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */
var objectTag$3 = '[object Object]';

/** Used for built-in method references. */
var funcProto$2 = Function.prototype,
    objectProto$b = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$2 = funcProto$2.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$9 = objectProto$b.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString$2.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$9.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString$2.call(Ctor) == objectCtorString;
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject$2(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag$2 = '[object Function]',
    genTag$1 = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction$1(value) {
  if (!isObject$2(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/** Used for built-in method references. */
var funcProto$1 = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$1 = funcProto$1.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto$a = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty$8).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject$2(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/* Built-in method references that are verified to be native. */
var Map$1 = getNative(root, 'Map');

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto$9 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? undefined : result;
  }
  return hasOwnProperty$7.call(data, key) ? data[key] : undefined;
}

/** Used for built-in method references. */
var objectProto$8 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$6 = objectProto$8.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty$6.call(data, key);
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map$1 || ListCache),
    'string': new Hash
  };
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$1 || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/** Used for built-in method references. */
var objectProto$7 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$5 = objectProto$7.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$5.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/** `Object#toString` result references. */
var argsTag$2 = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$2;
}

/** Used for built-in method references. */
var objectProto$6 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$4 = objectProto$6.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$4.call(value, 'callee') &&
    !propertyIsEnumerable$1.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray$1 = Array.isArray;

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/** Detect free variable `exports`. */
var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;

/** Built-in value references. */
var Buffer$2 = moduleExports$2 ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/** `Object#toString` result references. */
var argsTag$1 = '[object Arguments]',
    arrayTag$1 = '[object Array]',
    boolTag$2 = '[object Boolean]',
    dateTag$2 = '[object Date]',
    errorTag$1 = '[object Error]',
    funcTag$1 = '[object Function]',
    mapTag$4 = '[object Map]',
    numberTag$2 = '[object Number]',
    objectTag$2 = '[object Object]',
    regexpTag$2 = '[object RegExp]',
    setTag$4 = '[object Set]',
    stringTag$2 = '[object String]',
    weakMapTag$2 = '[object WeakMap]';

var arrayBufferTag$2 = '[object ArrayBuffer]',
    dataViewTag$3 = '[object DataView]',
    float32Tag$2 = '[object Float32Array]',
    float64Tag$2 = '[object Float64Array]',
    int8Tag$2 = '[object Int8Array]',
    int16Tag$2 = '[object Int16Array]',
    int32Tag$2 = '[object Int32Array]',
    uint8Tag$2 = '[object Uint8Array]',
    uint8ClampedTag$2 = '[object Uint8ClampedArray]',
    uint16Tag$2 = '[object Uint16Array]',
    uint32Tag$2 = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] =
typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] =
typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] =
typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] =
typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] =
typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] =
typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] =
typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] =
typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] =
typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$2] =
typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] =
typedArrayTags[weakMapTag$2] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/** Detect free variable `exports`. */
var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports$1 && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$5.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray$1(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$3.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$4;

  return value === proto;
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

/** Used for built-in method references. */
var objectProto$3 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$2.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction$1(value);
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject$2(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty$1.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer$1 = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$1.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

/* Built-in method references that are verified to be native. */
var Promise$1 = getNative(root, 'Promise');

/* Built-in method references that are verified to be native. */
var Set$1 = getNative(root, 'Set');

/* Built-in method references that are verified to be native. */
var WeakMap$1 = getNative(root, 'WeakMap');

/** `Object#toString` result references. */
var mapTag$3 = '[object Map]',
    objectTag$1 = '[object Object]',
    promiseTag = '[object Promise]',
    setTag$3 = '[object Set]',
    weakMapTag$1 = '[object WeakMap]';

var dataViewTag$2 = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map$1),
    promiseCtorString = toSource(Promise$1),
    setCtorString = toSource(Set$1),
    weakMapCtorString = toSource(WeakMap$1);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$2) ||
    (Map$1 && getTag(new Map$1) != mapTag$3) ||
    (Promise$1 && getTag(Promise$1.resolve()) != promiseTag) ||
    (Set$1 && getTag(new Set$1) != setTag$3) ||
    (WeakMap$1 && getTag(new WeakMap$1) != weakMapTag$1)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag$1 ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag$2;
        case mapCtorString: return mapTag$3;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag$3;
        case weakMapCtorString: return weakMapTag$1;
      }
    }
    return result;
  };
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

/** Built-in value references. */
var Uint8Array$1 = root.Uint8Array;

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

/** Used to convert symbols to primitives and strings. */
var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/** `Object#toString` result references. */
var boolTag$1 = '[object Boolean]',
    dateTag$1 = '[object Date]',
    mapTag$2 = '[object Map]',
    numberTag$1 = '[object Number]',
    regexpTag$1 = '[object RegExp]',
    setTag$2 = '[object Set]',
    stringTag$1 = '[object String]',
    symbolTag$2 = '[object Symbol]';

var arrayBufferTag$1 = '[object ArrayBuffer]',
    dataViewTag$1 = '[object DataView]',
    float32Tag$1 = '[object Float32Array]',
    float64Tag$1 = '[object Float64Array]',
    int8Tag$1 = '[object Int8Array]',
    int16Tag$1 = '[object Int16Array]',
    int32Tag$1 = '[object Int32Array]',
    uint8Tag$1 = '[object Uint8Array]',
    uint8ClampedTag$1 = '[object Uint8ClampedArray]',
    uint16Tag$1 = '[object Uint16Array]',
    uint32Tag$1 = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(object);

    case boolTag$1:
    case dateTag$1:
      return new Ctor(+object);

    case dataViewTag$1:
      return cloneDataView(object, isDeep);

    case float32Tag$1: case float64Tag$1:
    case int8Tag$1: case int16Tag$1: case int32Tag$1:
    case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
      return cloneTypedArray(object, isDeep);

    case mapTag$2:
      return new Ctor;

    case numberTag$1:
    case stringTag$1:
      return new Ctor(object);

    case regexpTag$1:
      return cloneRegExp(object);

    case setTag$2:
      return new Ctor;

    case symbolTag$2:
      return cloneSymbol(object);
  }
}

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject$2(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

/** `Object#toString` result references. */
var mapTag$1 = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag$1;
}

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

/** `Object#toString` result references. */
var setTag$1 = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag$1;
}

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG$1 = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG$2 = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag$1 = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag$1] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG$1,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
  if (result !== undefined) {
    return result;
  }
  if (!isObject$2(value)) {
    return value;
  }
  var isArr = isArray$1(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG$1 = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG$1);
}

var isArray = Array.isArray;
var keyList = Object.keys;
var hasProp = Object.prototype.hasOwnProperty;
var hasElementType = typeof Element !== 'undefined';

function equal(a, b) {
  // fast-deep-equal index.js 2.0.1
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    var arrA = isArray(a)
      , arrB = isArray(b)
      , i
      , length
      , key;

    if (arrA && arrB) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }

    if (arrA != arrB) return false;

    var dateA = a instanceof Date
      , dateB = b instanceof Date;
    if (dateA != dateB) return false;
    if (dateA && dateB) return a.getTime() == b.getTime();

    var regexpA = a instanceof RegExp
      , regexpB = b instanceof RegExp;
    if (regexpA != regexpB) return false;
    if (regexpA && regexpB) return a.toString() == b.toString();

    var keys = keyList(a);
    length = keys.length;

    if (length !== keyList(b).length)
      return false;

    for (i = length; i-- !== 0;)
      if (!hasProp.call(b, keys[i])) return false;
    // end fast-deep-equal

    // start react-fast-compare
    // custom handling for DOM elements
    if (hasElementType && a instanceof Element && b instanceof Element)
      return a === b;

    // custom handling for React
    for (i = length; i-- !== 0;) {
      key = keys[i];
      if (key === '_owner' && a.$$typeof) {
        // React-specific: avoid traversing React elements' _owner.
        //  _owner contains circular references
        // and is not needed when comparing the actual elements (and not their owners)
        // .$$typeof and ._store on just reasonable markers of a react element
        continue;
      } else {
        // all other properties should be traversed as usual
        if (!equal(a[key], b[key])) return false;
      }
    }
    // end react-fast-compare

    // fast-deep-equal index.js 2.0.1
    return true;
  }

  return a !== a && b !== b;
}
// end fast-deep-equal

var reactFastCompare = function exportedEqual(a, b) {
  try {
    return equal(a, b);
  } catch (error) {
    if ((error.message && error.message.match(/stack|recursion/i)) || (error.number === -2146828260)) {
      // warn on circular references, don't crash
      // browsers give this different errors name and messages:
      // chrome/safari: "RangeError", "Maximum call stack size exceeded"
      // firefox: "InternalError", too much recursion"
      // edge: "Error", "Out of stack space"
      console.warn('Warning: react-fast-compare does not handle circular references.', error.name, error.message);
      return false;
    }
    // some other error. we should definitely know about these
    throw error;
  }
};

const isEqual = /*@__PURE__*/getDefaultExportFromCjs(reactFastCompare);

/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone$1(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize$1(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize$1.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize$1.Cache = MapCache;

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize$1(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -Infinity) ? '-0' : result;
}

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolToString$1 = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray$1(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString$1 ? symbolToString$1.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -Infinity) ? '-0' : result;
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString$1(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Converts `value` to a property path array.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Util
 * @param {*} value The value to convert.
 * @returns {Array} Returns the new property path array.
 * @example
 *
 * _.toPath('a.b.c');
 * // => ['a', 'b', 'c']
 *
 * _.toPath('a[0].b.c');
 * // => ['a', '0', 'b', 'c']
 */
function toPath(value) {
  if (isArray$1(value)) {
    return arrayMap(value, toKey);
  }
  return isSymbol(value) ? [value] : copyArray(stringToPath(toString$1(value)));
}

var reactIs$1 = {exports: {}};

var reactIs_production_min = {};

/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d$1=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f$1=b?Symbol.for("react.strict_mode"):60108,g$1=b?Symbol.for("react.profiler"):60114,h$1=b?Symbol.for("react.provider"):60109,k$1=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m$1=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p$1=b?Symbol.for("react.suspense"):60113,q$1=b?
Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v$1=b?Symbol.for("react.block"):60121,w$1=b?Symbol.for("react.fundamental"):60117,x$1=b?Symbol.for("react.responder"):60118,y$1=b?Symbol.for("react.scope"):60119;
function z$1(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m$1:case e:case g$1:case f$1:case p$1:return a;default:switch(a=a&&a.$$typeof,a){case k$1:case n:case t:case r:case h$1:return a;default:return u}}case d$1:return u}}}function A$1(a){return z$1(a)===m$1}reactIs_production_min.AsyncMode=l;reactIs_production_min.ConcurrentMode=m$1;reactIs_production_min.ContextConsumer=k$1;reactIs_production_min.ContextProvider=h$1;reactIs_production_min.Element=c;reactIs_production_min.ForwardRef=n;reactIs_production_min.Fragment=e;reactIs_production_min.Lazy=t;reactIs_production_min.Memo=r;reactIs_production_min.Portal=d$1;
reactIs_production_min.Profiler=g$1;reactIs_production_min.StrictMode=f$1;reactIs_production_min.Suspense=p$1;reactIs_production_min.isAsyncMode=function(a){return A$1(a)||z$1(a)===l};reactIs_production_min.isConcurrentMode=A$1;reactIs_production_min.isContextConsumer=function(a){return z$1(a)===k$1};reactIs_production_min.isContextProvider=function(a){return z$1(a)===h$1};reactIs_production_min.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c};reactIs_production_min.isForwardRef=function(a){return z$1(a)===n};reactIs_production_min.isFragment=function(a){return z$1(a)===e};reactIs_production_min.isLazy=function(a){return z$1(a)===t};
reactIs_production_min.isMemo=function(a){return z$1(a)===r};reactIs_production_min.isPortal=function(a){return z$1(a)===d$1};reactIs_production_min.isProfiler=function(a){return z$1(a)===g$1};reactIs_production_min.isStrictMode=function(a){return z$1(a)===f$1};reactIs_production_min.isSuspense=function(a){return z$1(a)===p$1};
reactIs_production_min.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e||a===m$1||a===g$1||a===f$1||a===p$1||a===q$1||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h$1||a.$$typeof===k$1||a.$$typeof===n||a.$$typeof===w$1||a.$$typeof===x$1||a.$$typeof===y$1||a.$$typeof===v$1)};reactIs_production_min.typeOf=z$1;

{
  reactIs$1.exports = reactIs_production_min;
}

var reactIsExports = reactIs$1.exports;

var reactIs = reactIsExports;
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

function _extends$2() {
  _extends$2 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var FormikContext = /* @__PURE__ */ reactExports.createContext(void 0);
FormikContext.displayName = "FormikContext";
var FormikProvider = FormikContext.Provider;
FormikContext.Consumer;
function useFormikContext() {
  var formik = reactExports.useContext(FormikContext);
  return formik;
}
var isFunction = function isFunction2(obj) {
  return typeof obj === "function";
};
var isObject$1 = function isObject2(obj) {
  return obj !== null && typeof obj === "object";
};
var isInteger = function isInteger2(obj) {
  return String(Math.floor(Number(obj))) === obj;
};
var isString = function isString2(obj) {
  return Object.prototype.toString.call(obj) === "[object String]";
};
var isEmptyChildren = function isEmptyChildren2(children) {
  return reactExports.Children.count(children) === 0;
};
var isPromise = function isPromise2(value) {
  return isObject$1(value) && isFunction(value.then);
};
function getIn$1(obj, key, def, p) {
  if (p === void 0) {
    p = 0;
  }
  var path = toPath(key);
  while (obj && p < path.length) {
    obj = obj[path[p++]];
  }
  if (p !== path.length && !obj) {
    return def;
  }
  return obj === void 0 ? def : obj;
}
function setIn(obj, path, value) {
  var res = clone$1(obj);
  var resVal = res;
  var i = 0;
  var pathArray = toPath(path);
  for (; i < pathArray.length - 1; i++) {
    var currentPath = pathArray[i];
    var currentObj = getIn$1(obj, pathArray.slice(0, i + 1));
    if (currentObj && (isObject$1(currentObj) || Array.isArray(currentObj))) {
      resVal = resVal[currentPath] = clone$1(currentObj);
    } else {
      var nextPath = pathArray[i + 1];
      resVal = resVal[currentPath] = isInteger(nextPath) && Number(nextPath) >= 0 ? [] : {};
    }
  }
  if ((i === 0 ? obj : resVal)[pathArray[i]] === value) {
    return obj;
  }
  if (value === void 0) {
    delete resVal[pathArray[i]];
  } else {
    resVal[pathArray[i]] = value;
  }
  if (i === 0 && value === void 0) {
    delete res[pathArray[i]];
  }
  return res;
}
function setNestedObjectValues(object, value, visited, response) {
  if (visited === void 0) {
    visited = /* @__PURE__ */ new WeakMap();
  }
  if (response === void 0) {
    response = {};
  }
  for (var _i = 0, _Object$keys = Object.keys(object); _i < _Object$keys.length; _i++) {
    var k = _Object$keys[_i];
    var val = object[k];
    if (isObject$1(val)) {
      if (!visited.get(val)) {
        visited.set(val, true);
        response[k] = Array.isArray(val) ? [] : {};
        setNestedObjectValues(val, value, visited, response[k]);
      }
    } else {
      response[k] = value;
    }
  }
  return response;
}
function formikReducer(state, msg) {
  switch (msg.type) {
    case "SET_VALUES":
      return _extends$2({}, state, {
        values: msg.payload
      });
    case "SET_TOUCHED":
      return _extends$2({}, state, {
        touched: msg.payload
      });
    case "SET_ERRORS":
      if (isEqual(state.errors, msg.payload)) {
        return state;
      }
      return _extends$2({}, state, {
        errors: msg.payload
      });
    case "SET_STATUS":
      return _extends$2({}, state, {
        status: msg.payload
      });
    case "SET_ISSUBMITTING":
      return _extends$2({}, state, {
        isSubmitting: msg.payload
      });
    case "SET_ISVALIDATING":
      return _extends$2({}, state, {
        isValidating: msg.payload
      });
    case "SET_FIELD_VALUE":
      return _extends$2({}, state, {
        values: setIn(state.values, msg.payload.field, msg.payload.value)
      });
    case "SET_FIELD_TOUCHED":
      return _extends$2({}, state, {
        touched: setIn(state.touched, msg.payload.field, msg.payload.value)
      });
    case "SET_FIELD_ERROR":
      return _extends$2({}, state, {
        errors: setIn(state.errors, msg.payload.field, msg.payload.value)
      });
    case "RESET_FORM":
      return _extends$2({}, state, msg.payload);
    case "SET_FORMIK_STATE":
      return msg.payload(state);
    case "SUBMIT_ATTEMPT":
      return _extends$2({}, state, {
        touched: setNestedObjectValues(state.values, true),
        isSubmitting: true,
        submitCount: state.submitCount + 1
      });
    case "SUBMIT_FAILURE":
      return _extends$2({}, state, {
        isSubmitting: false
      });
    case "SUBMIT_SUCCESS":
      return _extends$2({}, state, {
        isSubmitting: false
      });
    default:
      return state;
  }
}
var emptyErrors = {};
var emptyTouched = {};
function useFormik(_ref) {
  var _ref$validateOnChange = _ref.validateOnChange, validateOnChange = _ref$validateOnChange === void 0 ? true : _ref$validateOnChange, _ref$validateOnBlur = _ref.validateOnBlur, validateOnBlur = _ref$validateOnBlur === void 0 ? true : _ref$validateOnBlur, _ref$validateOnMount = _ref.validateOnMount, validateOnMount = _ref$validateOnMount === void 0 ? false : _ref$validateOnMount, isInitialValid = _ref.isInitialValid, _ref$enableReinitiali = _ref.enableReinitialize, enableReinitialize = _ref$enableReinitiali === void 0 ? false : _ref$enableReinitiali, onSubmit = _ref.onSubmit, rest = _objectWithoutPropertiesLoose$1(_ref, ["validateOnChange", "validateOnBlur", "validateOnMount", "isInitialValid", "enableReinitialize", "onSubmit"]);
  var props = _extends$2({
    validateOnChange,
    validateOnBlur,
    validateOnMount,
    onSubmit
  }, rest);
  var initialValues = reactExports.useRef(props.initialValues);
  var initialErrors = reactExports.useRef(props.initialErrors || emptyErrors);
  var initialTouched = reactExports.useRef(props.initialTouched || emptyTouched);
  var initialStatus = reactExports.useRef(props.initialStatus);
  var isMounted = reactExports.useRef(false);
  var fieldRegistry = reactExports.useRef({});
  reactExports.useEffect(function() {
    isMounted.current = true;
    return function() {
      isMounted.current = false;
    };
  }, []);
  var _React$useState = reactExports.useState(0), setIteration = _React$useState[1];
  var stateRef = reactExports.useRef({
    values: cloneDeep(props.initialValues),
    errors: cloneDeep(props.initialErrors) || emptyErrors,
    touched: cloneDeep(props.initialTouched) || emptyTouched,
    status: cloneDeep(props.initialStatus),
    isSubmitting: false,
    isValidating: false,
    submitCount: 0
  });
  var state = stateRef.current;
  var dispatch = reactExports.useCallback(function(action) {
    var prev = stateRef.current;
    stateRef.current = formikReducer(prev, action);
    if (prev !== stateRef.current) setIteration(function(x) {
      return x + 1;
    });
  }, []);
  var runValidateHandler = reactExports.useCallback(function(values, field) {
    return new Promise(function(resolve, reject) {
      var maybePromisedErrors = props.validate(values, field);
      if (maybePromisedErrors == null) {
        resolve(emptyErrors);
      } else if (isPromise(maybePromisedErrors)) {
        maybePromisedErrors.then(function(errors) {
          resolve(errors || emptyErrors);
        }, function(actualException) {
          reject(actualException);
        });
      } else {
        resolve(maybePromisedErrors);
      }
    });
  }, [props.validate]);
  var runValidationSchema = reactExports.useCallback(function(values, field) {
    var validationSchema = props.validationSchema;
    var schema = isFunction(validationSchema) ? validationSchema(field) : validationSchema;
    var promise = field && schema.validateAt ? schema.validateAt(field, values) : validateYupSchema(values, schema);
    return new Promise(function(resolve, reject) {
      promise.then(function() {
        resolve(emptyErrors);
      }, function(err) {
        if (err.name === "ValidationError") {
          resolve(yupToFormErrors(err));
        } else {
          reject(err);
        }
      });
    });
  }, [props.validationSchema]);
  var runSingleFieldLevelValidation = reactExports.useCallback(function(field, value) {
    return new Promise(function(resolve) {
      return resolve(fieldRegistry.current[field].validate(value));
    });
  }, []);
  var runFieldLevelValidations = reactExports.useCallback(function(values) {
    var fieldKeysWithValidation = Object.keys(fieldRegistry.current).filter(function(f) {
      return isFunction(fieldRegistry.current[f].validate);
    });
    var fieldValidations = fieldKeysWithValidation.length > 0 ? fieldKeysWithValidation.map(function(f) {
      return runSingleFieldLevelValidation(f, getIn$1(values, f));
    }) : [Promise.resolve("DO_NOT_DELETE_YOU_WILL_BE_FIRED")];
    return Promise.all(fieldValidations).then(function(fieldErrorsList) {
      return fieldErrorsList.reduce(function(prev, curr, index) {
        if (curr === "DO_NOT_DELETE_YOU_WILL_BE_FIRED") {
          return prev;
        }
        if (curr) {
          prev = setIn(prev, fieldKeysWithValidation[index], curr);
        }
        return prev;
      }, {});
    });
  }, [runSingleFieldLevelValidation]);
  var runAllValidations = reactExports.useCallback(function(values) {
    return Promise.all([runFieldLevelValidations(values), props.validationSchema ? runValidationSchema(values) : {}, props.validate ? runValidateHandler(values) : {}]).then(function(_ref2) {
      var fieldErrors = _ref2[0], schemaErrors = _ref2[1], validateErrors = _ref2[2];
      var combinedErrors = deepmerge_1.all([fieldErrors, schemaErrors, validateErrors], {
        arrayMerge
      });
      return combinedErrors;
    });
  }, [props.validate, props.validationSchema, runFieldLevelValidations, runValidateHandler, runValidationSchema]);
  var validateFormWithHighPriority = useEventCallback(function(values) {
    if (values === void 0) {
      values = state.values;
    }
    dispatch({
      type: "SET_ISVALIDATING",
      payload: true
    });
    return runAllValidations(values).then(function(combinedErrors) {
      if (!!isMounted.current) {
        dispatch({
          type: "SET_ISVALIDATING",
          payload: false
        });
        dispatch({
          type: "SET_ERRORS",
          payload: combinedErrors
        });
      }
      return combinedErrors;
    });
  });
  reactExports.useEffect(function() {
    if (validateOnMount && isMounted.current === true && isEqual(initialValues.current, props.initialValues)) {
      validateFormWithHighPriority(initialValues.current);
    }
  }, [validateOnMount, validateFormWithHighPriority]);
  var resetForm = reactExports.useCallback(function(nextState) {
    var values = nextState && nextState.values ? nextState.values : initialValues.current;
    var errors = nextState && nextState.errors ? nextState.errors : initialErrors.current ? initialErrors.current : props.initialErrors || {};
    var touched = nextState && nextState.touched ? nextState.touched : initialTouched.current ? initialTouched.current : props.initialTouched || {};
    var status = nextState && nextState.status ? nextState.status : initialStatus.current ? initialStatus.current : props.initialStatus;
    initialValues.current = values;
    initialErrors.current = errors;
    initialTouched.current = touched;
    initialStatus.current = status;
    var dispatchFn = function dispatchFn2() {
      dispatch({
        type: "RESET_FORM",
        payload: {
          isSubmitting: !!nextState && !!nextState.isSubmitting,
          errors,
          touched,
          status,
          values,
          isValidating: !!nextState && !!nextState.isValidating,
          submitCount: !!nextState && !!nextState.submitCount && typeof nextState.submitCount === "number" ? nextState.submitCount : 0
        }
      });
    };
    if (props.onReset) {
      var maybePromisedOnReset = props.onReset(state.values, imperativeMethods);
      if (isPromise(maybePromisedOnReset)) {
        maybePromisedOnReset.then(dispatchFn);
      } else {
        dispatchFn();
      }
    } else {
      dispatchFn();
    }
  }, [props.initialErrors, props.initialStatus, props.initialTouched, props.onReset]);
  reactExports.useEffect(function() {
    if (isMounted.current === true && !isEqual(initialValues.current, props.initialValues)) {
      if (enableReinitialize) {
        initialValues.current = props.initialValues;
        resetForm();
        if (validateOnMount) {
          validateFormWithHighPriority(initialValues.current);
        }
      }
    }
  }, [enableReinitialize, props.initialValues, resetForm, validateOnMount, validateFormWithHighPriority]);
  reactExports.useEffect(function() {
    if (enableReinitialize && isMounted.current === true && !isEqual(initialErrors.current, props.initialErrors)) {
      initialErrors.current = props.initialErrors || emptyErrors;
      dispatch({
        type: "SET_ERRORS",
        payload: props.initialErrors || emptyErrors
      });
    }
  }, [enableReinitialize, props.initialErrors]);
  reactExports.useEffect(function() {
    if (enableReinitialize && isMounted.current === true && !isEqual(initialTouched.current, props.initialTouched)) {
      initialTouched.current = props.initialTouched || emptyTouched;
      dispatch({
        type: "SET_TOUCHED",
        payload: props.initialTouched || emptyTouched
      });
    }
  }, [enableReinitialize, props.initialTouched]);
  reactExports.useEffect(function() {
    if (enableReinitialize && isMounted.current === true && !isEqual(initialStatus.current, props.initialStatus)) {
      initialStatus.current = props.initialStatus;
      dispatch({
        type: "SET_STATUS",
        payload: props.initialStatus
      });
    }
  }, [enableReinitialize, props.initialStatus, props.initialTouched]);
  var validateField = useEventCallback(function(name) {
    if (fieldRegistry.current[name] && isFunction(fieldRegistry.current[name].validate)) {
      var value = getIn$1(state.values, name);
      var maybePromise = fieldRegistry.current[name].validate(value);
      if (isPromise(maybePromise)) {
        dispatch({
          type: "SET_ISVALIDATING",
          payload: true
        });
        return maybePromise.then(function(x) {
          return x;
        }).then(function(error) {
          dispatch({
            type: "SET_FIELD_ERROR",
            payload: {
              field: name,
              value: error
            }
          });
          dispatch({
            type: "SET_ISVALIDATING",
            payload: false
          });
        });
      } else {
        dispatch({
          type: "SET_FIELD_ERROR",
          payload: {
            field: name,
            value: maybePromise
          }
        });
        return Promise.resolve(maybePromise);
      }
    } else if (props.validationSchema) {
      dispatch({
        type: "SET_ISVALIDATING",
        payload: true
      });
      return runValidationSchema(state.values, name).then(function(x) {
        return x;
      }).then(function(error) {
        dispatch({
          type: "SET_FIELD_ERROR",
          payload: {
            field: name,
            value: getIn$1(error, name)
          }
        });
        dispatch({
          type: "SET_ISVALIDATING",
          payload: false
        });
      });
    }
    return Promise.resolve();
  });
  var registerField = reactExports.useCallback(function(name, _ref3) {
    var validate = _ref3.validate;
    fieldRegistry.current[name] = {
      validate
    };
  }, []);
  var unregisterField = reactExports.useCallback(function(name) {
    delete fieldRegistry.current[name];
  }, []);
  var setTouched = useEventCallback(function(touched, shouldValidate) {
    dispatch({
      type: "SET_TOUCHED",
      payload: touched
    });
    var willValidate = shouldValidate === void 0 ? validateOnBlur : shouldValidate;
    return willValidate ? validateFormWithHighPriority(state.values) : Promise.resolve();
  });
  var setErrors = reactExports.useCallback(function(errors) {
    dispatch({
      type: "SET_ERRORS",
      payload: errors
    });
  }, []);
  var setValues = useEventCallback(function(values, shouldValidate) {
    var resolvedValues = isFunction(values) ? values(state.values) : values;
    dispatch({
      type: "SET_VALUES",
      payload: resolvedValues
    });
    var willValidate = shouldValidate === void 0 ? validateOnChange : shouldValidate;
    return willValidate ? validateFormWithHighPriority(resolvedValues) : Promise.resolve();
  });
  var setFieldError = reactExports.useCallback(function(field, value) {
    dispatch({
      type: "SET_FIELD_ERROR",
      payload: {
        field,
        value
      }
    });
  }, []);
  var setFieldValue = useEventCallback(function(field, value, shouldValidate) {
    dispatch({
      type: "SET_FIELD_VALUE",
      payload: {
        field,
        value
      }
    });
    var willValidate = shouldValidate === void 0 ? validateOnChange : shouldValidate;
    return willValidate ? validateFormWithHighPriority(setIn(state.values, field, value)) : Promise.resolve();
  });
  var executeChange = reactExports.useCallback(function(eventOrTextValue, maybePath) {
    var field = maybePath;
    var val = eventOrTextValue;
    var parsed;
    if (!isString(eventOrTextValue)) {
      if (eventOrTextValue.persist) {
        eventOrTextValue.persist();
      }
      var target = eventOrTextValue.target ? eventOrTextValue.target : eventOrTextValue.currentTarget;
      var type = target.type, name = target.name, id = target.id, value = target.value, checked = target.checked; target.outerHTML; var options = target.options, multiple = target.multiple;
      field = maybePath ? maybePath : name ? name : id;
      val = /number|range/.test(type) ? (parsed = parseFloat(value), isNaN(parsed) ? "" : parsed) : /checkbox/.test(type) ? getValueForCheckbox(getIn$1(state.values, field), checked, value) : options && multiple ? getSelectedValues(options) : value;
    }
    if (field) {
      setFieldValue(field, val);
    }
  }, [setFieldValue, state.values]);
  var handleChange = useEventCallback(function(eventOrPath) {
    if (isString(eventOrPath)) {
      return function(event) {
        return executeChange(event, eventOrPath);
      };
    } else {
      executeChange(eventOrPath);
    }
  });
  var setFieldTouched = useEventCallback(function(field, touched, shouldValidate) {
    if (touched === void 0) {
      touched = true;
    }
    dispatch({
      type: "SET_FIELD_TOUCHED",
      payload: {
        field,
        value: touched
      }
    });
    var willValidate = shouldValidate === void 0 ? validateOnBlur : shouldValidate;
    return willValidate ? validateFormWithHighPriority(state.values) : Promise.resolve();
  });
  var executeBlur = reactExports.useCallback(function(e, path) {
    if (e.persist) {
      e.persist();
    }
    var _e$target = e.target, name = _e$target.name, id = _e$target.id; _e$target.outerHTML;
    var field = path ? path : name ? name : id;
    setFieldTouched(field, true);
  }, [setFieldTouched]);
  var handleBlur = useEventCallback(function(eventOrString) {
    if (isString(eventOrString)) {
      return function(event) {
        return executeBlur(event, eventOrString);
      };
    } else {
      executeBlur(eventOrString);
    }
  });
  var setFormikState = reactExports.useCallback(function(stateOrCb) {
    if (isFunction(stateOrCb)) {
      dispatch({
        type: "SET_FORMIK_STATE",
        payload: stateOrCb
      });
    } else {
      dispatch({
        type: "SET_FORMIK_STATE",
        payload: function payload() {
          return stateOrCb;
        }
      });
    }
  }, []);
  var setStatus = reactExports.useCallback(function(status) {
    dispatch({
      type: "SET_STATUS",
      payload: status
    });
  }, []);
  var setSubmitting = reactExports.useCallback(function(isSubmitting) {
    dispatch({
      type: "SET_ISSUBMITTING",
      payload: isSubmitting
    });
  }, []);
  var submitForm = useEventCallback(function() {
    dispatch({
      type: "SUBMIT_ATTEMPT"
    });
    return validateFormWithHighPriority().then(function(combinedErrors) {
      var isInstanceOfError = combinedErrors instanceof Error;
      var isActuallyValid = !isInstanceOfError && Object.keys(combinedErrors).length === 0;
      if (isActuallyValid) {
        var promiseOrUndefined;
        try {
          promiseOrUndefined = executeSubmit();
          if (promiseOrUndefined === void 0) {
            return;
          }
        } catch (error) {
          throw error;
        }
        return Promise.resolve(promiseOrUndefined).then(function(result) {
          if (!!isMounted.current) {
            dispatch({
              type: "SUBMIT_SUCCESS"
            });
          }
          return result;
        })["catch"](function(_errors) {
          if (!!isMounted.current) {
            dispatch({
              type: "SUBMIT_FAILURE"
            });
            throw _errors;
          }
        });
      } else if (!!isMounted.current) {
        dispatch({
          type: "SUBMIT_FAILURE"
        });
        if (isInstanceOfError) {
          throw combinedErrors;
        }
      }
      return;
    });
  });
  var handleSubmit = useEventCallback(function(e) {
    if (e && e.preventDefault && isFunction(e.preventDefault)) {
      e.preventDefault();
    }
    if (e && e.stopPropagation && isFunction(e.stopPropagation)) {
      e.stopPropagation();
    }
    submitForm()["catch"](function(reason) {
      console.warn("Warning: An unhandled error was caught from submitForm()", reason);
    });
  });
  var imperativeMethods = {
    resetForm,
    validateForm: validateFormWithHighPriority,
    validateField,
    setErrors,
    setFieldError,
    setFieldTouched,
    setFieldValue,
    setStatus,
    setSubmitting,
    setTouched,
    setValues,
    setFormikState,
    submitForm
  };
  var executeSubmit = useEventCallback(function() {
    return onSubmit(state.values, imperativeMethods);
  });
  var handleReset = useEventCallback(function(e) {
    if (e && e.preventDefault && isFunction(e.preventDefault)) {
      e.preventDefault();
    }
    if (e && e.stopPropagation && isFunction(e.stopPropagation)) {
      e.stopPropagation();
    }
    resetForm();
  });
  var getFieldMeta = reactExports.useCallback(function(name) {
    return {
      value: getIn$1(state.values, name),
      error: getIn$1(state.errors, name),
      touched: !!getIn$1(state.touched, name),
      initialValue: getIn$1(initialValues.current, name),
      initialTouched: !!getIn$1(initialTouched.current, name),
      initialError: getIn$1(initialErrors.current, name)
    };
  }, [state.errors, state.touched, state.values]);
  var getFieldHelpers = reactExports.useCallback(function(name) {
    return {
      setValue: function setValue(value, shouldValidate) {
        return setFieldValue(name, value, shouldValidate);
      },
      setTouched: function setTouched2(value, shouldValidate) {
        return setFieldTouched(name, value, shouldValidate);
      },
      setError: function setError(value) {
        return setFieldError(name, value);
      }
    };
  }, [setFieldValue, setFieldTouched, setFieldError]);
  var getFieldProps = reactExports.useCallback(function(nameOrOptions) {
    var isAnObject = isObject$1(nameOrOptions);
    var name = isAnObject ? nameOrOptions.name : nameOrOptions;
    var valueState = getIn$1(state.values, name);
    var field = {
      name,
      value: valueState,
      onChange: handleChange,
      onBlur: handleBlur
    };
    if (isAnObject) {
      var type = nameOrOptions.type, valueProp = nameOrOptions.value, is = nameOrOptions.as, multiple = nameOrOptions.multiple;
      if (type === "checkbox") {
        if (valueProp === void 0) {
          field.checked = !!valueState;
        } else {
          field.checked = !!(Array.isArray(valueState) && ~valueState.indexOf(valueProp));
          field.value = valueProp;
        }
      } else if (type === "radio") {
        field.checked = valueState === valueProp;
        field.value = valueProp;
      } else if (is === "select" && multiple) {
        field.value = field.value || [];
        field.multiple = true;
      }
    }
    return field;
  }, [handleBlur, handleChange, state.values]);
  var dirty = reactExports.useMemo(function() {
    return !isEqual(initialValues.current, state.values);
  }, [initialValues.current, state.values]);
  var isValid = reactExports.useMemo(function() {
    return typeof isInitialValid !== "undefined" ? dirty ? state.errors && Object.keys(state.errors).length === 0 : isInitialValid !== false && isFunction(isInitialValid) ? isInitialValid(props) : isInitialValid : state.errors && Object.keys(state.errors).length === 0;
  }, [isInitialValid, dirty, state.errors, props]);
  var ctx = _extends$2({}, state, {
    initialValues: initialValues.current,
    initialErrors: initialErrors.current,
    initialTouched: initialTouched.current,
    initialStatus: initialStatus.current,
    handleBlur,
    handleChange,
    handleReset,
    handleSubmit,
    resetForm,
    setErrors,
    setFormikState,
    setFieldTouched,
    setFieldValue,
    setFieldError,
    setStatus,
    setSubmitting,
    setTouched,
    setValues,
    submitForm,
    validateForm: validateFormWithHighPriority,
    validateField,
    isValid,
    dirty,
    unregisterField,
    registerField,
    getFieldProps,
    getFieldMeta,
    getFieldHelpers,
    validateOnBlur,
    validateOnChange,
    validateOnMount
  });
  return ctx;
}
function Formik(props) {
  var formikbag = useFormik(props);
  var component = props.component, children = props.children, render = props.render, innerRef = props.innerRef;
  reactExports.useImperativeHandle(innerRef, function() {
    return formikbag;
  });
  return reactExports.createElement(FormikProvider, {
    value: formikbag
  }, component ? reactExports.createElement(component, formikbag) : render ? render(formikbag) : children ? isFunction(children) ? children(formikbag) : !isEmptyChildren(children) ? reactExports.Children.only(children) : null : null);
}
function yupToFormErrors(yupError) {
  var errors = {};
  if (yupError.inner) {
    if (yupError.inner.length === 0) {
      return setIn(errors, yupError.path, yupError.message);
    }
    for (var _iterator = yupError.inner, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ; ) {
      var _ref5;
      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref5 = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref5 = _i.value;
      }
      var err = _ref5;
      if (!getIn$1(errors, err.path)) {
        errors = setIn(errors, err.path, err.message);
      }
    }
  }
  return errors;
}
function validateYupSchema(values, schema, sync, context) {
  if (sync === void 0) {
    sync = false;
  }
  var normalizedValues = prepareDataForValidation(values);
  return schema[sync ? "validateSync" : "validate"](normalizedValues, {
    abortEarly: false,
    context: normalizedValues
  });
}
function prepareDataForValidation(values) {
  var data = Array.isArray(values) ? [] : {};
  for (var k in values) {
    if (Object.prototype.hasOwnProperty.call(values, k)) {
      var key = String(k);
      if (Array.isArray(values[key]) === true) {
        data[key] = values[key].map(function(value) {
          if (Array.isArray(value) === true || isPlainObject(value)) {
            return prepareDataForValidation(value);
          } else {
            return value !== "" ? value : void 0;
          }
        });
      } else if (isPlainObject(values[key])) {
        data[key] = prepareDataForValidation(values[key]);
      } else {
        data[key] = values[key] !== "" ? values[key] : void 0;
      }
    }
  }
  return data;
}
function arrayMerge(target, source, options) {
  var destination = target.slice();
  source.forEach(function merge(e, i) {
    if (typeof destination[i] === "undefined") {
      var cloneRequested = options.clone !== false;
      var shouldClone = cloneRequested && options.isMergeableObject(e);
      destination[i] = shouldClone ? deepmerge_1(Array.isArray(e) ? [] : {}, e, options) : e;
    } else if (options.isMergeableObject(e)) {
      destination[i] = deepmerge_1(target[i], e, options);
    } else if (target.indexOf(e) === -1) {
      destination.push(e);
    }
  });
  return destination;
}
function getSelectedValues(options) {
  return Array.from(options).filter(function(el) {
    return el.selected;
  }).map(function(el) {
    return el.value;
  });
}
function getValueForCheckbox(currentValue, checked, valueProp) {
  if (typeof currentValue === "boolean") {
    return Boolean(checked);
  }
  var currentArrayOfValues = [];
  var isValueInArray = false;
  var index = -1;
  if (!Array.isArray(currentValue)) {
    if (!valueProp || valueProp == "true" || valueProp == "false") {
      return Boolean(checked);
    }
  } else {
    currentArrayOfValues = currentValue;
    index = currentValue.indexOf(valueProp);
    isValueInArray = index >= 0;
  }
  if (checked && valueProp && !isValueInArray) {
    return currentArrayOfValues.concat(valueProp);
  }
  if (!isValueInArray) {
    return currentArrayOfValues;
  }
  return currentArrayOfValues.slice(0, index).concat(currentArrayOfValues.slice(index + 1));
}
var useIsomorphicLayoutEffect = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function useEventCallback(fn) {
  var ref = reactExports.useRef(fn);
  useIsomorphicLayoutEffect(function() {
    ref.current = fn;
  });
  return reactExports.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref.current.apply(void 0, args);
  }, []);
}
var Form = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
  var action = props.action, rest = _objectWithoutPropertiesLoose$1(props, ["action"]);
  var _action = action != null ? action : "#";
  var _useFormikContext = useFormikContext(), handleReset = _useFormikContext.handleReset, handleSubmit = _useFormikContext.handleSubmit;
  return reactExports.createElement("form", _extends$2({
    onSubmit: handleSubmit,
    ref,
    onReset: handleReset,
    action: _action
  }, rest));
});
Form.displayName = "Form";

/**
 * Based on Kendo UI Core expression code <https://github.com/telerik/kendo-ui-core#license-information>
 */

function Cache(maxSize) {
  this._maxSize = maxSize;
  this.clear();
}
Cache.prototype.clear = function () {
  this._size = 0;
  this._values = Object.create(null);
};
Cache.prototype.get = function (key) {
  return this._values[key]
};
Cache.prototype.set = function (key, value) {
  this._size >= this._maxSize && this.clear();
  if (!(key in this._values)) this._size++;

  return (this._values[key] = value)
};

var SPLIT_REGEX = /[^.^\]^[]+|(?=\[\]|\.\.)/g,
  DIGIT_REGEX = /^\d+$/,
  LEAD_DIGIT_REGEX = /^\d/,
  SPEC_CHAR_REGEX = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g,
  CLEAN_QUOTES_REGEX = /^\s*(['"]?)(.*?)(\1)\s*$/,
  MAX_CACHE_SIZE = 512;

var pathCache = new Cache(MAX_CACHE_SIZE),
  setCache = new Cache(MAX_CACHE_SIZE),
  getCache = new Cache(MAX_CACHE_SIZE);

var propertyExpr = {
  Cache: Cache,

  split: split,

  normalizePath: normalizePath,

  setter: function (path) {
    var parts = normalizePath(path);

    return (
      setCache.get(path) ||
      setCache.set(path, function setter(obj, value) {
        var index = 0;
        var len = parts.length;
        var data = obj;

        while (index < len - 1) {
          var part = parts[index];
          if (
            part === '__proto__' ||
            part === 'constructor' ||
            part === 'prototype'
          ) {
            return obj
          }

          data = data[parts[index++]];
        }
        data[parts[index]] = value;
      })
    )
  },

  getter: function (path, safe) {
    var parts = normalizePath(path);
    return (
      getCache.get(path) ||
      getCache.set(path, function getter(data) {
        var index = 0,
          len = parts.length;
        while (index < len) {
          if (data != null || !safe) data = data[parts[index++]];
          else return
        }
        return data
      })
    )
  },

  join: function (segments) {
    return segments.reduce(function (path, part) {
      return (
        path +
        (isQuoted(part) || DIGIT_REGEX.test(part)
          ? '[' + part + ']'
          : (path ? '.' : '') + part)
      )
    }, '')
  },

  forEach: function (path, cb, thisArg) {
    forEach(Array.isArray(path) ? path : split(path), cb, thisArg);
  },
};

function normalizePath(path) {
  return (
    pathCache.get(path) ||
    pathCache.set(
      path,
      split(path).map(function (part) {
        return part.replace(CLEAN_QUOTES_REGEX, '$2')
      })
    )
  )
}

function split(path) {
  return path.match(SPLIT_REGEX) || ['']
}

function forEach(parts, iter, thisArg) {
  var len = parts.length,
    part,
    idx,
    isArray,
    isBracket;

  for (idx = 0; idx < len; idx++) {
    part = parts[idx];

    if (part) {
      if (shouldBeQuoted(part)) {
        part = '"' + part + '"';
      }

      isBracket = isQuoted(part);
      isArray = !isBracket && /^\d+$/.test(part);

      iter.call(thisArg, part, isBracket, isArray, idx, parts);
    }
  }
}

function isQuoted(str) {
  return (
    typeof str === 'string' && str && ["'", '"'].indexOf(str.charAt(0)) !== -1
  )
}

function hasLeadingNumber(part) {
  return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX)
}

function hasSpecialChars(part) {
  return SPEC_CHAR_REGEX.test(part)
}

function shouldBeQuoted(part) {
  return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part))
}

const reWords = /[A-Z\xc0-\xd6\xd8-\xde]?[a-z\xdf-\xf6\xf8-\xff]+(?:['’](?:d|ll|m|re|s|t|ve))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde]|$)|(?:[A-Z\xc0-\xd6\xd8-\xde]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['’](?:D|LL|M|RE|S|T|VE))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde](?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])|$)|[A-Z\xc0-\xd6\xd8-\xde]?(?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['’](?:d|ll|m|re|s|t|ve))?|[A-Z\xc0-\xd6\xd8-\xde]+(?:['’](?:D|LL|M|RE|S|T|VE))?|\d*(?:1ST|2ND|3RD|(?![123])\dTH)(?=\b|[a-z_])|\d*(?:1st|2nd|3rd|(?![123])\dth)(?=\b|[A-Z_])|\d+|(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?(?:\u200d(?:[^\ud800-\udfff]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?)*/g;

const words = (str) => str.match(reWords) || [];

const upperFirst = (str) => str[0].toUpperCase() + str.slice(1);

const join = (str, d) => words(str).join(d).toLowerCase();

const camelCase = (str) =>
  words(str).reduce(
    (acc, next) =>
      `${acc}${
        !acc
          ? next.toLowerCase()
          : next[0].toUpperCase() + next.slice(1).toLowerCase()
      }`,
    '',
  );

const pascalCase = (str) => upperFirst(camelCase(str));

const snakeCase = (str) => join(str, '_');

const kebabCase = (str) => join(str, '-');

const sentenceCase = (str) => upperFirst(join(str, ' '));

const titleCase = (str) => words(str).map(upperFirst).join(' ');

var tinyCase = {
  words,
  upperFirst,
  camelCase,
  pascalCase,
  snakeCase,
  kebabCase,
  sentenceCase,
  titleCase,
};

var toposort$2 = {exports: {}};

/**
 * Topological sorting function
 *
 * @param {Array} edges
 * @returns {Array}
 */

toposort$2.exports = function(edges) {
  return toposort(uniqueNodes(edges), edges)
};

toposort$2.exports.array = toposort;

function toposort(nodes, edges) {
  var cursor = nodes.length
    , sorted = new Array(cursor)
    , visited = {}
    , i = cursor
    // Better data structures make algorithm much faster.
    , outgoingEdges = makeOutgoingEdges(edges)
    , nodesHash = makeNodesHash(nodes);

  // check for unknown nodes
  edges.forEach(function(edge) {
    if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {
      throw new Error('Unknown node. There is an unknown node in the supplied edges.')
    }
  });

  while (i--) {
    if (!visited[i]) visit(nodes[i], i, new Set());
  }

  return sorted

  function visit(node, i, predecessors) {
    if(predecessors.has(node)) {
      var nodeRep;
      try {
        nodeRep = ", node was:" + JSON.stringify(node);
      } catch(e) {
        nodeRep = "";
      }
      throw new Error('Cyclic dependency' + nodeRep)
    }

    if (!nodesHash.has(node)) {
      throw new Error('Found unknown node. Make sure to provided all involved nodes. Unknown node: '+JSON.stringify(node))
    }

    if (visited[i]) return;
    visited[i] = true;

    var outgoing = outgoingEdges.get(node) || new Set();
    outgoing = Array.from(outgoing);

    if (i = outgoing.length) {
      predecessors.add(node);
      do {
        var child = outgoing[--i];
        visit(child, nodesHash.get(child), predecessors);
      } while (i)
      predecessors.delete(node);
    }

    sorted[--cursor] = node;
  }
}

function uniqueNodes(arr){
  var res = new Set();
  for (var i = 0, len = arr.length; i < len; i++) {
    var edge = arr[i];
    res.add(edge[0]);
    res.add(edge[1]);
  }
  return Array.from(res)
}

function makeOutgoingEdges(arr){
  var edges = new Map();
  for (var i = 0, len = arr.length; i < len; i++) {
    var edge = arr[i];
    if (!edges.has(edge[0])) edges.set(edge[0], new Set());
    if (!edges.has(edge[1])) edges.set(edge[1], new Set());
    edges.get(edge[0]).add(edge[1]);
  }
  return edges
}

function makeNodesHash(arr){
  var res = new Map();
  for (var i = 0, len = arr.length; i < len; i++) {
    res.set(arr[i], i);
  }
  return res
}

var toposortExports = toposort$2.exports;
const toposort$1 = /*@__PURE__*/getDefaultExportFromCjs(toposortExports);

const toString = Object.prototype.toString;
const errorToString = Error.prototype.toString;
const regExpToString = RegExp.prototype.toString;
const symbolToString = typeof Symbol !== 'undefined' ? Symbol.prototype.toString : () => '';
const SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
function printNumber(val) {
  if (val != +val) return 'NaN';
  const isNegativeZero = val === 0 && 1 / val < 0;
  return isNegativeZero ? '-0' : '' + val;
}
function printSimpleValue(val, quoteStrings = false) {
  if (val == null || val === true || val === false) return '' + val;
  const typeOf = typeof val;
  if (typeOf === 'number') return printNumber(val);
  if (typeOf === 'string') return quoteStrings ? `"${val}"` : val;
  if (typeOf === 'function') return '[Function ' + (val.name || 'anonymous') + ']';
  if (typeOf === 'symbol') return symbolToString.call(val).replace(SYMBOL_REGEXP, 'Symbol($1)');
  const tag = toString.call(val).slice(8, -1);
  if (tag === 'Date') return isNaN(val.getTime()) ? '' + val : val.toISOString(val);
  if (tag === 'Error' || val instanceof Error) return '[' + errorToString.call(val) + ']';
  if (tag === 'RegExp') return regExpToString.call(val);
  return null;
}
function printValue(value, quoteStrings) {
  let result = printSimpleValue(value, quoteStrings);
  if (result !== null) return result;
  return JSON.stringify(value, function (key, value) {
    let result = printSimpleValue(this[key], quoteStrings);
    if (result !== null) return result;
    return value;
  }, 2);
}

function toArray(value) {
  return value == null ? [] : [].concat(value);
}

let _Symbol$toStringTag, _Symbol$hasInstance, _Symbol$toStringTag2;
let strReg = /\$\{\s*(\w+)\s*\}/g;
_Symbol$toStringTag = Symbol.toStringTag;
class ValidationErrorNoStack {
  constructor(errorOrErrors, value, field, type) {
    this.name = void 0;
    this.message = void 0;
    this.value = void 0;
    this.path = void 0;
    this.type = void 0;
    this.params = void 0;
    this.errors = void 0;
    this.inner = void 0;
    this[_Symbol$toStringTag] = 'Error';
    this.name = 'ValidationError';
    this.value = value;
    this.path = field;
    this.type = type;
    this.errors = [];
    this.inner = [];
    toArray(errorOrErrors).forEach(err => {
      if (ValidationError.isError(err)) {
        this.errors.push(...err.errors);
        const innerErrors = err.inner.length ? err.inner : [err];
        this.inner.push(...innerErrors);
      } else {
        this.errors.push(err);
      }
    });
    this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0];
  }
}
_Symbol$hasInstance = Symbol.hasInstance;
_Symbol$toStringTag2 = Symbol.toStringTag;
class ValidationError extends Error {
  static formatError(message, params) {
    // Attempt to make the path more friendly for error message interpolation.
    const path = params.label || params.path || 'this';
    // Store the original path under `originalPath` so it isn't lost to custom
    // message functions; e.g., ones provided in `setLocale()` calls.
    params = Object.assign({}, params, {
      path,
      originalPath: params.path
    });
    if (typeof message === 'string') return message.replace(strReg, (_, key) => printValue(params[key]));
    if (typeof message === 'function') return message(params);
    return message;
  }
  static isError(err) {
    return err && err.name === 'ValidationError';
  }
  constructor(errorOrErrors, value, field, type, disableStack) {
    const errorNoStack = new ValidationErrorNoStack(errorOrErrors, value, field, type);
    if (disableStack) {
      return errorNoStack;
    }
    super();
    this.value = void 0;
    this.path = void 0;
    this.type = void 0;
    this.params = void 0;
    this.errors = [];
    this.inner = [];
    this[_Symbol$toStringTag2] = 'Error';
    this.name = errorNoStack.name;
    this.message = errorNoStack.message;
    this.type = errorNoStack.type;
    this.value = errorNoStack.value;
    this.path = errorNoStack.path;
    this.errors = errorNoStack.errors;
    this.inner = errorNoStack.inner;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ValidationError);
    }
  }
  static [_Symbol$hasInstance](inst) {
    return ValidationErrorNoStack[Symbol.hasInstance](inst) || super[Symbol.hasInstance](inst);
  }
}

let mixed = {
  default: '${path} is invalid',
  required: '${path} is a required field',
  defined: '${path} must be defined',
  notNull: '${path} cannot be null',
  oneOf: '${path} must be one of the following values: ${values}',
  notOneOf: '${path} must not be one of the following values: ${values}',
  notType: ({
    path,
    type,
    value,
    originalValue
  }) => {
    const castMsg = originalValue != null && originalValue !== value ? ` (cast from the value \`${printValue(originalValue, true)}\`).` : '.';
    return type !== 'mixed' ? `${path} must be a \`${type}\` type, ` + `but the final value was: \`${printValue(value, true)}\`` + castMsg : `${path} must match the configured type. ` + `The validated value was: \`${printValue(value, true)}\`` + castMsg;
  }
};
let string = {
  length: '${path} must be exactly ${length} characters',
  min: '${path} must be at least ${min} characters',
  max: '${path} must be at most ${max} characters',
  matches: '${path} must match the following: "${regex}"',
  email: '${path} must be a valid email',
  url: '${path} must be a valid URL',
  uuid: '${path} must be a valid UUID',
  datetime: '${path} must be a valid ISO date-time',
  datetime_precision: '${path} must be a valid ISO date-time with a sub-second precision of exactly ${precision} digits',
  datetime_offset: '${path} must be a valid ISO date-time with UTC "Z" timezone',
  trim: '${path} must be a trimmed string',
  lowercase: '${path} must be a lowercase string',
  uppercase: '${path} must be a upper case string'
};
let number = {
  min: '${path} must be greater than or equal to ${min}',
  max: '${path} must be less than or equal to ${max}',
  lessThan: '${path} must be less than ${less}',
  moreThan: '${path} must be greater than ${more}',
  positive: '${path} must be a positive number',
  negative: '${path} must be a negative number',
  integer: '${path} must be an integer'
};
let date = {
  min: '${path} field must be later than ${min}',
  max: '${path} field must be at earlier than ${max}'
};
let boolean = {
  isValue: '${path} field must be ${value}'
};
let object = {
  noUnknown: '${path} field has unspecified keys: ${unknown}',
  exact: '${path} object contains unknown properties: ${properties}'
};
let array = {
  min: '${path} field must have at least ${min} items',
  max: '${path} field must have less than or equal to ${max} items',
  length: '${path} must have ${length} items'
};
let tuple = {
  notType: params => {
    const {
      path,
      value,
      spec
    } = params;
    const typeLen = spec.types.length;
    if (Array.isArray(value)) {
      if (value.length < typeLen) return `${path} tuple value has too few items, expected a length of ${typeLen} but got ${value.length} for value: \`${printValue(value, true)}\``;
      if (value.length > typeLen) return `${path} tuple value has too many items, expected a length of ${typeLen} but got ${value.length} for value: \`${printValue(value, true)}\``;
    }
    return ValidationError.formatError(mixed.notType, params);
  }
};
Object.assign(Object.create(null), {
  mixed,
  string,
  number,
  date,
  object,
  array,
  boolean,
  tuple
});

const isSchema = obj => obj && obj.__isYupSchema__;

class Condition {
  static fromOptions(refs, config) {
    if (!config.then && !config.otherwise) throw new TypeError('either `then:` or `otherwise:` is required for `when()` conditions');
    let {
      is,
      then,
      otherwise
    } = config;
    let check = typeof is === 'function' ? is : (...values) => values.every(value => value === is);
    return new Condition(refs, (values, schema) => {
      var _branch;
      let branch = check(...values) ? then : otherwise;
      return (_branch = branch == null ? void 0 : branch(schema)) != null ? _branch : schema;
    });
  }
  constructor(refs, builder) {
    this.fn = void 0;
    this.refs = refs;
    this.refs = refs;
    this.fn = builder;
  }
  resolve(base, options) {
    let values = this.refs.map(ref =>
    // TODO: ? operator here?
    ref.getValue(options == null ? void 0 : options.value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context));
    let schema = this.fn(values, base, options);
    if (schema === undefined ||
    // @ts-ignore this can be base
    schema === base) {
      return base;
    }
    if (!isSchema(schema)) throw new TypeError('conditions must return a schema object');
    return schema.resolve(options);
  }
}

const prefixes = {
  context: '$',
  value: '.'
};
function create$9(key, options) {
  return new Reference(key, options);
}
class Reference {
  constructor(key, options = {}) {
    this.key = void 0;
    this.isContext = void 0;
    this.isValue = void 0;
    this.isSibling = void 0;
    this.path = void 0;
    this.getter = void 0;
    this.map = void 0;
    if (typeof key !== 'string') throw new TypeError('ref must be a string, got: ' + key);
    this.key = key.trim();
    if (key === '') throw new TypeError('ref must be a non-empty string');
    this.isContext = this.key[0] === prefixes.context;
    this.isValue = this.key[0] === prefixes.value;
    this.isSibling = !this.isContext && !this.isValue;
    let prefix = this.isContext ? prefixes.context : this.isValue ? prefixes.value : '';
    this.path = this.key.slice(prefix.length);
    this.getter = this.path && propertyExpr.getter(this.path, true);
    this.map = options.map;
  }
  getValue(value, parent, context) {
    let result = this.isContext ? context : this.isValue ? value : parent;
    if (this.getter) result = this.getter(result || {});
    if (this.map) result = this.map(result);
    return result;
  }

  /**
   *
   * @param {*} value
   * @param {Object} options
   * @param {Object=} options.context
   * @param {Object=} options.parent
   */
  cast(value, options) {
    return this.getValue(value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context);
  }
  resolve() {
    return this;
  }
  describe() {
    return {
      type: 'ref',
      key: this.key
    };
  }
  toString() {
    return `Ref(${this.key})`;
  }
  static isRef(value) {
    return value && value.__isYupRef;
  }
}

// @ts-ignore
Reference.prototype.__isYupRef = true;

const isAbsent = value => value == null;

function createValidation(config) {
  function validate({
    value,
    path = '',
    options,
    originalValue,
    schema
  }, panic, next) {
    const {
      name,
      test,
      params,
      message,
      skipAbsent
    } = config;
    let {
      parent,
      context,
      abortEarly = schema.spec.abortEarly,
      disableStackTrace = schema.spec.disableStackTrace
    } = options;
    function resolve(item) {
      return Reference.isRef(item) ? item.getValue(value, parent, context) : item;
    }
    function createError(overrides = {}) {
      const nextParams = Object.assign({
        value,
        originalValue,
        label: schema.spec.label,
        path: overrides.path || path,
        spec: schema.spec,
        disableStackTrace: overrides.disableStackTrace || disableStackTrace
      }, params, overrides.params);
      for (const key of Object.keys(nextParams)) nextParams[key] = resolve(nextParams[key]);
      const error = new ValidationError(ValidationError.formatError(overrides.message || message, nextParams), value, nextParams.path, overrides.type || name, nextParams.disableStackTrace);
      error.params = nextParams;
      return error;
    }
    const invalid = abortEarly ? panic : next;
    let ctx = {
      path,
      parent,
      type: name,
      from: options.from,
      createError,
      resolve,
      options,
      originalValue,
      schema
    };
    const handleResult = validOrError => {
      if (ValidationError.isError(validOrError)) invalid(validOrError);else if (!validOrError) invalid(createError());else next(null);
    };
    const handleError = err => {
      if (ValidationError.isError(err)) invalid(err);else panic(err);
    };
    const shouldSkip = skipAbsent && isAbsent(value);
    if (shouldSkip) {
      return handleResult(true);
    }
    let result;
    try {
      var _result;
      result = test.call(ctx, value, ctx);
      if (typeof ((_result = result) == null ? void 0 : _result.then) === 'function') {
        if (options.sync) {
          throw new Error(`Validation test of type: "${ctx.type}" returned a Promise during a synchronous validate. ` + `This test will finish after the validate call has returned`);
        }
        return Promise.resolve(result).then(handleResult, handleError);
      }
    } catch (err) {
      handleError(err);
      return;
    }
    handleResult(result);
  }
  validate.OPTIONS = config;
  return validate;
}

function getIn(schema, path, value, context = value) {
  let parent, lastPart, lastPartDebug;

  // root path: ''
  if (!path) return {
    parent,
    parentPath: path,
    schema
  };
  propertyExpr.forEach(path, (_part, isBracket, isArray) => {
    let part = isBracket ? _part.slice(1, _part.length - 1) : _part;
    schema = schema.resolve({
      context,
      parent,
      value
    });
    let isTuple = schema.type === 'tuple';
    let idx = isArray ? parseInt(part, 10) : 0;
    if (schema.innerType || isTuple) {
      if (isTuple && !isArray) throw new Error(`Yup.reach cannot implicitly index into a tuple type. the path part "${lastPartDebug}" must contain an index to the tuple element, e.g. "${lastPartDebug}[0]"`);
      if (value && idx >= value.length) {
        throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path}. ` + `because there is no value at that index. `);
      }
      parent = value;
      value = value && value[idx];
      schema = isTuple ? schema.spec.types[idx] : schema.innerType;
    }

    // sometimes the array index part of a path doesn't exist: "nested.arr.child"
    // in these cases the current part is the next schema and should be processed
    // in this iteration. For cases where the index signature is included this
    // check will fail and we'll handle the `child` part on the next iteration like normal
    if (!isArray) {
      if (!schema.fields || !schema.fields[part]) throw new Error(`The schema does not contain the path: ${path}. ` + `(failed at: ${lastPartDebug} which is a type: "${schema.type}")`);
      parent = value;
      value = value && value[part];
      schema = schema.fields[part];
    }
    lastPart = part;
    lastPartDebug = isBracket ? '[' + _part + ']' : '.' + _part;
  });
  return {
    schema,
    parent,
    parentPath: lastPart
  };
}

class ReferenceSet extends Set {
  describe() {
    const description = [];
    for (const item of this.values()) {
      description.push(Reference.isRef(item) ? item.describe() : item);
    }
    return description;
  }
  resolveAll(resolve) {
    let result = [];
    for (const item of this.values()) {
      result.push(resolve(item));
    }
    return result;
  }
  clone() {
    return new ReferenceSet(this.values());
  }
  merge(newItems, removeItems) {
    const next = this.clone();
    newItems.forEach(value => next.add(value));
    removeItems.forEach(value => next.delete(value));
    return next;
  }
}

// tweaked from https://github.com/Kelin2025/nanoclone/blob/0abeb7635bda9b68ef2277093f76dbe3bf3948e1/src/index.js
function clone(src, seen = new Map()) {
  if (isSchema(src) || !src || typeof src !== 'object') return src;
  if (seen.has(src)) return seen.get(src);
  let copy;
  if (src instanceof Date) {
    // Date
    copy = new Date(src.getTime());
    seen.set(src, copy);
  } else if (src instanceof RegExp) {
    // RegExp
    copy = new RegExp(src);
    seen.set(src, copy);
  } else if (Array.isArray(src)) {
    // Array
    copy = new Array(src.length);
    seen.set(src, copy);
    for (let i = 0; i < src.length; i++) copy[i] = clone(src[i], seen);
  } else if (src instanceof Map) {
    // Map
    copy = new Map();
    seen.set(src, copy);
    for (const [k, v] of src.entries()) copy.set(k, clone(v, seen));
  } else if (src instanceof Set) {
    // Set
    copy = new Set();
    seen.set(src, copy);
    for (const v of src) copy.add(clone(v, seen));
  } else if (src instanceof Object) {
    // Object
    copy = {};
    seen.set(src, copy);
    for (const [k, v] of Object.entries(src)) copy[k] = clone(v, seen);
  } else {
    throw Error(`Unable to clone ${src}`);
  }
  return copy;
}

// If `CustomSchemaMeta` isn't extended with any keys, we'll fall back to a
// loose Record definition allowing free form usage.
class Schema {
  constructor(options) {
    this.type = void 0;
    this.deps = [];
    this.tests = void 0;
    this.transforms = void 0;
    this.conditions = [];
    this._mutate = void 0;
    this.internalTests = {};
    this._whitelist = new ReferenceSet();
    this._blacklist = new ReferenceSet();
    this.exclusiveTests = Object.create(null);
    this._typeCheck = void 0;
    this.spec = void 0;
    this.tests = [];
    this.transforms = [];
    this.withMutation(() => {
      this.typeError(mixed.notType);
    });
    this.type = options.type;
    this._typeCheck = options.check;
    this.spec = Object.assign({
      strip: false,
      strict: false,
      abortEarly: true,
      recursive: true,
      disableStackTrace: false,
      nullable: false,
      optional: true,
      coerce: true
    }, options == null ? void 0 : options.spec);
    this.withMutation(s => {
      s.nonNullable();
    });
  }

  // TODO: remove
  get _type() {
    return this.type;
  }
  clone(spec) {
    if (this._mutate) {
      if (spec) Object.assign(this.spec, spec);
      return this;
    }

    // if the nested value is a schema we can skip cloning, since
    // they are already immutable
    const next = Object.create(Object.getPrototypeOf(this));

    // @ts-expect-error this is readonly
    next.type = this.type;
    next._typeCheck = this._typeCheck;
    next._whitelist = this._whitelist.clone();
    next._blacklist = this._blacklist.clone();
    next.internalTests = Object.assign({}, this.internalTests);
    next.exclusiveTests = Object.assign({}, this.exclusiveTests);

    // @ts-expect-error this is readonly
    next.deps = [...this.deps];
    next.conditions = [...this.conditions];
    next.tests = [...this.tests];
    next.transforms = [...this.transforms];
    next.spec = clone(Object.assign({}, this.spec, spec));
    return next;
  }
  label(label) {
    let next = this.clone();
    next.spec.label = label;
    return next;
  }
  meta(...args) {
    if (args.length === 0) return this.spec.meta;
    let next = this.clone();
    next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);
    return next;
  }
  withMutation(fn) {
    let before = this._mutate;
    this._mutate = true;
    let result = fn(this);
    this._mutate = before;
    return result;
  }
  concat(schema) {
    if (!schema || schema === this) return this;
    if (schema.type !== this.type && this.type !== 'mixed') throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${schema.type}`);
    let base = this;
    let combined = schema.clone();
    const mergedSpec = Object.assign({}, base.spec, combined.spec);
    combined.spec = mergedSpec;
    combined.internalTests = Object.assign({}, base.internalTests, combined.internalTests);

    // manually merge the blacklist/whitelist (the other `schema` takes
    // precedence in case of conflicts)
    combined._whitelist = base._whitelist.merge(schema._whitelist, schema._blacklist);
    combined._blacklist = base._blacklist.merge(schema._blacklist, schema._whitelist);

    // start with the current tests
    combined.tests = base.tests;
    combined.exclusiveTests = base.exclusiveTests;

    // manually add the new tests to ensure
    // the deduping logic is consistent
    combined.withMutation(next => {
      schema.tests.forEach(fn => {
        next.test(fn.OPTIONS);
      });
    });
    combined.transforms = [...base.transforms, ...combined.transforms];
    return combined;
  }
  isType(v) {
    if (v == null) {
      if (this.spec.nullable && v === null) return true;
      if (this.spec.optional && v === undefined) return true;
      return false;
    }
    return this._typeCheck(v);
  }
  resolve(options) {
    let schema = this;
    if (schema.conditions.length) {
      let conditions = schema.conditions;
      schema = schema.clone();
      schema.conditions = [];
      schema = conditions.reduce((prevSchema, condition) => condition.resolve(prevSchema, options), schema);
      schema = schema.resolve(options);
    }
    return schema;
  }
  resolveOptions(options) {
    var _options$strict, _options$abortEarly, _options$recursive, _options$disableStack;
    return Object.assign({}, options, {
      from: options.from || [],
      strict: (_options$strict = options.strict) != null ? _options$strict : this.spec.strict,
      abortEarly: (_options$abortEarly = options.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly,
      recursive: (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive,
      disableStackTrace: (_options$disableStack = options.disableStackTrace) != null ? _options$disableStack : this.spec.disableStackTrace
    });
  }

  /**
   * Run the configured transform pipeline over an input value.
   */

  cast(value, options = {}) {
    let resolvedSchema = this.resolve(Object.assign({
      value
    }, options));
    let allowOptionality = options.assert === 'ignore-optionality';
    let result = resolvedSchema._cast(value, options);
    if (options.assert !== false && !resolvedSchema.isType(result)) {
      if (allowOptionality && isAbsent(result)) {
        return result;
      }
      let formattedValue = printValue(value);
      let formattedResult = printValue(result);
      throw new TypeError(`The value of ${options.path || 'field'} could not be cast to a value ` + `that satisfies the schema type: "${resolvedSchema.type}". \n\n` + `attempted value: ${formattedValue} \n` + (formattedResult !== formattedValue ? `result of cast: ${formattedResult}` : ''));
    }
    return result;
  }
  _cast(rawValue, options) {
    let value = rawValue === undefined ? rawValue : this.transforms.reduce((prevValue, fn) => fn.call(this, prevValue, rawValue, this), rawValue);
    if (value === undefined) {
      value = this.getDefault(options);
    }
    return value;
  }
  _validate(_value, options = {}, panic, next) {
    let {
      path,
      originalValue = _value,
      strict = this.spec.strict
    } = options;
    let value = _value;
    if (!strict) {
      value = this._cast(value, Object.assign({
        assert: false
      }, options));
    }
    let initialTests = [];
    for (let test of Object.values(this.internalTests)) {
      if (test) initialTests.push(test);
    }
    this.runTests({
      path,
      value,
      originalValue,
      options,
      tests: initialTests
    }, panic, initialErrors => {
      // even if we aren't ending early we can't proceed further if the types aren't correct
      if (initialErrors.length) {
        return next(initialErrors, value);
      }
      this.runTests({
        path,
        value,
        originalValue,
        options,
        tests: this.tests
      }, panic, next);
    });
  }

  /**
   * Executes a set of validations, either schema, produced Tests or a nested
   * schema validate result.
   */
  runTests(runOptions, panic, next) {
    let fired = false;
    let {
      tests,
      value,
      originalValue,
      path,
      options
    } = runOptions;
    let panicOnce = arg => {
      if (fired) return;
      fired = true;
      panic(arg, value);
    };
    let nextOnce = arg => {
      if (fired) return;
      fired = true;
      next(arg, value);
    };
    let count = tests.length;
    let nestedErrors = [];
    if (!count) return nextOnce([]);
    let args = {
      value,
      originalValue,
      path,
      options,
      schema: this
    };
    for (let i = 0; i < tests.length; i++) {
      const test = tests[i];
      test(args, panicOnce, function finishTestRun(err) {
        if (err) {
          Array.isArray(err) ? nestedErrors.push(...err) : nestedErrors.push(err);
        }
        if (--count <= 0) {
          nextOnce(nestedErrors);
        }
      });
    }
  }
  asNestedTest({
    key,
    index,
    parent,
    parentPath,
    originalParent,
    options
  }) {
    const k = key != null ? key : index;
    if (k == null) {
      throw TypeError('Must include `key` or `index` for nested validations');
    }
    const isIndex = typeof k === 'number';
    let value = parent[k];
    const testOptions = Object.assign({}, options, {
      // Nested validations fields are always strict:
      //    1. parent isn't strict so the casting will also have cast inner values
      //    2. parent is strict in which case the nested values weren't cast either
      strict: true,
      parent,
      value,
      originalValue: originalParent[k],
      // FIXME: tests depend on `index` being passed around deeply,
      //   we should not let the options.key/index bleed through
      key: undefined,
      // index: undefined,
      [isIndex ? 'index' : 'key']: k,
      path: isIndex || k.includes('.') ? `${parentPath || ''}[${isIndex ? k : `"${k}"`}]` : (parentPath ? `${parentPath}.` : '') + key
    });
    return (_, panic, next) => this.resolve(testOptions)._validate(value, testOptions, panic, next);
  }
  validate(value, options) {
    var _options$disableStack2;
    let schema = this.resolve(Object.assign({}, options, {
      value
    }));
    let disableStackTrace = (_options$disableStack2 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack2 : schema.spec.disableStackTrace;
    return new Promise((resolve, reject) => schema._validate(value, options, (error, parsed) => {
      if (ValidationError.isError(error)) error.value = parsed;
      reject(error);
    }, (errors, validated) => {
      if (errors.length) reject(new ValidationError(errors, validated, undefined, undefined, disableStackTrace));else resolve(validated);
    }));
  }
  validateSync(value, options) {
    var _options$disableStack3;
    let schema = this.resolve(Object.assign({}, options, {
      value
    }));
    let result;
    let disableStackTrace = (_options$disableStack3 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack3 : schema.spec.disableStackTrace;
    schema._validate(value, Object.assign({}, options, {
      sync: true
    }), (error, parsed) => {
      if (ValidationError.isError(error)) error.value = parsed;
      throw error;
    }, (errors, validated) => {
      if (errors.length) throw new ValidationError(errors, value, undefined, undefined, disableStackTrace);
      result = validated;
    });
    return result;
  }
  isValid(value, options) {
    return this.validate(value, options).then(() => true, err => {
      if (ValidationError.isError(err)) return false;
      throw err;
    });
  }
  isValidSync(value, options) {
    try {
      this.validateSync(value, options);
      return true;
    } catch (err) {
      if (ValidationError.isError(err)) return false;
      throw err;
    }
  }
  _getDefault(options) {
    let defaultValue = this.spec.default;
    if (defaultValue == null) {
      return defaultValue;
    }
    return typeof defaultValue === 'function' ? defaultValue.call(this, options) : clone(defaultValue);
  }
  getDefault(options
  // If schema is defaulted we know it's at least not undefined
  ) {
    let schema = this.resolve(options || {});
    return schema._getDefault(options);
  }
  default(def) {
    if (arguments.length === 0) {
      return this._getDefault();
    }
    let next = this.clone({
      default: def
    });
    return next;
  }
  strict(isStrict = true) {
    return this.clone({
      strict: isStrict
    });
  }
  nullability(nullable, message) {
    const next = this.clone({
      nullable
    });
    next.internalTests.nullable = createValidation({
      message,
      name: 'nullable',
      test(value) {
        return value === null ? this.schema.spec.nullable : true;
      }
    });
    return next;
  }
  optionality(optional, message) {
    const next = this.clone({
      optional
    });
    next.internalTests.optionality = createValidation({
      message,
      name: 'optionality',
      test(value) {
        return value === undefined ? this.schema.spec.optional : true;
      }
    });
    return next;
  }
  optional() {
    return this.optionality(true);
  }
  defined(message = mixed.defined) {
    return this.optionality(false, message);
  }
  nullable() {
    return this.nullability(true);
  }
  nonNullable(message = mixed.notNull) {
    return this.nullability(false, message);
  }
  required(message = mixed.required) {
    return this.clone().withMutation(next => next.nonNullable(message).defined(message));
  }
  notRequired() {
    return this.clone().withMutation(next => next.nullable().optional());
  }
  transform(fn) {
    let next = this.clone();
    next.transforms.push(fn);
    return next;
  }

  /**
   * Adds a test function to the schema's queue of tests.
   * tests can be exclusive or non-exclusive.
   *
   * - exclusive tests, will replace any existing tests of the same name.
   * - non-exclusive: can be stacked
   *
   * If a non-exclusive test is added to a schema with an exclusive test of the same name
   * the exclusive test is removed and further tests of the same name will be stacked.
   *
   * If an exclusive test is added to a schema with non-exclusive tests of the same name
   * the previous tests are removed and further tests of the same name will replace each other.
   */

  test(...args) {
    let opts;
    if (args.length === 1) {
      if (typeof args[0] === 'function') {
        opts = {
          test: args[0]
        };
      } else {
        opts = args[0];
      }
    } else if (args.length === 2) {
      opts = {
        name: args[0],
        test: args[1]
      };
    } else {
      opts = {
        name: args[0],
        message: args[1],
        test: args[2]
      };
    }
    if (opts.message === undefined) opts.message = mixed.default;
    if (typeof opts.test !== 'function') throw new TypeError('`test` is a required parameters');
    let next = this.clone();
    let validate = createValidation(opts);
    let isExclusive = opts.exclusive || opts.name && next.exclusiveTests[opts.name] === true;
    if (opts.exclusive) {
      if (!opts.name) throw new TypeError('Exclusive tests must provide a unique `name` identifying the test');
    }
    if (opts.name) next.exclusiveTests[opts.name] = !!opts.exclusive;
    next.tests = next.tests.filter(fn => {
      if (fn.OPTIONS.name === opts.name) {
        if (isExclusive) return false;
        if (fn.OPTIONS.test === validate.OPTIONS.test) return false;
      }
      return true;
    });
    next.tests.push(validate);
    return next;
  }
  when(keys, options) {
    if (!Array.isArray(keys) && typeof keys !== 'string') {
      options = keys;
      keys = '.';
    }
    let next = this.clone();
    let deps = toArray(keys).map(key => new Reference(key));
    deps.forEach(dep => {
      // @ts-ignore readonly array
      if (dep.isSibling) next.deps.push(dep.key);
    });
    next.conditions.push(typeof options === 'function' ? new Condition(deps, options) : Condition.fromOptions(deps, options));
    return next;
  }
  typeError(message) {
    let next = this.clone();
    next.internalTests.typeError = createValidation({
      message,
      name: 'typeError',
      skipAbsent: true,
      test(value) {
        if (!this.schema._typeCheck(value)) return this.createError({
          params: {
            type: this.schema.type
          }
        });
        return true;
      }
    });
    return next;
  }
  oneOf(enums, message = mixed.oneOf) {
    let next = this.clone();
    enums.forEach(val => {
      next._whitelist.add(val);
      next._blacklist.delete(val);
    });
    next.internalTests.whiteList = createValidation({
      message,
      name: 'oneOf',
      skipAbsent: true,
      test(value) {
        let valids = this.schema._whitelist;
        let resolved = valids.resolveAll(this.resolve);
        return resolved.includes(value) ? true : this.createError({
          params: {
            values: Array.from(valids).join(', '),
            resolved
          }
        });
      }
    });
    return next;
  }
  notOneOf(enums, message = mixed.notOneOf) {
    let next = this.clone();
    enums.forEach(val => {
      next._blacklist.add(val);
      next._whitelist.delete(val);
    });
    next.internalTests.blacklist = createValidation({
      message,
      name: 'notOneOf',
      test(value) {
        let invalids = this.schema._blacklist;
        let resolved = invalids.resolveAll(this.resolve);
        if (resolved.includes(value)) return this.createError({
          params: {
            values: Array.from(invalids).join(', '),
            resolved
          }
        });
        return true;
      }
    });
    return next;
  }
  strip(strip = true) {
    let next = this.clone();
    next.spec.strip = strip;
    return next;
  }

  /**
   * Return a serialized description of the schema including validations, flags, types etc.
   *
   * @param options Provide any needed context for resolving runtime schema alterations (lazy, when conditions, etc).
   */
  describe(options) {
    const next = (options ? this.resolve(options) : this).clone();
    const {
      label,
      meta,
      optional,
      nullable
    } = next.spec;
    const description = {
      meta,
      label,
      optional,
      nullable,
      default: next.getDefault(options),
      type: next.type,
      oneOf: next._whitelist.describe(),
      notOneOf: next._blacklist.describe(),
      tests: next.tests.map(fn => ({
        name: fn.OPTIONS.name,
        params: fn.OPTIONS.params
      })).filter((n, idx, list) => list.findIndex(c => c.name === n.name) === idx)
    };
    return description;
  }
}
// @ts-expect-error
Schema.prototype.__isYupSchema__ = true;
for (const method of ['validate', 'validateSync']) Schema.prototype[`${method}At`] = function (path, value, options = {}) {
  const {
    parent,
    parentPath,
    schema
  } = getIn(this, path, value, options.context);
  return schema[method](parent && parent[parentPath], Object.assign({}, options, {
    parent,
    path
  }));
};
for (const alias of ['equals', 'is']) Schema.prototype[alias] = Schema.prototype.oneOf;
for (const alias of ['not', 'nope']) Schema.prototype[alias] = Schema.prototype.notOneOf;

/**
 * This file is a modified version of the file from the following repository:
 * Date.parse with progressive enhancement for ISO 8601 <https://github.com/csnover/js-iso8601>
 * NON-CONFORMANT EDITION.
 * © 2011 Colin Snover <http://zetafleet.com>
 * Released under MIT license.
 */

// prettier-ignore
//                1 YYYY                2 MM        3 DD              4 HH     5 mm        6 ss           7 msec         8 Z 9 ±   10 tzHH    11 tzmm
const isoReg = /^(\d{4}|[+-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,.](\d{1,}))?)?(?:(Z)|([+-])(\d{2})(?::?(\d{2}))?)?)?$/;
function parseIsoDate(date) {
  const struct = parseDateStruct(date);
  if (!struct) return Date.parse ? Date.parse(date) : Number.NaN;

  // timestamps without timezone identifiers should be considered local time
  if (struct.z === undefined && struct.plusMinus === undefined) {
    return new Date(struct.year, struct.month, struct.day, struct.hour, struct.minute, struct.second, struct.millisecond).valueOf();
  }
  let totalMinutesOffset = 0;
  if (struct.z !== 'Z' && struct.plusMinus !== undefined) {
    totalMinutesOffset = struct.hourOffset * 60 + struct.minuteOffset;
    if (struct.plusMinus === '+') totalMinutesOffset = 0 - totalMinutesOffset;
  }
  return Date.UTC(struct.year, struct.month, struct.day, struct.hour, struct.minute + totalMinutesOffset, struct.second, struct.millisecond);
}
function parseDateStruct(date) {
  var _regexResult$7$length, _regexResult$;
  const regexResult = isoReg.exec(date);
  if (!regexResult) return null;

  // use of toNumber() avoids NaN timestamps caused by “undefined”
  // values being passed to Date constructor
  return {
    year: toNumber(regexResult[1]),
    month: toNumber(regexResult[2], 1) - 1,
    day: toNumber(regexResult[3], 1),
    hour: toNumber(regexResult[4]),
    minute: toNumber(regexResult[5]),
    second: toNumber(regexResult[6]),
    millisecond: regexResult[7] ?
    // allow arbitrary sub-second precision beyond milliseconds
    toNumber(regexResult[7].substring(0, 3)) : 0,
    precision: (_regexResult$7$length = (_regexResult$ = regexResult[7]) == null ? void 0 : _regexResult$.length) != null ? _regexResult$7$length : undefined,
    z: regexResult[8] || undefined,
    plusMinus: regexResult[9] || undefined,
    hourOffset: toNumber(regexResult[10]),
    minuteOffset: toNumber(regexResult[11])
  };
}
function toNumber(str, defaultValue = 0) {
  return Number(str) || defaultValue;
}

// Taken from HTML spec: https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address
let rEmail =
// eslint-disable-next-line
/^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
let rUrl =
// eslint-disable-next-line
/^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i;

// eslint-disable-next-line
let rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
let yearMonthDay = '^\\d{4}-\\d{2}-\\d{2}';
let hourMinuteSecond = '\\d{2}:\\d{2}:\\d{2}';
let zOrOffset = '(([+-]\\d{2}(:?\\d{2})?)|Z)';
let rIsoDateTime = new RegExp(`${yearMonthDay}T${hourMinuteSecond}(\\.\\d+)?${zOrOffset}$`);
let isTrimmed = value => isAbsent(value) || value === value.trim();
let objStringTag = {}.toString();
function create$6() {
  return new StringSchema();
}
class StringSchema extends Schema {
  constructor() {
    super({
      type: 'string',
      check(value) {
        if (value instanceof String) value = value.valueOf();
        return typeof value === 'string';
      }
    });
    this.withMutation(() => {
      this.transform((value, _raw, ctx) => {
        if (!ctx.spec.coerce || ctx.isType(value)) return value;

        // don't ever convert arrays
        if (Array.isArray(value)) return value;
        const strValue = value != null && value.toString ? value.toString() : value;

        // no one wants plain objects converted to [Object object]
        if (strValue === objStringTag) return value;
        return strValue;
      });
    });
  }
  required(message) {
    return super.required(message).withMutation(schema => schema.test({
      message: message || mixed.required,
      name: 'required',
      skipAbsent: true,
      test: value => !!value.length
    }));
  }
  notRequired() {
    return super.notRequired().withMutation(schema => {
      schema.tests = schema.tests.filter(t => t.OPTIONS.name !== 'required');
      return schema;
    });
  }
  length(length, message = string.length) {
    return this.test({
      message,
      name: 'length',
      exclusive: true,
      params: {
        length
      },
      skipAbsent: true,
      test(value) {
        return value.length === this.resolve(length);
      }
    });
  }
  min(min, message = string.min) {
    return this.test({
      message,
      name: 'min',
      exclusive: true,
      params: {
        min
      },
      skipAbsent: true,
      test(value) {
        return value.length >= this.resolve(min);
      }
    });
  }
  max(max, message = string.max) {
    return this.test({
      name: 'max',
      exclusive: true,
      message,
      params: {
        max
      },
      skipAbsent: true,
      test(value) {
        return value.length <= this.resolve(max);
      }
    });
  }
  matches(regex, options) {
    let excludeEmptyString = false;
    let message;
    let name;
    if (options) {
      if (typeof options === 'object') {
        ({
          excludeEmptyString = false,
          message,
          name
        } = options);
      } else {
        message = options;
      }
    }
    return this.test({
      name: name || 'matches',
      message: message || string.matches,
      params: {
        regex
      },
      skipAbsent: true,
      test: value => value === '' && excludeEmptyString || value.search(regex) !== -1
    });
  }
  email(message = string.email) {
    return this.matches(rEmail, {
      name: 'email',
      message,
      excludeEmptyString: true
    });
  }
  url(message = string.url) {
    return this.matches(rUrl, {
      name: 'url',
      message,
      excludeEmptyString: true
    });
  }
  uuid(message = string.uuid) {
    return this.matches(rUUID, {
      name: 'uuid',
      message,
      excludeEmptyString: false
    });
  }
  datetime(options) {
    let message = '';
    let allowOffset;
    let precision;
    if (options) {
      if (typeof options === 'object') {
        ({
          message = '',
          allowOffset = false,
          precision = undefined
        } = options);
      } else {
        message = options;
      }
    }
    return this.matches(rIsoDateTime, {
      name: 'datetime',
      message: message || string.datetime,
      excludeEmptyString: true
    }).test({
      name: 'datetime_offset',
      message: message || string.datetime_offset,
      params: {
        allowOffset
      },
      skipAbsent: true,
      test: value => {
        if (!value || allowOffset) return true;
        const struct = parseDateStruct(value);
        if (!struct) return false;
        return !!struct.z;
      }
    }).test({
      name: 'datetime_precision',
      message: message || string.datetime_precision,
      params: {
        precision
      },
      skipAbsent: true,
      test: value => {
        if (!value || precision == undefined) return true;
        const struct = parseDateStruct(value);
        if (!struct) return false;
        return struct.precision === precision;
      }
    });
  }

  //-- transforms --
  ensure() {
    return this.default('').transform(val => val === null ? '' : val);
  }
  trim(message = string.trim) {
    return this.transform(val => val != null ? val.trim() : val).test({
      message,
      name: 'trim',
      test: isTrimmed
    });
  }
  lowercase(message = string.lowercase) {
    return this.transform(value => !isAbsent(value) ? value.toLowerCase() : value).test({
      message,
      name: 'string_case',
      exclusive: true,
      skipAbsent: true,
      test: value => isAbsent(value) || value === value.toLowerCase()
    });
  }
  uppercase(message = string.uppercase) {
    return this.transform(value => !isAbsent(value) ? value.toUpperCase() : value).test({
      message,
      name: 'string_case',
      exclusive: true,
      skipAbsent: true,
      test: value => isAbsent(value) || value === value.toUpperCase()
    });
  }
}
create$6.prototype = StringSchema.prototype;

//
// String Interfaces
//

let isNaN$1 = value => value != +value;
function create$5() {
  return new NumberSchema();
}
class NumberSchema extends Schema {
  constructor() {
    super({
      type: 'number',
      check(value) {
        if (value instanceof Number) value = value.valueOf();
        return typeof value === 'number' && !isNaN$1(value);
      }
    });
    this.withMutation(() => {
      this.transform((value, _raw, ctx) => {
        if (!ctx.spec.coerce) return value;
        let parsed = value;
        if (typeof parsed === 'string') {
          parsed = parsed.replace(/\s/g, '');
          if (parsed === '') return NaN;
          // don't use parseFloat to avoid positives on alpha-numeric strings
          parsed = +parsed;
        }

        // null -> NaN isn't useful; treat all nulls as null and let it fail on
        // nullability check vs TypeErrors
        if (ctx.isType(parsed) || parsed === null) return parsed;
        return parseFloat(parsed);
      });
    });
  }
  min(min, message = number.min) {
    return this.test({
      message,
      name: 'min',
      exclusive: true,
      params: {
        min
      },
      skipAbsent: true,
      test(value) {
        return value >= this.resolve(min);
      }
    });
  }
  max(max, message = number.max) {
    return this.test({
      message,
      name: 'max',
      exclusive: true,
      params: {
        max
      },
      skipAbsent: true,
      test(value) {
        return value <= this.resolve(max);
      }
    });
  }
  lessThan(less, message = number.lessThan) {
    return this.test({
      message,
      name: 'max',
      exclusive: true,
      params: {
        less
      },
      skipAbsent: true,
      test(value) {
        return value < this.resolve(less);
      }
    });
  }
  moreThan(more, message = number.moreThan) {
    return this.test({
      message,
      name: 'min',
      exclusive: true,
      params: {
        more
      },
      skipAbsent: true,
      test(value) {
        return value > this.resolve(more);
      }
    });
  }
  positive(msg = number.positive) {
    return this.moreThan(0, msg);
  }
  negative(msg = number.negative) {
    return this.lessThan(0, msg);
  }
  integer(message = number.integer) {
    return this.test({
      name: 'integer',
      message,
      skipAbsent: true,
      test: val => Number.isInteger(val)
    });
  }
  truncate() {
    return this.transform(value => !isAbsent(value) ? value | 0 : value);
  }
  round(method) {
    var _method;
    let avail = ['ceil', 'floor', 'round', 'trunc'];
    method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || 'round';

    // this exists for symemtry with the new Math.trunc
    if (method === 'trunc') return this.truncate();
    if (avail.indexOf(method.toLowerCase()) === -1) throw new TypeError('Only valid options for round() are: ' + avail.join(', '));
    return this.transform(value => !isAbsent(value) ? Math[method](value) : value);
  }
}
create$5.prototype = NumberSchema.prototype;

//
// Number Interfaces
//

let invalidDate = new Date('');
let isDate$1 = obj => Object.prototype.toString.call(obj) === '[object Date]';
class DateSchema extends Schema {
  constructor() {
    super({
      type: 'date',
      check(v) {
        return isDate$1(v) && !isNaN(v.getTime());
      }
    });
    this.withMutation(() => {
      this.transform((value, _raw, ctx) => {
        // null -> InvalidDate isn't useful; treat all nulls as null and let it fail on
        // nullability check vs TypeErrors
        if (!ctx.spec.coerce || ctx.isType(value) || value === null) return value;
        value = parseIsoDate(value);

        // 0 is a valid timestamp equivalent to 1970-01-01T00:00:00Z(unix epoch) or before.
        return !isNaN(value) ? new Date(value) : DateSchema.INVALID_DATE;
      });
    });
  }
  prepareParam(ref, name) {
    let param;
    if (!Reference.isRef(ref)) {
      let cast = this.cast(ref);
      if (!this._typeCheck(cast)) throw new TypeError(`\`${name}\` must be a Date or a value that can be \`cast()\` to a Date`);
      param = cast;
    } else {
      param = ref;
    }
    return param;
  }
  min(min, message = date.min) {
    let limit = this.prepareParam(min, 'min');
    return this.test({
      message,
      name: 'min',
      exclusive: true,
      params: {
        min
      },
      skipAbsent: true,
      test(value) {
        return value >= this.resolve(limit);
      }
    });
  }
  max(max, message = date.max) {
    let limit = this.prepareParam(max, 'max');
    return this.test({
      message,
      name: 'max',
      exclusive: true,
      params: {
        max
      },
      skipAbsent: true,
      test(value) {
        return value <= this.resolve(limit);
      }
    });
  }
}
DateSchema.INVALID_DATE = invalidDate;

// @ts-expect-error
function sortFields(fields, excludedEdges = []) {
  let edges = [];
  let nodes = new Set();
  let excludes = new Set(excludedEdges.map(([a, b]) => `${a}-${b}`));
  function addNode(depPath, key) {
    let node = propertyExpr.split(depPath)[0];
    nodes.add(node);
    if (!excludes.has(`${key}-${node}`)) edges.push([key, node]);
  }
  for (const key of Object.keys(fields)) {
    let value = fields[key];
    nodes.add(key);
    if (Reference.isRef(value) && value.isSibling) addNode(value.path, key);else if (isSchema(value) && 'deps' in value) value.deps.forEach(path => addNode(path, key));
  }
  return toposort$1.array(Array.from(nodes), edges).reverse();
}

function findIndex$1(arr, err) {
  let idx = Infinity;
  arr.some((key, ii) => {
    var _err$path;
    if ((_err$path = err.path) != null && _err$path.includes(key)) {
      idx = ii;
      return true;
    }
  });
  return idx;
}
function sortByKeyOrder(keys) {
  return (a, b) => {
    return findIndex$1(keys, a) - findIndex$1(keys, b);
  };
}

const parseJson = (value, _, ctx) => {
  if (typeof value !== 'string') {
    return value;
  }
  let parsed = value;
  try {
    parsed = JSON.parse(value);
  } catch (err) {
    /* */
  }
  return ctx.isType(parsed) ? parsed : value;
};

// @ts-ignore
function deepPartial(schema) {
  if ('fields' in schema) {
    const partial = {};
    for (const [key, fieldSchema] of Object.entries(schema.fields)) {
      partial[key] = deepPartial(fieldSchema);
    }
    return schema.setFields(partial);
  }
  if (schema.type === 'array') {
    const nextArray = schema.optional();
    if (nextArray.innerType) nextArray.innerType = deepPartial(nextArray.innerType);
    return nextArray;
  }
  if (schema.type === 'tuple') {
    return schema.optional().clone({
      types: schema.spec.types.map(deepPartial)
    });
  }
  if ('optional' in schema) {
    return schema.optional();
  }
  return schema;
}
const deepHas = (obj, p) => {
  const path = [...propertyExpr.normalizePath(p)];
  if (path.length === 1) return path[0] in obj;
  let last = path.pop();
  let parent = propertyExpr.getter(propertyExpr.join(path), true)(obj);
  return !!(parent && last in parent);
};
let isObject = obj => Object.prototype.toString.call(obj) === '[object Object]';
function unknown(ctx, value) {
  let known = Object.keys(ctx.fields);
  return Object.keys(value).filter(key => known.indexOf(key) === -1);
}
const defaultSort = sortByKeyOrder([]);
function create$3(spec) {
  return new ObjectSchema(spec);
}
class ObjectSchema extends Schema {
  constructor(spec) {
    super({
      type: 'object',
      check(value) {
        return isObject(value) || typeof value === 'function';
      }
    });
    this.fields = Object.create(null);
    this._sortErrors = defaultSort;
    this._nodes = [];
    this._excludedEdges = [];
    this.withMutation(() => {
      if (spec) {
        this.shape(spec);
      }
    });
  }
  _cast(_value, options = {}) {
    var _options$stripUnknown;
    let value = super._cast(_value, options);

    //should ignore nulls here
    if (value === undefined) return this.getDefault(options);
    if (!this._typeCheck(value)) return value;
    let fields = this.fields;
    let strip = (_options$stripUnknown = options.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;
    let props = [].concat(this._nodes, Object.keys(value).filter(v => !this._nodes.includes(v)));
    let intermediateValue = {}; // is filled during the transform below
    let innerOptions = Object.assign({}, options, {
      parent: intermediateValue,
      __validating: options.__validating || false
    });
    let isChanged = false;
    for (const prop of props) {
      let field = fields[prop];
      let exists = (prop in value);
      if (field) {
        let fieldValue;
        let inputValue = value[prop];

        // safe to mutate since this is fired in sequence
        innerOptions.path = (options.path ? `${options.path}.` : '') + prop;
        field = field.resolve({
          value: inputValue,
          context: options.context,
          parent: intermediateValue
        });
        let fieldSpec = field instanceof Schema ? field.spec : undefined;
        let strict = fieldSpec == null ? void 0 : fieldSpec.strict;
        if (fieldSpec != null && fieldSpec.strip) {
          isChanged = isChanged || prop in value;
          continue;
        }
        fieldValue = !options.__validating || !strict ?
        // TODO: use _cast, this is double resolving
        field.cast(value[prop], innerOptions) : value[prop];
        if (fieldValue !== undefined) {
          intermediateValue[prop] = fieldValue;
        }
      } else if (exists && !strip) {
        intermediateValue[prop] = value[prop];
      }
      if (exists !== prop in intermediateValue || intermediateValue[prop] !== value[prop]) {
        isChanged = true;
      }
    }
    return isChanged ? intermediateValue : value;
  }
  _validate(_value, options = {}, panic, next) {
    let {
      from = [],
      originalValue = _value,
      recursive = this.spec.recursive
    } = options;
    options.from = [{
      schema: this,
      value: originalValue
    }, ...from];
    // this flag is needed for handling `strict` correctly in the context of
    // validation vs just casting. e.g strict() on a field is only used when validating
    options.__validating = true;
    options.originalValue = originalValue;
    super._validate(_value, options, panic, (objectErrors, value) => {
      if (!recursive || !isObject(value)) {
        next(objectErrors, value);
        return;
      }
      originalValue = originalValue || value;
      let tests = [];
      for (let key of this._nodes) {
        let field = this.fields[key];
        if (!field || Reference.isRef(field)) {
          continue;
        }
        tests.push(field.asNestedTest({
          options,
          key,
          parent: value,
          parentPath: options.path,
          originalParent: originalValue
        }));
      }
      this.runTests({
        tests,
        value,
        originalValue,
        options
      }, panic, fieldErrors => {
        next(fieldErrors.sort(this._sortErrors).concat(objectErrors), value);
      });
    });
  }
  clone(spec) {
    const next = super.clone(spec);
    next.fields = Object.assign({}, this.fields);
    next._nodes = this._nodes;
    next._excludedEdges = this._excludedEdges;
    next._sortErrors = this._sortErrors;
    return next;
  }
  concat(schema) {
    let next = super.concat(schema);
    let nextFields = next.fields;
    for (let [field, schemaOrRef] of Object.entries(this.fields)) {
      const target = nextFields[field];
      nextFields[field] = target === undefined ? schemaOrRef : target;
    }
    return next.withMutation(s =>
    // XXX: excludes here is wrong
    s.setFields(nextFields, [...this._excludedEdges, ...schema._excludedEdges]));
  }
  _getDefault(options) {
    if ('default' in this.spec) {
      return super._getDefault(options);
    }

    // if there is no default set invent one
    if (!this._nodes.length) {
      return undefined;
    }
    let dft = {};
    this._nodes.forEach(key => {
      var _innerOptions;
      const field = this.fields[key];
      let innerOptions = options;
      if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
        innerOptions = Object.assign({}, innerOptions, {
          parent: innerOptions.value,
          value: innerOptions.value[key]
        });
      }
      dft[key] = field && 'getDefault' in field ? field.getDefault(innerOptions) : undefined;
    });
    return dft;
  }
  setFields(shape, excludedEdges) {
    let next = this.clone();
    next.fields = shape;
    next._nodes = sortFields(shape, excludedEdges);
    next._sortErrors = sortByKeyOrder(Object.keys(shape));
    // XXX: this carries over edges which may not be what you want
    if (excludedEdges) next._excludedEdges = excludedEdges;
    return next;
  }
  shape(additions, excludes = []) {
    return this.clone().withMutation(next => {
      let edges = next._excludedEdges;
      if (excludes.length) {
        if (!Array.isArray(excludes[0])) excludes = [excludes];
        edges = [...next._excludedEdges, ...excludes];
      }

      // XXX: excludes here is wrong
      return next.setFields(Object.assign(next.fields, additions), edges);
    });
  }
  partial() {
    const partial = {};
    for (const [key, schema] of Object.entries(this.fields)) {
      partial[key] = 'optional' in schema && schema.optional instanceof Function ? schema.optional() : schema;
    }
    return this.setFields(partial);
  }
  deepPartial() {
    const next = deepPartial(this);
    return next;
  }
  pick(keys) {
    const picked = {};
    for (const key of keys) {
      if (this.fields[key]) picked[key] = this.fields[key];
    }
    return this.setFields(picked, this._excludedEdges.filter(([a, b]) => keys.includes(a) && keys.includes(b)));
  }
  omit(keys) {
    const remaining = [];
    for (const key of Object.keys(this.fields)) {
      if (keys.includes(key)) continue;
      remaining.push(key);
    }
    return this.pick(remaining);
  }
  from(from, to, alias) {
    let fromGetter = propertyExpr.getter(from, true);
    return this.transform(obj => {
      if (!obj) return obj;
      let newObj = obj;
      if (deepHas(obj, from)) {
        newObj = Object.assign({}, obj);
        if (!alias) delete newObj[from];
        newObj[to] = fromGetter(obj);
      }
      return newObj;
    });
  }

  /** Parse an input JSON string to an object */
  json() {
    return this.transform(parseJson);
  }

  /**
   * Similar to `noUnknown` but only validates that an object is the right shape without stripping the unknown keys
   */
  exact(message) {
    return this.test({
      name: 'exact',
      exclusive: true,
      message: message || object.exact,
      test(value) {
        if (value == null) return true;
        const unknownKeys = unknown(this.schema, value);
        return unknownKeys.length === 0 || this.createError({
          params: {
            properties: unknownKeys.join(', ')
          }
        });
      }
    });
  }
  stripUnknown() {
    return this.clone({
      noUnknown: true
    });
  }
  noUnknown(noAllow = true, message = object.noUnknown) {
    if (typeof noAllow !== 'boolean') {
      message = noAllow;
      noAllow = true;
    }
    let next = this.test({
      name: 'noUnknown',
      exclusive: true,
      message: message,
      test(value) {
        if (value == null) return true;
        const unknownKeys = unknown(this.schema, value);
        return !noAllow || unknownKeys.length === 0 || this.createError({
          params: {
            unknown: unknownKeys.join(', ')
          }
        });
      }
    });
    next.spec.noUnknown = noAllow;
    return next;
  }
  unknown(allow = true, message = object.noUnknown) {
    return this.noUnknown(!allow, message);
  }
  transformKeys(fn) {
    return this.transform(obj => {
      if (!obj) return obj;
      const result = {};
      for (const key of Object.keys(obj)) result[fn(key)] = obj[key];
      return result;
    });
  }
  camelCase() {
    return this.transformKeys(tinyCase.camelCase);
  }
  snakeCase() {
    return this.transformKeys(tinyCase.snakeCase);
  }
  constantCase() {
    return this.transformKeys(key => tinyCase.snakeCase(key).toUpperCase());
  }
  describe(options) {
    const next = (options ? this.resolve(options) : this).clone();
    const base = super.describe(options);
    base.fields = {};
    for (const [key, value] of Object.entries(next.fields)) {
      var _innerOptions2;
      let innerOptions = options;
      if ((_innerOptions2 = innerOptions) != null && _innerOptions2.value) {
        innerOptions = Object.assign({}, innerOptions, {
          parent: innerOptions.value,
          value: innerOptions.value[key]
        });
      }
      base.fields[key] = value.describe(innerOptions);
    }
    return base;
  }
}
create$3.prototype = ObjectSchema.prototype;

const loginValidationSchema = create$3({
  username: create$6().email("Correo electrónico inválido").required("El correo electrónico es requerido"),
  password: create$6().required("La contraseña es requerida")
});
const forgotPasswordValidationSchema = create$3({
  email: create$6().email("Correo electrónico inválido").required("El correo electrónico es requerido")
});

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var s = function() {
  return s = Object.assign || function(e3) {
    for (var t2, r2 = 1, o2 = arguments.length; r2 < o2; r2++) for (var n2 in t2 = arguments[r2]) Object.prototype.hasOwnProperty.call(t2, n2) && (e3[n2] = t2[n2]);
    return e3;
  }, s.apply(this, arguments);
};
var f, p = function(e3) {
  var t2;
  e3 ? function(e4) {
    if (e4) for (; e4.lastChild; ) e4.lastChild.remove();
  }("string" == typeof e3 ? document.getElementById(e3) : e3) : (t2 = document.querySelector(".grecaptcha-badge")) && t2.parentNode && document.body.removeChild(t2.parentNode);
}, d = function(e3, t2) {
  p(t2), window.___grecaptcha_cfg = void 0;
  var r2 = document.querySelector("#" + e3);
  r2 && r2.remove(), function() {
    var e4 = document.querySelector('script[src^="https://www.gstatic.com/recaptcha/releases"]');
    e4 && e4.remove();
  }();
}, y = function(e3) {
  var t2 = e3.render, r2 = e3.onLoadCallbackName, o2 = e3.language, n2 = e3.onLoad, a2 = e3.useRecaptchaNet, c2 = e3.useEnterprise, i2 = e3.scriptProps, s2 = void 0 === i2 ? {} : i2, u2 = s2.nonce, l2 = void 0 === u2 ? "" : u2, f2 = s2.defer, p2 = void 0 !== f2 && f2, d2 = s2.async, y2 = void 0 !== d2 && d2, m2 = s2.id, v2 = void 0 === m2 ? "" : m2, b2 = s2.appendTo, h2 = v2 || "google-recaptcha-v3";
  if (function(e4) {
    return !!document.querySelector("#" + e4);
  }(h2)) n2();
  else {
    var g2 = function(e4) {
      return "https://www." + (e4.useRecaptchaNet ? "recaptcha.net" : "google.com") + "/recaptcha/" + (e4.useEnterprise ? "enterprise.js" : "api.js");
    }({ useEnterprise: c2, useRecaptchaNet: a2 }), S2 = document.createElement("script");
    S2.id = h2, S2.src = g2 + "?render=" + t2 + ("explicit" === t2 ? "&onload=" + r2 : "") + (o2 ? "&hl=" + o2 : ""), l2 && (S2.nonce = l2), S2.defer = !!p2, S2.async = !!y2, S2.onload = n2, ("body" === b2 ? document.body : document.getElementsByTagName("head")[0]).appendChild(S2);
  }
}, m = function(e3) {
  console.warn(e3);
};
!function(e3) {
  e3.SCRIPT_NOT_AVAILABLE = "Recaptcha script is not available";
}(f || (f = {}));
var v = reactExports.createContext({ executeRecaptcha: function() {
  throw Error("GoogleReCaptcha Context has not yet been implemented, if you are using useGoogleReCaptcha hook, make sure the hook is called inside component wrapped by GoogleRecaptchaProvider");
} }); v.Consumer;
function h(t2) {
  var i2 = t2.reCaptchaKey, u2 = t2.useEnterprise, l2 = void 0 !== u2 && u2, p2 = t2.useRecaptchaNet, b2 = void 0 !== p2 && p2, h2 = t2.scriptProps, g2 = t2.language, S2 = t2.container, w2 = t2.children, $2 = reactExports.useState(null), C2 = $2[0], P2 = $2[1], x2 = reactExports.useRef(i2), E2 = JSON.stringify(h2), R2 = JSON.stringify(null == S2 ? void 0 : S2.parameters);
  reactExports.useEffect(function() {
    if (i2) {
      var e3 = (null == h2 ? void 0 : h2.id) || "google-recaptcha-v3", t3 = (null == h2 ? void 0 : h2.onLoadCallbackName) || "onRecaptchaLoadCallback";
      window[t3] = function() {
        var e4 = l2 ? window.grecaptcha.enterprise : window.grecaptcha, t4 = s({ badge: "inline", size: "invisible", sitekey: i2 }, (null == S2 ? void 0 : S2.parameters) || {});
        x2.current = e4.render(null == S2 ? void 0 : S2.element, t4);
      };
      return y({ render: (null == S2 ? void 0 : S2.element) ? "explicit" : i2, onLoadCallbackName: t3, useEnterprise: l2, useRecaptchaNet: b2, scriptProps: h2, language: g2, onLoad: function() {
        if (window && window.grecaptcha) {
          var e4 = l2 ? window.grecaptcha.enterprise : window.grecaptcha;
          e4.ready(function() {
            P2(e4);
          });
        } else m("<GoogleRecaptchaProvider /> " + f.SCRIPT_NOT_AVAILABLE);
      }}), function() {
        d(e3, null == S2 ? void 0 : S2.element);
      };
    }
    m("<GoogleReCaptchaProvider /> recaptcha key not provided");
  }, [l2, b2, E2, R2, g2, i2, null == S2 ? void 0 : S2.element]);
  var M2 = reactExports.useCallback(function(e3) {
    if (!C2 || !C2.execute) throw new Error("<GoogleReCaptchaProvider /> Google Recaptcha has not been loaded");
    return C2.execute(x2.current, { action: e3 });
  }, [C2, x2]), N2 = reactExports.useMemo(function() {
    return { executeRecaptcha: C2 ? M2 : void 0, container: null == S2 ? void 0 : S2.element };
  }, [M2, C2, null == S2 ? void 0 : S2.element]);
  return React$1.createElement(v.Provider, { value: N2 }, w2);
}
var g = function() {
  return reactExports.useContext(v);
};
function w(e3, t2) {
  return e3(t2 = { exports: {} }, t2.exports), t2.exports;
  /** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
}
var $ = "function" == typeof Symbol && Symbol.for, C = $ ? Symbol.for("react.element") : 60103, P = $ ? Symbol.for("react.portal") : 60106, x = $ ? Symbol.for("react.fragment") : 60107, E = $ ? Symbol.for("react.strict_mode") : 60108, R = $ ? Symbol.for("react.profiler") : 60114, M = $ ? Symbol.for("react.provider") : 60109, N = $ ? Symbol.for("react.context") : 60110, O = $ ? Symbol.for("react.async_mode") : 60111, _ = $ ? Symbol.for("react.concurrent_mode") : 60111, T = $ ? Symbol.for("react.forward_ref") : 60112, j = $ ? Symbol.for("react.suspense") : 60113, L = $ ? Symbol.for("react.suspense_list") : 60120, k = $ ? Symbol.for("react.memo") : 60115, F = $ ? Symbol.for("react.lazy") : 60116, A = $ ? Symbol.for("react.block") : 60121, V = $ ? Symbol.for("react.fundamental") : 60117, z = $ ? Symbol.for("react.responder") : 60118, G = $ ? Symbol.for("react.scope") : 60119;
function I(e3) {
  if ("object" == typeof e3 && null !== e3) {
    var t2 = e3.$$typeof;
    switch (t2) {
      case C:
        switch (e3 = e3.type) {
          case O:
          case _:
          case x:
          case R:
          case E:
          case j:
            return e3;
          default:
            switch (e3 = e3 && e3.$$typeof) {
              case N:
              case T:
              case F:
              case k:
              case M:
                return e3;
              default:
                return t2;
            }
        }
      case P:
        return t2;
    }
  }
}
function D(e3) {
  return I(e3) === _;
}
var q = { AsyncMode: O, ConcurrentMode: _, ContextConsumer: N, ContextProvider: M, Element: C, ForwardRef: T, Fragment: x, Lazy: F, Memo: k, Portal: P, Profiler: R, StrictMode: E, Suspense: j, isAsyncMode: function(e3) {
  return D(e3) || I(e3) === O;
}, isConcurrentMode: D, isContextConsumer: function(e3) {
  return I(e3) === N;
}, isContextProvider: function(e3) {
  return I(e3) === M;
}, isElement: function(e3) {
  return "object" == typeof e3 && null !== e3 && e3.$$typeof === C;
}, isForwardRef: function(e3) {
  return I(e3) === T;
}, isFragment: function(e3) {
  return I(e3) === x;
}, isLazy: function(e3) {
  return I(e3) === F;
}, isMemo: function(e3) {
  return I(e3) === k;
}, isPortal: function(e3) {
  return I(e3) === P;
}, isProfiler: function(e3) {
  return I(e3) === R;
}, isStrictMode: function(e3) {
  return I(e3) === E;
}, isSuspense: function(e3) {
  return I(e3) === j;
}, isValidElementType: function(e3) {
  return "string" == typeof e3 || "function" == typeof e3 || e3 === x || e3 === _ || e3 === R || e3 === E || e3 === j || e3 === L || "object" == typeof e3 && null !== e3 && (e3.$$typeof === F || e3.$$typeof === k || e3.$$typeof === M || e3.$$typeof === N || e3.$$typeof === T || e3.$$typeof === V || e3.$$typeof === z || e3.$$typeof === G || e3.$$typeof === A);
}, typeOf: I }, B = w(function(e3, t2) {
}), J = (B.AsyncMode, B.ConcurrentMode, B.ContextConsumer, B.ContextProvider, B.Element, B.ForwardRef, B.Fragment, B.Lazy, B.Memo, B.Portal, B.Profiler, B.StrictMode, B.Suspense, B.isAsyncMode, B.isConcurrentMode, B.isContextConsumer, B.isContextProvider, B.isElement, B.isForwardRef, B.isFragment, B.isLazy, B.isMemo, B.isPortal, B.isProfiler, B.isStrictMode, B.isSuspense, B.isValidElementType, B.typeOf, w(function(e3) {
  e3.exports = q ;
})), H = { $$typeof: true, compare: true, defaultProps: true, displayName: true, propTypes: true, type: true }, Q = {};
Q[J.ForwardRef] = { $$typeof: true, render: true, defaultProps: true, displayName: true, propTypes: true }, Q[J.Memo] = H;

const LoginFormContent = () => {
  const { handleLogin } = useAuth();
  const [isModalOpen, setIsModalOpen] = reactExports.useState(false);
  const [email, setEmail] = reactExports.useState("");
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const navigate = useNavigate();
  const { executeRecaptcha } = g();
  const initialValues = {
    username: "",
    password: ""
  };
  const handleSubmit = async (values) => {
    if (!executeRecaptcha) {
      Swal.fire({
        title: "Error",
        text: "No se pudo verificar la seguridad. Por favor, recarga la página e intenta nuevamente.",
        icon: "error",
        confirmButtonText: "Aceptar"
      });
      return;
    }
    setIsLoading(true);
    try {
      const token = await executeRecaptcha("login");
      await handleLogin(values.username, values.password, token);
    } catch (error) {
      console.error("Error al ejecutar reCAPTCHA:", error);
      Swal.fire({
        title: "Error de verificación",
        text: "No se pudo verificar la seguridad. Por favor, intenta nuevamente.",
        icon: "error",
        confirmButtonText: "Aceptar"
      });
    } finally {
      setIsLoading(false);
    }
  };
  const toggleModal = () => setIsModalOpen((prev) => !prev);
  const handleClick = () => {
    sessionStorage.setItem("previousPath", window.location.pathname);
    navigate("/validation");
  };
  const forgotPasswordInitialValues = {
    email: ""
  };
  const handleForgotPassword = (values) => {
    setEmail(values.email);
    handleClick();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-screen flex w-full", children: [
    isLoading && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute flex items-center justify-center size-full z-10", children: [
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-4", style: { boxShadow: "0px 12px 30px 0px rgba(0, 0, 0, 0.2)" }, children: [
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx(QN, { description: "Iniciando..." }),
        " "
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-2/4 border-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(VN, { "data-testid": "layout-outside" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-2/4 flex items-center ", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-9/12 px-10 bg-white mx-auto rounded-lg flex flex-col item-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Formik,
        {
          initialValues,
          validationSchema: loginValidationSchema,
          onSubmit: handleSubmit,
          children: ({ errors, touched, handleChange, handleBlur, values }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Form, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl text-center font-medium mb-6", children: "INICIAR SESIÓN" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-between", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Ny,
                {
                  name: "username",
                  type: "email",
                  placeholder: "Correo electrónico",
                  value: values.username,
                  onChange: handleChange,
                  onBlur: handleBlur,
                  "data-testid": "input-username",
                  disabled: isLoading
                }
              ),
              errors.username && touched.username && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-500 text-sm my-2", children: errors.username })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-between", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                zd,
                {
                  name: "password",
                  placeholder: "Contraseña",
                  value: values.password,
                  onChange: handleChange,
                  onBlur: handleBlur,
                  "data-testid": "password-password",
                  disabled: isLoading
                }
              ),
              errors.password && touched.password && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-500 text-sm my-2", children: errors.password })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-between", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: "text-sm underline text-gray-600 cursor-pointer",
                onClick: toggleModal,
                children: "Olvidaste la contraseña"
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-end my-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              FN,
              {
                txtBtn: "Continuar",
                typeButton: "default",
                full: true,
                type: "submit",
                disabled: isLoading,
                "data-testid": "button-Continuar"
              }
            ) })
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "¿Aún no tienes una cuenta de Mathilde Ads?   " }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium text-base cursor-pointer underline", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/register", children: "Regístrate" }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(S1, { width: "40%", isOpen: isModalOpen, onClose: toggleModal, "data-testid": "modal", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pt-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
          "Si deseas cambiar tu contraseña ingresa el ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: "correo eléctronico" }),
          " registrado en la plataforma."
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Formik,
          {
            initialValues: forgotPasswordInitialValues,
            validationSchema: forgotPasswordValidationSchema,
            onSubmit: handleForgotPassword,
            children: ({ errors, touched, handleChange, handleBlur, values }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Form, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full my-3", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Ny,
                  {
                    name: "email",
                    type: "email",
                    placeholder: "Correo electronico",
                    value: values.email,
                    onChange: handleChange,
                    onBlur: handleBlur,
                    required: true,
                    "data-testid": "input-email"
                  }
                ),
                errors.email && touched.email && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-500 text-sm my-2", children: errors.email })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                FN,
                {
                  txtBtn: "Continuar",
                  typeButton: "default",
                  full: false,
                  type: "submit",
                  disabled: false,
                  className: "",
                  "data-testid": "button-Continuar-modal"
                }
              ) })
            ] })
          }
        )
      ] }) })
    ] }) })
  ] });
};
const LoginForm = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    h,
    {
      reCaptchaKey: "6LdCXC8rAAAAAL-Cg8XZHkdLSkwVc7Q2KOwvPfhq",
      scriptProps: {
        async: false,
        defer: false,
        appendTo: "head",
        nonce: void 0
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(LoginFormContent, {})
    }
  );
};

const API_URL$1 = "https://mthmocks.pruebasmathilde.com/castlemock/mock/rest/project/nIVSsr/application/YPlsJX/register";
const registerUser = async (userData) => {
  console.log(userData);
  try {
    const response = await axios.post(API_URL$1, userData);
    return response.data;
  } catch (error) {
    throw new Error("Error al registrar el usuario");
  }
};
const RegisterFormService = {
  roles: [
    { value: "Administrador", label: "Administrador" },
    { value: "Gestor de campañas", label: "Gestor de campañas" },
    { value: "Analista", label: "Analista" },
    { value: "Creativo", label: "Creativo" }
  ]};

const usePasswordValidation = () => {
  const [password, setPassword] = reactExports.useState("");
  const [confirmPassword, setConfirmPassword] = reactExports.useState("");
  const [validations, setValidations] = reactExports.useState({
    hasMinLength: false,
    hasNumber: false,
    hasUpperCase: false,
    hasLowerCase: false,
    hasSpecialChar: false
  });
  reactExports.useEffect(() => {
    setValidations({
      hasMinLength: password.length >= 8,
      hasNumber: /\d/.test(password),
      hasUpperCase: /[A-Z]/.test(password),
      hasLowerCase: /[a-z]/.test(password),
      hasSpecialChar: /[!@#$%^&*(),.?":{}|<>]/.test(password)
    });
  }, [password]);
  const isPasswordValid = () => {
    return password.trim() && confirmPassword.trim() && password === confirmPassword && Object.values(validations).every((v) => v);
  };
  const showError = () => {
    return !isPasswordValid() && password.trim() && confirmPassword.trim();
  };
  return {
    password,
    setPassword,
    confirmPassword,
    setConfirmPassword,
    showError,
    validations
  };
};

const useModal = () => {
  const [isModalOpen, setIsModalOpen] = reactExports.useState(false);
  const [termsAccepted, setTermsAccepted] = reactExports.useState(false);
  const [buttonEnabled, setButtonEnabled] = reactExports.useState(false);
  const modalRef = reactExports.useRef(null);
  const toggleModal = (forceClose = false) => {
    setIsModalOpen((prev) => {
      if (prev && !forceClose) {
        setTermsAccepted(false);
      }
      return !prev;
    });
  };
  const handleScroll = () => {
    if (modalRef.current) {
      const { scrollTop, scrollHeight, clientHeight } = modalRef.current;
      if (scrollTop + clientHeight >= scrollHeight - 5 && !buttonEnabled) {
        setButtonEnabled(true);
      }
    }
  };
  const handleAcceptTerms = () => {
    setTermsAccepted(true);
    toggleModal(true);
  };
  return {
    isModalOpen,
    toggleModal,
    termsAccepted,
    handleAcceptTerms,
    buttonEnabled,
    handleScroll,
    modalRef,
    setTermsAccepted
  };
};

const registerValidationSchema = create$3({
  name: create$6().required("El nombre es requerido").min(2, "El nombre debe tener al menos 2 caracteres"),
  firtsName: create$6().required("El apellido es requerido").min(2, "El apellido debe tener al menos 2 caracteres"),
  company: create$6().required("La empresa es requerida").min(2, "El nombre de la empresa debe tener al menos 2 caracteres"),
  phone: create$6().required("El teléfono es requerido").matches(/^[0-9]+$/, "Solo se permiten números").min(10, "El teléfono debe tener al menos 10 dígitos"),
  role: create$6().required("El rol es requerido"),
  email: create$6().required("El correo electrónico es requerido").email("Correo electrónico inválido"),
  password: create$6().required("La contraseña es requerida").min(8, "La contraseña debe tener al menos 8 caracteres"),
  confirmPassword: create$6().required("Confirmar contraseña es requerido").oneOf([create$9("password")], "Las contraseñas no coinciden")
});

const RegisterFormContent = () => {
  const { roles } = RegisterFormService;
  const navigate = useNavigate();
  const {
    showError
  } = usePasswordValidation();
  const {
    isModalOpen,
    toggleModal,
    termsAccepted,
    handleAcceptTerms,
    buttonEnabled,
    handleScroll,
    modalRef,
    setTermsAccepted
  } = useModal();
  const initialValues = {
    name: "",
    firtsName: "",
    company: "",
    phone: "",
    role: "",
    email: "",
    password: "",
    confirmPassword: "",
    termsAccepted: false
  };
  const handleSubmit = async (values, { setSubmitting }) => {
    console.log(values);
    if (!termsAccepted) {
      Swal.fire({
        text: "Debes aceptar los términos y condiciones.",
        icon: "warning",
        showConfirmButton: true
      });
      setSubmitting(false);
      return;
    }
    const formData = {
      ...values,
      term: termsAccepted
    };
    try {
      const response = await registerUser({
        formRegister: formData
      });
      console.log(response);
      sessionStorage.setItem("previousPath", window.location.pathname);
      sessionStorage.setItem("email", values.email);
      sessionStorage.setItem("password", values.password);
      navigate("/validation");
    } catch (err) {
      console.log(err);
      Swal.fire({
        text: err instanceof Error ? err.message : "Ha ocurrido un error.",
        icon: "error",
        showConfirmButton: false,
        timer: 1500
      });
    }
    setSubmitting(false);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-screen flex w-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-2/4 border-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(VN, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-2/4 flex items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Formik,
        {
          initialValues,
          validationSchema: registerValidationSchema,
          onSubmit: handleSubmit,
          children: ({ values, errors, touched, handleChange, handleBlur, isSubmitting }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Form, { className: "w-9/12 px-10 bg-white mt-28 mx-auto rounded-lg", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl mb-6", children: "REGISTRO DE USUARIOS" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "my-3", children: "Bienvenido a Mathilde, completa los datos y empieza a transformar tu estrategia digital." }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-2/4 mr-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Ny,
                  {
                    type: "text",
                    placeholder: "Nombres",
                    name: "name",
                    value: values.name,
                    onChange: handleChange,
                    onBlur: handleBlur,
                    required: true
                  }
                ),
                errors.name && touched.name && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-500 text-sm my-2", children: errors.name })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-2/4 ml-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Ny,
                  {
                    type: "text",
                    placeholder: "Apellidos",
                    name: "firtsName",
                    value: values.firtsName,
                    onChange: handleChange,
                    onBlur: handleBlur,
                    required: true
                  }
                ),
                errors.firtsName && touched.firtsName && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-500 text-sm my-2", children: errors.firtsName })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-2/3 mr-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Ny,
                  {
                    type: "text",
                    placeholder: "Empresa",
                    name: "company",
                    value: values.company,
                    onChange: handleChange,
                    onBlur: handleBlur,
                    required: true
                  }
                ),
                errors.company && touched.company && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-500 text-sm my-2", children: errors.company })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-2/3 ml-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Ny,
                  {
                    type: "number",
                    placeholder: "Celular",
                    name: "phone",
                    value: values.phone,
                    onChange: handleChange,
                    onBlur: handleBlur,
                    required: true
                  }
                ),
                errors.phone && touched.phone && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-500 text-sm my-2", children: errors.phone })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-2/3 mr-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Xy,
                  {
                    name: "role",
                    options: roles,
                    value: values.role,
                    onChange: handleChange,
                    onBlur: handleBlur
                  }
                ),
                errors.role && touched.role && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-500 text-sm my-2", children: errors.role })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-2/3 ml-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Ny,
                  {
                    type: "email",
                    name: "email",
                    value: values.email,
                    onChange: handleChange,
                    onBlur: handleBlur,
                    placeholder: "Correo electrónico",
                    required: true
                  }
                ),
                errors.email && touched.email && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-500 text-sm my-2", children: errors.email })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-2/3 mr-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  zd,
                  {
                    name: "password",
                    placeholder: "Contraseña",
                    value: values.password,
                    onChange: handleChange,
                    onBlur: handleBlur,
                    required: true
                  }
                ),
                errors.password && touched.password && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-500 text-sm my-2", children: errors.password })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-2/3 ml-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  zd,
                  {
                    name: "confirmPassword",
                    placeholder: "Confirmar contraseña",
                    value: values.confirmPassword,
                    onChange: handleChange,
                    onBlur: handleBlur,
                    required: true
                  }
                ),
                errors.confirmPassword && touched.confirmPassword && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-500 text-sm my-2", children: errors.confirmPassword })
              ] })
            ] }),
            showError() && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mth-msg", children: /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Las contraseñas no coinciden." }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex mt-5", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              qN,
              {
                label: "Acepto los términos y condiciones de la plataforma y la política de privacidad.",
                checked: termsAccepted,
                onOpenModal: toggleModal,
                onChange: setTermsAccepted
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-end", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/", className: "mr-2 flex items-center", children: "Cancelar" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                FN,
                {
                  txtBtn: "Continuar",
                  typeButton: "default",
                  full: false,
                  type: "submit",
                  label: "",
                  disabled: isSubmitting,
                  className: ""
                }
              )
            ] })
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(S1, { isOpen: isModalOpen, onClose: toggleModal, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            ref: modalRef,
            onScroll: handleScroll,
            style: { maxHeight: "70vh", overflowY: "auto", padding: "25px" },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-center font-bold", children: "TÉRMINOS Y CONDICIONES MATHILDE ADS" }),
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "1. Disposiciones generales." }),
                  " ",
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  'ADL DIGITAL LAB S.A.S (en adelante ADL) es la sociedad titular de la Plataforma Mathilde Ads (en adelante "Plataforma Mathilde"), cuyo propósito es poner a disposición de sus clientes una plataforma de Pauta Digital, bajo los lineamientos y parámetros establecidos en estos términos y condiciones.'
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "1.1. Definiciones" }),
                  " ",
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  'Inventario de Pauta: Es el inventario digital de publicidad que incluye sitios web, aplicaciones e inventario de Video y Display en Desktop y Mobile. Bloques de Anuncios: Espacio dentro del sitio web o la aplicación creada para albergar piezas gráficas de publicidad. Transacción programática: Significa el acto de compra y/o venta de publicidad programática a través de bloques de anuncios y procesamiento de data. Plataforma Mathilde: Elementos del Software usado por ADL para la prestación de los servicios de marketing tech. Plataforma de Datos Augusta ("PDA"): Es la Plataforma corporativa Multicloud de Datos que entrega valor y enriquece los procesos de negocio; facilitando el acceso, análisis y uso compartido de la información en proyectos que apliquen analítica en la nube. Data Management Platform ("DMP"): Es la plataforma de datos en donde se albergan las audiencias disponibles según el servicio adquirido. Para el caso particular es el DMP Bluekai de Oracle que se aloja en Augusta. Las audiencias son bases de datos anonimizadas. Segmentación: Grupos de audiencias de públicos traídos desde el DMP hacia el ecosistema de publicidad. Demand Side Platform ("DSP"): Es la plataforma de compra programática en donde se realiza la activación de campañas publicitarias. Supply Site Platform ("SSP"): Es la plataforma de venta programática que dispone los espacios publicitarios de propiedad de terceros. Pujas de Anuncios: Intención de compra de un anuncio de publicidad por un anunciante desde el DSP. Comprador: Anunciante que dispone una publicidad dentro del DSP para la generación de campañas publicitarias. Recolección de Data: Recolección de data que pasa desde la plataforma de datos corporativa Augusta hacia el DSP y el SSP. Smart Owned Media ("SOM"): Corresponde a la autopauta o espacios publicitarios que se llenan con información referente al mismo dueño del sitio o a marcas autorizadas por el sitio para fungir como tal. Smart Paid Media ("SPM"): Corresponde a las estrategias de publicidad y marketing digital que son ofrecidas por el equipo de Mathilde para cumplir objetivos de tráfico, leads, desembolsos, clicks, sesiones y demás que se requiera por el tomador del servicio. Costo por mil impresiones ("CPM"): Costo asociado a la venta de publicidad digital por cada vez que se imprime o renderiza un anuncio en la página web, el cual se gestiona por medio de la plataforma Mathilde. Costo por clic ("CPC"): Costo asociado al evento de clic que se genera al momento de ver un anuncio de publicidad. Costo por lead ("CPL"): Costo asociado al llenado exitoso del formulario dispuesto en alguna página web del tomador del servicio. Costo de adquisición ("CPA"): Costo por generación de desembolso en crédito de las entidades. Costo por publicación ("CPP"): Costo derivado de que el usuario genere una publicación de un vehículo de manera gratuita o paga. Cliente: Se refiere a todas las personas naturales o jurídicas o entidades de cualquier naturaleza que soliciten o contraten la prestación de servicios por parte de ADL de la Plataforma Mathilde. Usuario: Son las personas y/o empresas que utilizan los canales digitales para consumir contenido, crear contenido, interactuar con marcas y completar una transacción en comercios electrónicos, portales de contacto etc.'
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "1.2. Condiciones Generales " }),
                  " ",
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  "El presente documento establece las políticas de uso de la Plataforma Mathilde y la diversidad de servicios que se prestan y/o se activan por medio de esta, así como las condiciones de prestación de estos servicios. Es deber del Cliente leer cuidadosamente este documento antes consumir cualquiera de los servicios que se prestan a través de la Plataforma Mathilde, por lo que al acceder previamente se entenderá que entiende, acepta y cumplirá con los términos y condiciones, sino está de acuerdo, debe abstenerse de ingresar y de usar el servicio de la Plataforma Mathilde."
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "1.3. Descripción del Servicio. " }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  "Mathilde es una Plataforma tecnológica que le permite a los Clientes, crear, administrar, supervisar y gestionar campañas de publicidad digital, con las siguientes disponibilidades:"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "1.3.1 Anuncios Dirigidos." }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  "Por medio de la Plataforma Mathilde el Cliente podrá gestionar la entrega de anuncios dirigidos, usar diversas interfaces, administrar las campañas de publicidad desplegadas y utilizar datos anonimizados, los cuales, podrá combinar con la información de su público objetivo definido para entregar materiales publicitarios específicos y/o inventario en los canales utilizados por el público objetivo definido por el Cliente"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "1.3.1 Anuncios Dirigidos." }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  "Por medio de la Plataforma Mathilde el Cliente podrá gestionar la entrega de anuncios dirigidos, usar diversas interfaces, administrar las campañas de publicidad desplegadas y utilizar datos anonimizados, los cuales, podrá combinar con la información de su público objetivo definido para entregar materiales publicitarios específicos y/o inventario en los canales utilizados por el público objetivo definido por el Cliente."
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "1.3.1.1. Opciones para evitar publicidad dirigida." }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  "Tenga en cuenta que, aunque ADL cree que la publicidad dirigida es beneficiosa para todas las partes involucradas, no se elude ningún dispositivo y el Usuario dispone de mecanismos que le permiten dejar de recibir publicidad dirigida, lo cual, puede afectar las campañas dirigidas por el Cliente. Tenga en cuenta que las diferentes plataformas y dispositivos utilizan diferentes identificadores y diferentes tecnologías, y también que cada navegador y cada dispositivo tiene su propia configuración aplicable. Por lo que, si el Usuario elimina las cookies, los bloques de cookies y/o ejecuta el retiro de un anuncio específico, no será responsabilidad de ADL el impacto que pueda tener en la campaña publicitaria."
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "1.3.2 Información de Comportamientos. " }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  "El Cliente podrá acceder por medio de la Plataforma Mathilde a la siguiente información del público objetivo que defina: • Der talle de campañas implementadas • Impresiones • Clic's • Placements • Filtros IP • Fecha, hora, día de la semana de la impresión • Conversión de la Campaña • Bid request"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "1.3.2. Gestión de campaña en redes sociales: " }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  "Por medio de la Plataforma Mathilde el Cliente por sí mismo o por medio de ADL, podrá crear, monitorear y optimizar los anuncios en las diferentes plataformas de redes sociales en las que la Plataforma Mathilde este conectada."
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "1.3.3. Análisis de Datos y Reporte de Rendimiento" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  "Se podrá generar reportes detallados del rendimiento de las campañas, lo cual, le brinda al Cliente un análisis en tiempo real y recomendaciones basadas en datos que le permitirán optimizar las estrategias de marketing."
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "1.3.4. Otros Servicios" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  "ADL podrá prestar servicios, ofrecer productos adicionales o accesorios en la Plataforma Mathilde, de forma directa o través de un tercero, cuyos términos y condiciones serán los señalados al momento en que se tome el servicio. Los servicios ofrecidos por terceros serán prestados directamente por el tercero bajo los términos y condiciones que él disponga, por lo cual, el Usuario o Cliente deberá consultarlos previo adquirir el servicio, ADL no asumirá responsabilidad alguna por la prestación del servicio que realice el tercero."
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "2. Recopilación de Información del Usuario" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  "ADL recopila información de los anuncios del publico objeto definido por el Cliente, los anuncios son diseñados por el Cliente y se marcan como preferentes y relevantes, de allí que la Plataforma Mathilde se alimente de información recopilada utilizando los siguientes estándares (típicos de la industria) y tecnologías web:"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("ol", { className: "mb-4", children: "2.1.1. Cookies. Las cookies son una tecnología que se basa en archivos de datos de pequeño tamaño que contienen una cadena de caracteres alfanuméricos que generalmente incluyen un identificador único y se colocan en el dispositivo o computadora de un visitante. Las cookies generalmente se almacenan en la computadora del usuario de forma permanente o temporal (cookies persistentes). Usamos cookies en los sitios web de nuestros clientes para operar nuestra tecnología y recopilar información del usuario y analizar estadísticamente las preferencias publicitarias." }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("ol", { className: "mb-4", children: "2.1.1. Cookies. Las cookies son una tecnología que se basa en archivos de datos de pequeño tamaño que contienen una cadena de caracteres alfanuméricos que generalmente incluyen un identificador único y se colocan en el dispositivo o computadora de un visitante. Las cookies generalmente se almacenan en la computadora del usuario de forma permanente o temporal (cookies persistentes). Usamos cookies en los sitios web de nuestros clientes para operar nuestra tecnología y recopilar información del usuario y analizar estadísticamente las preferencias publicitarias." }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("ol", { className: "mb-4", children: '2.1.2. HTML5 y objetos almacenados localmente. Al igual que las cookies, esta tecnología también se basa en fragmentos de código conocidos como "objetos almacenados localmente". Los objetos almacenados localmente, como el almacenamiento web HTML5, suelen contener una mayor cantidad y diferentes tipos de datos que las cookies del navegador. La mayoría de las versiones actuales de los navegadores web comunes borran estos datos almacenados localmente cuando borra o borra su caché de cookies. Por lo general, el servicio analiza automáticamente toda la información relevante y la recopila.' }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("ol", { className: "mb-4", children: "2.1.3. Etiquetas y píxeles. Las etiquetas y los píxeles son bloques de código que nosotros y nuestros clientes podemos usar para rastrear su navegación en Internet: desde recursos hasta sitios web o aplicaciones en particular para rastrear su comportamiento de navegación. A veces, las balizas web se utilizan para estos fines. Suelen ser imágenes gráficas transparentes o invisibles, no mayores de 1x1 píxel, se colocan en una página o de otro modo, recurso de Internet o se envían dentro de un correo electrónico para monitorear el comportamiento del usuario que visita el recurso o envía el correo electrónico. A menudo se usa en combinación con cookies. Creamos y usamos un sistema de sincronización único para verificar la calidad de la información que hemos recopilado con la información que nuestros clientes recopilaron de forma independiente, y luego ayudar a nuestros clientes o terceros que pretenden proporcionarle publicidad dirigida." }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("ol", { className: "mb-4", children: "2.1.4. Identificadores de dispositivos móviles. Los identificadores de dispositivos móviles o ID de dispositivos móviles son identificadores únicos que se pueden utilizar para identificar un dispositivo móvil. Podemos utilizar identificadores de dispositivos estándar para rastrear su uso de aplicaciones móviles y determinar si una parte del inventario de publicidad se ha entregado a un usuario específico o reorientado, o para determinar la frecuencia de cierto inventario para un determinado usuario. En última instancia, devolver la identificación del dispositivo a los anunciantes nos ayuda a nosotros y a nuestros clientes a mejorar la calidad de la publicidad y su eficacia." }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("ol", { className: "mb-4", children: "2.1.5. Kits de desarrollo de software. Estos son bloques de código o algoritmos similares a las etiquetas y los píxeles que están incrustados en un recurso digital que nos permite rastrear cierta información relacionada con el uso de la aplicación, recopilada durante el proceso de utilización de nuestra tecnología." }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("ol", { className: "mb-4", children: "2.1.6. Otras tecnologías: tenga en cuenta que utilizamos otras tecnologías, incluidos los objetos almacenados localmente, para recopilar información del usuario con el fin de ayudar a los usuarios con la entrega del inventario y proporcionar informes a nuestros clientes o para evaluar la calidad de la publicidad." }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("ol", { className: "mb-4", children: "2.1.7. Otros proveedores de servicios. Los servicios SSP, DSP y DMP se basan en plataformas específicas que se comunican activamente con otras plataformas con el fin de complementar las funcionalidades de cada una en las plataformas SSP, DSP y DMP. Además, utilizamos servicios de varios terceros para analizar datos, prevenir fraudes, alojar datos, mantener y respaldar la Plataforma Mathilde, y para otros servicios relacionados que sean necesarios para proporcionar los servicios. Por lo anterior, el Cliente reconoce que ADL, utiliza y procesa la información a través de la tecnología empleada, en nombre de los anunciantes en línea, editores, socios comerciales y otras empresas que utilizan materiales publicitarios y/o inventario o servicios de la plataforma Mathilde." }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "2.2. Almacenamiento e intercambio de información del usuario." }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  "ADL solo almacena información en caso de necesidad. Por lo general, elimina la información derivada de las campañas trimestralmente. Tenga en cuenta que ciertas leyes y regulaciones pueden obligarnos a almacenar información del usuario durante un período de tiempo particular: leyes de lavado de dinero, regulaciones de informes financieros, leyes fiscales, demandas, denuncias etc. Además, es posible que tengamos que cumplir con la decisión de la entidad jurisdiccional correspondiente. y mantener la información durante un período más largo. ADL, comparte la siguiente información: • información con nuestros Clientes. Se comparte con el fin de ayudarlos a identificar, comprar publicidad y dirigirse a editores específicos. Los Clientes pueden usar esta información junto con otra información que hayan recopilado de forma independiente para proporcionarle materiales publicitarios específicos. También evalúan y analizan campañas publicitarias particulares, inventario, etc. • Cambio de control. ADL, podrá compartir información del usuario en relación con fusiones, adquisiciones, eventos de cambio de control, que incluyen, entre otros, la venta o transferencia de todo o parte de nuestro negocio o activos. En este caso, se requerirá el consentimiento informado del Cliente, en su caso, será otorgado a una nueva entidad de acuerdo con el evento de un cambio de control. • Cumplimiento de leyes y regulaciones. ADL podrá compartir la información del usuario con las autoridades reguladoras, la jurisdicción, civil, penal y/o administrativa."
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "2.3. Información recopilada de Usuarios finales o propietarios de datos personales Diferente a los Clientes." }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  "ADL en el curso de la prestación de servicios, no recopila información que revele el dato personal que conlleve a identificar a la persona, ni ejecuta el tratamiento de la información personal de los titulares que pudieran llegar a tener los Clientes, tales como: nombre, dirección, número de teléfono fijo y/o celular etc, el Cliente podrá utilizar los servicios de la Plataforma Mathilde para procesar la información de navegación que provenga de los Sitios web de los Clientes y pueden ser procesados a través de la tecnología de la Plataforma Mathilde, sin que ADL conozca el dato personal o tenga acceso o el control de los mismos. Por lo que ADL recopila información anonimizada y generalizada la cual, no es considerada información personal. En algunas otras jurisdicciones en las que brindamos servicios a nuestros clientes, en ciertos contextos, dicha información, incluidas las direcciones de Protocolo de Internet (IP) y otra información, como ciertos identificadores de dispositivos únicos que pueden identificar una computadora o dispositivo móvil en particular (por ejemplo, en la Unión Europea) dicha información se considera información personal. Tenga en cuenta que ADL puede trabajar con plataformas o aplicaciones de datos de terceros que pueden integrarse directamente en nuestra tecnología o utilizarse por separado, complementando la tecnología de la Plataforma Mathilde. Los Clientes pueden operar utilizando sus etiquetas, píxeles, cookies u otras tecnologías similares para sus actividades comerciales, bajo el cumplimiento de las disposiciones normativas a que haya lugar. ADL no es responsables de que el Cliente, utilice información personal o cualquier tipo de tecnología de seguimiento, tampoco es responsables de sus políticas de privacidad y no tiene el control sobre los mismos. Por lo que ADL procederá con la suspensión de la prestación del servicio cuando se produzca y/o evidencie una violación del tratamiento de los datos personales conforme lo dispone la ley 1581 de 2012 y demás normas que la complementen, modifiquen o sustituyan."
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "2.3.1. Tratamiento de los Datos" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  "ADL en la prestación del servicio no ejecuta el tratamiento de datos personales, no interactúa directamente con los titulares de la información personal, por lo que por medio de la plataforma Mathilde ADS se procesa la información proporcionada por los Clientes utilizando diversos software y servicios, y no siempre nuestro software a este respecto. Por lo tanto, cuando se cargue información de carácter personal a la plataforma es obligación del Cliente cuando trate información personal cumplir con todas las leyes de la jurisdicción colombiana, en especial con la ley 1581 de 2012 y demás normas complementarias, ADL, no se dirige directamente a ningún grupo en particular de propietarios de información personal por lo que de ocurrir, se realizara el tratamiento de la información acatando la política de tratamiento de datos de Cliente y el contrato marco de transmisión de datos bilateral que previo análisis, de aplicar, debe ser constituido entre el Cliente y ADL. Así las cosas, ADL no será responsable del incumplimiento legal en el tratamiento de los datos personales que el Cliente materialice, en el uso de la plataforma Mathilde."
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "2.3.2. De la Transmisión de Datos" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  "En el evento en el que el Cliente comparta datos personales de titulares con ADL, se entenderá que se hace bajo la modalidad de transmisión de datos personales y, con ocasión a ello, ADL asumirá el rol de ENCARGADO sobre los datos personales que le sean transmitidos por el Cliente, en su rol de RESPONSABLE y ejecutara el tratamiento de la información con base en las finalidades de la Política de Tratamiento de Datos del Cliente. Las partes en función de los servicios determinaran si es procedente la suscripción de un Contrato de transmisión de datos."
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "2.3.3. Política hacia los niños." }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  "Los servicios de ADL no están dirigidos a personas menores de 18 años. Si se da cuenta de que su hijo ha proporcionado información personal sin su consentimiento, comuníquese con ADL de inmediato. No recopilamos información personal de niños menores de 18 años. Si es menor de edad, puede utilizar nuestros servicios solo junto con un el acompañamiento y aceptación del padre o tutor."
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "3. Obligaciones " }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "3.1. Obligaciones generales de ADL" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  "• Poner a disposición del Cliente la Plataforma de Mathilde para que las mismas puedan ser utilizadas por éste, permitiendo el acceso al uso de estas, siempre que se cumplan todas las condiciones establecidas en estos términos y condiciones. • Brindar soporte técnico de ser requerido en cuanto al uso de la Plataforma Mathilde. • Suministrar la información necesaria para el uso de la Plataforma Mathilde. • Informar por medio de los términos y condiciones los cambios y/o actualizaciones efectuadas en la Plataforma de Mathilde que incidan en el servicio prestado. • Informar al Cliente con antelación sobre mantenimientos programados o no programados en la plataforma Mathilde, que puedan llegar a afectar el uso de esta. • Proteger cuando aplique la información personal del Cliente que sea conocida por ADL o por los terceros, de acuerdo con lo establecido en las leyes colombianas sobre protección de datos personales. • Realizar su mejor esfuerzo para que la Plataforma Mathilde se encuentre bajo una disponibilidad de 7*24; esta disponibilidad podrá verse afectada por diferentes circunstancias, entre ellas, fallas o errores, indisponibilidad de servidores, mantenimientos programados o no programados, actualizaciones, entre otros eventos. • ADL no es responsable por el funcionamiento de la Plataforma Mathilde derivada de la falta de conexión, red inestable o suspensión del servicio de conectividad que pueda presentar del Cliente, que genere fallas, intermitencia o no funcionalidad de la Plataforma Mathilde."
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "3.2. Obligaciones del Cliente " }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  "• Pagar a ADL, según corresponda, la remuneración establecida por el consumo que se ejecute de los servicios prestados en la Plataforma Mathilde. • Guardar custodia de las credenciales del acceso a la Plataforma Mathilde, las credenciales son de uso personal e intransferible, por tanto, no está autorizado a compartirla con terceros o comercializarlas. Cualquier novedad con las credenciales deberá notificarla de manera inmediata a ADL. • El Cliente debe utilizar de manera exclusiva la Plataforma de Mathilde y abstenerse de permitir su uso por parte de terceros no autorizados. • Atender dentro de los 5 días hábiles siguientes los requerimientos de información que realice ADL y los requerimientos relacionados con PQR presentadas por los usuarios que le sean trasladas por ADL. • No publicar contenido que contenga términos engañosos al Usuario • Si la publicación del Cliente es dirigida a productos nocivos deberá se advertirá claramente al público acerca de su nocividad y de la necesidad de consultar las condiciones o indicaciones para su uso correcto, así como las contraindicaciones del caso. • Abstenerse de operar como intermediario o vender a terceros los servicios ofrecidos en la Plataforma de Mathilde, salvo que así se haya acordado con ADL. • El Cliente no podrá utilizar sus cuentas de acceso o en general los servicios contratados, para prestar los mismos servicios a terceras personas, bien sea de forma gratuita u onerosa, como un servicio independiente o complementario a otras actividades, salvo que así se haya pactado y autorizado por ADL. • Ajustar el contenido de sus campañas digitales, cumpliendo con lo establecido en el numeral 4.3. • Abstenerse de sublicenciar o permitir el uso de los derechos concedidos mediante este reglamento, a terceros no autorizados previa y expresamente por ADL. • Conservar las claves, credenciales, software, guías y accesos que ADL le ha permitido utilizar, con los debidos estándares de privacidad y seguridad según ha sido informado asumiendo toda la responsabilidad frente a ADL por cualquier vulneración a sus sistemas de seguridad o indebido uso que se haga de la Plataforma de Mathilde por parte de sus empleados, administradores, contratistas y sus proveedores, y que impliquen la configuración de riesgos reputacionales para ADL o las Entidades Financieras Aliadas, pérdidas económicas, perjuicios a otros, investigaciones o sanciones de autoridades competentes. • Conservar la funcionalidad del contenido de la Plataforma de Mathilde así como sus características, evitando cualquier alteración, filtración, modificación o inhabilitación de las mismas. • Garantizar que todo su personal cumpla con los lineamientos impartidos por ADL o para el acceso a la información y uso de la Plataforma Mathilde cuando por virtud de su cargo, deba acceder a la misma. • Asumir la carga tributaria que legalmente le corresponda con ocasión a la contratación de los servicios adquiridos."
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "4. Uso de la Plataforma Mathilde" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "4.1. Deberes del Cliente en el Uso de la Plataforma Mathilde" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  "Para que se habilite por parte de ADL el uso de la Plataforma el Cliente, deberá: • Cumplir con los términos y condiciones que se relacionan por medio del presente documento. • Cumplir con los requisitos de vinculación de ADL. • Realizar previo al consumo del servicio, la negociación de los servicios a utilizar en la plataforma Mathilde. • Consumir el servicio de la Plataforma Mathilde, conforme lo acordado con el área comercial, los presentes términos y condiciones y lo establecido en el contrato de prestación de servicios."
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "4.2. Uso NO Autorizado " }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  "• No podrán usar la Plataforma con el fin de transmitir, distribuir, editar, almacenar, modificar, adaptar o de cualquier forma transformar el material dispuesto en la Plataforma, de tal manera que: (i) Se infrinjan las normas nacionales, supranacionales o internacionales sobre derechos de autor, propiedad industrial, secretos comerciales o cualquier otro derecho de propiedad intelectual de terceros o de manera que viole la privacidad, publicidad, derechos personales o personalísimos de terceros; (ii) Resulte lesivo, difamatorio, amenazante o abusivo a los derechos de terceros, tanto personas naturales como jurídicas o cualquier otra forma asociativa. • No podrán vulnerar o intentar vulnerar la seguridad de la Plataforma Mathilde. • Particularmente se encuentran inhabilitados para: o Acceder a información que no esté dirigida o autorizada para acceso al Cliente o acceder a los servidores o cuentas a los cuales no se encuentre autorizado o Probar o intentar probar la vulnerabilidad de cualquiera de los sistemas o redes por las cuales opera la Plataforma Mathilde. Esta limitación comprende la vulneración de las medidas de seguridad o autenticación dispuestas por ADL o Intentar interferir con los servicios prestados, incluyendo, pero sin limitarse al uso de virus, malware o programas de computador con potencialidad para afectar software, sistemas o herramientas. • No podrán incluir o suministrar información falsa, errónea, inexacta o que de cualquier otra manera no corresponda con la realidad, induciendo en error a ADL. • No le está permitido utilizar la Plataforma para ejecutar actividades que signifiquen la comisión de conductas relacionadas con los delitos de lavado de activos o financiación del terrorismo o aquellos conexos con estos. • No podrá borrar, editar o transformar de cualquier forma o comercializar cualquier material y/o información dispuesta en la Plataforma Mathilde. • No podrá usar cualquier elemento, diseño o software para interferir o intentar interferir con el funcionamiento adecuado de la Plataforma Mathilde o que tenga como propósito la modificación de esta. • No podrá intentar descifrar, compilar o desensamblar cualquier software o sistema que sea utilizado para el funcionamiento de la Plataforma Mathilde. • Si tienen credenciales que le permita el acceso a un área no pública de la Plataforma Mathilde, no podrá revelar o compartir estas credenciales con terceras personas o usar la contraseña para propósitos no autorizados. • No podrá permitir que personas no autorizadas, accedan o utilicen la Plataforma Mathilde o a documentación relativa a estas. • No le está permitido comercializar, distribuir, modificar, reproducir, copiar o archivar por cualquier medio la información que proporcione la Plataforma Mathilde o el contenido inherente a esta, las credenciales, o a las herramientas de información que hayan sido puestas a su disposición. • Le está prohibido usar la Plataforma Mathilde para fines diferentes a los permitidos. • No podrá utilizar ningún tipo de tecnología orientada a acceder de forma fraudulenta o maliciosa a la Plataforma Mathilde o utilizar dicha tecnología para conseguir información cuyo acceso no le haya sido permitido. Parágrafo Primero: El Cliente deberá reparar los daños y asumir las demás consecuencias de orden penal, si llegara a ocurrir, por la ejecución de actos propios o de terceros bajo su dirección, en donde se vulnere la seguridad de cualquier sistema o red asociada a la Plataforma Mathilde. Parágrafo Segundo: ADL podrá iniciar los rastreos, investigaciones y cualquier otra forma de indagación sobre las personas e instrumentos utilizados para vulnerar la seguridad dispuestas en la Plataforma Mathilde. En cualquier evento promoverá las denuncias o demandas buscando que se proscriban dichas actuaciones, así como la indemnización de los perjuicios ocasionados."
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "4.3. Prohibición de Contenido Inapropiado" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  "Los Clientes de la Plataforma Mathilde, se comprometen a no crear, cargar, distribuir o promover, a través de la Plataforma, contenido publicitario que incluya, promueva o sugiera: • Incluir imágenes o información considerada como pornográfica, que incluyan material sexual explícito o que sea considerada como pornografía infantil en los términos del Decreto 1524 de 2002 o cualquier otra disposición legal o reglamentaria que regule la materia. • Contenido que incite, promueva o perpetue la violencia, el odio, la discriminación o la intolerancia hacia cualquier individuo basado en su raza, etnia, nacionalidad, religión, género, discapacidad, entre otras características protegidas • Material difamatorio, obsceno ofensivo o que pueda causar daño a la sensibilidad de los usuarios. • Introducir en los servidores o cualquier otro sistema donde se encuentre alojada la Plataforma Mathilde, malware o programas de computador con potencialidad para afectar software, sistemas o herramientas. • Incluir material que revele secretos industriales o comerciales salvo que sea el legítimo propietario de estos o haya obtenido autorización para el efecto. • Incluir material que esté protegido por las leyes sobre derechos de autor o cualquier otro derecho de propiedad intelectual o industrial, a menos que el Cliente sea titular de tales derechos y/o se encuentre facultado para comunicar públicamente los derechos incorporados en la publicación. ADL presume de buena fe que el Usuario o Cliente tiene las facultades necesarias para publicar los textos o imágenes. Cualquier persona que acredite mejor derecho o pueda sustentar la falta de capacidad del Cliente para la comunicación pública, podrá comunicarse en cualquier tiempo con ADL a través de los canales de comunicación dispuestos para que este lleve a cabo las actuaciones pertinentes. Parágrafo: ADL se reserva el derecho de revisa, suspender o eliminar cualquier contenido que, a su exclusivo criterio, infrinja estas prohibiciones o cualquier otra disposición de los presentes términos y condiciones, sin necesidad de previo aviso. En caso de incumplimiento de esta cláusula, ADL podrá dar por terminado sin previo aviso la cuenta del Cliente infractor, por lo que no asumirá responsabilidad alguna por las perdidas o daños derivados de la cancelación o suspensión que realice."
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "4.3.1. Excepción de responsabilidad por contenido Inapropiado." }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  "ADL no será responsable en ningún caso por los contenidos generados, subidos, distribuidos, cargados o promocionados por los Clientes a través de la Plataforma Mathilde, el Cliente acepta y reconoce que es el único responsable del contenido que publique, y garantiza que dicho contenido cumple con la legislación colombiana incluyéndose pero no limitándose a la ley 1482 de 2011 contra los actos de discriminación y la ley 679 de 2001 relacionada con la prevención de la explotación sexual en menores y cualquier otra normatividad aplicable. En caso de que un tercero presente reclamaciones, demandas o acciones judiciales por la publicación de contenido inapropiado, será el Cliente el único responsable de los daños y perjuicios ocasionados, exonerando a ADL de cualquier responsabilidad incluido, pero sin limitarse a costos judiciales, honorarios de representación legal, sanciones, multas y/o condenas declaradas mediante sentencias judiciales. El uso de la Plataforma Mathilde por parte del Cliente implica el reconocimiento de que ADL, actúa únicamente como un intermediario tecnológico, y no ejerce control ni responsabilidad editorial sobre los contenidos generados por los Clientes, por lo anterior ADL queda exonerado de toda responsabilidad civil, penal o administrativa derivada del uso indebido que ejecute el Cliente de la Plataforma Mathilde."
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "5. Registro de Usuarios" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  "Para utilizar la Plataforma Mathilde los Clientes deberán gestionar el proceso de vinculación con ADL, quien una vez ejecute los tramites de creación de clientes proporcionará la activación de la cuenta para su respectivo uso, para lo cual el cliente proporcionará información precisa y actualizada. Los Clientes son responsables de mantener la confidencialidad de sus credenciales de acceso y todas las actividades que ocurran bajo su cuenta. El cliente, se obliga a cumplir con todas las recomendaciones de seguridad que le proporcione ADL para uso y manejo de su cuenta. No se permite la creación de múltiples cuentas para una misma persona o entidad sin autorización previa de ADL, el Cliente podrá crear su usuario, sin embargo, el mismo se activará para uso de la Plataforma Mathilde, una vez se cierre la negociación con el área comercial de ADL."
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "6. Cesión del Usuario." }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  "Las cuentas de usuario registradas no podrán ser objeto de venta, cesión o cualquier otro título traslaticio sin el consentimiento previo y escrito de ADL autorizado para tal fin. Tanto el enajenante como el adquirente serán responsables de forma exclusiva y excluyente por la transferencia del usuario por fuera del procedimiento señalado. ADL no responderá económica u operativamente por la transferencia a cualquier título de las cuentas de usuario registradas sin su autorización previa y escrita. El titular originario (y único titular) será el responsable por los contenidos, imágenes, anuncios, ofertas, promociones que sean publicadas desde su perfil. ADL presume de buena fe que cada una de las cuentas de usuario registradas está siendo usada por sus legítimos titulares."
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "6.1.1. Canales de Contacto" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  "Recuerda que en cualquier momento podrás hacer la selección, actualización o modificación de tus canales de contacto para fines comerciales, de publicidad y de cobranza a través del formulario que ha dispuesto ADL en cumplimiento de ley 2300/23, el cual podrás encontrar en el siguiente link: ___________. En caso de no seleccionar tus canales, entenderemos que nos autorizas para seguirte contactando a través de los datos de contacto que le has suministrado a ADL y a los canales asociados a los mismos, tales como tu correo electrónico, llamada, mensaje de texto, whatsapp y/o mensajería web y app. Para cancelar el recibimiento de mensajes publicitarios podrás diligenciar el siguiente formulario: __________________. O podrás enviar tu solicitud al correo _________________________"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "7. Aviso de Privacidad" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  "A través de este enlace encontrarás la Política de Tratamiento de Datos Personales que regirá el Tratamiento de tus Datos Personales, la cual aceptas previa y expresamente como Cliente de la Plataforma Mathilde para los fines que allí se informan de manera previa, expresa e informada. Toda la información suministrada por los Clientes que en virtud de la Ley 1581 de 2011, su normatividad complementaria o aquella que la modifique sea considera como dato personal, se encontrará sometida a la Política de Tratamiento de Datos Personales de ADL y será tratada para las finalidades dispuestas por esta. El procedimiento para la rectificación, actualización, supresión podrá ser realizado por los titulares de la misma de conformidad con el procedimiento establecido. Las Partes declaran que al ejecutar cualquier transacción que implique el tratamiento de datos personales. cuentan con las autorizaciones de tratamiento de datos, previas y expresas de los Titulares de cuyos datos vaya a tratar en el desarrollo del servicio contratado y que cuenta con los soportes que así lo acreditan."
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "8. Tarifas" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  "El valor de los servicios prestados por ADL será el informado en el momento de su adquisición o el que hayan acordado las partes en las respectivas órdenes de compra, contratos o demás documentos contractuales que suscriban las partes. Los impuestos y demás cargas tributarias serán asumidas por quien corresponda según la ley. Todo pago deberá realizarse dentro de los 30 días calendario siguientes a la fecha en la que ADL haya radicado la factura ante al Cliente."
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "9. Información Confidencial " }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  "Revelador: Parte que revele directa o indirectamente información a la otra parte Receptor: Quien recibe la información Información confidencial: Toda información que el revelador revele a la otra parte por cualquier medio, ya sea directa o indirectamente. ¿A qué se obliga el Receptor? • Divulgar la información estrictamente necesaria únicamente a las personas relacionadas con el Contrato. • Deberá dar instrucciones a sus empleados y terceros sobre el correcto uso de la información. ¿Hasta cuándo debe el Receptor guardar la confidencialidad de la información? • Terminación del contrato y 10 años más. • La obligación de confidencialidad sobre datos personales será indefinida. • A solicitud de devolución presentada por el Revelador dentro de los 5 días hábiles posteriores a la solicitud, siempre que no haya obligación contractual o legal de conservar la información. ¿Cuándo no aplica esta cláusula? • Cuando la información sea de dominio público. • Si la información la conocía el Receptor con anterioridad a que el Revelador la haya entregado. Cuando una autoridad competente requiera la información El Receptor deberá: • Informarle al revelador • Indicarle a la autoridad que se trata de información confidencial."
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "10. Modificación" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  "ADL tiene la facultad unilateral de modificar los términos y condiciones en cualquier tiempo, caso en el cual publicará en la web los ajustes realizados para facilidad de acceso al público. En cualquier momento ADL podrá limitar, adicionar o suprimir cualquier de los servicios de Mathilde ADS, las condiciones para su acceso, las funcionalidades, características, su valor y en general cualquier servicio prestado en la Plataforma Mathilde, lo cual será informado por cualquiera de los canales dispuestos por ADL. Anunciada una modificación, el Usuario y/o Cliente podrá pronunciarse para su aceptación o no, dentro de los diez (10) días calendario siguientes; sí el Usuario y/o Cliente no está de acuerdo con las modificaciones, podrá dejar de hacer uso de la Plataforma Mathilde notificándolo previamente a ADL y garantizando el borrado de toda la información de acuerdo con lo establecido en estos términos y condiciones. El Usuario y/o Cliente tiene la obligación de revisar estos términos y condiciones cada vez que haga uso de las herramientas de la Plataforma, consulte o consuma los servicios ofrecidos en la Plataforma Mathilde y en general, cada vez que solicite la prestación de servicios allí expuestos."
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "11. Seguridad" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  "Para evitar el acceso y la divulgación no autorizados, para mantener la precisión de los datos y para garantizar el uso adecuado de su información, utilizamos procedimientos físicos, técnicos y administrativos estándar de la industria para salvaguardar cualquier información personal que recopilemos. Sin embargo, tenga en cuenta que no se puede garantizar que la transmisión o el almacenamiento de información sea completamente seguro, aunque tomamos todas las precauciones razonables para protegernos contra incidentes de seguridad."
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "12. Disposiciones Finales" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  "ADL tendrá la facultad discrecional de eliminar, borrar, corregir, adaptar, cualquier texto o imagen publicados por sus Clientes en la Plataforma Mathilde cuando evidencie, por su propia cuenta o a través de información de terceros, que la publicación contraría en todo o en partes estos Términos y Condiciones, derechos de terceros, el ordenamiento jurídico de la República de Colombia o cualquier otra norma que en virtud de tratados o instrumentos internacionales resulte vinculante. En tales situaciones, comunicará al usuario titular de la publicación la decisión adoptada y las razones por las cuales se procedió. El Cliente podrá oponerse fundadamente a la actuación, presentando su queja a través de los canales de comunicación dispuestos. La Plataforma se rigen por las leyes vigentes y aplicables en la República de Colombia. ADL no asume responsabilidad alguna por cualquiera de los textos o imágenes que no se encuentre de acuerdo con las leyes de terceros países, o tratados o instrumentos internacionales no vinculantes para la República de Colombia. ADL no garantiza que las publicaciones, textos o imágenes sean accesibles o visibles en países distintos al territorio que comprende la República de Colombia, o que tal material se encuentre de acuerdo con leyes distintas a las de la República de Colombia. El Cliente que acceda a la Plataforma Mathilde será individual y exclusivamente responsable del cumplimiento de las leyes aplicables a la jurisdicción en la que se encuentre. De presentarse decisión judicial que declare la nulidad, invalidez o ineficacia de alguna de las disposiciones de estos Términos y Condiciones, ello no afectará la subsistencia y la producción de efectos jurídicos de las demás declaraciones aquí contenidas. ADL no tiene deber legal o contractual alguno para inspeccionar las publicaciones, ofertas o bienes publicados. Igualmente. La selección y celebración de actos o negocios jurídicos por parte de los Clientes solamente compromete entre sí las declaraciones de voluntad que estos realicen. Cualquier interacción entre Usuarios o Clientes, independiente del motivo o finalidad que se hayan propuesto con ello, es de exclusiva y excluyente responsabilidad de los intervinientes. ADL no será responsable civil o penalmente por los hechos que ocasionaren algún perjuicio, moral o patrimonial, que tenga como origen las interacciones entre usuarios en la Plataforma. Sin perjuicio de ello, en virtud de solicitud de autoridad judicial o administrativa, ADL podrá suministrar información que se pueda recolectar sobre la presunta comisión de conductas punibles o hechos dañosos. Facturación. ADL propenderá por emitir la factura de los servicios prestados dentro de los tiempos legales y/o contractuales estipulados; sin embargo, si por imposibilidades operativas, técnicas o administrativas, no se logra generar, emitir o enviar la factura dentro del término legal o contractual, ADL se compromete a remitirla tan pronto se supere el inconveniente o imposibilidad presentada."
                ] })
              ] })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "py-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          FN,
          {
            txtBtn: "Acepto",
            typeButton: "default",
            full: false,
            disabled: !buttonEnabled,
            onClick: handleAcceptTerms,
            type: "button"
          }
        ) }) })
      ] })
    ] })
  ] });
};
const RegisterForm = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    h,
    {
      reCaptchaKey: "6LdCXC8rAAAAAL-Cg8XZHkdLSkwVc7Q2KOwvPfhq",
      scriptProps: {
        async: false,
        defer: false,
        appendTo: "head",
        nonce: void 0
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(RegisterFormContent, {})
    }
  );
};

const resetPasswordSchema = create$3().shape({
  password: create$6().required("La contraseña es obligatoria").min(8, "Debe tener al menos 8 caracteres").matches(/\d/, "Debe contener al menos un número").matches(/[A-Z]/, "Debe contener al menos una mayúscula").matches(/[a-z]/, "Debe contener al menos una minúscula").matches(/[!@#$%^&*(),.?":{}|<>]/, "Debe contener al menos un carácter especial"),
  confirmPassword: create$6().required("Confirma tu contraseña").oneOf([create$9("password")], "Las contraseñas no coinciden")
});

const ResetPass = () => {
  const navigate = useNavigate();
  const handleSubmit = async (values) => {
    try {
      console.log("Valores del formulario:", values);
      navigate("/");
    } catch (error) {
      console.error("Error al actualizar la contraseña:", error);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-screen flex w-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-2/4 border-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(VN, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-2/4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Formik,
      {
        initialValues: {
          password: "",
          confirmPassword: ""
        },
        validationSchema: resetPasswordSchema,
        onSubmit: handleSubmit,
        children: (formikProps) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Form, { className: "w-3/5 px-10 bg-white mx-auto rounded-lg flex flex-col justify-center h-full", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-2xl text-center mb-6", children: "Crea una nueva contraseña para ingresar a la plataforma." }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(UN, { formik: formikProps }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex mt-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            FN,
            {
              txtBtn: "Confirmar",
              typeButton: "default",
              full: true,
              type: "submit",
              disabled: !formikProps.isValid || formikProps.isSubmitting
            }
          ) })
        ] })
      }
    ) })
  ] });
};

const postRequest = async (url, data) => {
  try {
    const response = await axios.post(url, data);
    return response.data;
  } catch (error) {
    console.error(`Error en la solicitud a ${url}:`, error);
    throw error;
  }
};
const verifyOtp = async (code) => {
  return postRequest("https://mthmocks.pruebasmathilde.com/castlemock/mock/rest/project/nIVSsr/application/YPlsJX/reset", { code });
};

const ValidationPass = () => {
  const { login } = useAuth();
  const inputsRef = reactExports.useRef([]);
  const navigate = useNavigate();
  const [errorMessage, setErrorMessage] = reactExports.useState("");
  const [loading, setLoading] = reactExports.useState(false);
  const [redirectPath, setRedirectPath] = reactExports.useState("/");
  const [timeLeft, setTimeLeft] = reactExports.useState(60);
  const [isActive, setIsActive] = reactExports.useState(true);
  reactExports.useEffect(() => {
    const currentPath = sessionStorage.getItem("previousPath") || "/";
    console.log("Previous path:", currentPath);
    if (currentPath === "/") {
      setRedirectPath("/reset");
    } else if (currentPath === "/register") {
      setRedirectPath("/dashboard");
    }
  }, []);
  reactExports.useEffect(() => {
    let interval = void 0;
    if (isActive && timeLeft > 0) {
      interval = setInterval(() => {
        setTimeLeft((time) => time - 1);
      }, 1e3);
    } else if (timeLeft === 0) {
      setIsActive(false);
      if (interval) {
        clearInterval(interval);
      }
    }
    return () => {
      if (interval) {
        clearInterval(interval);
      }
    };
  }, [timeLeft, isActive]);
  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs < 10 ? "0" : ""}${secs}`;
  };
  const handleInput = (e, index) => {
    const value = e.target.value;
    if (/^[0-9]$/.test(value)) {
      if (index < inputsRef.current.length - 1) {
        inputsRef.current[index + 1]?.focus();
      }
    } else {
      e.target.value = "";
    }
    if (index === inputsRef.current.length - 1 && value) {
      const otp = inputsRef.current.map((input) => input?.value).join("");
      console.log("OTP ingresado:", otp);
      handleVerifyOtp(Number(otp));
    }
  };
  const handleVerifyOtp = async (otp) => {
    setLoading(true);
    setErrorMessage("");
    try {
      const response = await verifyOtp(otp);
      if (response.success) {
        if (redirectPath === "/dashboard") {
          const email = sessionStorage.getItem("email");
          const password = sessionStorage.getItem("password");
          login("admin@avaldigitallabs.com", "123");
        } else {
          navigate(redirectPath);
        }
      } else {
        setErrorMessage("El código OTP ingresado es incorrecto. Inténtalo de nuevo.");
      }
    } catch (error) {
      console.error("Error al verificar OTP:", error);
      setErrorMessage("Ocurrió un error al verificar el OTP. Intenta nuevamente más tarde.");
    } finally {
      setLoading(false);
    }
  };
  const handleResendCode = () => {
    setTimeLeft(60);
    setIsActive(true);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-screen flex w-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-2/4 border-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(VN, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-2/4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { className: "w-3/5 px-10 bg-white mx-auto rounded-lg flex flex-col justify-center h-full", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-2xl text-center mb-6", children: "Hemos enviado un código OTP al correo electrónico registrado para activar tu cuenta." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex w-full justify-evenly", children: Array.from({ length: 6 }).map((_, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-14", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Ny,
        {
          type: "text",
          classInclude: "mth-input-code text-center",
          maxLength: 1,
          onChange: (e) => handleInput(e, index),
          ref: (el) => {
            inputsRef.current[index] = el;
          }
        }
      ) }, index)) }),
      errorMessage && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-red-500 text-center", children: errorMessage }),
      loading && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-blue-500 text-center", children: "Verificando OTP..." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-between", children: isActive ? /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-sm underline text-gray-600 cursor-pointer", children: [
        formatTime(timeLeft),
        " para solicitar un nuevo código"
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: handleResendCode,
          className: "text-sm underline text-gray-600 cursor-pointer",
          children: "Reenviar código"
        }
      ) })
    ] }) })
  ] });
};

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function memoize(fn2) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache[arg] === void 0) cache[arg] = fn2(arg);
    return cache[arg];
  };
}
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = /* @__PURE__ */ memoize(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
);
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  }
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? true : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
}();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash$2(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match$1(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index) {
  return value.charCodeAt(index) | 0;
}
function substr(value, begin, end2) {
  return value.slice(begin, end2);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root, parent, type, props, children, length2) {
  return { value, root, parent, type, props, children, line, column, length: length2, return: "" };
}
function copy(root, props) {
  return assign(node("", null, null, "", null, null, 0), root, { length: -root.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end2) {
  return substr(characters, begin, end2);
}
function token(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      case type:
        return position;
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index, position - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index) {
  while (!token(peek()))
    next();
  return slice(index, position);
}
function compile(value) {
  return dealloc(parse$1("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse$1(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index = 0;
  var offset2 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference2 = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset2:
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference2 = ruleset(characters2, root, parent, index, offset2, rules, points, type, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset2 === 0)
                parse$1(characters2, root, reference2, reference2, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 109:
                  case 115:
                    parse$1(value, reference2, reference2, rule && append(ruleset(value, reference2, reference2, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse$1(characters2, reference2, reference2, reference2, [""], children, 0, points, children);
                }
        }
        index = offset2 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset2 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent, index, offset2, rules, points, type, props, children, length2) {
  var post = offset2 - 1;
  var rule = offset2 === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i = 0, j = 0, k = 0; i < index; ++i)
    for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x)
      if (z = trim(j > 0 ? rule[x] + " " + y : replace(y, /&\f/g, rule[x])))
        props[k++] = z;
  return node(value, root, parent, offset2 === 0 ? RULESET : type, props, children, length2);
}
function comment(value, root, parent) {
  return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root, parent, length2) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
function serialize(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i = 0; i < length2; i++)
    output += callback(children[i], i, children, callback) || "";
  return output;
}
function stringify(element, index, children, callback) {
  switch (element.type) {
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index, children, callback) {
    var output = "";
    for (var i = 0; i < length2; i++)
      output += collection[i](element, index, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
var weakMemoize = function weakMemoize2(func) {
  var cache = /* @__PURE__ */ new WeakMap();
  return function(arg) {
    if (cache.has(arg)) {
      return cache.get(arg);
    }
    var ret = func(arg);
    cache.set(arg, ret);
    return ret;
  };
};
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index] = 1;
        }
        parsed[index] += identifierWithPointTracking(position - 1, points, index);
        break;
      case 2:
        parsed[index] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index] = peek() === 58 ? "&\f" : "";
          points[index] = parsed[index].length;
          break;
        }
      default:
        parsed[index] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value, parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent) return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i = 0, k = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k++) {
      element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
function prefix(value, length2) {
  switch (hash$2(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6) switch (charat(value, length2 + 1)) {
        case 109:
          if (charat(value, length2 + 4) !== 45) break;
        case 102:
          return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
        case 115:
          return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
      }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115) break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index, children, callback) {
  if (element.length > -1) {
    if (!element["return"]) switch (element.type) {
      case DECLARATION:
        element["return"] = prefix(element.value, element.length);
        break;
      case KEYFRAMES:
        return serialize([copy(element, {
          value: replace(element.value, "@", "@" + WEBKIT)
        })], callback);
      case RULESET:
        if (element.length) return combine(element.props, function(value) {
          switch (match$1(value, /(::plac\w+|:read-\w+)/)) {
            case ":read-only":
            case ":read-write":
              return serialize([copy(element, {
                props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
              })], callback);
            case "::placeholder":
              return serialize([copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
              })], callback);
          }
          return "";
        });
    }
  }
};
var isBrowser$5 = typeof document !== "undefined";
var getServerStylisCache = isBrowser$5 ? void 0 : weakMemoize(function() {
  return memoize(function() {
    var cache = {};
    return function(name) {
      return cache[name];
    };
  });
});
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key = options.key;
  if (isBrowser$5 && key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  if (isBrowser$5) {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i = 1; i < attrib.length; i++) {
          inserted[attrib[i]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  if (isBrowser$5) {
    var currentSheet;
    var finalizingPlugins = [stringify, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles) {
      return serialize(compile(styles), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  } else {
    var _finalizingPlugins = [stringify];
    var _serializer = middleware(omnipresentPlugins.concat(stylisPlugins, _finalizingPlugins));
    var _stylis = function _stylis2(styles) {
      return serialize(compile(styles), _serializer);
    };
    var serverStylisCache = getServerStylisCache(stylisPlugins)(key);
    var getRules3 = function getRules4(selector, serialized) {
      var name = serialized.name;
      if (serverStylisCache[name] === void 0) {
        serverStylisCache[name] = _stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      }
      return serverStylisCache[name];
    };
    _insert = function _insert2(selector, serialized, sheet, shouldCache) {
      var name = serialized.name;
      var rules = getRules3(selector, serialized);
      if (cache.compat === void 0) {
        if (shouldCache) {
          cache.inserted[name] = true;
        }
        return rules;
      } else {
        if (shouldCache) {
          cache.inserted[name] = rules;
        } else {
          return rules;
        }
      }
    };
  }
  var cache = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};
var isBrowser$3 = typeof document !== "undefined";
var syncFallback = function syncFallback2(create) {
  return create();
};
var useInsertionEffect = reactExports.useInsertionEffect ? reactExports.useInsertionEffect : false;
var useInsertionEffectAlwaysWithSyncFallback = !isBrowser$3 ? syncFallback : useInsertionEffect || syncFallback;
var isBrowser$2 = typeof document !== "undefined";
var EmotionCacheContext = /* @__PURE__ */ reactExports.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
    var cache = reactExports.useContext(EmotionCacheContext);
    return func(props, cache, ref);
  });
};
if (!isBrowser$2) {
  withEmotionCache = function withEmotionCache3(func) {
    return function(props) {
      var cache = reactExports.useContext(EmotionCacheContext);
      if (cache === null) {
        cache = createCache({
          key: "css"
        });
        return /* @__PURE__ */ reactExports.createElement(EmotionCacheContext.Provider, {
          value: cache
        }, func(props, cache));
      } else {
        return func(props, cache);
      }
    };
  };
}
var ThemeContext = /* @__PURE__ */ reactExports.createContext({});
var isBrowser$1 = typeof document !== "undefined";
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = "";
  classNames.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles2 = function registerStyles3(cache, serialized, isStringTag) {
  var className = cache.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser$1 === false && cache.compat !== void 0) && cache.registered[className] === void 0
  ) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles2 = function insertStyles3(cache, serialized, isStringTag) {
  registerStyles2(cache, serialized, isStringTag);
  var className = cache.key + "-" + serialized.name;
  if (cache.inserted[serialized.name] === void 0) {
    var stylesForSSR = "";
    var current = serialized;
    do {
      var maybeStyles = cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
      if (!isBrowser$1 && maybeStyles !== void 0) {
        stylesForSSR += maybeStyles;
      }
      current = current.next;
    } while (current !== void 0);
    if (!isBrowser$1 && stylesForSSR.length !== 0) {
      return stylesForSSR;
    }
  }
};
function murmur2(str) {
  var h = 0;
  var k, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
    k ^= /* k >>> r: */
    k >>> 24;
    h = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h ^= str.charCodeAt(i) & 255;
      h = /* Math.imul(h, m): */
      (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  h ^= h >>> 13;
  h = /* Math.imul(h, m): */
  (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}
var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty2 = function isCustomProperty3(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue2 = function isProcessableValue3(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize(function(styleName) {
  return isCustomProperty2(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue2 = function processStyleValue3(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty2(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  if (interpolation.__emotion_styles !== void 0) {
    return interpolation;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      if (interpolation.anim === 1) {
        cursor = {
          name: interpolation.name,
          styles: interpolation.styles,
          next: cursor
        };
        return interpolation.name;
      }
      if (interpolation.styles !== void 0) {
        var next2 = interpolation.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles = interpolation.styles + ";";
        return styles;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  if (registered == null) {
    return interpolation;
  }
  var cached = registered[interpolation];
  return cached !== void 0 ? cached : interpolation;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];
      if (typeof value !== "object") {
        if (registered != null && registered[value] !== void 0) {
          string += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue2(value)) {
          string += processStyleName(_key) + ":" + processStyleValue2(_key, value) + ";";
        }
      } else {
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue2(value[_i])) {
              string += processStyleName(_key) + ":" + processStyleValue2(_key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (_key) {
            case "animation":
            case "animationName": {
              string += processStyleName(_key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string += _key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var cursor;
var serializeStyles2 = function serializeStyles3(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings);
  } else {
    styles += strings[0];
  }
  for (var i = 1; i < args.length; i++) {
    styles += handleInterpolation(mergedProps, registered, args[i]);
    if (stringMode) {
      styles += strings[i];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles)) !== null) {
    identifierName += "-" + // $FlowFixMe we know it's not null
    match2[1];
  }
  var name = murmur2(styles) + identifierName;
  return {
    name,
    styles,
    next: cursor
  };
};
var testOmitPropsOnStringTag = isPropValid;
var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
  return key !== "theme";
};
var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
  var shouldForwardProp;
  if (options) {
    var optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp !== "function" && isReal) {
    shouldForwardProp = tag.__emotion_forwardProp;
  }
  return shouldForwardProp;
};
var isBrowser = typeof document !== "undefined";
var Insertion2 = function Insertion3(_ref) {
  var cache = _ref.cache, serialized = _ref.serialized, isStringTag = _ref.isStringTag;
  registerStyles2(cache, serialized, isStringTag);
  var rules = useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles2(cache, serialized, isStringTag);
  });
  if (!isBrowser && rules !== void 0) {
    var _ref2;
    var serializedNames = serialized.name;
    var next2 = serialized.next;
    while (next2 !== void 0) {
      serializedNames += " " + next2.name;
      next2 = next2.next;
    }
    return /* @__PURE__ */ reactExports.createElement("style", (_ref2 = {}, _ref2["data-emotion"] = cache.key + " " + serializedNames, _ref2.dangerouslySetInnerHTML = {
      __html: rules
    }, _ref2.nonce = cache.sheet.nonce, _ref2));
  }
  return null;
};
var createStyled = function createStyled2(tag, options) {
  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  var shouldForwardProp = composeShouldForwardProps(tag, options, isReal);
  var defaultShouldForwardProp = shouldForwardProp || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp("as");
  return function() {
    var args = arguments;
    var styles = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
    if (identifierName !== void 0) {
      styles.push("label:" + identifierName + ";");
    }
    if (args[0] == null || args[0].raw === void 0) {
      styles.push.apply(styles, args);
    } else {
      styles.push(args[0][0]);
      var len = args.length;
      var i = 1;
      for (; i < len; i++) {
        styles.push(args[i], args[0][i]);
      }
    }
    var Styled = withEmotionCache(function(props, cache, ref) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = "";
      var classInterpolations = [];
      var mergedProps = props;
      if (props.theme == null) {
        mergedProps = {};
        for (var key in props) {
          mergedProps[key] = props[key];
        }
        mergedProps.theme = reactExports.useContext(ThemeContext);
      }
      if (typeof props.className === "string") {
        className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }
      var serialized = serializeStyles2(styles.concat(classInterpolations), cache.registered, mergedProps);
      className += cache.key + "-" + serialized.name;
      if (targetClassName !== void 0) {
        className += " " + targetClassName;
      }
      var finalShouldForwardProp = shouldUseAs && shouldForwardProp === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};
      for (var _key in props) {
        if (shouldUseAs && _key === "as") continue;
        if (
          // $FlowFixMe
          finalShouldForwardProp(_key)
        ) {
          newProps[_key] = props[_key];
        }
      }
      newProps.className = className;
      newProps.ref = ref;
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion2, {
        cache,
        serialized,
        isStringTag: typeof FinalTag === "string"
      }), /* @__PURE__ */ reactExports.createElement(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles;
    Styled.__emotion_forwardProp = shouldForwardProp;
    Object.defineProperty(Styled, "toString", {
      value: function value() {
        return "." + targetClassName;
      }
    });
    Styled.withComponent = function(nextTag, nextOptions) {
      return createStyled2(nextTag, _extends$1({}, options, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      })).apply(void 0, styles);
    };
    return Styled;
  };
};
var tags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
var newStyled = createStyled.bind();
tags.forEach(function(tagName) {
  newStyled[tagName] = newStyled(tagName);
});
var classnames$1 = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(module) {
  (function() {
    var hasOwn = {}.hasOwnProperty;
    function classNames() {
      var classes = [];
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        if (!arg) continue;
        var argType = typeof arg;
        if (argType === "string" || argType === "number") {
          classes.push(arg);
        } else if (Array.isArray(arg)) {
          if (arg.length) {
            var inner = classNames.apply(null, arg);
            if (inner) {
              classes.push(inner);
            }
          }
        } else if (argType === "object") {
          if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
            classes.push(arg.toString());
            continue;
          }
          for (var key in arg) {
            if (hasOwn.call(arg, key) && arg[key]) {
              classes.push(key);
            }
          }
        }
      }
      return classes.join(" ");
    }
    if (module.exports) {
      classNames.default = classNames;
      module.exports = classNames;
    } else {
      window.classNames = classNames;
    }
  })();
})(classnames$1);
var classnames = classnames$1.exports;
var LegacySidebarContext = React$1.createContext(void 0);
var useLegacySidebar = function() {
  var context = React$1.useContext(LegacySidebarContext);
  return context;
};
var useMediaQuery = function(breakpoint) {
  var _a = React$1.useState(!!breakpoint && typeof window !== "undefined" && window.matchMedia(breakpoint).matches), matches = _a[0], setMatches = _a[1];
  React$1.useEffect(function() {
    if (breakpoint) {
      var media_1 = window.matchMedia(breakpoint);
      var handleMatch_1 = function() {
        if (media_1.matches !== matches) {
          setMatches(media_1.matches);
        }
      };
      handleMatch_1();
      media_1.addEventListener("change", handleMatch_1);
      return function() {
        return media_1.removeEventListener("change", handleMatch_1);
      };
    }
  }, [matches, breakpoint]);
  return matches;
};
var sidebarClasses = {
  root: "ps-sidebar-root",
  container: "ps-sidebar-container",
  image: "ps-sidebar-image",
  backdrop: "ps-sidebar-backdrop",
  collapsed: "ps-collapsed",
  toggled: "ps-toggled",
  rtl: "ps-rtl",
  broken: "ps-broken"
};
var menuClasses = {
  root: "ps-menu-root",
  menuItemRoot: "ps-menuitem-root",
  subMenuRoot: "ps-submenu-root",
  button: "ps-menu-button",
  prefix: "ps-menu-prefix",
  suffix: "ps-menu-suffix",
  label: "ps-menu-label",
  icon: "ps-menu-icon",
  subMenuContent: "ps-submenu-content",
  SubMenuExpandIcon: "ps-submenu-expand-icon",
  disabled: "ps-disabled",
  active: "ps-active",
  open: "ps-open"
};
var StyledBackdrop = newStyled.div(templateObject_1$b || (templateObject_1$b = __makeTemplateObject(["\n  position: fixed;\n  top: 0px;\n  right: 0px;\n  bottom: 0px;\n  left: 0px;\n  z-index: 1;\n  background-color: rgb(0, 0, 0, 0.3);\n"], ["\n  position: fixed;\n  top: 0px;\n  right: 0px;\n  bottom: 0px;\n  left: 0px;\n  z-index: 1;\n  background-color: rgb(0, 0, 0, 0.3);\n"])));
var templateObject_1$b;
var BREAK_POINTS = {
  xs: "480px",
  sm: "576px",
  md: "768px",
  lg: "992px",
  xl: "1200px",
  xxl: "1600px",
  always: "always",
  all: "all"
};
var StyledSidebar = newStyled.aside(templateObject_1$a || (templateObject_1$a = __makeTemplateObject(["\n  position: relative;\n  border-right-width: 1px;\n  border-right-style: solid;\n  border-color: #efefef;\n\n  transition: ", ";\n\n  width: ", ";\n  min-width: ", ";\n\n  &.", " {\n    width: ", ";\n    min-width: ", ";\n  }\n\n  &.", " {\n    direction: rtl;\n    border-right-width: none;\n    border-left-width: 1px;\n    border-right-style: none;\n    border-left-style: solid;\n  }\n\n  &.", " {\n    position: fixed;\n    height: 100%;\n    top: 0px;\n    z-index: 100;\n\n    ", "\n\n    &.", " {\n      ", "\n    }\n\n    &.", " {\n      ", "\n    }\n\n    &.", " {\n      right: -", ";\n\n      &.", " {\n        right: -", ";\n      }\n\n      &.", " {\n        right: 0;\n      }\n    }\n  }\n\n  ", "\n"], ["\n  position: relative;\n  border-right-width: 1px;\n  border-right-style: solid;\n  border-color: #efefef;\n\n  transition: ", ";\n\n  width: ", ";\n  min-width: ", ";\n\n  &.", " {\n    width: ", ";\n    min-width: ", ";\n  }\n\n  &.", " {\n    direction: rtl;\n    border-right-width: none;\n    border-left-width: 1px;\n    border-right-style: none;\n    border-left-style: solid;\n  }\n\n  &.", " {\n    position: fixed;\n    height: 100%;\n    top: 0px;\n    z-index: 100;\n\n    ", "\n\n    &.", " {\n      ", "\n    }\n\n    &.", " {\n      ", "\n    }\n\n    &.", " {\n      right: -", ";\n\n      &.", " {\n        right: -", ";\n      }\n\n      &.", " {\n        right: 0;\n      }\n    }\n  }\n\n  ", "\n"])), function(_a) {
  var transitionDuration = _a.transitionDuration;
  return "width, left, right, ".concat(transitionDuration, "ms");
}, function(_a) {
  var width = _a.width;
  return width;
}, function(_a) {
  var width = _a.width;
  return width;
}, sidebarClasses.collapsed, function(_a) {
  var collapsedWidth = _a.collapsedWidth;
  return collapsedWidth;
}, function(_a) {
  var collapsedWidth = _a.collapsedWidth;
  return collapsedWidth;
}, sidebarClasses.rtl, sidebarClasses.broken, function(_a) {
  var rtl = _a.rtl, width = _a.width;
  return !rtl ? "left: -".concat(width, ";") : "";
}, sidebarClasses.collapsed, function(_a) {
  var rtl = _a.rtl, collapsedWidth = _a.collapsedWidth;
  return !rtl ? "left: -".concat(collapsedWidth, "; ") : "";
}, sidebarClasses.toggled, function(_a) {
  var rtl = _a.rtl;
  return !rtl ? "left: 0;" : "";
}, sidebarClasses.rtl, function(_a) {
  var width = _a.width;
  return width;
}, sidebarClasses.collapsed, function(_a) {
  var collapsedWidth = _a.collapsedWidth;
  return collapsedWidth;
}, sidebarClasses.toggled, function(_a) {
  var rootStyles = _a.rootStyles;
  return rootStyles;
});
var StyledSidebarContainer = newStyled.div(templateObject_2$1 || (templateObject_2$1 = __makeTemplateObject(["\n  position: relative;\n  height: 100%;\n  overflow-y: auto;\n  overflow-x: hidden;\n  z-index: 3;\n\n  ", "\n"], ["\n  position: relative;\n  height: 100%;\n  overflow-y: auto;\n  overflow-x: hidden;\n  z-index: 3;\n\n  ", "\n"])), function(_a) {
  var backgroundColor = _a.backgroundColor;
  return backgroundColor ? "background-color:".concat(backgroundColor, ";") : "";
});
var StyledSidebarImage = newStyled.img(templateObject_3$1 || (templateObject_3$1 = __makeTemplateObject(["\n  &.", " {\n    width: 100%;\n    height: 100%;\n    object-fit: cover;\n    object-position: center;\n    position: absolute;\n    left: 0;\n    top: 0;\n    z-index: 2;\n  }\n"], ["\n  &.", " {\n    width: 100%;\n    height: 100%;\n    object-fit: cover;\n    object-position: center;\n    position: absolute;\n    left: 0;\n    top: 0;\n    z-index: 2;\n  }\n"])), sidebarClasses.image);
var SidebarContext = React$1.createContext({
  collapsed: false,
  toggled: false,
  rtl: false,
  transitionDuration: 300
});
var Sidebar = React$1.forwardRef(function(_a, ref) {
  var _b;
  var collapsed = _a.collapsed, toggled = _a.toggled, onBackdropClick = _a.onBackdropClick, onBreakPoint = _a.onBreakPoint, _c = _a.width, width = _c === void 0 ? "250px" : _c, _d = _a.collapsedWidth, collapsedWidth = _d === void 0 ? "80px" : _d, defaultCollapsed = _a.defaultCollapsed, className = _a.className, children = _a.children, breakPoint = _a.breakPoint, customBreakPoint = _a.customBreakPoint, _e = _a.backgroundColor, backgroundColor = _e === void 0 ? "rgb(249, 249, 249, 0.7)" : _e, _f = _a.transitionDuration, transitionDuration = _f === void 0 ? 300 : _f, image = _a.image, rtl = _a.rtl, rootStyles = _a.rootStyles, rest = __rest(_a, ["collapsed", "toggled", "onBackdropClick", "onBreakPoint", "width", "collapsedWidth", "defaultCollapsed", "className", "children", "breakPoint", "customBreakPoint", "backgroundColor", "transitionDuration", "image", "rtl", "rootStyles"]);
  var getBreakpointValue = function() {
    if (customBreakPoint) {
      return "(max-width: ".concat(customBreakPoint, ")");
    }
    if (breakPoint) {
      if (["xs", "sm", "md", "lg", "xl", "xxl"].includes(breakPoint)) {
        return "(max-width: ".concat(BREAK_POINTS[breakPoint], ")");
      }
      if (breakPoint === "always" || breakPoint === "all") {
        if (breakPoint === "always") {
          console.warn('The "always" breakPoint is deprecated and will be removed in future release. Please use the "all" breakPoint instead.');
        }
        return "screen";
      }
      return "(max-width: ".concat(breakPoint, ")");
    }
  };
  var breakpointCallbackFnRef = React$1.useRef();
  breakpointCallbackFnRef.current = function(broken2) {
    onBreakPoint === null || onBreakPoint === void 0 ? void 0 : onBreakPoint(broken2);
  };
  var broken = useMediaQuery(getBreakpointValue());
  var _g = React$1.useState(false), mounted = _g[0], setMounted = _g[1];
  var legacySidebarContext = useLegacySidebar();
  var collapsedValue = collapsed !== null && collapsed !== void 0 ? collapsed : !mounted && defaultCollapsed ? true : legacySidebarContext === null || legacySidebarContext === void 0 ? void 0 : legacySidebarContext.collapsed;
  var toggledValue = toggled !== null && toggled !== void 0 ? toggled : legacySidebarContext === null || legacySidebarContext === void 0 ? void 0 : legacySidebarContext.toggled;
  var handleBackdropClick = function() {
    onBackdropClick === null || onBackdropClick === void 0 ? void 0 : onBackdropClick();
    legacySidebarContext === null || legacySidebarContext === void 0 ? void 0 : legacySidebarContext.updateSidebarState({ toggled: false });
  };
  React$1.useEffect(function() {
    var _a2;
    (_a2 = breakpointCallbackFnRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(breakpointCallbackFnRef, broken);
  }, [broken]);
  React$1.useEffect(function() {
    legacySidebarContext === null || legacySidebarContext === void 0 ? void 0 : legacySidebarContext.updateSidebarState({ broken, rtl, transitionDuration });
  }, [broken, legacySidebarContext === null || legacySidebarContext === void 0 ? void 0 : legacySidebarContext.updateSidebarState, rtl, transitionDuration]);
  React$1.useEffect(function() {
    if (!mounted) {
      legacySidebarContext === null || legacySidebarContext === void 0 ? void 0 : legacySidebarContext.updateSidebarState({
        collapsed: defaultCollapsed
      });
      setMounted(true);
    }
  }, [defaultCollapsed, mounted, legacySidebarContext === null || legacySidebarContext === void 0 ? void 0 : legacySidebarContext.updateSidebarState]);
  return React$1.createElement(
    SidebarContext.Provider,
    { value: { collapsed: collapsedValue, toggled: toggledValue, rtl, transitionDuration } },
    React$1.createElement(
      StyledSidebar,
      __assign({ ref, "data-testid": "".concat(sidebarClasses.root, "-test-id"), rtl, rootStyles, width, collapsedWidth, transitionDuration, className: classnames(sidebarClasses.root, (_b = {}, _b[sidebarClasses.collapsed] = collapsedValue, _b[sidebarClasses.toggled] = toggledValue, _b[sidebarClasses.broken] = broken, _b[sidebarClasses.rtl] = rtl, _b), className) }, rest),
      React$1.createElement(StyledSidebarContainer, { "data-testid": "".concat(sidebarClasses.container, "-test-id"), className: sidebarClasses.container, backgroundColor }, children),
      image && React$1.createElement(StyledSidebarImage, { "data-testid": "".concat(sidebarClasses.image, "-test-id"), src: image, alt: "sidebar background", className: sidebarClasses.image }),
      broken && toggledValue && React$1.createElement(StyledBackdrop, { "data-testid": "".concat(sidebarClasses.backdrop, "-test-id"), role: "button", tabIndex: 0, "aria-label": "backdrop", onClick: handleBackdropClick, onKeyPress: handleBackdropClick, className: sidebarClasses.backdrop })
    )
  );
});
var templateObject_1$a, templateObject_2$1, templateObject_3$1;
var StyledUl = newStyled.ul(templateObject_1$9 || (templateObject_1$9 = __makeTemplateObject(["\n  list-style-type: none;\n  padding: 0;\n  margin: 0;\n"], ["\n  list-style-type: none;\n  padding: 0;\n  margin: 0;\n"])));
var templateObject_1$9;
var StyledMenu = newStyled.nav(templateObject_1$8 || (templateObject_1$8 = __makeTemplateObject(["\n  &.", " {\n    ", "\n  }\n"], ["\n  &.", " {\n    ", "\n  }\n"])), menuClasses.root, function(_a) {
  var rootStyles = _a.rootStyles;
  return rootStyles;
});
var MenuContext = React$1.createContext(void 0);
var LevelContext = React$1.createContext(0);
var MenuFR = function(_a, ref) {
  var children = _a.children, className = _a.className, _b = _a.transitionDuration, transitionDuration = _b === void 0 ? 300 : _b, _c = _a.closeOnClick, closeOnClick = _c === void 0 ? false : _c, rootStyles = _a.rootStyles, menuItemStyles = _a.menuItemStyles, renderExpandIcon = _a.renderExpandIcon, rest = __rest(_a, ["children", "className", "transitionDuration", "closeOnClick", "rootStyles", "menuItemStyles", "renderExpandIcon"]);
  var providerValue = React$1.useMemo(function() {
    return { transitionDuration, closeOnClick, menuItemStyles, renderExpandIcon };
  }, [transitionDuration, closeOnClick, menuItemStyles, renderExpandIcon]);
  return React$1.createElement(
    MenuContext.Provider,
    { value: providerValue },
    React$1.createElement(
      LevelContext.Provider,
      { value: 0 },
      React$1.createElement(
        StyledMenu,
        __assign({ ref, className: classnames(menuClasses.root, className), rootStyles }, rest),
        React$1.createElement(StyledUl, null, children)
      )
    )
  );
};
var Menu = React$1.forwardRef(MenuFR);
var templateObject_1$8;
var useMenu = function() {
  var context = React$1.useContext(MenuContext);
  if (context === void 0) {
    throw new Error("Menu Component is required!");
  }
  return context;
};
var StyledSubMenuContent = newStyled.div(templateObject_1$7 || (templateObject_1$7 = __makeTemplateObject(["\n  height: 0px;\n  overflow: hidden;\n  z-index: 999;\n  transition: height ", "ms;\n  box-sizing: border-box;\n  background-color: white;\n\n  ", "\n\n  ", "\n\n  ", ";\n\n  ", ";\n"], ["\n  height: 0px;\n  overflow: hidden;\n  z-index: 999;\n  transition: height ", "ms;\n  box-sizing: border-box;\n  background-color: white;\n\n  ", "\n\n  ", "\n\n  ", ";\n\n  ", ";\n"])), function(_a) {
  var transitionDuration = _a.transitionDuration;
  return transitionDuration;
}, function(_a) {
  var firstLevel = _a.firstLevel, collapsed = _a.collapsed;
  return firstLevel && collapsed && "\n     background-color: white;\n     box-shadow: 0 3px 6px -4px #0000001f, 0 6px 16px #00000014, 0 9px 28px 8px #0000000d;\n     ";
}, function(_a) {
  var defaultOpen = _a.defaultOpen;
  return defaultOpen && "height: auto;display: block;";
}, function(_a) {
  var collapsed = _a.collapsed, firstLevel = _a.firstLevel, openWhenCollapsed = _a.openWhenCollapsed;
  return collapsed && firstLevel ? "\n      position: fixed;\n      padding-left: 0px;\n      width: 200px;\n      border-radius: 4px;\n      height: auto!important;\n      display: block!important;     \n      transition: none!important;     \n      visibility: ".concat(openWhenCollapsed ? "visible" : "hidden", ";\n     ") : "\n      position: static!important;\n      transform: none!important;\n      ";
}, function(_a) {
  var rootStyles = _a.rootStyles;
  return rootStyles;
});
var SubMenuContentFR = function(_a, ref) {
  var children = _a.children, open = _a.open, openWhenCollapsed = _a.openWhenCollapsed, firstLevel = _a.firstLevel, collapsed = _a.collapsed, defaultOpen = _a.defaultOpen, rest = __rest(_a, ["children", "open", "openWhenCollapsed", "firstLevel", "collapsed", "defaultOpen"]);
  var transitionDuration = useMenu().transitionDuration;
  var defaultOpenState = React$1.useState(defaultOpen)[0];
  return React$1.createElement(
    StyledSubMenuContent,
    __assign({ "data-testid": "".concat(menuClasses.subMenuContent, "-test-id"), ref, firstLevel, collapsed, open, openWhenCollapsed, transitionDuration, defaultOpen: defaultOpenState }, rest),
    React$1.createElement(StyledUl, null, children)
  );
};
var SubMenuContent = React$1.forwardRef(SubMenuContentFR);
var templateObject_1$7;
var StyledMenuLabel = newStyled.span(templateObject_1$6 || (templateObject_1$6 = __makeTemplateObject(["\n  flex-grow: 1;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n\n  ", ";\n"], ["\n  flex-grow: 1;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n\n  ", ";\n"])), function(_a) {
  var rootStyles = _a.rootStyles;
  return rootStyles;
});
var templateObject_1$6;
var StyledMenuIcon = newStyled.span(templateObject_1$5 || (templateObject_1$5 = __makeTemplateObject(["\n  width: 35px;\n  min-width: 35px;\n  height: 35px;\n  line-height: 35px;\n  text-align: center;\n  display: inline-block;\n  border-radius: 2px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n\n  ", "\n\n  ", ";\n"], ["\n  width: 35px;\n  min-width: 35px;\n  height: 35px;\n  line-height: 35px;\n  text-align: center;\n  display: inline-block;\n  border-radius: 2px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n\n  ", "\n\n  ", ";\n"])), function(_a) {
  var rtl = _a.rtl;
  return rtl ? "margin-left: 10px;" : "margin-right: 10px;";
}, function(_a) {
  var rootStyles = _a.rootStyles;
  return rootStyles;
});
var templateObject_1$5;
var StyledMenuPrefix = newStyled.span(templateObject_1$4 || (templateObject_1$4 = __makeTemplateObject(["\n  ", "\n  opacity: ", ";\n  transition: opacity ", "ms;\n\n  ", ";\n"], ["\n  ", "\n  opacity: ", ";\n  transition: opacity ", "ms;\n\n  ", ";\n"])), function(_a) {
  var rtl = _a.rtl;
  return rtl ? "margin-left: 5px;" : "margin-right: 5px;";
}, function(_a) {
  var firstLevel = _a.firstLevel, collapsed = _a.collapsed;
  return firstLevel && collapsed ? "0" : "1";
}, function(_a) {
  var transitionDuration = _a.transitionDuration;
  return transitionDuration;
}, function(_a) {
  var rootStyles = _a.rootStyles;
  return rootStyles;
});
var templateObject_1$4;
var StyledMenuSuffix = newStyled.span(templateObject_1$3 || (templateObject_1$3 = __makeTemplateObject(["\n  margin-right: 5px;\n  margin-left: 5px;\n  opacity: ", ";\n  transition: opacity ", "ms;\n\n  ", ";\n"], ["\n  margin-right: 5px;\n  margin-left: 5px;\n  opacity: ", ";\n  transition: opacity ", "ms;\n\n  ", ";\n"])), function(_a) {
  var firstLevel = _a.firstLevel, collapsed = _a.collapsed;
  return firstLevel && collapsed ? "0" : "1";
}, function(_a) {
  var transitionDuration = _a.transitionDuration;
  return transitionDuration;
}, function(_a) {
  var rootStyles = _a.rootStyles;
  return rootStyles;
});
var templateObject_1$3;
var StyledExpandIconWrapper = newStyled.span(templateObject_1$2 || (templateObject_1$2 = __makeTemplateObject(["\n  ", "\n\n  ", ";\n"], ["\n  ", "\n\n  ", ";\n"])), function(_a) {
  var collapsed = _a.collapsed, level = _a.level, rtl = _a.rtl;
  return collapsed && level === 0 && "\n    position: absolute;\n    ".concat(rtl ? "left: 10px;" : "right: 10px;", "\n    top: 50%;\n    transform: translateY(-50%);\n    \n    ");
}, function(_a) {
  var rootStyles = _a.rootStyles;
  return rootStyles;
});
var StyledExpandIcon = newStyled.span(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n  display: inline-block;\n  transition: transform 0.3s;\n  ", "\n\n  width: 5px;\n  height: 5px;\n  transform: rotate(", ");\n"], ["\n  display: inline-block;\n  transition: transform 0.3s;\n  ", "\n\n  width: 5px;\n  height: 5px;\n  transform: rotate(", ");\n"])), function(_a) {
  var rtl = _a.rtl;
  return rtl ? "\n          border-left: 2px solid currentcolor;\n          border-top: 2px solid currentcolor;\n        " : " border-right: 2px solid currentcolor;\n          border-bottom: 2px solid currentcolor;\n        ";
}, function(_a) {
  var open = _a.open, rtl = _a.rtl;
  return open ? rtl ? "-135deg" : "45deg" : "-45deg";
});
var StyledExpandIconCollapsed = newStyled.span(templateObject_3 || (templateObject_3 = __makeTemplateObject(["\n  width: 5px;\n  height: 5px;\n  background-color: currentcolor;\n  border-radius: 50%;\n  display: inline-block;\n"], ["\n  width: 5px;\n  height: 5px;\n  background-color: currentcolor;\n  border-radius: 50%;\n  display: inline-block;\n"])));
var templateObject_1$2, templateObject_2, templateObject_3;
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node2) {
  if (node2 == null) {
    return window;
  }
  if (node2.toString() !== "[object Window]") {
    var ownerDocument = node2.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node2;
}
function isElement(node2) {
  var OwnElement = getWindow(node2).Element;
  return node2 instanceof OwnElement || node2 instanceof Element;
}
function isHTMLElement(node2) {
  var OwnElement = getWindow(node2).HTMLElement;
  return node2 instanceof OwnElement || node2 instanceof HTMLElement;
}
function isShadowRoot(node2) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node2).ShadowRoot;
  return node2 instanceof OwnElement || node2 instanceof ShadowRoot;
}
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
var max = Math.max;
var min = Math.min;
var round = Math.round;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next2 = child;
    do {
      if (next2 && parent.isSameNode(next2)) {
        return true;
      }
      next2 = next2.parentNode || next2.host;
    } while (next2);
  }
  return false;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle$1(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle$1(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x = _ref.x, y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position2 = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle$1(offsetParent).position !== "static" && position2 === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position: position2
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node2) {
  var win = getWindow(node2);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node2) {
  if (["html", "body", "#document"].indexOf(getNodeName(node2)) >= 0) {
    return node2.ownerDocument.body;
  }
  if (isHTMLElement(node2) && isScrollParent(node2)) {
    return node2;
  }
  return getScrollParent(getParentNode(node2));
}
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break") break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    placement: state.placement
  });
}
var popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min$1 = offset2 + overflow[mainSide];
    var max$1 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset2, tether ? max(max$1, tetherMax) : max$1);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node2) {
  if (node2 === getWindow(node2) || !isHTMLElement(node2)) {
    return getWindowScroll(node2);
  } else {
    return getHTMLElementScroll(node2);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect2 = _ref3.effect;
        if (typeof effect2 === "function") {
          var cleanupFn = effect2({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
var usePopper = function(options) {
  var level = options.level, buttonRef = options.buttonRef, contentRef = options.contentRef;
  var _a = React$1.useContext(SidebarContext), collapsed = _a.collapsed, toggled = _a.toggled, transitionDuration = _a.transitionDuration;
  var popperInstanceRef = React$1.useRef();
  React$1.useEffect(function() {
    if (level === 0 && collapsed && contentRef.current && buttonRef.current) {
      popperInstanceRef.current = createPopper(buttonRef.current, contentRef.current, {
        placement: "right",
        strategy: "fixed",
        modifiers: [
          {
            name: "offset",
            options: {
              offset: [0, 5]
            }
          }
        ]
      });
    }
    return function() {
      var _a2;
      return (_a2 = popperInstanceRef.current) === null || _a2 === void 0 ? void 0 : _a2.destroy();
    };
  }, [level, collapsed, contentRef, buttonRef]);
  React$1.useEffect(function() {
    if (contentRef.current && buttonRef.current) {
      var ro = new ResizeObserver(function() {
        var _a2;
        (_a2 = popperInstanceRef.current) === null || _a2 === void 0 ? void 0 : _a2.update();
      });
      ro.observe(contentRef.current);
      ro.observe(buttonRef.current);
    }
    setTimeout(function() {
      var _a2;
      (_a2 = popperInstanceRef.current) === null || _a2 === void 0 ? void 0 : _a2.update();
    }, transitionDuration);
  }, [transitionDuration, toggled, contentRef, buttonRef]);
  return { popperInstance: popperInstanceRef.current };
};
var menuButtonStyles = function(props) {
  var rtl = props.rtl, level = props.level, collapsed = props.collapsed, disabled = props.disabled, active = props.active;
  return "\n    display: flex;\n    align-items: center;\n    height: 50px;\n    text-decoration: none;\n    color: inherit;\n    box-sizing: border-box;\n    cursor: pointer;\n\n    ".concat(rtl ? "padding-left: 20px;\n           padding-right: ".concat(level === 0 ? 20 : (collapsed ? level : level + 1) * 20, "px;\n            ") : "padding-right: 20px;\n           padding-left: ".concat(level === 0 ? 20 : (collapsed ? level : level + 1) * 20, "px;\n           "), "\n\n    &:hover {\n      background-color: #f3f3f3;\n    }\n\n    ").concat(disabled && " \n      pointer-events: none;\n      cursor: default;\n      color:#adadad;\n        ", "\n\n    ").concat(active && "background-color: #e2eef9;", "\n  \n  ");
};
var MenuButtonRef = function(_a, ref) {
  var className = _a.className, component = _a.component, children = _a.children, rest = __rest(_a, ["className", "component", "children"]);
  if (component) {
    if (typeof component === "string") {
      return React$1.createElement(component, __assign(__assign({ className: classnames(className) }, rest), { ref }), children);
    } else {
      var _b = component.props, classNameProp = _b.className, props = __rest(_b, ["className"]);
      return React$1.cloneElement(component, __assign(__assign(__assign({ className: classnames(className, classNameProp) }, rest), props), { ref }), children);
    }
  } else {
    return React$1.createElement("a", __assign({ ref, className: classnames(className) }, rest), children);
  }
};
var MenuButton = React$1.forwardRef(MenuButtonRef);
var StyledSubMenu = newStyled.li(templateObject_1$1 || (templateObject_1$1 = __makeTemplateObject(["\n  position: relative;\n  width: 100%;\n\n  ", ";\n\n  ", ";\n\n  > .", " {\n    ", ";\n\n    ", ";\n  }\n"], ["\n  position: relative;\n  width: 100%;\n\n  ", ";\n\n  ", ";\n\n  > .", " {\n    ", ";\n\n    ", ";\n  }\n"])), function(_a) {
  var menuItemStyles = _a.menuItemStyles;
  return menuItemStyles;
}, function(_a) {
  var rootStyles = _a.rootStyles;
  return rootStyles;
}, menuClasses.button, function(_a) {
  var level = _a.level, disabled = _a.disabled, active = _a.active, collapsed = _a.collapsed, rtl = _a.rtl;
  return menuButtonStyles({
    level,
    disabled,
    active,
    collapsed,
    rtl
  });
}, function(_a) {
  var buttonStyles = _a.buttonStyles;
  return buttonStyles;
});
var SubMenuFR = function(_a, ref) {
  var _b;
  var children = _a.children, className = _a.className, label = _a.label, icon = _a.icon, title = _a.title, prefix2 = _a.prefix, suffix = _a.suffix, openControlled = _a.open, defaultOpen = _a.defaultOpen, _c = _a.active, active = _c === void 0 ? false : _c, _d = _a.disabled, disabled = _d === void 0 ? false : _d, rootStyles = _a.rootStyles, component = _a.component, onOpenChange = _a.onOpenChange, onClick = _a.onClick, onKeyUp = _a.onKeyUp, rest = __rest(_a, ["children", "className", "label", "icon", "title", "prefix", "suffix", "open", "defaultOpen", "active", "disabled", "rootStyles", "component", "onOpenChange", "onClick", "onKeyUp"]);
  var level = React$1.useContext(LevelContext);
  var _e = React$1.useContext(SidebarContext), collapsed = _e.collapsed, rtl = _e.rtl, sidebarTransitionDuration = _e.transitionDuration;
  var _f = useMenu(), renderExpandIcon = _f.renderExpandIcon, closeOnClick = _f.closeOnClick, menuItemStyles = _f.menuItemStyles, transitionDuration = _f.transitionDuration;
  var _g = React$1.useState(!!defaultOpen), open = _g[0], setOpen = _g[1];
  var _h = React$1.useState(false), openWhenCollapsed = _h[0], setOpenWhenCollapsed = _h[1];
  var _j = React$1.useState(false), mounted = _j[0], setMounted = _j[1];
  var buttonRef = React$1.useRef(null);
  var contentRef = React$1.useRef(null);
  var timer = React$1.useRef();
  var popperInstance = usePopper({
    level,
    buttonRef,
    contentRef
  }).popperInstance;
  var expandContent = React$1.useCallback(function() {
    var _a2;
    var target = contentRef.current;
    if (target) {
      var height = (_a2 = target === null || target === void 0 ? void 0 : target.querySelector(".".concat(menuClasses.subMenuContent, " > ul"))) === null || _a2 === void 0 ? void 0 : _a2.clientHeight;
      target.style.overflow = "hidden";
      target.style.height = "".concat(height, "px");
      timer.current = setTimeout(function() {
        target.style.overflow = "auto";
        target.style.height = "auto";
      }, transitionDuration);
    }
  }, [transitionDuration]);
  var collapseContent = function() {
    var _a2;
    var target = contentRef.current;
    if (target) {
      var height = (_a2 = target === null || target === void 0 ? void 0 : target.querySelector(".".concat(menuClasses.subMenuContent, " > ul"))) === null || _a2 === void 0 ? void 0 : _a2.clientHeight;
      target.style.overflow = "hidden";
      target.style.height = "".concat(height, "px");
      target.offsetHeight;
      target.style.height = "0px";
    }
  };
  var handleSlideToggle = function() {
    if (!(level === 0 && collapsed)) {
      if (typeof openControlled === "undefined") {
        clearTimeout(Number(timer.current));
        open ? collapseContent() : expandContent();
        onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(!open);
        setOpen(!open);
      } else {
        onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(!openControlled);
      }
    }
  };
  React$1.useEffect(function() {
    if (!(level === 0 && collapsed) && typeof openControlled !== "undefined" && mounted) {
      clearTimeout(Number(timer.current));
      !openControlled ? collapseContent() : expandContent();
    }
  }, [collapsed, expandContent, label, level, onOpenChange, openControlled]);
  var handleOnClick = function(event) {
    onClick === null || onClick === void 0 ? void 0 : onClick(event);
    handleSlideToggle();
  };
  var handleOnKeyUp = function(event) {
    onKeyUp === null || onKeyUp === void 0 ? void 0 : onKeyUp(event);
    if (event.key === "Enter") {
      handleSlideToggle();
    }
  };
  var getSubMenuItemStyles = function(element) {
    if (menuItemStyles) {
      var params = { level, disabled, active, isSubmenu: true, open: openControlled !== null && openControlled !== void 0 ? openControlled : open };
      var rootElStyles = menuItemStyles.root, buttonElStyles = menuItemStyles.button, labelElStyles = menuItemStyles.label, iconElStyles = menuItemStyles.icon, prefixElStyles = menuItemStyles.prefix, suffixElStyles = menuItemStyles.suffix, subMenuContentElStyles = menuItemStyles.subMenuContent, SubMenuExpandIconElStyles = menuItemStyles.SubMenuExpandIcon;
      switch (element) {
        case "root":
          return typeof rootElStyles === "function" ? rootElStyles(params) : rootElStyles;
        case "button":
          return typeof buttonElStyles === "function" ? buttonElStyles(params) : buttonElStyles;
        case "label":
          return typeof labelElStyles === "function" ? labelElStyles(params) : labelElStyles;
        case "icon":
          return typeof iconElStyles === "function" ? iconElStyles(params) : iconElStyles;
        case "prefix":
          return typeof prefixElStyles === "function" ? prefixElStyles(params) : prefixElStyles;
        case "suffix":
          return typeof suffixElStyles === "function" ? suffixElStyles(params) : suffixElStyles;
        case "SubMenuExpandIcon":
          return typeof SubMenuExpandIconElStyles === "function" ? SubMenuExpandIconElStyles(params) : SubMenuExpandIconElStyles;
        case "subMenuContent":
          return typeof subMenuContentElStyles === "function" ? subMenuContentElStyles(params) : subMenuContentElStyles;
        default:
          return void 0;
      }
    }
  };
  React$1.useEffect(function() {
    setTimeout(function() {
      return popperInstance === null || popperInstance === void 0 ? void 0 : popperInstance.update();
    }, sidebarTransitionDuration);
    if (collapsed && level === 0) {
      setOpenWhenCollapsed(false);
    }
  }, [collapsed, level, rtl, sidebarTransitionDuration, popperInstance]);
  React$1.useEffect(function() {
    var handleTogglePopper = function(target) {
      var _a2, _b2, _c2;
      if (!openWhenCollapsed && ((_a2 = buttonRef.current) === null || _a2 === void 0 ? void 0 : _a2.contains(target)))
        setOpenWhenCollapsed(true);
      else if (closeOnClick && !((_b2 = target.closest(".".concat(menuClasses.menuItemRoot))) === null || _b2 === void 0 ? void 0 : _b2.classList.contains(menuClasses.subMenuRoot)) || !((_c2 = contentRef.current) === null || _c2 === void 0 ? void 0 : _c2.contains(target)) && openWhenCollapsed) {
        setOpenWhenCollapsed(false);
      }
    };
    var handleDocumentClick = function(event) {
      handleTogglePopper(event.target);
    };
    var handleDocumentKeyUp = function(event) {
      if (event.key === "Enter") {
        handleTogglePopper(event.target);
      } else if (event.key === "Escape") {
        setOpenWhenCollapsed(false);
      }
    };
    var removeEventListeners = function() {
      document.removeEventListener("click", handleDocumentClick);
      document.removeEventListener("keyup", handleDocumentKeyUp);
    };
    removeEventListeners();
    if (collapsed && level === 0) {
      document.addEventListener("click", handleDocumentClick, false);
      document.addEventListener("keyup", handleDocumentKeyUp, false);
    }
    return function() {
      removeEventListeners();
    };
  }, [collapsed, level, closeOnClick, openWhenCollapsed]);
  React$1.useEffect(function() {
    setMounted(true);
  }, []);
  var sharedClasses = (_b = {}, _b[menuClasses.active] = active, _b[menuClasses.disabled] = disabled, _b[menuClasses.open] = openControlled !== null && openControlled !== void 0 ? openControlled : open, _b);
  return React$1.createElement(
    StyledSubMenu,
    { ref, className: classnames(menuClasses.menuItemRoot, menuClasses.subMenuRoot, sharedClasses, className), menuItemStyles: getSubMenuItemStyles("root"), level, collapsed, rtl, disabled, active, buttonStyles: getSubMenuItemStyles("button"), rootStyles },
    React$1.createElement(
      MenuButton,
      __assign({ "data-testid": "".concat(menuClasses.button, "-test-id"), ref: buttonRef, title, className: classnames(menuClasses.button, sharedClasses), onClick: handleOnClick, onKeyUp: handleOnKeyUp, component, tabIndex: 0 }, rest),
      icon && React$1.createElement(StyledMenuIcon, { rtl, className: classnames(menuClasses.icon, sharedClasses), rootStyles: getSubMenuItemStyles("icon") }, icon),
      prefix2 && React$1.createElement(StyledMenuPrefix, { collapsed, transitionDuration: sidebarTransitionDuration, firstLevel: level === 0, className: classnames(menuClasses.prefix, sharedClasses), rtl, rootStyles: getSubMenuItemStyles("prefix") }, prefix2),
      React$1.createElement(StyledMenuLabel, { className: classnames(menuClasses.label, sharedClasses), rootStyles: getSubMenuItemStyles("label") }, label),
      suffix && React$1.createElement(StyledMenuSuffix, { collapsed, transitionDuration: sidebarTransitionDuration, firstLevel: level === 0, className: classnames(menuClasses.suffix, sharedClasses), rootStyles: getSubMenuItemStyles("suffix") }, suffix),
      React$1.createElement(StyledExpandIconWrapper, { rtl, className: classnames(menuClasses.SubMenuExpandIcon, sharedClasses), collapsed, level, rootStyles: getSubMenuItemStyles("SubMenuExpandIcon") }, renderExpandIcon ? renderExpandIcon({
        level,
        disabled,
        active,
        open: openControlled !== null && openControlled !== void 0 ? openControlled : open
      }) : collapsed && level === 0 ? React$1.createElement(StyledExpandIconCollapsed, null) : React$1.createElement(StyledExpandIcon, { rtl, open: openControlled !== null && openControlled !== void 0 ? openControlled : open }))
    ),
    React$1.createElement(
      SubMenuContent,
      { ref: contentRef, openWhenCollapsed, open: openControlled !== null && openControlled !== void 0 ? openControlled : open, firstLevel: level === 0, collapsed, defaultOpen: openControlled && !mounted || defaultOpen, className: classnames(menuClasses.subMenuContent, sharedClasses), rootStyles: getSubMenuItemStyles("subMenuContent") },
      React$1.createElement(LevelContext.Provider, { value: level + 1 }, children)
    )
  );
};
React$1.forwardRef(SubMenuFR);
var templateObject_1$1;
var StyledMenuItem = newStyled.li(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  width: 100%;\n  position: relative;\n\n  ", ";\n\n  ", ";\n\n  > .", " {\n    ", ";\n\n    ", ";\n  }\n"], ["\n  width: 100%;\n  position: relative;\n\n  ", ";\n\n  ", ";\n\n  > .", " {\n    ", ";\n\n    ", ";\n  }\n"])), function(_a) {
  var menuItemStyles = _a.menuItemStyles;
  return menuItemStyles;
}, function(_a) {
  var rootStyles = _a.rootStyles;
  return rootStyles;
}, menuClasses.button, function(_a) {
  var level = _a.level, disabled = _a.disabled, active = _a.active, collapsed = _a.collapsed, rtl = _a.rtl;
  return menuButtonStyles({
    level,
    disabled,
    active,
    collapsed,
    rtl
  });
}, function(_a) {
  var buttonStyles = _a.buttonStyles;
  return buttonStyles;
});
var MenuItemFR = function(_a, ref) {
  var _b;
  var children = _a.children, icon = _a.icon, className = _a.className, prefix2 = _a.prefix, suffix = _a.suffix, _c = _a.active, active = _c === void 0 ? false : _c, _d = _a.disabled, disabled = _d === void 0 ? false : _d, component = _a.component, rootStyles = _a.rootStyles, rest = __rest(_a, ["children", "icon", "className", "prefix", "suffix", "active", "disabled", "component", "rootStyles"]);
  var level = React$1.useContext(LevelContext);
  var _e = React$1.useContext(SidebarContext), collapsed = _e.collapsed, rtl = _e.rtl, transitionDuration = _e.transitionDuration;
  var menuItemStyles = useMenu().menuItemStyles;
  var getMenuItemStyles = function(element) {
    if (menuItemStyles) {
      var params = { level, disabled, active, isSubmenu: false };
      var rootElStyles = menuItemStyles.root, buttonElStyles = menuItemStyles.button, labelElStyles = menuItemStyles.label, iconElStyles = menuItemStyles.icon, prefixElStyles = menuItemStyles.prefix, suffixElStyles = menuItemStyles.suffix;
      switch (element) {
        case "root":
          return typeof rootElStyles === "function" ? rootElStyles(params) : rootElStyles;
        case "button":
          return typeof buttonElStyles === "function" ? buttonElStyles(params) : buttonElStyles;
        case "label":
          return typeof labelElStyles === "function" ? labelElStyles(params) : labelElStyles;
        case "icon":
          return typeof iconElStyles === "function" ? iconElStyles(params) : iconElStyles;
        case "prefix":
          return typeof prefixElStyles === "function" ? prefixElStyles(params) : prefixElStyles;
        case "suffix":
          return typeof suffixElStyles === "function" ? suffixElStyles(params) : suffixElStyles;
        default:
          return void 0;
      }
    }
  };
  var sharedClasses = (_b = {}, _b[menuClasses.active] = active, _b[menuClasses.disabled] = disabled, _b);
  return React$1.createElement(
    StyledMenuItem,
    { ref, className: classnames(menuClasses.menuItemRoot, sharedClasses, className), menuItemStyles: getMenuItemStyles("root"), level, collapsed, rtl, disabled, active, buttonStyles: getMenuItemStyles("button"), rootStyles },
    React$1.createElement(
      MenuButton,
      __assign({ className: classnames(menuClasses.button, sharedClasses), "data-testid": "".concat(menuClasses.button, "-test-id"), component, tabIndex: 0 }, rest),
      icon && React$1.createElement(StyledMenuIcon, { rtl, className: classnames(menuClasses.icon, sharedClasses), rootStyles: getMenuItemStyles("icon") }, icon),
      prefix2 && React$1.createElement(StyledMenuPrefix, { collapsed, transitionDuration, firstLevel: level === 0, className: classnames(menuClasses.prefix, sharedClasses), rtl, rootStyles: getMenuItemStyles("prefix") }, prefix2),
      React$1.createElement(StyledMenuLabel, { className: classnames(menuClasses.label, sharedClasses), rootStyles: getMenuItemStyles("label") }, children),
      suffix && React$1.createElement(StyledMenuSuffix, { collapsed, transitionDuration, firstLevel: level === 0, className: classnames(menuClasses.suffix, sharedClasses), rootStyles: getMenuItemStyles("suffix") }, suffix)
    )
  );
};
var MenuItem = React$1.forwardRef(MenuItemFR);
var templateObject_1;

var DefaultContext = {
  color: undefined,
  size: undefined,
  className: undefined,
  style: undefined,
  attr: undefined
};
var IconContext = React$1.createContext && /*#__PURE__*/React$1.createContext(DefaultContext);

var _excluded = ["attr", "size", "title"];
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } } return target; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), true).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function Tree2Element(tree) {
  return tree && tree.map((node, i) => /*#__PURE__*/React$1.createElement(node.tag, _objectSpread({
    key: i
  }, node.attr), Tree2Element(node.child)));
}
function GenIcon(data) {
  return props => /*#__PURE__*/React$1.createElement(IconBase, _extends({
    attr: _objectSpread({}, data.attr)
  }, props), Tree2Element(data.child));
}
function IconBase(props) {
  var elem = conf => {
    var {
        attr,
        size,
        title
      } = props,
      svgProps = _objectWithoutProperties(props, _excluded);
    var computedSize = size || conf.size || "1em";
    var className;
    if (conf.className) className = conf.className;
    if (props.className) className = (className ? className + " " : "") + props.className;
    return /*#__PURE__*/React$1.createElement("svg", _extends({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, conf.attr, attr, svgProps, {
      className: className,
      style: _objectSpread(_objectSpread({
        color: props.color || conf.color
      }, conf.style), props.style),
      height: computedSize,
      width: computedSize,
      xmlns: "http://www.w3.org/2000/svg"
    }), title && /*#__PURE__*/React$1.createElement("title", null, title), props.children);
  };
  return IconContext !== undefined ? /*#__PURE__*/React$1.createElement(IconContext.Consumer, null, conf => elem(conf)) : elem(DefaultContext);
}

// THIS FILE IS AUTO GENERATED
function FaFacebook (props) {
  return GenIcon({"attr":{"viewBox":"0 0 512 512"},"child":[{"tag":"path","attr":{"d":"M504 256C504 119 393 8 256 8S8 119 8 256c0 123.78 90.69 226.38 209.25 245V327.69h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14 0 55.52 4.84 55.52 4.84v61h-31.28c-30.8 0-40.41 19.12-40.41 38.73V256h68.78l-11 71.69h-57.78V501C413.31 482.38 504 379.78 504 256z"},"child":[]}]})(props);
}function FaTiktok (props) {
  return GenIcon({"attr":{"viewBox":"0 0 448 512"},"child":[{"tag":"path","attr":{"d":"M448,209.91a210.06,210.06,0,0,1-122.77-39.25V349.38A162.55,162.55,0,1,1,185,188.31V278.2a74.62,74.62,0,1,0,52.23,71.18V0l88,0a121.18,121.18,0,0,0,1.86,22.17h0A122.18,122.18,0,0,0,381,102.39a121.43,121.43,0,0,0,67,20.14Z"},"child":[]}]})(props);
}function FaListAlt (props) {
  return GenIcon({"attr":{"viewBox":"0 0 512 512"},"child":[{"tag":"path","attr":{"d":"M464 480H48c-26.51 0-48-21.49-48-48V80c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v352c0 26.51-21.49 48-48 48zM128 120c-22.091 0-40 17.909-40 40s17.909 40 40 40 40-17.909 40-40-17.909-40-40-40zm0 96c-22.091 0-40 17.909-40 40s17.909 40 40 40 40-17.909 40-40-17.909-40-40-40zm0 96c-22.091 0-40 17.909-40 40s17.909 40 40 40 40-17.909 40-40-17.909-40-40-40zm288-136v-32c0-6.627-5.373-12-12-12H204c-6.627 0-12 5.373-12 12v32c0 6.627 5.373 12 12 12h200c6.627 0 12-5.373 12-12zm0 96v-32c0-6.627-5.373-12-12-12H204c-6.627 0-12 5.373-12 12v32c0 6.627 5.373 12 12 12h200c6.627 0 12-5.373 12-12zm0 96v-32c0-6.627-5.373-12-12-12H204c-6.627 0-12 5.373-12 12v32c0 6.627 5.373 12 12 12h200c6.627 0 12-5.373 12-12z"},"child":[]}]})(props);
}function FaUsers (props) {
  return GenIcon({"attr":{"viewBox":"0 0 640 512"},"child":[{"tag":"path","attr":{"d":"M96 224c35.3 0 64-28.7 64-64s-28.7-64-64-64-64 28.7-64 64 28.7 64 64 64zm448 0c35.3 0 64-28.7 64-64s-28.7-64-64-64-64 28.7-64 64 28.7 64 64 64zm32 32h-64c-17.6 0-33.5 7.1-45.1 18.6 40.3 22.1 68.9 62 75.1 109.4h66c17.7 0 32-14.3 32-32v-32c0-35.3-28.7-64-64-64zm-256 0c61.9 0 112-50.1 112-112S381.9 32 320 32 208 82.1 208 144s50.1 112 112 112zm76.8 32h-8.3c-20.8 10-43.9 16-68.5 16s-47.6-6-68.5-16h-8.3C179.6 288 128 339.6 128 403.2V432c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48v-28.8c0-63.6-51.6-115.2-115.2-115.2zm-223.7-13.4C161.5 263.1 145.6 256 128 256H64c-35.3 0-64 28.7-64 64v32c0 17.7 14.3 32 32 32h65.9c6.3-47.4 34.9-87.3 75.2-109.4z"},"child":[]}]})(props);
}

// THIS FILE IS AUTO GENERATED
function BsFillBoxSeamFill (props) {
  return GenIcon({"attr":{"fill":"currentColor","viewBox":"0 0 16 16"},"child":[{"tag":"path","attr":{"fillRule":"evenodd","d":"M15.528 2.973a.75.75 0 0 1 .472.696v8.662a.75.75 0 0 1-.472.696l-7.25 2.9a.75.75 0 0 1-.557 0l-7.25-2.9A.75.75 0 0 1 0 12.331V3.669a.75.75 0 0 1 .471-.696L7.443.184l.01-.003.268-.108a.75.75 0 0 1 .558 0l.269.108.01.003zM10.404 2 4.25 4.461 1.846 3.5 1 3.839v.4l6.5 2.6v7.922l.5.2.5-.2V6.84l6.5-2.6v-.4l-.846-.339L8 5.961 5.596 5l6.154-2.461z"},"child":[]}]})(props);
}function BsStack (props) {
  return GenIcon({"attr":{"fill":"currentColor","viewBox":"0 0 16 16"},"child":[{"tag":"path","attr":{"d":"m14.12 10.163 1.715.858c.22.11.22.424 0 .534L8.267 15.34a.6.6 0 0 1-.534 0L.165 11.555a.299.299 0 0 1 0-.534l1.716-.858 5.317 2.659c.505.252 1.1.252 1.604 0l5.317-2.66zM7.733.063a.6.6 0 0 1 .534 0l7.568 3.784a.3.3 0 0 1 0 .535L8.267 8.165a.6.6 0 0 1-.534 0L.165 4.382a.299.299 0 0 1 0-.535z"},"child":[]},{"tag":"path","attr":{"d":"m14.12 6.576 1.715.858c.22.11.22.424 0 .534l-7.568 3.784a.6.6 0 0 1-.534 0L.165 7.968a.299.299 0 0 1 0-.534l1.716-.858 5.317 2.659c.505.252 1.1.252 1.604 0z"},"child":[]}]})(props);
}

// THIS FILE IS AUTO GENERATED
function AiFillPieChart (props) {
  return GenIcon({"attr":{"viewBox":"0 0 1024 1024"},"child":[{"tag":"path","attr":{"d":"M863.1 518.5H505.5V160.9c0-4.4-3.6-8-8-8h-26a398.57 398.57 0 0 0-282.5 117 397.47 397.47 0 0 0-85.6 127C82.6 446.2 72 498.5 72 552.5S82.6 658.7 103.4 708c20.1 47.5 48.9 90.3 85.6 127 36.7 36.7 79.4 65.5 127 85.6a396.64 396.64 0 0 0 155.6 31.5 398.57 398.57 0 0 0 282.5-117c36.7-36.7 65.5-79.4 85.6-127a396.64 396.64 0 0 0 31.5-155.6v-26c-.1-4.4-3.7-8-8.1-8zM951 463l-2.6-28.2c-8.5-92-49.3-178.8-115.1-244.3A398.5 398.5 0 0 0 588.4 75.6L560.1 73c-4.7-.4-8.7 3.2-8.7 7.9v383.7c0 4.4 3.6 8 8 8l383.6-1c4.7-.1 8.4-4 8-8.6z"},"child":[]}]})(props);
}

// THIS FILE IS AUTO GENERATED
function IoMegaphone (props) {
  return GenIcon({"attr":{"viewBox":"0 0 512 512"},"child":[{"tag":"path","attr":{"d":"M48 176v.66a17.38 17.38 0 0 1-4.2 11.23v.05C38.4 194.32 32 205.74 32 224c0 16.55 5.3 28.23 11.68 35.91A19 19 0 0 1 48 272a32 32 0 0 0 32 32h8a8 8 0 0 0 8-8V152a8 8 0 0 0-8-8h-8a32 32 0 0 0-32 32zm404.18 10.55-.93-.17a4 4 0 0 1-3.25-3.93V62c0-12.64-8.39-24-20.89-28.32-11.92-4.11-24.34-.76-31.68 8.53a431.18 431.18 0 0 1-51.31 51.69c-23.63 20-46.24 34.25-67 42.31a8 8 0 0 0-5.15 7.47V299a16 16 0 0 0 9.69 14.69c19.34 8.29 40.24 21.83 62 40.28a433.74 433.74 0 0 1 51.68 52.16 26.22 26.22 0 0 0 21.1 9.87 33.07 33.07 0 0 0 10.44-1.74C439.71 410 448 399.05 448 386.4V265.53a4 4 0 0 1 3.33-3.94l.85-.14C461.8 258.84 480 247.67 480 224s-18.2-34.84-27.82-37.45zM240 320V152a8 8 0 0 0-8-8h-96a8 8 0 0 0-8 8v304a24 24 0 0 0 24 24h52.45a32.66 32.66 0 0 0 25.93-12.45 31.65 31.65 0 0 0 5.21-29.05c-1.62-5.18-3.63-11-5.77-17.19-7.91-22.9-18.34-37.07-21.12-69.32A32 32 0 0 0 240 320z"},"child":[]}]})(props);
}function IoSettingsSharp (props) {
  return GenIcon({"attr":{"viewBox":"0 0 512 512"},"child":[{"tag":"path","attr":{"d":"M256 176a80 80 0 1 0 80 80 80.24 80.24 0 0 0-80-80zm172.72 80a165.53 165.53 0 0 1-1.64 22.34l48.69 38.12a11.59 11.59 0 0 1 2.63 14.78l-46.06 79.52a11.64 11.64 0 0 1-14.14 4.93l-57.25-23a176.56 176.56 0 0 1-38.82 22.67l-8.56 60.78a11.93 11.93 0 0 1-11.51 9.86h-92.12a12 12 0 0 1-11.51-9.53l-8.56-60.78A169.3 169.3 0 0 1 151.05 393L93.8 416a11.64 11.64 0 0 1-14.14-4.92L33.6 331.57a11.59 11.59 0 0 1 2.63-14.78l48.69-38.12A174.58 174.58 0 0 1 83.28 256a165.53 165.53 0 0 1 1.64-22.34l-48.69-38.12a11.59 11.59 0 0 1-2.63-14.78l46.06-79.52a11.64 11.64 0 0 1 14.14-4.93l57.25 23a176.56 176.56 0 0 1 38.82-22.67l8.56-60.78A11.93 11.93 0 0 1 209.94 26h92.12a12 12 0 0 1 11.51 9.53l8.56 60.78A169.3 169.3 0 0 1 361 119l57.2-23a11.64 11.64 0 0 1 14.14 4.92l46.06 79.52a11.59 11.59 0 0 1-2.63 14.78l-48.69 38.12a174.58 174.58 0 0 1 1.64 22.66z"},"child":[]}]})(props);
}

// THIS FILE IS AUTO GENERATED
function IoIosExit (props) {
  return GenIcon({"attr":{"viewBox":"0 0 512 512"},"child":[{"tag":"path","attr":{"d":"M144 136v107h179.9l-47.2-47.9c-5-5.1-5-13.3.1-18.4 5.1-5 13.3-5 18.4.1l69 70c2.4 2.5 3.7 5.8 3.7 9.1 0 1.7-.3 3.4-1 5-.6 1.5-1.6 2.9-2.7 4.1l-69 70c-5 5.1-13.3 5.2-18.4.1-5.1-5-5.2-13.3-.1-18.4l47.2-47.9H144v107c0 22 18 40 40 40h240c22 0 40-18 40-40V136c0-22-18-40-40-40H184c-22 0-40 18-40 40zM61 243c-7.2 0-13 5.8-13 13s5.8 13 13 13h83v-26H61z"},"child":[]}]})(props);
}

// THIS FILE IS AUTO GENERATED
function FaMeta (props) {
  return GenIcon({"attr":{"viewBox":"0 0 640 512"},"child":[{"tag":"path","attr":{"d":"M640 317.9C640 409.2 600.6 466.4 529.7 466.4C467.1 466.4 433.9 431.8 372.8 329.8L341.4 277.2C333.1 264.7 326.9 253 320.2 242.2C300.1 276 273.1 325.2 273.1 325.2C206.1 441.8 168.5 466.4 116.2 466.4C43.42 466.4 0 409.1 0 320.5C0 177.5 79.78 42.4 183.9 42.4C234.1 42.4 277.7 67.08 328.7 131.9C365.8 81.8 406.8 42.4 459.3 42.4C558.4 42.4 640 168.1 640 317.9H640zM287.4 192.2C244.5 130.1 216.5 111.7 183 111.7C121.1 111.7 69.22 217.8 69.22 321.7C69.22 370.2 87.7 397.4 118.8 397.4C149 397.4 167.8 378.4 222 293.6C222 293.6 246.7 254.5 287.4 192.2V192.2zM531.2 397.4C563.4 397.4 578.1 369.9 578.1 322.5C578.1 198.3 523.8 97.08 454.9 97.08C421.7 97.08 393.8 123 360 175.1C369.4 188.9 379.1 204.1 389.3 220.5L426.8 282.9C485.5 377 500.3 397.4 531.2 397.4L531.2 397.4z"},"child":[]}]})(props);
}function FaRobot (props) {
  return GenIcon({"attr":{"viewBox":"0 0 640 512"},"child":[{"tag":"path","attr":{"d":"M320 0c17.7 0 32 14.3 32 32l0 64 120 0c39.8 0 72 32.2 72 72l0 272c0 39.8-32.2 72-72 72l-304 0c-39.8 0-72-32.2-72-72l0-272c0-39.8 32.2-72 72-72l120 0 0-64c0-17.7 14.3-32 32-32zM208 384c-8.8 0-16 7.2-16 16s7.2 16 16 16l32 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0zm96 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l32 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0zm96 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l32 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0zM264 256a40 40 0 1 0 -80 0 40 40 0 1 0 80 0zm152 40a40 40 0 1 0 0-80 40 40 0 1 0 0 80zM48 224l16 0 0 192-16 0c-26.5 0-48-21.5-48-48l0-96c0-26.5 21.5-48 48-48zm544 0c26.5 0 48 21.5 48 48l0 96c0 26.5-21.5 48-48 48l-16 0 0-192 16 0z"},"child":[]}]})(props);
}

const SidebarMth = () => {
  const { handleLogout } = useAuth();
  const [collapsed, setCollapsed] = reactExports.useState(true);
  const [activeModal, setActiveModal] = reactExports.useState(null);
  const navigate = useNavigate();
  const handleMouseEnter = () => {
    if (!activeModal) {
      setCollapsed(false);
    }
  };
  const handleMouseLeave = () => {
    if (!activeModal) {
      setCollapsed(true);
    }
  };
  const handleModalToggle = (modalName) => {
    setActiveModal(activeModal === modalName ? null : modalName);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed top-0 left-0 h-full z-40", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Sidebar,
      {
        collapsed,
        rootStyles: {
          [`.${sidebarClasses.container}`]: {
            backgroundColor: "#483FFF",
            color: "#483FFF",
            height: "100vh",
            display: "flex",
            flexDirection: "column"
          }
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-5 mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/dashboard", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Cn, { classIm: "mx-3", src: "https://ftp.mathilde-ads.com/151-5f18f5b0ce0f79b3c7e3ffbd4828ec14.png", alt: "Logo Mathilde ads", width: 58, height: 58 }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Menu, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              MenuItem,
              {
                icon: /* @__PURE__ */ jsxRuntimeExports.jsx(FaListAlt, { className: "text-xl" }),
                onClick: () => handleModalToggle("campanas"),
                className: "bg-white my-1 mb-2 mx-3 rounded-md hover:bg-opacity-90",
                rootStyles: {
                  button: {
                    width: collapsed ? "calc(100% - 0.5rem)" : "calc(100% - 1rem)",
                    margin: collapsed ? "0 0.25rem" : "0 0.5rem",
                    color: "#483FFF",
                    "&:hover": {
                      color: "#483FFF"
                    }
                  }
                },
                children: "Campañas"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              MenuItem,
              {
                icon: /* @__PURE__ */ jsxRuntimeExports.jsx(FaRobot, { className: "text-xl" }),
                onClick: () => {
                  const link = document.createElement("a");
                  link.href = "https://pruebasmathilde.com/chatbot-frontend/";
                  link.target = "_blank";
                  link.rel = "noopener noreferrer";
                  link.click();
                },
                className: "bg-white my-1 mb-2 mx-3 rounded-md hover:bg-opacity-90",
                rootStyles: {
                  button: {
                    width: collapsed ? "calc(100% - 0.5rem)" : "calc(100% - 1rem)",
                    margin: collapsed ? "0 0.25rem" : "0 0.5rem",
                    color: "#483FFF",
                    "&:hover": {
                      color: "#483FFF"
                    }
                  }
                },
                children: "Asistente IA"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              MenuItem,
              {
                icon: /* @__PURE__ */ jsxRuntimeExports.jsx(BsFillBoxSeamFill, { className: "text-xl" }),
                onClick: () => {
                  const link = document.createElement("a");
                  link.href = "https://ssp.mathilde-ads.com/login";
                  link.target = "_blank";
                  link.rel = "noopener noreferrer";
                  link.click();
                },
                className: "bg-white my-1 mb-2 mx-3 rounded-md hover:bg-opacity-90",
                rootStyles: {
                  button: {
                    width: collapsed ? "calc(100% - 0.5rem)" : "calc(100% - 1rem)",
                    margin: collapsed ? "0 0.25rem" : "0 0.5rem",
                    color: "#483FFF",
                    "&:hover": {
                      color: "#483FFF"
                    }
                  }
                },
                children: "Medios"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              MenuItem,
              {
                icon: /* @__PURE__ */ jsxRuntimeExports.jsx(FaUsers, { className: "text-xl" }),
                onClick: () => {
                  const link = document.createElement("a");
                  link.href = "https://dsp.mathilde-ads.com/login";
                  link.target = "_blank";
                  link.rel = "noopener noreferrer";
                  link.click();
                },
                className: "bg-white my-1 mb-2 mx-3 rounded-md hover:bg-opacity-90",
                rootStyles: {
                  button: {
                    width: collapsed ? "calc(100% - 0.5rem)" : "calc(100% - 1rem)",
                    margin: collapsed ? "0 0.25rem" : "0 0.5rem",
                    color: "#483FFF",
                    "&:hover": {
                      color: "#483FFF"
                    }
                  }
                },
                children: " Audiencias "
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              MenuItem,
              {
                icon: /* @__PURE__ */ jsxRuntimeExports.jsx(AiFillPieChart, { className: "text-xl" }),
                onClick: () => navigate("/report"),
                className: "bg-white my-1 mb-2 mx-3 rounded-md hover:bg-opacity-90",
                rootStyles: {
                  button: {
                    width: collapsed ? "calc(100% - 0.5rem)" : "calc(100% - 1rem)",
                    margin: collapsed ? "0 0.25rem" : "0 0.5rem",
                    color: "#483FFF",
                    "&:hover": {
                      color: "#483FFF"
                    }
                  }
                },
                children: " Reportes "
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              MenuItem,
              {
                icon: /* @__PURE__ */ jsxRuntimeExports.jsx(IoSettingsSharp, { className: "text-xl" }),
                onClick: () => navigate("/settings"),
                className: "bg-white my-1 mb-2 mx-3 rounded-md hover:bg-opacity-90",
                rootStyles: {
                  button: {
                    width: collapsed ? "calc(100% - 0.5rem)" : "calc(100% - 1rem)",
                    margin: collapsed ? "0 0.25rem" : "0 0.5rem",
                    color: "#483FFF",
                    "&:hover": {
                      color: "#483FFF"
                    }
                  }
                },
                children: "Configuración"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-auto self-end p-4 w-full cursor-pointer", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center bg-white rounded-md p-2", onClick: handleLogout, children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "text-3xl", style: { color: "#483FFF" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IoIosExit, {}) }) }) })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(S1, { width: "40%", isOpen: activeModal === "campanas", onClose: () => setActiveModal(null), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col px-10 pb-5", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-center font-bold mb-3", children: "Selecciona el tipo de campaña que quieres crear" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-3/6 p-2 flex", onClick: () => window.open("https://dsp.mathilde-ads.com/login", "_blank"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(u0, { imageUrl: "https://ftp.mathilde-ads.com/151-ace94cf43477f7394e72ff6819cc621a.svg", title: "Medios Propios", description: "Crea y administra campañas a los usuarios que ingresan a tus canales." }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-3/6 p-2 flex", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/summaryCampaign", onClick: () => setActiveModal(null), children: /* @__PURE__ */ jsxRuntimeExports.jsx(u0, { imageUrl: "https://ftp.mathilde-ads.com/151-1625a87e98d0195b779465fd1e699481.svg", title: "Medios Pagos", description: "Activa campañas de Marketing Digital usando inventario de Redes Sociales y Google." }) }) })
      ] })
    ] }) })
  ] }) });
};

const API_URL = "https://xlnrchrag0.execute-api.us-east-2.amazonaws.com/dev/campaings/dashboard";
const dataAdvertiser = {
  advertiser: [
    { value: "ACOMEDIOS-TUBOLETA", label: "ACOMEDIOS-TUBOLETA" },
    { value: "BANCOAVVILLAS", label: "BANCOAVVILLAS" },
    { value: "BANCOPOPULAR", label: "BANCOPOPULAR" },
    { value: "BANCODEBOGOTA", label: "BANCODEBOGOTA" },
    { value: "BANCODEOCCIDENTE", label: "BANCODEOCCIDENTE" },
    { value: "DALE", label: "DALE" },
    { value: "GLOBANT-KALLEY", label: "GLOBANT-KALLEY" },
    { value: "IPG-ARKADIA", label: "IPG-ARKADIA" },
    { value: "IPG-CENCOSUD", label: "IPG-CENCOSUD" },
    { value: "IPG-COLMEDICA", label: "IPG-COLMEDICA" },
    { value: "IPG-CRUZ VERDE", label: "IPG-CRUZ VERDE" },
    { value: "IPG-FONTANAR", label: "IPG-FONTANAR" },
    { value: "IPG-MARVAL", label: "IPG-MARVAL" },
    { value: "IPG-NESTLE", label: "IPG-NESTLE" },
    { value: "IPG-UNIEAN", label: "IPG-UNIEAN" },
    { value: "MML-ADMEDIAROCK", label: "MML-ADMEDIAROCK" },
    { value: "MML-AVIATUR", label: "MML-AVIATUR" },
    { value: "MML-BRAVO", label: "MML-BRAVO" },
    { value: "MML-CREDICORP", label: "MML-CREDICORP" },
    { value: "MML-ESTELAR", label: "MML-ESTELAR" },
    { value: "MML-GSK", label: "MML-GSK" },
    { value: "MML-TOROORTIZ", label: "MML-TOROORTIZ" },
    { value: "MULTIBANK", label: "MULTIBANK" },
    { value: "PORVENIR", label: "PORVENIR" },
    { value: "UM-BANCODEBOGOTA", label: "UM-BANCODEBOGOTA" },
    { value: "UM-BANCODEOCCIDENTE", label: "UM-BANCODEOCCIDENTE" }
  ],
  getAdvertiser() {
    return this.advertiser;
  }
};
const getReportData = async (requestData) => {
  try {
    const token = sessionStorage.getItem("tokCog");
    console.log(`Token: ${token}`);
    if (!token) {
      throw new Error("No hay token de autorización disponible");
    }
    const response = await axios.post(API_URL, requestData, {
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${token}`
      }
    });
    if (!response.data) {
      throw new Error("No se recibieron datos del servidor");
    }
    return response.data;
  } catch (error) {
    if (axios.isAxiosError(error)) {
      if (error.response?.data?.message === "The incoming token has expired") {
        sessionStorage.removeItem("tokCog");
        localStorage.removeItem("user");
        window.location.href = "/";
      }
      throw new Error(`Error al obtener el reporte: ${error.response?.data?.message || error.message}`);
    }
    throw error;
  }
};

/**
 * @module constants
 * @summary Useful constants
 * @description
 * Collection of useful date constants.
 *
 * The constants could be imported from `date-fns/constants`:
 *
 * ```ts
 * import { maxTime, minTime } from "./constants/date-fns/constants";
 *
 * function isAllowedTime(time) {
 *   return time <= maxTime && time >= minTime;
 * }
 * ```
 */


/**
 * @constant
 * @name millisecondsInWeek
 * @summary Milliseconds in 1 week.
 */
const millisecondsInWeek = 604800000;

/**
 * @constant
 * @name millisecondsInDay
 * @summary Milliseconds in 1 day.
 */
const millisecondsInDay = 86400000;

/**
 * @constant
 * @name millisecondsInMinute
 * @summary Milliseconds in 1 minute
 */
const millisecondsInMinute = 60000;

/**
 * @constant
 * @name millisecondsInHour
 * @summary Milliseconds in 1 hour
 */
const millisecondsInHour = 3600000;

/**
 * @constant
 * @name millisecondsInSecond
 * @summary Milliseconds in 1 second
 */
const millisecondsInSecond = 1000;

/**
 * @constant
 * @name constructFromSymbol
 * @summary Symbol enabling Date extensions to inherit properties from the reference date.
 *
 * The symbol is used to enable the `constructFrom` function to construct a date
 * using a reference date and a value. It allows to transfer extra properties
 * from the reference date to the new date. It's useful for extensions like
 * [`TZDate`](https://github.com/date-fns/tz) that accept a time zone as
 * a constructor argument.
 */
const constructFromSymbol = Symbol.for("constructDateFrom");

/**
 * @name constructFrom
 * @category Generic Helpers
 * @summary Constructs a date using the reference date and the value
 *
 * @description
 * The function constructs a new date using the constructor from the reference
 * date and the given value. It helps to build generic functions that accept
 * date extensions.
 *
 * It defaults to `Date` if the passed reference date is a number or a string.
 *
 * Starting from v3.7.0, it allows to construct a date using `[Symbol.for("constructDateFrom")]`
 * enabling to transfer extra properties from the reference date to the new date.
 * It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)
 * that accept a time zone as a constructor argument.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The reference date to take constructor from
 * @param value - The value to create the date
 *
 * @returns Date initialized using the given date and value
 *
 * @example
 * import { constructFrom } from "./constructFrom/date-fns";
 *
 * // A function that clones a date preserving the original type
 * function cloneDate<DateType extends Date>(date: DateType): DateType {
 *   return constructFrom(
 *     date, // Use constructor from the given date
 *     date.getTime() // Use the date value to create a new date
 *   );
 * }
 */
function constructFrom(date, value) {
  if (typeof date === "function") return date(value);

  if (date && typeof date === "object" && constructFromSymbol in date)
    return date[constructFromSymbol](value);

  if (date instanceof Date) return new date.constructor(value);

  return new Date(value);
}

/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * Starting from v3.7.0, it clones a date using `[Symbol.for("constructDateFrom")]`
 * enabling to transfer extra properties from the reference date to the new date.
 * It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)
 * that accept a time zone as a constructor argument.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param argument - The value to convert
 *
 * @returns The parsed date in the local time zone
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */
function toDate(argument, context) {
  // [TODO] Get rid of `toDate` or `constructFrom`?
  return constructFrom(context || argument, argument);
}

/**
 * The {@link addDays} function options.
 */

/**
 * @name addDays
 * @category Day Helpers
 * @summary Add the specified number of days to the given date.
 *
 * @description
 * Add the specified number of days to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of days to be added.
 * @param options - An object with options
 *
 * @returns The new date with the days added
 *
 * @example
 * // Add 10 days to 1 September 2014:
 * const result = addDays(new Date(2014, 8, 1), 10)
 * //=> Thu Sep 11 2014 00:00:00
 */
function addDays(date, amount, options) {
  const _date = toDate(date, options?.in);
  if (isNaN(amount)) return constructFrom(options?.in || date, NaN);

  // If 0 days, no-op to avoid changing times in the hour before end of DST
  if (!amount) return _date;

  _date.setDate(_date.getDate() + amount);
  return _date;
}

let defaultOptions = {};

function getDefaultOptions$1() {
  return defaultOptions;
}

/**
 * The {@link startOfWeek} function options.
 */

/**
 * @name startOfWeek
 * @category Week Helpers
 * @summary Return the start of a week for the given date.
 *
 * @description
 * Return the start of a week for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of a week
 *
 * @example
 * // The start of a week for 2 September 2014 11:55:00:
 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // If the week starts on Monday, the start of the week for 2 September 2014 11:55:00:
 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
 * //=> Mon Sep 01 2014 00:00:00
 */
function startOfWeek(date, options) {
  const defaultOptions = getDefaultOptions$1();
  const weekStartsOn =
    options?.weekStartsOn ??
    options?.locale?.options?.weekStartsOn ??
    defaultOptions.weekStartsOn ??
    defaultOptions.locale?.options?.weekStartsOn ??
    0;

  const _date = toDate(date, options?.in);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;

  _date.setDate(_date.getDate() - diff);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

/**
 * The {@link startOfISOWeek} function options.
 */

/**
 * @name startOfISOWeek
 * @category ISO Week Helpers
 * @summary Return the start of an ISO week for the given date.
 *
 * @description
 * Return the start of an ISO week for the given date.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of an ISO week
 *
 * @example
 * // The start of an ISO week for 2 September 2014 11:55:00:
 * const result = startOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Mon Sep 01 2014 00:00:00
 */
function startOfISOWeek(date, options) {
  return startOfWeek(date, { ...options, weekStartsOn: 1 });
}

/**
 * The {@link getISOWeekYear} function options.
 */

/**
 * @name getISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Get the ISO week-numbering year of the given date.
 *
 * @description
 * Get the ISO week-numbering year of the given date,
 * which always starts 3 days before the year's first Thursday.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param date - The given date
 *
 * @returns The ISO week-numbering year
 *
 * @example
 * // Which ISO-week numbering year is 2 January 2005?
 * const result = getISOWeekYear(new Date(2005, 0, 2))
 * //=> 2004
 */
function getISOWeekYear(date, options) {
  const _date = toDate(date, options?.in);
  const year = _date.getFullYear();

  const fourthOfJanuaryOfNextYear = constructFrom(_date, 0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);

  const fourthOfJanuaryOfThisYear = constructFrom(_date, 0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);

  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

/**
 * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
 * They usually appear for dates that denote time before the timezones were introduced
 * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
 * and GMT+01:00:00 after that date)
 *
 * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
 * which would lead to incorrect calculations.
 *
 * This function returns the timezone offset in milliseconds that takes seconds in account.
 */
function getTimezoneOffsetInMilliseconds(date) {
  const _date = toDate(date);
  const utcDate = new Date(
    Date.UTC(
      _date.getFullYear(),
      _date.getMonth(),
      _date.getDate(),
      _date.getHours(),
      _date.getMinutes(),
      _date.getSeconds(),
      _date.getMilliseconds(),
    ),
  );
  utcDate.setUTCFullYear(_date.getFullYear());
  return +date - +utcDate;
}

function normalizeDates(context, ...dates) {
  const normalize = constructFrom.bind(
    null,
    dates.find((date) => typeof date === "object"),
  );
  return dates.map(normalize);
}

/**
 * The {@link startOfDay} function options.
 */

/**
 * @name startOfDay
 * @category Day Helpers
 * @summary Return the start of a day for the given date.
 *
 * @description
 * Return the start of a day for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - The options
 *
 * @returns The start of a day
 *
 * @example
 * // The start of a day for 2 September 2014 11:55:00:
 * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 00:00:00
 */
function startOfDay(date, options) {
  const _date = toDate(date, options?.in);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

/**
 * The {@link differenceInCalendarDays} function options.
 */

/**
 * @name differenceInCalendarDays
 * @category Day Helpers
 * @summary Get the number of calendar days between the given dates.
 *
 * @description
 * Get the number of calendar days between the given dates. This means that the times are removed
 * from the dates and then the difference in days is calculated.
 *
 * @param laterDate - The later date
 * @param earlierDate - The earlier date
 * @param options - The options object
 *
 * @returns The number of calendar days
 *
 * @example
 * // How many calendar days are between
 * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
 * const result = differenceInCalendarDays(
 *   new Date(2012, 6, 2, 0, 0),
 *   new Date(2011, 6, 2, 23, 0)
 * )
 * //=> 366
 * // How many calendar days are between
 * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
 * const result = differenceInCalendarDays(
 *   new Date(2011, 6, 3, 0, 1),
 *   new Date(2011, 6, 2, 23, 59)
 * )
 * //=> 1
 */
function differenceInCalendarDays(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options?.in,
    laterDate,
    earlierDate,
  );

  const laterStartOfDay = startOfDay(laterDate_);
  const earlierStartOfDay = startOfDay(earlierDate_);

  const laterTimestamp =
    +laterStartOfDay - getTimezoneOffsetInMilliseconds(laterStartOfDay);
  const earlierTimestamp =
    +earlierStartOfDay - getTimezoneOffsetInMilliseconds(earlierStartOfDay);

  // Round the number of days to the nearest integer because the number of
  // milliseconds in a day is not constant (e.g. it's different in the week of
  // the daylight saving time clock shift).
  return Math.round((laterTimestamp - earlierTimestamp) / millisecondsInDay);
}

/**
 * The {@link startOfISOWeekYear} function options.
 */

/**
 * @name startOfISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Return the start of an ISO week-numbering year for the given date.
 *
 * @description
 * Return the start of an ISO week-numbering year,
 * which always starts 3 days before the year's first Thursday.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of an ISO week-numbering year
 *
 * @example
 * // The start of an ISO week-numbering year for 2 July 2005:
 * const result = startOfISOWeekYear(new Date(2005, 6, 2))
 * //=> Mon Jan 03 2005 00:00:00
 */
function startOfISOWeekYear(date, options) {
  const year = getISOWeekYear(date, options);
  const fourthOfJanuary = constructFrom(date, 0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  return startOfISOWeek(fourthOfJanuary);
}

/**
 * @name isDate
 * @category Common Helpers
 * @summary Is the given value a date?
 *
 * @description
 * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.
 *
 * @param value - The value to check
 *
 * @returns True if the given value is a date
 *
 * @example
 * // For a valid date:
 * const result = isDate(new Date())
 * //=> true
 *
 * @example
 * // For an invalid date:
 * const result = isDate(new Date(NaN))
 * //=> true
 *
 * @example
 * // For some value:
 * const result = isDate('2014-02-31')
 * //=> false
 *
 * @example
 * // For an object:
 * const result = isDate({})
 * //=> false
 */
function isDate(value) {
  return (
    value instanceof Date ||
    (typeof value === "object" &&
      Object.prototype.toString.call(value) === "[object Date]")
  );
}

/**
 * @name isValid
 * @category Common Helpers
 * @summary Is the given date valid?
 *
 * @description
 * Returns false if argument is Invalid Date and true otherwise.
 * Argument is converted to Date using `toDate`. See [toDate](https://date-fns.org/docs/toDate)
 * Invalid Date is a Date, whose time value is NaN.
 *
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @param date - The date to check
 *
 * @returns The date is valid
 *
 * @example
 * // For the valid date:
 * const result = isValid(new Date(2014, 1, 31))
 * //=> true
 *
 * @example
 * // For the value, convertible into a date:
 * const result = isValid(1393804800000)
 * //=> true
 *
 * @example
 * // For the invalid date:
 * const result = isValid(new Date(''))
 * //=> false
 */
function isValid(date) {
  return !((!isDate(date) && typeof date !== "number") || isNaN(+toDate(date)));
}

/**
 * The {@link startOfYear} function options.
 */

/**
 * @name startOfYear
 * @category Year Helpers
 * @summary Return the start of a year for the given date.
 *
 * @description
 * Return the start of a year for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - The options
 *
 * @returns The start of a year
 *
 * @example
 * // The start of a year for 2 September 2014 11:55:00:
 * const result = startOfYear(new Date(2014, 8, 2, 11, 55, 00))
 * //=> Wed Jan 01 2014 00:00:00
 */
function startOfYear(date, options) {
  const date_ = toDate(date, options?.in);
  date_.setFullYear(date_.getFullYear(), 0, 1);
  date_.setHours(0, 0, 0, 0);
  return date_;
}

const formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds",
  },

  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds",
  },

  halfAMinute: "half a minute",

  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes",
  },

  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes",
  },

  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours",
  },

  xHours: {
    one: "1 hour",
    other: "{{count}} hours",
  },

  xDays: {
    one: "1 day",
    other: "{{count}} days",
  },

  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks",
  },

  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks",
  },

  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months",
  },

  xMonths: {
    one: "1 month",
    other: "{{count}} months",
  },

  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years",
  },

  xYears: {
    one: "1 year",
    other: "{{count}} years",
  },

  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years",
  },

  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years",
  },
};

const formatDistance = (token, count, options) => {
  let result;

  const tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }

  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }

  return result;
};

function buildFormatLongFn(args) {
  return (options = {}) => {
    // TODO: Remove String()
    const width = options.width ? String(options.width) : args.defaultWidth;
    const format = args.formats[width] || args.formats[args.defaultWidth];
    return format;
  };
}

const dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy",
};

const timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a",
};

const dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}",
};

const formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full",
  }),

  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full",
  }),

  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full",
  }),
};

const formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P",
};

const formatRelative = (token, _date, _baseDate, _options) =>
  formatRelativeLocale[token];

/**
 * The localize function argument callback which allows to convert raw value to
 * the actual type.
 *
 * @param value - The value to convert
 *
 * @returns The converted value
 */

/**
 * The map of localized values for each width.
 */

/**
 * The index type of the locale unit value. It types conversion of units of
 * values that don't start at 0 (i.e. quarters).
 */

/**
 * Converts the unit value to the tuple of values.
 */

/**
 * The tuple of localized era values. The first element represents BC,
 * the second element represents AD.
 */

/**
 * The tuple of localized quarter values. The first element represents Q1.
 */

/**
 * The tuple of localized day values. The first element represents Sunday.
 */

/**
 * The tuple of localized month values. The first element represents January.
 */

function buildLocalizeFn(args) {
  return (value, options) => {
    const context = options?.context ? String(options.context) : "standalone";

    let valuesArray;
    if (context === "formatting" && args.formattingValues) {
      const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      const width = options?.width ? String(options.width) : defaultWidth;

      valuesArray =
        args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      const defaultWidth = args.defaultWidth;
      const width = options?.width ? String(options.width) : args.defaultWidth;

      valuesArray = args.values[width] || args.values[defaultWidth];
    }
    const index = args.argumentCallback ? args.argumentCallback(value) : value;

    // @ts-expect-error - For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!
    return valuesArray[index];
  };
}

const eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"],
};

const quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"],
};

// Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.
const monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec",
  ],

  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December",
  ],
};

const dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday",
  ],
};

const dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night",
  },
};

const formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night",
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night",
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night",
  },
};

const ordinalNumber = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);

  // If ordinal numbers depend on context, for example,
  // if they are different for different grammatical genders,
  // use `options.unit`.
  //
  // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
  // 'day', 'hour', 'minute', 'second'.

  const rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};

const localize = {
  ordinalNumber,

  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide",
  }),

  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
  }),

  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide",
  }),

  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide",
  }),

  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide",
  }),
};

function buildMatchFn(args) {
  return (string, options = {}) => {
    const width = options.width;

    const matchPattern =
      (width && args.matchPatterns[width]) ||
      args.matchPatterns[args.defaultMatchWidth];
    const matchResult = string.match(matchPattern);

    if (!matchResult) {
      return null;
    }
    const matchedString = matchResult[0];

    const parsePatterns =
      (width && args.parsePatterns[width]) ||
      args.parsePatterns[args.defaultParseWidth];

    const key = Array.isArray(parsePatterns)
      ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString))
      : // [TODO] -- I challenge you to fix the type
        findKey(parsePatterns, (pattern) => pattern.test(matchedString));

    let value;

    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback
      ? // [TODO] -- I challenge you to fix the type
        options.valueCallback(value)
      : value;

    const rest = string.slice(matchedString.length);

    return { value, rest };
  };
}

function findKey(object, predicate) {
  for (const key in object) {
    if (
      Object.prototype.hasOwnProperty.call(object, key) &&
      predicate(object[key])
    ) {
      return key;
    }
  }
  return undefined;
}

function findIndex(array, predicate) {
  for (let key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return undefined;
}

function buildMatchPatternFn(args) {
  return (string, options = {}) => {
    const matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    const matchedString = matchResult[0];

    const parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    let value = args.valueCallback
      ? args.valueCallback(parseResult[0])
      : parseResult[0];

    // [TODO] I challenge you to fix the type
    value = options.valueCallback ? options.valueCallback(value) : value;

    const rest = string.slice(matchedString.length);

    return { value, rest };
  };
}

const matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern = /\d+/i;

const matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i,
};
const parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i],
};

const matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i,
};
const parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i],
};

const matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i,
};
const parseMonthPatterns = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],

  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],
};

const matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i,
};
const parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i],
};

const matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i,
};
const parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i,
  },
};

const match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: (value) => parseInt(value, 10),
  }),

  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any",
  }),

  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1,
  }),

  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any",
  }),

  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any",
  }),

  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any",
  }),
};

/**
 * @category Locales
 * @summary English locale (United States).
 * @language English
 * @iso-639-2 eng
 * @author Sasha Koss [@kossnocorp](https://github.com/kossnocorp)
 * @author Lesha Koss [@leshakoss](https://github.com/leshakoss)
 */
const enUS = {
  code: "en-US",
  formatDistance: formatDistance,
  formatLong: formatLong,
  formatRelative: formatRelative,
  localize: localize,
  match: match,
  options: {
    weekStartsOn: 0 /* Sunday */,
    firstWeekContainsDate: 1,
  },
};

/**
 * The {@link getDayOfYear} function options.
 */

/**
 * @name getDayOfYear
 * @category Day Helpers
 * @summary Get the day of the year of the given date.
 *
 * @description
 * Get the day of the year of the given date.
 *
 * @param date - The given date
 * @param options - The options
 *
 * @returns The day of year
 *
 * @example
 * // Which day of the year is 2 July 2014?
 * const result = getDayOfYear(new Date(2014, 6, 2))
 * //=> 183
 */
function getDayOfYear(date, options) {
  const _date = toDate(date, options?.in);
  const diff = differenceInCalendarDays(_date, startOfYear(_date));
  const dayOfYear = diff + 1;
  return dayOfYear;
}

/**
 * The {@link getISOWeek} function options.
 */

/**
 * @name getISOWeek
 * @category ISO Week Helpers
 * @summary Get the ISO week of the given date.
 *
 * @description
 * Get the ISO week of the given date.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param date - The given date
 * @param options - The options
 *
 * @returns The ISO week
 *
 * @example
 * // Which week of the ISO-week numbering year is 2 January 2005?
 * const result = getISOWeek(new Date(2005, 0, 2))
 * //=> 53
 */
function getISOWeek(date, options) {
  const _date = toDate(date, options?.in);
  const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);

  // Round the number of weeks to the nearest integer because the number of
  // milliseconds in a week is not constant (e.g. it's different in the week of
  // the daylight saving time clock shift).
  return Math.round(diff / millisecondsInWeek) + 1;
}

/**
 * The {@link getWeekYear} function options.
 */

/**
 * @name getWeekYear
 * @category Week-Numbering Year Helpers
 * @summary Get the local week-numbering year of the given date.
 *
 * @description
 * Get the local week-numbering year of the given date.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @param date - The given date
 * @param options - An object with options.
 *
 * @returns The local week-numbering year
 *
 * @example
 * // Which week numbering year is 26 December 2004 with the default settings?
 * const result = getWeekYear(new Date(2004, 11, 26))
 * //=> 2005
 *
 * @example
 * // Which week numbering year is 26 December 2004 if week starts on Saturday?
 * const result = getWeekYear(new Date(2004, 11, 26), { weekStartsOn: 6 })
 * //=> 2004
 *
 * @example
 * // Which week numbering year is 26 December 2004 if the first week contains 4 January?
 * const result = getWeekYear(new Date(2004, 11, 26), { firstWeekContainsDate: 4 })
 * //=> 2004
 */
function getWeekYear(date, options) {
  const _date = toDate(date, options?.in);
  const year = _date.getFullYear();

  const defaultOptions = getDefaultOptions$1();
  const firstWeekContainsDate =
    options?.firstWeekContainsDate ??
    options?.locale?.options?.firstWeekContainsDate ??
    defaultOptions.firstWeekContainsDate ??
    defaultOptions.locale?.options?.firstWeekContainsDate ??
    1;

  const firstWeekOfNextYear = constructFrom(options?.in || date, 0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfWeek(firstWeekOfNextYear, options);

  const firstWeekOfThisYear = constructFrom(options?.in || date, 0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfWeek(firstWeekOfThisYear, options);

  if (+_date >= +startOfNextYear) {
    return year + 1;
  } else if (+_date >= +startOfThisYear) {
    return year;
  } else {
    return year - 1;
  }
}

/**
 * The {@link startOfWeekYear} function options.
 */

/**
 * @name startOfWeekYear
 * @category Week-Numbering Year Helpers
 * @summary Return the start of a local week-numbering year for the given date.
 *
 * @description
 * Return the start of a local week-numbering year.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of a week-numbering year
 *
 * @example
 * // The start of an a week-numbering year for 2 July 2005 with default settings:
 * const result = startOfWeekYear(new Date(2005, 6, 2))
 * //=> Sun Dec 26 2004 00:00:00
 *
 * @example
 * // The start of a week-numbering year for 2 July 2005
 * // if Monday is the first day of week
 * // and 4 January is always in the first week of the year:
 * const result = startOfWeekYear(new Date(2005, 6, 2), {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> Mon Jan 03 2005 00:00:00
 */
function startOfWeekYear(date, options) {
  const defaultOptions = getDefaultOptions$1();
  const firstWeekContainsDate =
    options?.firstWeekContainsDate ??
    options?.locale?.options?.firstWeekContainsDate ??
    defaultOptions.firstWeekContainsDate ??
    defaultOptions.locale?.options?.firstWeekContainsDate ??
    1;

  const year = getWeekYear(date, options);
  const firstWeek = constructFrom(options?.in || date, 0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  const _date = startOfWeek(firstWeek, options);
  return _date;
}

/**
 * The {@link getWeek} function options.
 */

/**
 * @name getWeek
 * @category Week Helpers
 * @summary Get the local week index of the given date.
 *
 * @description
 * Get the local week index of the given date.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @param date - The given date
 * @param options - An object with options
 *
 * @returns The week
 *
 * @example
 * // Which week of the local week numbering year is 2 January 2005 with default options?
 * const result = getWeek(new Date(2005, 0, 2))
 * //=> 2
 *
 * @example
 * // Which week of the local week numbering year is 2 January 2005,
 * // if Monday is the first day of the week,
 * // and the first week of the year always contains 4 January?
 * const result = getWeek(new Date(2005, 0, 2), {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> 53
 */
function getWeek(date, options) {
  const _date = toDate(date, options?.in);
  const diff = +startOfWeek(_date, options) - +startOfWeekYear(_date, options);

  // Round the number of weeks to the nearest integer because the number of
  // milliseconds in a week is not constant (e.g. it's different in the week of
  // the daylight saving time clock shift).
  return Math.round(diff / millisecondsInWeek) + 1;
}

function addLeadingZeros(number, targetLength) {
  const sign = number < 0 ? "-" : "";
  const output = Math.abs(number).toString().padStart(targetLength, "0");
  return sign + output;
}

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* |                                |
 * |  d  | Day of month                   |  D  |                                |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  m  | Minute                         |  M  | Month                          |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  y  | Year (abs)                     |  Y  |                                |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 */

const lightFormatters = {
  // Year
  y(date, token) {
    // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
    // |----------|-------|----|-------|-------|-------|
    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |

    const signedYear = date.getFullYear();
    // Returns 1 for 1 BC (which is year 0 in JavaScript)
    const year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
  },

  // Month
  M(date, token) {
    const month = date.getMonth();
    return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },

  // Day of the month
  d(date, token) {
    return addLeadingZeros(date.getDate(), token.length);
  },

  // AM or PM
  a(date, token) {
    const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";

    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },

  // Hour [1-12]
  h(date, token) {
    return addLeadingZeros(date.getHours() % 12 || 12, token.length);
  },

  // Hour [0-23]
  H(date, token) {
    return addLeadingZeros(date.getHours(), token.length);
  },

  // Minute
  m(date, token) {
    return addLeadingZeros(date.getMinutes(), token.length);
  },

  // Second
  s(date, token) {
    return addLeadingZeros(date.getSeconds(), token.length);
  },

  // Fraction of second
  S(date, token) {
    const numberOfDigits = token.length;
    const milliseconds = date.getMilliseconds();
    const fractionalSeconds = Math.trunc(
      milliseconds * Math.pow(10, numberOfDigits - 3),
    );
    return addLeadingZeros(fractionalSeconds, token.length);
  },
};

const dayPeriodEnum = {
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night",
};

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
 * |  p! | Long localized time            |  P! | Long localized date            |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 * - `P` is long localized date format
 * - `p` is long localized time format
 */

const formatters = {
  // Era
  G: function (date, token, localize) {
    const era = date.getFullYear() > 0 ? 1 : 0;
    switch (token) {
      // AD, BC
      case "G":
      case "GG":
      case "GGG":
        return localize.era(era, { width: "abbreviated" });
      // A, B
      case "GGGGG":
        return localize.era(era, { width: "narrow" });
      // Anno Domini, Before Christ
      case "GGGG":
      default:
        return localize.era(era, { width: "wide" });
    }
  },

  // Year
  y: function (date, token, localize) {
    // Ordinal number
    if (token === "yo") {
      const signedYear = date.getFullYear();
      // Returns 1 for 1 BC (which is year 0 in JavaScript)
      const year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize.ordinalNumber(year, { unit: "year" });
    }

    return lightFormatters.y(date, token);
  },

  // Local week-numbering year
  Y: function (date, token, localize, options) {
    const signedWeekYear = getWeekYear(date, options);
    // Returns 1 for 1 BC (which is year 0 in JavaScript)
    const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;

    // Two digit year
    if (token === "YY") {
      const twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }

    // Ordinal number
    if (token === "Yo") {
      return localize.ordinalNumber(weekYear, { unit: "year" });
    }

    // Padding
    return addLeadingZeros(weekYear, token.length);
  },

  // ISO week-numbering year
  R: function (date, token) {
    const isoWeekYear = getISOWeekYear(date);

    // Padding
    return addLeadingZeros(isoWeekYear, token.length);
  },

  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function (date, token) {
    const year = date.getFullYear();
    return addLeadingZeros(year, token.length);
  },

  // Quarter
  Q: function (date, token, localize) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token) {
      // 1, 2, 3, 4
      case "Q":
        return String(quarter);
      // 01, 02, 03, 04
      case "QQ":
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "Qo":
        return localize.ordinalNumber(quarter, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "QQQ":
        return localize.quarter(quarter, {
          width: "abbreviated",
          context: "formatting",
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "QQQQQ":
        return localize.quarter(quarter, {
          width: "narrow",
          context: "formatting",
        });
      // 1st quarter, 2nd quarter, ...
      case "QQQQ":
      default:
        return localize.quarter(quarter, {
          width: "wide",
          context: "formatting",
        });
    }
  },

  // Stand-alone quarter
  q: function (date, token, localize) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token) {
      // 1, 2, 3, 4
      case "q":
        return String(quarter);
      // 01, 02, 03, 04
      case "qq":
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return localize.ordinalNumber(quarter, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return localize.quarter(quarter, {
          width: "abbreviated",
          context: "standalone",
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return localize.quarter(quarter, {
          width: "narrow",
          context: "standalone",
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return localize.quarter(quarter, {
          width: "wide",
          context: "standalone",
        });
    }
  },

  // Month
  M: function (date, token, localize) {
    const month = date.getMonth();
    switch (token) {
      case "M":
      case "MM":
        return lightFormatters.M(date, token);
      // 1st, 2nd, ..., 12th
      case "Mo":
        return localize.ordinalNumber(month + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "MMM":
        return localize.month(month, {
          width: "abbreviated",
          context: "formatting",
        });
      // J, F, ..., D
      case "MMMMM":
        return localize.month(month, {
          width: "narrow",
          context: "formatting",
        });
      // January, February, ..., December
      case "MMMM":
      default:
        return localize.month(month, { width: "wide", context: "formatting" });
    }
  },

  // Stand-alone month
  L: function (date, token, localize) {
    const month = date.getMonth();
    switch (token) {
      // 1, 2, ..., 12
      case "L":
        return String(month + 1);
      // 01, 02, ..., 12
      case "LL":
        return addLeadingZeros(month + 1, 2);
      // 1st, 2nd, ..., 12th
      case "Lo":
        return localize.ordinalNumber(month + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "LLL":
        return localize.month(month, {
          width: "abbreviated",
          context: "standalone",
        });
      // J, F, ..., D
      case "LLLLL":
        return localize.month(month, {
          width: "narrow",
          context: "standalone",
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return localize.month(month, { width: "wide", context: "standalone" });
    }
  },

  // Local week of year
  w: function (date, token, localize, options) {
    const week = getWeek(date, options);

    if (token === "wo") {
      return localize.ordinalNumber(week, { unit: "week" });
    }

    return addLeadingZeros(week, token.length);
  },

  // ISO week of year
  I: function (date, token, localize) {
    const isoWeek = getISOWeek(date);

    if (token === "Io") {
      return localize.ordinalNumber(isoWeek, { unit: "week" });
    }

    return addLeadingZeros(isoWeek, token.length);
  },

  // Day of the month
  d: function (date, token, localize) {
    if (token === "do") {
      return localize.ordinalNumber(date.getDate(), { unit: "date" });
    }

    return lightFormatters.d(date, token);
  },

  // Day of year
  D: function (date, token, localize) {
    const dayOfYear = getDayOfYear(date);

    if (token === "Do") {
      return localize.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
    }

    return addLeadingZeros(dayOfYear, token.length);
  },

  // Day of week
  E: function (date, token, localize) {
    const dayOfWeek = date.getDay();
    switch (token) {
      // Tue
      case "E":
      case "EE":
      case "EEE":
        return localize.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting",
        });
      // T
      case "EEEEE":
        return localize.day(dayOfWeek, {
          width: "narrow",
          context: "formatting",
        });
      // Tu
      case "EEEEEE":
        return localize.day(dayOfWeek, {
          width: "short",
          context: "formatting",
        });
      // Tuesday
      case "EEEE":
      default:
        return localize.day(dayOfWeek, {
          width: "wide",
          context: "formatting",
        });
    }
  },

  // Local day of week
  e: function (date, token, localize, options) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case "e":
        return String(localDayOfWeek);
      // Padded numerical value
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      // 1st, 2nd, ..., 7th
      case "eo":
        return localize.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "eee":
        return localize.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting",
        });
      // T
      case "eeeee":
        return localize.day(dayOfWeek, {
          width: "narrow",
          context: "formatting",
        });
      // Tu
      case "eeeeee":
        return localize.day(dayOfWeek, {
          width: "short",
          context: "formatting",
        });
      // Tuesday
      case "eeee":
      default:
        return localize.day(dayOfWeek, {
          width: "wide",
          context: "formatting",
        });
    }
  },

  // Stand-alone local day of week
  c: function (date, token, localize, options) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      // Numerical value (same as in `e`)
      case "c":
        return String(localDayOfWeek);
      // Padded numerical value
      case "cc":
        return addLeadingZeros(localDayOfWeek, token.length);
      // 1st, 2nd, ..., 7th
      case "co":
        return localize.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "ccc":
        return localize.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone",
        });
      // T
      case "ccccc":
        return localize.day(dayOfWeek, {
          width: "narrow",
          context: "standalone",
        });
      // Tu
      case "cccccc":
        return localize.day(dayOfWeek, {
          width: "short",
          context: "standalone",
        });
      // Tuesday
      case "cccc":
      default:
        return localize.day(dayOfWeek, {
          width: "wide",
          context: "standalone",
        });
    }
  },

  // ISO day of week
  i: function (date, token, localize) {
    const dayOfWeek = date.getDay();
    const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      // 2
      case "i":
        return String(isoDayOfWeek);
      // 02
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token.length);
      // 2nd
      case "io":
        return localize.ordinalNumber(isoDayOfWeek, { unit: "day" });
      // Tue
      case "iii":
        return localize.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting",
        });
      // T
      case "iiiii":
        return localize.day(dayOfWeek, {
          width: "narrow",
          context: "formatting",
        });
      // Tu
      case "iiiiii":
        return localize.day(dayOfWeek, {
          width: "short",
          context: "formatting",
        });
      // Tuesday
      case "iiii":
      default:
        return localize.day(dayOfWeek, {
          width: "wide",
          context: "formatting",
        });
    }
  },

  // AM or PM
  a: function (date, token, localize) {
    const hours = date.getHours();
    const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";

    switch (token) {
      case "a":
      case "aa":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting",
        });
      case "aaa":
        return localize
          .dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting",
          })
          .toLowerCase();
      case "aaaaa":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting",
        });
      case "aaaa":
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting",
        });
    }
  },

  // AM, PM, midnight, noon
  b: function (date, token, localize) {
    const hours = date.getHours();
    let dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }

    switch (token) {
      case "b":
      case "bb":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting",
        });
      case "bbb":
        return localize
          .dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting",
          })
          .toLowerCase();
      case "bbbbb":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting",
        });
      case "bbbb":
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting",
        });
    }
  },

  // in the morning, in the afternoon, in the evening, at night
  B: function (date, token, localize) {
    const hours = date.getHours();
    let dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }

    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting",
        });
      case "BBBBB":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting",
        });
      case "BBBB":
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting",
        });
    }
  },

  // Hour [1-12]
  h: function (date, token, localize) {
    if (token === "ho") {
      let hours = date.getHours() % 12;
      if (hours === 0) hours = 12;
      return localize.ordinalNumber(hours, { unit: "hour" });
    }

    return lightFormatters.h(date, token);
  },

  // Hour [0-23]
  H: function (date, token, localize) {
    if (token === "Ho") {
      return localize.ordinalNumber(date.getHours(), { unit: "hour" });
    }

    return lightFormatters.H(date, token);
  },

  // Hour [0-11]
  K: function (date, token, localize) {
    const hours = date.getHours() % 12;

    if (token === "Ko") {
      return localize.ordinalNumber(hours, { unit: "hour" });
    }

    return addLeadingZeros(hours, token.length);
  },

  // Hour [1-24]
  k: function (date, token, localize) {
    let hours = date.getHours();
    if (hours === 0) hours = 24;

    if (token === "ko") {
      return localize.ordinalNumber(hours, { unit: "hour" });
    }

    return addLeadingZeros(hours, token.length);
  },

  // Minute
  m: function (date, token, localize) {
    if (token === "mo") {
      return localize.ordinalNumber(date.getMinutes(), { unit: "minute" });
    }

    return lightFormatters.m(date, token);
  },

  // Second
  s: function (date, token, localize) {
    if (token === "so") {
      return localize.ordinalNumber(date.getSeconds(), { unit: "second" });
    }

    return lightFormatters.s(date, token);
  },

  // Fraction of second
  S: function (date, token) {
    return lightFormatters.S(date, token);
  },

  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function (date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();

    if (timezoneOffset === 0) {
      return "Z";
    }

    switch (token) {
      // Hours and optional minutes
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);

      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`
      case "XXXX":
      case "XX": // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);

      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`
      case "XXXXX":
      case "XXX": // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },

  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function (date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();

    switch (token) {
      // Hours and optional minutes
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);

      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`
      case "xxxx":
      case "xx": // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);

      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`
      case "xxxxx":
      case "xxx": // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },

  // Timezone (GMT)
  O: function (date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();

    switch (token) {
      // Short
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      // Long
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },

  // Timezone (specific non-location)
  z: function (date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();

    switch (token) {
      // Short
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      // Long
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },

  // Seconds timestamp
  t: function (date, token, _localize) {
    const timestamp = Math.trunc(+date / 1000);
    return addLeadingZeros(timestamp, token.length);
  },

  // Milliseconds timestamp
  T: function (date, token, _localize) {
    return addLeadingZeros(+date, token.length);
  },
};

function formatTimezoneShort(offset, delimiter = "") {
  const sign = offset > 0 ? "-" : "+";
  const absOffset = Math.abs(offset);
  const hours = Math.trunc(absOffset / 60);
  const minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}

function formatTimezoneWithOptionalMinutes(offset, delimiter) {
  if (offset % 60 === 0) {
    const sign = offset > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, delimiter);
}

function formatTimezone(offset, delimiter = "") {
  const sign = offset > 0 ? "-" : "+";
  const absOffset = Math.abs(offset);
  const hours = addLeadingZeros(Math.trunc(absOffset / 60), 2);
  const minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}

const dateLongFormatter = (pattern, formatLong) => {
  switch (pattern) {
    case "P":
      return formatLong.date({ width: "short" });
    case "PP":
      return formatLong.date({ width: "medium" });
    case "PPP":
      return formatLong.date({ width: "long" });
    case "PPPP":
    default:
      return formatLong.date({ width: "full" });
  }
};

const timeLongFormatter = (pattern, formatLong) => {
  switch (pattern) {
    case "p":
      return formatLong.time({ width: "short" });
    case "pp":
      return formatLong.time({ width: "medium" });
    case "ppp":
      return formatLong.time({ width: "long" });
    case "pppp":
    default:
      return formatLong.time({ width: "full" });
  }
};

const dateTimeLongFormatter = (pattern, formatLong) => {
  const matchResult = pattern.match(/(P+)(p+)?/) || [];
  const datePattern = matchResult[1];
  const timePattern = matchResult[2];

  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong);
  }

  let dateTimeFormat;

  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong.dateTime({ width: "short" });
      break;
    case "PP":
      dateTimeFormat = formatLong.dateTime({ width: "medium" });
      break;
    case "PPP":
      dateTimeFormat = formatLong.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong.dateTime({ width: "full" });
      break;
  }

  return dateTimeFormat
    .replace("{{date}}", dateLongFormatter(datePattern, formatLong))
    .replace("{{time}}", timeLongFormatter(timePattern, formatLong));
};

const longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter,
};

const dayOfYearTokenRE = /^D+$/;
const weekYearTokenRE = /^Y+$/;

const throwTokens = ["D", "DD", "YY", "YYYY"];

function isProtectedDayOfYearToken(token) {
  return dayOfYearTokenRE.test(token);
}

function isProtectedWeekYearToken(token) {
  return weekYearTokenRE.test(token);
}

function warnOrThrowProtectedError(token, format, input) {
  const _message = message(token, format, input);
  console.warn(_message);
  if (throwTokens.includes(token)) throw new RangeError(_message);
}

function message(token, format, input) {
  const subject = token[0] === "Y" ? "years" : "days of the month";
  return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}

// This RegExp consists of three parts separated by `|`:
// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps
const formattingTokensRegExp$1 =
  /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;

// This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`
const longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;

const escapedStringRegExp$1 = /^'([^]*?)'?$/;
const doubleQuoteRegExp$1 = /''/g;
const unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;

/**
 * The {@link format} function options.
 */

/**
 * @name format
 * @alias formatDate
 * @category Common Helpers
 * @summary Format the date.
 *
 * @description
 * Return the formatted date string in the given format. The result may vary by locale.
 *
 * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 * (see the last example)
 *
 * Format of the string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 7 below the table).
 *
 * Accepted patterns:
 * | Unit                            | Pattern | Result examples                   | Notes |
 * |---------------------------------|---------|-----------------------------------|-------|
 * | Era                             | G..GGG  | AD, BC                            |       |
 * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 | GGGGG   | A, B                              |       |
 * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
 * |                                 | yy      | 44, 01, 00, 17                    | 5     |
 * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
 * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
 * |                                 | yyyyy   | ...                               | 3,5   |
 * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
 * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
 * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
 * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
 * |                                 | YYYYY   | ...                               | 3,5   |
 * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
 * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
 * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
 * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
 * |                                 | RRRRR   | ...                               | 3,5,7 |
 * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
 * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
 * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
 * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
 * |                                 | uuuuu   | ...                               | 3,5   |
 * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
 * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | QQ      | 01, 02, 03, 04                    |       |
 * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
 * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | qq      | 01, 02, 03, 04                    |       |
 * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
 * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
 * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | MM      | 01, 02, ..., 12                   |       |
 * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 | MMMM    | January, February, ..., December  | 2     |
 * |                                 | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
 * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | LL      | 01, 02, ..., 12                   |       |
 * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 | LLLL    | January, February, ..., December  | 2     |
 * |                                 | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | w       | 1, 2, ..., 53                     |       |
 * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
 * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | II      | 01, 02, ..., 53                   | 7     |
 * | Day of month                    | d       | 1, 2, ..., 31                     |       |
 * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
 * |                                 | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
 * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
 * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
 * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 | DDDD    | ...                               | 3     |
 * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
 * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
 * |                                 | ii      | 01, 02, ..., 07                   | 7     |
 * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |
 * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
 * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
 * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 7     |
 * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | ee      | 02, 03, ..., 01                   |       |
 * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | cc      | 02, 03, ..., 01                   |       |
 * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          | a..aa   | AM, PM                            |       |
 * |                                 | aaa     | am, pm                            |       |
 * |                                 | aaaa    | a.m., p.m.                        | 2     |
 * |                                 | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |
 * |                                 | bbb     | am, pm, noon, midnight            |       |
 * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
 * |                                 | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
 * |                                 | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
 * |                                 | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
 * |                                 | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
 * |                                 | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          | m       | 0, 1, ..., 59                     |       |
 * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | mm      | 00, 01, ..., 59                   |       |
 * | Second                          | s       | 0, 1, ..., 59                     |       |
 * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | ss      | 00, 01, ..., 59                   |       |
 * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
 * |                                 | SS      | 00, 01, ..., 99                   |       |
 * |                                 | SSS     | 000, 001, ..., 999                |       |
 * |                                 | SSSS    | ...                               | 3     |
 * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
 * |                                 | XX      | -0800, +0530, Z                   |       |
 * |                                 | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
 * |                                 | xx      | -0800, +0530, +0000               |       |
 * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
 * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
 * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
 * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
 * | Seconds timestamp               | t       | 512969520                         | 7     |
 * |                                 | tt      | ...                               | 3,7   |
 * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
 * |                                 | TT      | ...                               | 3,7   |
 * | Long localized date             | P       | 04/29/1453                        | 7     |
 * |                                 | PP      | Apr 29, 1453                      | 7     |
 * |                                 | PPP     | April 29th, 1453                  | 7     |
 * |                                 | PPPP    | Friday, April 29th, 1453          | 2,7   |
 * | Long localized time             | p       | 12:00 AM                          | 7     |
 * |                                 | pp      | 12:00:00 AM                       | 7     |
 * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
 * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
 * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 7     |
 * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 7     |
 * |                                 | PPPppp  | April 29th, 1453 at ...           | 7     |
 * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 2,7   |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
 *    the output will be the same as default pattern for this unit, usually
 *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
 *    are marked with "2" in the last column of the table.
 *
 *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
 *
 * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
 *    The output will be padded with zeros to match the length of the pattern.
 *
 *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
 *
 * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 5. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` always returns the last two digits of a year,
 *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
 *
 *    | Year | `yy` | `uu` |
 *    |------|------|------|
 *    | 1    |   01 |   01 |
 *    | 14   |   14 |   14 |
 *    | 376  |   76 |  376 |
 *    | 1453 |   53 | 1453 |
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [getISOWeekYear](https://date-fns.org/docs/getISOWeekYear)
 *    and [getWeekYear](https://date-fns.org/docs/getWeekYear)).
 *
 * 6. Specific non-location timezones are currently unavailable in `date-fns`,
 *    so right now these tokens fall back to GMT timezones.
 *
 * 7. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `t`: seconds timestamp
 *    - `T`: milliseconds timestamp
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 9. `D` and `DD` tokens represent days of the year but they are often confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * @param date - The original date
 * @param format - The string of tokens
 * @param options - An object with options
 *
 * @returns The formatted date string
 *
 * @throws `date` must not be Invalid Date
 * @throws `options.locale` must contain `localize` property
 * @throws `options.locale` must contain `formatLong` property
 * @throws use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws format string contains an unescaped latin alphabet character
 *
 * @example
 * // Represent 11 February 2014 in middle-endian format:
 * const result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
 * //=> '02/11/2014'
 *
 * @example
 * // Represent 2 July 2014 in Esperanto:
 * import { eoLocale } from 'date-fns/locale/eo'
 * const result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
 *   locale: eoLocale
 * })
 * //=> '2-a de julio 2014'
 *
 * @example
 * // Escape string by single quote characters:
 * const result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
 * //=> "3 o'clock"
 */
function format(date, formatStr, options) {
  const defaultOptions = getDefaultOptions$1();
  const locale = defaultOptions.locale ?? enUS;

  const firstWeekContainsDate =
    defaultOptions.firstWeekContainsDate ??
    defaultOptions.locale?.options?.firstWeekContainsDate ??
    1;

  const weekStartsOn =
    defaultOptions.weekStartsOn ??
    defaultOptions.locale?.options?.weekStartsOn ??
    0;

  const originalDate = toDate(date, options?.in);

  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }

  let parts = formatStr
    .match(longFormattingTokensRegExp$1)
    .map((substring) => {
      const firstCharacter = substring[0];
      if (firstCharacter === "p" || firstCharacter === "P") {
        const longFormatter = longFormatters[firstCharacter];
        return longFormatter(substring, locale.formatLong);
      }
      return substring;
    })
    .join("")
    .match(formattingTokensRegExp$1)
    .map((substring) => {
      // Replace two single quote characters with one single quote character
      if (substring === "''") {
        return { isToken: false, value: "'" };
      }

      const firstCharacter = substring[0];
      if (firstCharacter === "'") {
        return { isToken: false, value: cleanEscapedString$1(substring) };
      }

      if (formatters[firstCharacter]) {
        return { isToken: true, value: substring };
      }

      if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
        throw new RangeError(
          "Format string contains an unescaped latin alphabet character `" +
            firstCharacter +
            "`",
        );
      }

      return { isToken: false, value: substring };
    });

  // invoke localize preprocessor (only for french locales at the moment)
  if (locale.localize.preprocessor) {
    parts = locale.localize.preprocessor(originalDate, parts);
  }

  const formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale,
  };

  return parts
    .map((part) => {
      if (!part.isToken) return part.value;

      const token = part.value;

      if (
        (isProtectedWeekYearToken(token)) ||
        (isProtectedDayOfYearToken(token))
      ) {
        warnOrThrowProtectedError(token, formatStr, String(date));
      }

      const formatter = formatters[token[0]];
      return formatter(originalDate, token, locale.localize, formatterOptions);
    })
    .join("");
}

function cleanEscapedString$1(input) {
  const matched = input.match(escapedStringRegExp$1);

  if (!matched) {
    return input;
  }

  return matched[1].replace(doubleQuoteRegExp$1, "'");
}

/**
 * @name getDefaultOptions
 * @category Common Helpers
 * @summary Get default options.
 * @pure false
 *
 * @description
 * Returns an object that contains defaults for
 * `options.locale`, `options.weekStartsOn` and `options.firstWeekContainsDate`
 * arguments for all functions.
 *
 * You can change these with [setDefaultOptions](https://date-fns.org/docs/setDefaultOptions).
 *
 * @returns The default options
 *
 * @example
 * const result = getDefaultOptions()
 * //=> {}
 *
 * @example
 * setDefaultOptions({ weekStarsOn: 1, firstWeekContainsDate: 4 })
 * const result = getDefaultOptions()
 * //=> { weekStarsOn: 1, firstWeekContainsDate: 4 }
 */
function getDefaultOptions() {
  return Object.assign({}, getDefaultOptions$1());
}

/**
 * The {@link getISODay} function options.
 */

/**
 * @name getISODay
 * @category Weekday Helpers
 * @summary Get the day of the ISO week of the given date.
 *
 * @description
 * Get the day of the ISO week of the given date,
 * which is 7 for Sunday, 1 for Monday etc.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param date - The given date
 * @param options - An object with options
 *
 * @returns The day of ISO week
 *
 * @example
 * // Which day of the ISO week is 26 February 2012?
 * const result = getISODay(new Date(2012, 1, 26))
 * //=> 7
 */
function getISODay(date, options) {
  const day = toDate(date, options?.in).getDay();
  return day === 0 ? 7 : day;
}

/**
 * @name transpose
 * @category Generic Helpers
 * @summary Transpose the date to the given constructor.
 *
 * @description
 * The function transposes the date to the given constructor. It helps you
 * to transpose the date in the system time zone to say `UTCDate` or any other
 * date extension.
 *
 * @typeParam InputDate - The input `Date` type derived from the passed argument.
 * @typeParam ResultDate - The result `Date` type derived from the passed constructor.
 *
 * @param date - The date to use values from
 * @param constructor - The date constructor to use
 *
 * @returns Date transposed to the given constructor
 *
 * @example
 * // Create July 10, 2022 00:00 in locale time zone
 * const date = new Date(2022, 6, 10)
 * //=> 'Sun Jul 10 2022 00:00:00 GMT+0800 (Singapore Standard Time)'
 *
 * @example
 * // Transpose the date to July 10, 2022 00:00 in UTC
 * transpose(date, UTCDate)
 * //=> 'Sun Jul 10 2022 00:00:00 GMT+0000 (Coordinated Universal Time)'
 */
function transpose(date, constructor) {
  const date_ = isConstructor(constructor)
    ? new constructor(0)
    : constructFrom(constructor, 0);
  date_.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
  date_.setHours(
    date.getHours(),
    date.getMinutes(),
    date.getSeconds(),
    date.getMilliseconds(),
  );
  return date_;
}

function isConstructor(constructor) {
  return (
    typeof constructor === "function" &&
    constructor.prototype?.constructor === constructor
  );
}

const TIMEZONE_UNIT_PRIORITY = 10;

class Setter {
  subPriority = 0;

  validate(_utcDate, _options) {
    return true;
  }
}

class ValueSetter extends Setter {
  constructor(
    value,

    validateValue,

    setValue,

    priority,
    subPriority,
  ) {
    super();
    this.value = value;
    this.validateValue = validateValue;
    this.setValue = setValue;
    this.priority = priority;
    if (subPriority) {
      this.subPriority = subPriority;
    }
  }

  validate(date, options) {
    return this.validateValue(date, this.value, options);
  }

  set(date, flags, options) {
    return this.setValue(date, flags, this.value, options);
  }
}

class DateTimezoneSetter extends Setter {
  priority = TIMEZONE_UNIT_PRIORITY;
  subPriority = -1;

  constructor(context, reference) {
    super();
    this.context = context || ((date) => constructFrom(reference, date));
  }

  set(date, flags) {
    if (flags.timestampIsSet) return date;
    return constructFrom(date, transpose(date, this.context));
  }
}

class Parser {
  run(dateString, token, match, options) {
    const result = this.parse(dateString, token, match, options);
    if (!result) {
      return null;
    }

    return {
      setter: new ValueSetter(
        result.value,
        this.validate,
        this.set,
        this.priority,
        this.subPriority,
      ),
      rest: result.rest,
    };
  }

  validate(_utcDate, _value, _options) {
    return true;
  }
}

class EraParser extends Parser {
  priority = 140;

  parse(dateString, token, match) {
    switch (token) {
      // AD, BC
      case "G":
      case "GG":
      case "GGG":
        return (
          match.era(dateString, { width: "abbreviated" }) ||
          match.era(dateString, { width: "narrow" })
        );

      // A, B
      case "GGGGG":
        return match.era(dateString, { width: "narrow" });
      // Anno Domini, Before Christ
      case "GGGG":
      default:
        return (
          match.era(dateString, { width: "wide" }) ||
          match.era(dateString, { width: "abbreviated" }) ||
          match.era(dateString, { width: "narrow" })
        );
    }
  }

  set(date, flags, value) {
    flags.era = value;
    date.setFullYear(value, 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = ["R", "u", "t", "T"];
}

const numericPatterns = {
  month: /^(1[0-2]|0?\d)/, // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/, // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/, // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/, // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/, // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/, // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/, // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/, // 0 to 12
  minute: /^[0-5]?\d/, // 0 to 59
  second: /^[0-5]?\d/, // 0 to 59

  singleDigit: /^\d/, // 0 to 9
  twoDigits: /^\d{1,2}/, // 0 to 99
  threeDigits: /^\d{1,3}/, // 0 to 999
  fourDigits: /^\d{1,4}/, // 0 to 9999

  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/, // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/, // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/, // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/, // 0 to 9999, -0 to -9999
};

const timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/,
};

function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }

  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest,
  };
}

function parseNumericPattern(pattern, dateString) {
  const matchResult = dateString.match(pattern);

  if (!matchResult) {
    return null;
  }

  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length),
  };
}

function parseTimezonePattern(pattern, dateString) {
  const matchResult = dateString.match(pattern);

  if (!matchResult) {
    return null;
  }

  // Input is 'Z'
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: dateString.slice(1),
    };
  }

  const sign = matchResult[1] === "+" ? 1 : -1;
  const hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  const minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  const seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;

  return {
    value:
      sign *
      (hours * millisecondsInHour +
        minutes * millisecondsInMinute +
        seconds * millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length),
  };
}

function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
}

function parseNDigits(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, dateString);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
  }
}

function parseNDigitsSigned(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
  }
}

function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}

function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  const isCommonEra = currentYear > 0;
  // Absolute number of the current year:
  // 1 -> 1 AC
  // 0 -> 1 BC
  // -1 -> 2 BC
  const absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;

  let result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    const rangeEnd = absCurrentYear + 50;
    const rangeEndCentury = Math.trunc(rangeEnd / 100) * 100;
    const isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }

  return isCommonEra ? result : 1 - result;
}

function isLeapYearIndex(year) {
  return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0);
}

// From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns
// | Year     |     y | yy |   yyy |  yyyy | yyyyy |
// |----------|-------|----|-------|-------|-------|
// | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
// | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
// | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
// | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
// | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
class YearParser extends Parser {
  priority = 130;
  incompatibleTokens = ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"];

  parse(dateString, token, match) {
    const valueCallback = (year) => ({
      year,
      isTwoDigitYear: token === "yy",
    });

    switch (token) {
      case "y":
        return mapValue(parseNDigits(4, dateString), valueCallback);
      case "yo":
        return mapValue(
          match.ordinalNumber(dateString, {
            unit: "year",
          }),
          valueCallback,
        );
      default:
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
  }

  validate(_date, value) {
    return value.isTwoDigitYear || value.year > 0;
  }

  set(date, flags, value) {
    const currentYear = date.getFullYear();

    if (value.isTwoDigitYear) {
      const normalizedTwoDigitYear = normalizeTwoDigitYear(
        value.year,
        currentYear,
      );
      date.setFullYear(normalizedTwoDigitYear, 0, 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    const year =
      !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
    date.setFullYear(year, 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
}

// Local week-numbering year
class LocalWeekYearParser extends Parser {
  priority = 130;

  parse(dateString, token, match) {
    const valueCallback = (year) => ({
      year,
      isTwoDigitYear: token === "YY",
    });

    switch (token) {
      case "Y":
        return mapValue(parseNDigits(4, dateString), valueCallback);
      case "Yo":
        return mapValue(
          match.ordinalNumber(dateString, {
            unit: "year",
          }),
          valueCallback,
        );
      default:
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
  }

  validate(_date, value) {
    return value.isTwoDigitYear || value.year > 0;
  }

  set(date, flags, value, options) {
    const currentYear = getWeekYear(date, options);

    if (value.isTwoDigitYear) {
      const normalizedTwoDigitYear = normalizeTwoDigitYear(
        value.year,
        currentYear,
      );
      date.setFullYear(
        normalizedTwoDigitYear,
        0,
        options.firstWeekContainsDate,
      );
      date.setHours(0, 0, 0, 0);
      return startOfWeek(date, options);
    }

    const year =
      !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
    date.setFullYear(year, 0, options.firstWeekContainsDate);
    date.setHours(0, 0, 0, 0);
    return startOfWeek(date, options);
  }

  incompatibleTokens = [
    "y",
    "R",
    "u",
    "Q",
    "q",
    "M",
    "L",
    "I",
    "d",
    "D",
    "i",
    "t",
    "T",
  ];
}

// ISO week-numbering year
class ISOWeekYearParser extends Parser {
  priority = 130;

  parse(dateString, token) {
    if (token === "R") {
      return parseNDigitsSigned(4, dateString);
    }

    return parseNDigitsSigned(token.length, dateString);
  }

  set(date, _flags, value) {
    const firstWeekOfYear = constructFrom(date, 0);
    firstWeekOfYear.setFullYear(value, 0, 4);
    firstWeekOfYear.setHours(0, 0, 0, 0);
    return startOfISOWeek(firstWeekOfYear);
  }

  incompatibleTokens = [
    "G",
    "y",
    "Y",
    "u",
    "Q",
    "q",
    "M",
    "L",
    "w",
    "d",
    "D",
    "e",
    "c",
    "t",
    "T",
  ];
}

class ExtendedYearParser extends Parser {
  priority = 130;

  parse(dateString, token) {
    if (token === "u") {
      return parseNDigitsSigned(4, dateString);
    }

    return parseNDigitsSigned(token.length, dateString);
  }

  set(date, _flags, value) {
    date.setFullYear(value, 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"];
}

class QuarterParser extends Parser {
  priority = 120;

  parse(dateString, token, match) {
    switch (token) {
      // 1, 2, 3, 4
      case "Q":
      case "QQ": // 01, 02, 03, 04
        return parseNDigits(token.length, dateString);
      // 1st, 2nd, 3rd, 4th
      case "Qo":
        return match.ordinalNumber(dateString, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "QQQ":
        return (
          match.quarter(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.quarter(dateString, {
            width: "narrow",
            context: "formatting",
          })
        );

      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "QQQQQ":
        return match.quarter(dateString, {
          width: "narrow",
          context: "formatting",
        });
      // 1st quarter, 2nd quarter, ...
      case "QQQQ":
      default:
        return (
          match.quarter(dateString, {
            width: "wide",
            context: "formatting",
          }) ||
          match.quarter(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.quarter(dateString, {
            width: "narrow",
            context: "formatting",
          })
        );
    }
  }

  validate(_date, value) {
    return value >= 1 && value <= 4;
  }

  set(date, _flags, value) {
    date.setMonth((value - 1) * 3, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "M",
    "L",
    "w",
    "I",
    "d",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T",
  ];
}

class StandAloneQuarterParser extends Parser {
  priority = 120;

  parse(dateString, token, match) {
    switch (token) {
      // 1, 2, 3, 4
      case "q":
      case "qq": // 01, 02, 03, 04
        return parseNDigits(token.length, dateString);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return match.ordinalNumber(dateString, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return (
          match.quarter(dateString, {
            width: "abbreviated",
            context: "standalone",
          }) ||
          match.quarter(dateString, {
            width: "narrow",
            context: "standalone",
          })
        );

      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return match.quarter(dateString, {
          width: "narrow",
          context: "standalone",
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return (
          match.quarter(dateString, {
            width: "wide",
            context: "standalone",
          }) ||
          match.quarter(dateString, {
            width: "abbreviated",
            context: "standalone",
          }) ||
          match.quarter(dateString, {
            width: "narrow",
            context: "standalone",
          })
        );
    }
  }

  validate(_date, value) {
    return value >= 1 && value <= 4;
  }

  set(date, _flags, value) {
    date.setMonth((value - 1) * 3, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = [
    "Y",
    "R",
    "Q",
    "M",
    "L",
    "w",
    "I",
    "d",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T",
  ];
}

class MonthParser extends Parser {
  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "Q",
    "L",
    "w",
    "I",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T",
  ];

  priority = 110;

  parse(dateString, token, match) {
    const valueCallback = (value) => value - 1;

    switch (token) {
      // 1, 2, ..., 12
      case "M":
        return mapValue(
          parseNumericPattern(numericPatterns.month, dateString),
          valueCallback,
        );
      // 01, 02, ..., 12
      case "MM":
        return mapValue(parseNDigits(2, dateString), valueCallback);
      // 1st, 2nd, ..., 12th
      case "Mo":
        return mapValue(
          match.ordinalNumber(dateString, {
            unit: "month",
          }),
          valueCallback,
        );
      // Jan, Feb, ..., Dec
      case "MMM":
        return (
          match.month(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.month(dateString, { width: "narrow", context: "formatting" })
        );

      // J, F, ..., D
      case "MMMMM":
        return match.month(dateString, {
          width: "narrow",
          context: "formatting",
        });
      // January, February, ..., December
      case "MMMM":
      default:
        return (
          match.month(dateString, { width: "wide", context: "formatting" }) ||
          match.month(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.month(dateString, { width: "narrow", context: "formatting" })
        );
    }
  }

  validate(_date, value) {
    return value >= 0 && value <= 11;
  }

  set(date, _flags, value) {
    date.setMonth(value, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
}

class StandAloneMonthParser extends Parser {
  priority = 110;

  parse(dateString, token, match) {
    const valueCallback = (value) => value - 1;

    switch (token) {
      // 1, 2, ..., 12
      case "L":
        return mapValue(
          parseNumericPattern(numericPatterns.month, dateString),
          valueCallback,
        );
      // 01, 02, ..., 12
      case "LL":
        return mapValue(parseNDigits(2, dateString), valueCallback);
      // 1st, 2nd, ..., 12th
      case "Lo":
        return mapValue(
          match.ordinalNumber(dateString, {
            unit: "month",
          }),
          valueCallback,
        );
      // Jan, Feb, ..., Dec
      case "LLL":
        return (
          match.month(dateString, {
            width: "abbreviated",
            context: "standalone",
          }) ||
          match.month(dateString, { width: "narrow", context: "standalone" })
        );

      // J, F, ..., D
      case "LLLLL":
        return match.month(dateString, {
          width: "narrow",
          context: "standalone",
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return (
          match.month(dateString, { width: "wide", context: "standalone" }) ||
          match.month(dateString, {
            width: "abbreviated",
            context: "standalone",
          }) ||
          match.month(dateString, { width: "narrow", context: "standalone" })
        );
    }
  }

  validate(_date, value) {
    return value >= 0 && value <= 11;
  }

  set(date, _flags, value) {
    date.setMonth(value, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "Q",
    "M",
    "w",
    "I",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T",
  ];
}

/**
 * The {@link setWeek} function options.
 */

/**
 * @name setWeek
 * @category Week Helpers
 * @summary Set the local week to the given date.
 *
 * @description
 * Set the local week to the given date, saving the weekday number.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param week - The week of the new date
 * @param options - An object with options
 *
 * @returns The new date with the local week set
 *
 * @example
 * // Set the 1st week to 2 January 2005 with default options:
 * const result = setWeek(new Date(2005, 0, 2), 1)
 * //=> Sun Dec 26 2004 00:00:00
 *
 * @example
 * // Set the 1st week to 2 January 2005,
 * // if Monday is the first day of the week,
 * // and the first week of the year always contains 4 January:
 * const result = setWeek(new Date(2005, 0, 2), 1, {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> Sun Jan 4 2004 00:00:00
 */
function setWeek(date, week, options) {
  const date_ = toDate(date, options?.in);
  const diff = getWeek(date_, options) - week;
  date_.setDate(date_.getDate() - diff * 7);
  return toDate(date_, options?.in);
}

// Local week of year
class LocalWeekParser extends Parser {
  priority = 100;

  parse(dateString, token, match) {
    switch (token) {
      case "w":
        return parseNumericPattern(numericPatterns.week, dateString);
      case "wo":
        return match.ordinalNumber(dateString, { unit: "week" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }

  validate(_date, value) {
    return value >= 1 && value <= 53;
  }

  set(date, _flags, value, options) {
    return startOfWeek(setWeek(date, value, options), options);
  }

  incompatibleTokens = [
    "y",
    "R",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "I",
    "d",
    "D",
    "i",
    "t",
    "T",
  ];
}

/**
 * The {@link setISOWeek} function options.
 */

/**
 * @name setISOWeek
 * @category ISO Week Helpers
 * @summary Set the ISO week to the given date.
 *
 * @description
 * Set the ISO week to the given date, saving the weekday number.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The `Date` type of the context function.
 *
 * @param date - The date to be changed
 * @param week - The ISO week of the new date
 * @param options - An object with options
 *
 * @returns The new date with the ISO week set
 *
 * @example
 * // Set the 53rd ISO week to 7 August 2004:
 * const result = setISOWeek(new Date(2004, 7, 7), 53)
 * //=> Sat Jan 01 2005 00:00:00
 */
function setISOWeek(date, week, options) {
  const _date = toDate(date, options?.in);
  const diff = getISOWeek(_date, options) - week;
  _date.setDate(_date.getDate() - diff * 7);
  return _date;
}

// ISO week of year
class ISOWeekParser extends Parser {
  priority = 100;

  parse(dateString, token, match) {
    switch (token) {
      case "I":
        return parseNumericPattern(numericPatterns.week, dateString);
      case "Io":
        return match.ordinalNumber(dateString, { unit: "week" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }

  validate(_date, value) {
    return value >= 1 && value <= 53;
  }

  set(date, _flags, value) {
    return startOfISOWeek(setISOWeek(date, value));
  }

  incompatibleTokens = [
    "y",
    "Y",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "w",
    "d",
    "D",
    "e",
    "c",
    "t",
    "T",
  ];
}

const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const DAYS_IN_MONTH_LEAP_YEAR = [
  31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31,
];

// Day of the month
class DateParser extends Parser {
  priority = 90;
  subPriority = 1;

  parse(dateString, token, match) {
    switch (token) {
      case "d":
        return parseNumericPattern(numericPatterns.date, dateString);
      case "do":
        return match.ordinalNumber(dateString, { unit: "date" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }

  validate(date, value) {
    const year = date.getFullYear();
    const isLeapYear = isLeapYearIndex(year);
    const month = date.getMonth();
    if (isLeapYear) {
      return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
    } else {
      return value >= 1 && value <= DAYS_IN_MONTH[month];
    }
  }

  set(date, _flags, value) {
    date.setDate(value);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "Q",
    "w",
    "I",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T",
  ];
}

class DayOfYearParser extends Parser {
  priority = 90;

  subpriority = 1;

  parse(dateString, token, match) {
    switch (token) {
      case "D":
      case "DD":
        return parseNumericPattern(numericPatterns.dayOfYear, dateString);
      case "Do":
        return match.ordinalNumber(dateString, { unit: "date" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }

  validate(date, value) {
    const year = date.getFullYear();
    const isLeapYear = isLeapYearIndex(year);
    if (isLeapYear) {
      return value >= 1 && value <= 366;
    } else {
      return value >= 1 && value <= 365;
    }
  }

  set(date, _flags, value) {
    date.setMonth(0, value);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "Q",
    "M",
    "L",
    "w",
    "I",
    "d",
    "E",
    "i",
    "e",
    "c",
    "t",
    "T",
  ];
}

/**
 * The {@link setDay} function options.
 */

/**
 * @name setDay
 * @category Weekday Helpers
 * @summary Set the day of the week to the given date.
 *
 * @description
 * Set the day of the week to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param day - The day of the week of the new date
 * @param options - An object with options.
 *
 * @returns The new date with the day of the week set
 *
 * @example
 * // Set week day to Sunday, with the default weekStartsOn of Sunday:
 * const result = setDay(new Date(2014, 8, 1), 0)
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // Set week day to Sunday, with a weekStartsOn of Monday:
 * const result = setDay(new Date(2014, 8, 1), 0, { weekStartsOn: 1 })
 * //=> Sun Sep 07 2014 00:00:00
 */
function setDay(date, day, options) {
  const defaultOptions = getDefaultOptions$1();
  const weekStartsOn =
    options?.weekStartsOn ??
    options?.locale?.options?.weekStartsOn ??
    defaultOptions.weekStartsOn ??
    defaultOptions.locale?.options?.weekStartsOn ??
    0;

  const date_ = toDate(date, options?.in);
  const currentDay = date_.getDay();

  const remainder = day % 7;
  const dayIndex = (remainder + 7) % 7;

  const delta = 7 - weekStartsOn;
  const diff =
    day < 0 || day > 6
      ? day - ((currentDay + delta) % 7)
      : ((dayIndex + delta) % 7) - ((currentDay + delta) % 7);
  return addDays(date_, diff, options);
}

// Day of week
class DayParser extends Parser {
  priority = 90;

  parse(dateString, token, match) {
    switch (token) {
      // Tue
      case "E":
      case "EE":
      case "EEE":
        return (
          match.day(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.day(dateString, { width: "short", context: "formatting" }) ||
          match.day(dateString, { width: "narrow", context: "formatting" })
        );

      // T
      case "EEEEE":
        return match.day(dateString, {
          width: "narrow",
          context: "formatting",
        });
      // Tu
      case "EEEEEE":
        return (
          match.day(dateString, { width: "short", context: "formatting" }) ||
          match.day(dateString, { width: "narrow", context: "formatting" })
        );

      // Tuesday
      case "EEEE":
      default:
        return (
          match.day(dateString, { width: "wide", context: "formatting" }) ||
          match.day(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.day(dateString, { width: "short", context: "formatting" }) ||
          match.day(dateString, { width: "narrow", context: "formatting" })
        );
    }
  }

  validate(_date, value) {
    return value >= 0 && value <= 6;
  }

  set(date, _flags, value, options) {
    date = setDay(date, value, options);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = ["D", "i", "e", "c", "t", "T"];
}

// Local day of week
class LocalDayParser extends Parser {
  priority = 90;
  parse(dateString, token, match, options) {
    const valueCallback = (value) => {
      // We want here floor instead of trunc, so we get -7 for value 0 instead of 0
      const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
      return ((value + options.weekStartsOn + 6) % 7) + wholeWeekDays;
    };

    switch (token) {
      // 3
      case "e":
      case "ee": // 03
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
      // 3rd
      case "eo":
        return mapValue(
          match.ordinalNumber(dateString, {
            unit: "day",
          }),
          valueCallback,
        );
      // Tue
      case "eee":
        return (
          match.day(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.day(dateString, { width: "short", context: "formatting" }) ||
          match.day(dateString, { width: "narrow", context: "formatting" })
        );

      // T
      case "eeeee":
        return match.day(dateString, {
          width: "narrow",
          context: "formatting",
        });
      // Tu
      case "eeeeee":
        return (
          match.day(dateString, { width: "short", context: "formatting" }) ||
          match.day(dateString, { width: "narrow", context: "formatting" })
        );

      // Tuesday
      case "eeee":
      default:
        return (
          match.day(dateString, { width: "wide", context: "formatting" }) ||
          match.day(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.day(dateString, { width: "short", context: "formatting" }) ||
          match.day(dateString, { width: "narrow", context: "formatting" })
        );
    }
  }

  validate(_date, value) {
    return value >= 0 && value <= 6;
  }

  set(date, _flags, value, options) {
    date = setDay(date, value, options);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = [
    "y",
    "R",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "I",
    "d",
    "D",
    "E",
    "i",
    "c",
    "t",
    "T",
  ];
}

// Stand-alone local day of week
class StandAloneLocalDayParser extends Parser {
  priority = 90;

  parse(dateString, token, match, options) {
    const valueCallback = (value) => {
      // We want here floor instead of trunc, so we get -7 for value 0 instead of 0
      const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
      return ((value + options.weekStartsOn + 6) % 7) + wholeWeekDays;
    };

    switch (token) {
      // 3
      case "c":
      case "cc": // 03
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
      // 3rd
      case "co":
        return mapValue(
          match.ordinalNumber(dateString, {
            unit: "day",
          }),
          valueCallback,
        );
      // Tue
      case "ccc":
        return (
          match.day(dateString, {
            width: "abbreviated",
            context: "standalone",
          }) ||
          match.day(dateString, { width: "short", context: "standalone" }) ||
          match.day(dateString, { width: "narrow", context: "standalone" })
        );

      // T
      case "ccccc":
        return match.day(dateString, {
          width: "narrow",
          context: "standalone",
        });
      // Tu
      case "cccccc":
        return (
          match.day(dateString, { width: "short", context: "standalone" }) ||
          match.day(dateString, { width: "narrow", context: "standalone" })
        );

      // Tuesday
      case "cccc":
      default:
        return (
          match.day(dateString, { width: "wide", context: "standalone" }) ||
          match.day(dateString, {
            width: "abbreviated",
            context: "standalone",
          }) ||
          match.day(dateString, { width: "short", context: "standalone" }) ||
          match.day(dateString, { width: "narrow", context: "standalone" })
        );
    }
  }

  validate(_date, value) {
    return value >= 0 && value <= 6;
  }

  set(date, _flags, value, options) {
    date = setDay(date, value, options);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = [
    "y",
    "R",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "I",
    "d",
    "D",
    "E",
    "i",
    "e",
    "t",
    "T",
  ];
}

/**
 * The {@link setISODay} function options.
 */

/**
 * @name setISODay
 * @category Weekday Helpers
 * @summary Set the day of the ISO week to the given date.
 *
 * @description
 * Set the day of the ISO week to the given date.
 * ISO week starts with Monday.
 * 7 is the index of Sunday, 1 is the index of Monday, etc.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param day - The day of the ISO week of the new date
 * @param options - An object with options
 *
 * @returns The new date with the day of the ISO week set
 *
 * @example
 * // Set Sunday to 1 September 2014:
 * const result = setISODay(new Date(2014, 8, 1), 7)
 * //=> Sun Sep 07 2014 00:00:00
 */
function setISODay(date, day, options) {
  const date_ = toDate(date, options?.in);
  const currentDay = getISODay(date_, options);
  const diff = day - currentDay;
  return addDays(date_, diff, options);
}

// ISO day of week
class ISODayParser extends Parser {
  priority = 90;

  parse(dateString, token, match) {
    const valueCallback = (value) => {
      if (value === 0) {
        return 7;
      }
      return value;
    };

    switch (token) {
      // 2
      case "i":
      case "ii": // 02
        return parseNDigits(token.length, dateString);
      // 2nd
      case "io":
        return match.ordinalNumber(dateString, { unit: "day" });
      // Tue
      case "iii":
        return mapValue(
          match.day(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
            match.day(dateString, {
              width: "short",
              context: "formatting",
            }) ||
            match.day(dateString, {
              width: "narrow",
              context: "formatting",
            }),
          valueCallback,
        );
      // T
      case "iiiii":
        return mapValue(
          match.day(dateString, {
            width: "narrow",
            context: "formatting",
          }),
          valueCallback,
        );
      // Tu
      case "iiiiii":
        return mapValue(
          match.day(dateString, {
            width: "short",
            context: "formatting",
          }) ||
            match.day(dateString, {
              width: "narrow",
              context: "formatting",
            }),
          valueCallback,
        );
      // Tuesday
      case "iiii":
      default:
        return mapValue(
          match.day(dateString, {
            width: "wide",
            context: "formatting",
          }) ||
            match.day(dateString, {
              width: "abbreviated",
              context: "formatting",
            }) ||
            match.day(dateString, {
              width: "short",
              context: "formatting",
            }) ||
            match.day(dateString, {
              width: "narrow",
              context: "formatting",
            }),
          valueCallback,
        );
    }
  }

  validate(_date, value) {
    return value >= 1 && value <= 7;
  }

  set(date, _flags, value) {
    date = setISODay(date, value);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = [
    "y",
    "Y",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "w",
    "d",
    "D",
    "E",
    "e",
    "c",
    "t",
    "T",
  ];
}

class AMPMParser extends Parser {
  priority = 80;

  parse(dateString, token, match) {
    switch (token) {
      case "a":
      case "aa":
      case "aaa":
        return (
          match.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting",
          })
        );

      case "aaaaa":
        return match.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting",
        });
      case "aaaa":
      default:
        return (
          match.dayPeriod(dateString, {
            width: "wide",
            context: "formatting",
          }) ||
          match.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting",
          })
        );
    }
  }

  set(date, _flags, value) {
    date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date;
  }

  incompatibleTokens = ["b", "B", "H", "k", "t", "T"];
}

class AMPMMidnightParser extends Parser {
  priority = 80;

  parse(dateString, token, match) {
    switch (token) {
      case "b":
      case "bb":
      case "bbb":
        return (
          match.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting",
          })
        );

      case "bbbbb":
        return match.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting",
        });
      case "bbbb":
      default:
        return (
          match.dayPeriod(dateString, {
            width: "wide",
            context: "formatting",
          }) ||
          match.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting",
          })
        );
    }
  }

  set(date, _flags, value) {
    date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date;
  }

  incompatibleTokens = ["a", "B", "H", "k", "t", "T"];
}

// in the morning, in the afternoon, in the evening, at night
class DayPeriodParser extends Parser {
  priority = 80;

  parse(dateString, token, match) {
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return (
          match.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting",
          })
        );

      case "BBBBB":
        return match.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting",
        });
      case "BBBB":
      default:
        return (
          match.dayPeriod(dateString, {
            width: "wide",
            context: "formatting",
          }) ||
          match.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting",
          }) ||
          match.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting",
          })
        );
    }
  }

  set(date, _flags, value) {
    date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date;
  }

  incompatibleTokens = ["a", "b", "t", "T"];
}

class Hour1to12Parser extends Parser {
  priority = 70;

  parse(dateString, token, match) {
    switch (token) {
      case "h":
        return parseNumericPattern(numericPatterns.hour12h, dateString);
      case "ho":
        return match.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }

  validate(_date, value) {
    return value >= 1 && value <= 12;
  }

  set(date, _flags, value) {
    const isPM = date.getHours() >= 12;
    if (isPM && value < 12) {
      date.setHours(value + 12, 0, 0, 0);
    } else if (!isPM && value === 12) {
      date.setHours(0, 0, 0, 0);
    } else {
      date.setHours(value, 0, 0, 0);
    }
    return date;
  }

  incompatibleTokens = ["H", "K", "k", "t", "T"];
}

class Hour0to23Parser extends Parser {
  priority = 70;

  parse(dateString, token, match) {
    switch (token) {
      case "H":
        return parseNumericPattern(numericPatterns.hour23h, dateString);
      case "Ho":
        return match.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }

  validate(_date, value) {
    return value >= 0 && value <= 23;
  }

  set(date, _flags, value) {
    date.setHours(value, 0, 0, 0);
    return date;
  }

  incompatibleTokens = ["a", "b", "h", "K", "k", "t", "T"];
}

class Hour0To11Parser extends Parser {
  priority = 70;

  parse(dateString, token, match) {
    switch (token) {
      case "K":
        return parseNumericPattern(numericPatterns.hour11h, dateString);
      case "Ko":
        return match.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }

  validate(_date, value) {
    return value >= 0 && value <= 11;
  }

  set(date, _flags, value) {
    const isPM = date.getHours() >= 12;
    if (isPM && value < 12) {
      date.setHours(value + 12, 0, 0, 0);
    } else {
      date.setHours(value, 0, 0, 0);
    }
    return date;
  }

  incompatibleTokens = ["h", "H", "k", "t", "T"];
}

class Hour1To24Parser extends Parser {
  priority = 70;

  parse(dateString, token, match) {
    switch (token) {
      case "k":
        return parseNumericPattern(numericPatterns.hour24h, dateString);
      case "ko":
        return match.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }

  validate(_date, value) {
    return value >= 1 && value <= 24;
  }

  set(date, _flags, value) {
    const hours = value <= 24 ? value % 24 : value;
    date.setHours(hours, 0, 0, 0);
    return date;
  }

  incompatibleTokens = ["a", "b", "h", "H", "K", "t", "T"];
}

class MinuteParser extends Parser {
  priority = 60;

  parse(dateString, token, match) {
    switch (token) {
      case "m":
        return parseNumericPattern(numericPatterns.minute, dateString);
      case "mo":
        return match.ordinalNumber(dateString, { unit: "minute" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }

  validate(_date, value) {
    return value >= 0 && value <= 59;
  }

  set(date, _flags, value) {
    date.setMinutes(value, 0, 0);
    return date;
  }

  incompatibleTokens = ["t", "T"];
}

class SecondParser extends Parser {
  priority = 50;

  parse(dateString, token, match) {
    switch (token) {
      case "s":
        return parseNumericPattern(numericPatterns.second, dateString);
      case "so":
        return match.ordinalNumber(dateString, { unit: "second" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }

  validate(_date, value) {
    return value >= 0 && value <= 59;
  }

  set(date, _flags, value) {
    date.setSeconds(value, 0);
    return date;
  }

  incompatibleTokens = ["t", "T"];
}

class FractionOfSecondParser extends Parser {
  priority = 30;

  parse(dateString, token) {
    const valueCallback = (value) =>
      Math.trunc(value * Math.pow(10, -token.length + 3));
    return mapValue(parseNDigits(token.length, dateString), valueCallback);
  }

  set(date, _flags, value) {
    date.setMilliseconds(value);
    return date;
  }

  incompatibleTokens = ["t", "T"];
}

// Timezone (ISO-8601. +00:00 is `'Z'`)
class ISOTimezoneWithZParser extends Parser {
  priority = 10;

  parse(dateString, token) {
    switch (token) {
      case "X":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalMinutes,
          dateString,
        );
      case "XX":
        return parseTimezonePattern(timezonePatterns.basic, dateString);
      case "XXXX":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalSeconds,
          dateString,
        );
      case "XXXXX":
        return parseTimezonePattern(
          timezonePatterns.extendedOptionalSeconds,
          dateString,
        );
      case "XXX":
      default:
        return parseTimezonePattern(timezonePatterns.extended, dateString);
    }
  }

  set(date, flags, value) {
    if (flags.timestampIsSet) return date;
    return constructFrom(
      date,
      date.getTime() - getTimezoneOffsetInMilliseconds(date) - value,
    );
  }

  incompatibleTokens = ["t", "T", "x"];
}

// Timezone (ISO-8601)
class ISOTimezoneParser extends Parser {
  priority = 10;

  parse(dateString, token) {
    switch (token) {
      case "x":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalMinutes,
          dateString,
        );
      case "xx":
        return parseTimezonePattern(timezonePatterns.basic, dateString);
      case "xxxx":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalSeconds,
          dateString,
        );
      case "xxxxx":
        return parseTimezonePattern(
          timezonePatterns.extendedOptionalSeconds,
          dateString,
        );
      case "xxx":
      default:
        return parseTimezonePattern(timezonePatterns.extended, dateString);
    }
  }

  set(date, flags, value) {
    if (flags.timestampIsSet) return date;
    return constructFrom(
      date,
      date.getTime() - getTimezoneOffsetInMilliseconds(date) - value,
    );
  }

  incompatibleTokens = ["t", "T", "X"];
}

class TimestampSecondsParser extends Parser {
  priority = 40;

  parse(dateString) {
    return parseAnyDigitsSigned(dateString);
  }

  set(date, _flags, value) {
    return [constructFrom(date, value * 1000), { timestampIsSet: true }];
  }

  incompatibleTokens = "*";
}

class TimestampMillisecondsParser extends Parser {
  priority = 20;

  parse(dateString) {
    return parseAnyDigitsSigned(dateString);
  }

  set(date, _flags, value) {
    return [constructFrom(date, value), { timestampIsSet: true }];
  }

  incompatibleTokens = "*";
}

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O* | Timezone (GMT)                 |
 * |  p  |                                |  P  |                                |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z* | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `parse` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 */
const parsers = {
  G: new EraParser(),
  y: new YearParser(),
  Y: new LocalWeekYearParser(),
  R: new ISOWeekYearParser(),
  u: new ExtendedYearParser(),
  Q: new QuarterParser(),
  q: new StandAloneQuarterParser(),
  M: new MonthParser(),
  L: new StandAloneMonthParser(),
  w: new LocalWeekParser(),
  I: new ISOWeekParser(),
  d: new DateParser(),
  D: new DayOfYearParser(),
  E: new DayParser(),
  e: new LocalDayParser(),
  c: new StandAloneLocalDayParser(),
  i: new ISODayParser(),
  a: new AMPMParser(),
  b: new AMPMMidnightParser(),
  B: new DayPeriodParser(),
  h: new Hour1to12Parser(),
  H: new Hour0to23Parser(),
  K: new Hour0To11Parser(),
  k: new Hour1To24Parser(),
  m: new MinuteParser(),
  s: new SecondParser(),
  S: new FractionOfSecondParser(),
  X: new ISOTimezoneWithZParser(),
  x: new ISOTimezoneParser(),
  t: new TimestampSecondsParser(),
  T: new TimestampMillisecondsParser(),
};

/**
 * The {@link parse} function options.
 */

// This RegExp consists of three parts separated by `|`:
// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps
const formattingTokensRegExp =
  /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;

// This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`
const longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;

const escapedStringRegExp = /^'([^]*?)'?$/;
const doubleQuoteRegExp = /''/g;

const notWhitespaceRegExp = /\S/;
const unescapedLatinCharacterRegExp = /[a-zA-Z]/;

/**
 * @name parse
 * @category Common Helpers
 * @summary Parse the date.
 *
 * @description
 * Return the date parsed from string using the given format string.
 *
 * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters in the format string wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 *
 * Format of the format string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 5 below the table).
 *
 * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
 * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
 *
 * ```javascript
 * parse('23 AM', 'HH a', new Date())
 * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
 * ```
 *
 * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
 *
 * Accepted format string patterns:
 * | Unit                            |Prior| Pattern | Result examples                   | Notes |
 * |---------------------------------|-----|---------|-----------------------------------|-------|
 * | Era                             | 140 | G..GGG  | AD, BC                            |       |
 * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 |     | GGGGG   | A, B                              |       |
 * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
 * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
 * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
 * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
 * |                                 |     | yyyyy   | ...                               | 2,4   |
 * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
 * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
 * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
 * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
 * |                                 |     | YYYYY   | ...                               | 2,4   |
 * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
 * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
 * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
 * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
 * |                                 |     | RRRRR   | ...                               | 2,4,5 |
 * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
 * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
 * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
 * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
 * |                                 |     | uuuuu   | ...                               | 2,4   |
 * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
 * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
 * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
 * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | qq      | 01, 02, 03, 04                    |       |
 * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
 * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
 * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | MM      | 01, 02, ..., 12                   |       |
 * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | MMMM    | January, February, ..., December  | 2     |
 * |                                 |     | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
 * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | LL      | 01, 02, ..., 12                   |       |
 * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | LLLL    | January, February, ..., December  | 2     |
 * |                                 |     | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
 * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
 * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
 * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
 * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
 * |                                 |     | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
 * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
 * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
 * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 |     | DDDD    | ...                               | 2     |
 * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
 * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
 * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
 * |                                 |     | iii     | Mon, Tue, Wed, ..., Sun           | 5     |
 * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
 * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
 * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |
 * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | ee      | 02, 03, ..., 01                   |       |
 * |                                 |     | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | cc      | 02, 03, ..., 01                   |       |
 * |                                 |     | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
 * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
 * |                                 |     | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
 * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 |     | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
 * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
 * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
 * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
 * |                                 |     | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
 * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
 * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | mm      | 00, 01, ..., 59                   |       |
 * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
 * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | ss      | 00, 01, ..., 59                   |       |
 * | Seconds timestamp               |  40 | t       | 512969520                         |       |
 * |                                 |     | tt      | ...                               | 2     |
 * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
 * |                                 |     | SS      | 00, 01, ..., 99                   |       |
 * |                                 |     | SSS     | 000, 001, ..., 999                |       |
 * |                                 |     | SSSS    | ...                               | 2     |
 * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
 * |                                 |     | TT      | ...                               | 2     |
 * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
 * |                                 |     | XX      | -0800, +0530, Z                   |       |
 * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
 * |                                 |     | xx      | -0800, +0530, +0000               |       |
 * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
 * |                                 |     | PP      | May 29, 1453                      |       |
 * |                                 |     | PPP     | May 29th, 1453                    |       |
 * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
 * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
 * |                                 |     | pp      | 12:00:00 AM                       |       |
 * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
 * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
 * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
 * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular.
 *    In `format` function, they will produce different result:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 *    `parse` will try to match both formatting and stand-alone units interchangeably.
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table:
 *    - for numerical units (`yyyyyyyy`) `parse` will try to match a number
 *      as wide as the sequence
 *    - for text units (`MMMMMMMM`) `parse` will try to match the widest variation of the unit.
 *      These variations are marked with "2" in the last column of the table.
 *
 * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 4. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` will try to guess the century of two digit year by proximity with `referenceDate`:
 *
 *    `parse('50', 'yy', new Date(2018, 0, 1)) //=> Sat Jan 01 2050 00:00:00`
 *
 *    `parse('75', 'yy', new Date(2018, 0, 1)) //=> Wed Jan 01 1975 00:00:00`
 *
 *    while `uu` will just assign the year as is:
 *
 *    `parse('50', 'uu', new Date(2018, 0, 1)) //=> Sat Jan 01 0050 00:00:00`
 *
 *    `parse('75', 'uu', new Date(2018, 0, 1)) //=> Tue Jan 01 0075 00:00:00`
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [setISOWeekYear](https://date-fns.org/docs/setISOWeekYear)
 *    and [setWeekYear](https://date-fns.org/docs/setWeekYear)).
 *
 * 5. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 7. `D` and `DD` tokens represent days of the year but they are often confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
 *    on the given locale.
 *
 *    using `en-US` locale: `P` => `MM/dd/yyyy`
 *    using `en-US` locale: `p` => `hh:mm a`
 *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
 *    using `pt-BR` locale: `p` => `HH:mm`
 *
 * Values will be assigned to the date in the descending order of its unit's priority.
 * Units of an equal priority overwrite each other in the order of appearance.
 *
 * If no values of higher priority are parsed (e.g. when parsing string 'January 1st' without a year),
 * the values will be taken from 3rd argument `referenceDate` which works as a context of parsing.
 *
 * `referenceDate` must be passed for correct work of the function.
 * If you're not sure which `referenceDate` to supply, create a new instance of Date:
 * `parse('02/11/2014', 'MM/dd/yyyy', new Date())`
 * In this case parsing will be done in the context of the current date.
 * If `referenceDate` is `Invalid Date` or a value not convertible to valid `Date`,
 * then `Invalid Date` will be returned.
 *
 * The result may vary by locale.
 *
 * If `formatString` matches with `dateString` but does not provides tokens, `referenceDate` will be returned.
 *
 * If parsing failed, `Invalid Date` will be returned.
 * Invalid Date is a Date, whose time value is NaN.
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param dateStr - The string to parse
 * @param formatStr - The string of tokens
 * @param referenceDate - defines values missing from the parsed dateString
 * @param options - An object with options.
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * @returns The parsed date
 *
 * @throws `options.locale` must contain `match` property
 * @throws use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws format string contains an unescaped latin alphabet character
 *
 * @example
 * // Parse 11 February 2014 from middle-endian format:
 * var result = parse('02/11/2014', 'MM/dd/yyyy', new Date())
 * //=> Tue Feb 11 2014 00:00:00
 *
 * @example
 * // Parse 28th of February in Esperanto locale in the context of 2010 year:
 * import eo from 'date-fns/locale/eo'
 * var result = parse('28-a de februaro', "do 'de' MMMM", new Date(2010, 0, 1), {
 *   locale: eo
 * })
 * //=> Sun Feb 28 2010 00:00:00
 */
function parse(dateStr, formatStr, referenceDate, options) {
  const invalidDate = () => constructFrom(referenceDate, NaN);
  const defaultOptions = getDefaultOptions();
  const locale = defaultOptions.locale ?? enUS;

  const firstWeekContainsDate =
    defaultOptions.firstWeekContainsDate ??
    defaultOptions.locale?.options?.firstWeekContainsDate ??
    1;

  const weekStartsOn =
    defaultOptions.weekStartsOn ??
    defaultOptions.locale?.options?.weekStartsOn ??
    0;

  const subFnOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale,
  };

  // If timezone isn't specified, it will try to use the context or
  // the reference date and fallback to the system time zone.
  const setters = [new DateTimezoneSetter(options?.in, referenceDate)];

  const tokens = formatStr
    .match(longFormattingTokensRegExp)
    .map((substring) => {
      const firstCharacter = substring[0];
      if (firstCharacter in longFormatters) {
        const longFormatter = longFormatters[firstCharacter];
        return longFormatter(substring, locale.formatLong);
      }
      return substring;
    })
    .join("")
    .match(formattingTokensRegExp);

  const usedTokens = [];

  for (let token of tokens) {
    if (
      isProtectedWeekYearToken(token)
    ) {
      warnOrThrowProtectedError(token, formatStr, dateStr);
    }
    if (
      isProtectedDayOfYearToken(token)
    ) {
      warnOrThrowProtectedError(token, formatStr, dateStr);
    }

    const firstCharacter = token[0];
    const parser = parsers[firstCharacter];
    if (parser) {
      const { incompatibleTokens } = parser;
      if (Array.isArray(incompatibleTokens)) {
        const incompatibleToken = usedTokens.find(
          (usedToken) =>
            incompatibleTokens.includes(usedToken.token) ||
            usedToken.token === firstCharacter,
        );
        if (incompatibleToken) {
          throw new RangeError(
            `The format string mustn't contain \`${incompatibleToken.fullToken}\` and \`${token}\` at the same time`,
          );
        }
      } else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) {
        throw new RangeError(
          `The format string mustn't contain \`${token}\` and any other token at the same time`,
        );
      }

      usedTokens.push({ token: firstCharacter, fullToken: token });

      const parseResult = parser.run(
        dateStr,
        token,
        locale.match,
        subFnOptions,
      );

      if (!parseResult) {
        return invalidDate();
      }

      setters.push(parseResult.setter);

      dateStr = parseResult.rest;
    } else {
      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError(
          "Format string contains an unescaped latin alphabet character `" +
            firstCharacter +
            "`",
        );
      }

      // Replace two single quote characters with one single quote character
      if (token === "''") {
        token = "'";
      } else if (firstCharacter === "'") {
        token = cleanEscapedString(token);
      }

      // Cut token from string, or, if string doesn't match the token, return Invalid Date
      if (dateStr.indexOf(token) === 0) {
        dateStr = dateStr.slice(token.length);
      } else {
        return invalidDate();
      }
    }
  }

  // Check if the remaining input contains something other than whitespace
  if (dateStr.length > 0 && notWhitespaceRegExp.test(dateStr)) {
    return invalidDate();
  }

  const uniquePrioritySetters = setters
    .map((setter) => setter.priority)
    .sort((a, b) => b - a)
    .filter((priority, index, array) => array.indexOf(priority) === index)
    .map((priority) =>
      setters
        .filter((setter) => setter.priority === priority)
        .sort((a, b) => b.subPriority - a.subPriority),
    )
    .map((setterArray) => setterArray[0]);

  let date = toDate(referenceDate, options?.in);

  if (isNaN(+date)) return invalidDate();

  const flags = {};
  for (const setter of uniquePrioritySetters) {
    if (!setter.validate(date, subFnOptions)) {
      return invalidDate();
    }

    const result = setter.set(date, flags, subFnOptions);
    // Result is tuple (date, flags)
    if (Array.isArray(result)) {
      date = result[0];
      Object.assign(flags, result[1]);
      // Result is date
    } else {
      date = result;
    }
  }

  return date;
}

function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}

const Dashboard = () => {
  const [selectedAdvertiser, setSelectedAdvertiser] = reactExports.useState("BANCODEBOGOTA");
  const [reportData, setReportData] = reactExports.useState(null);
  const [loading, setLoading] = reactExports.useState(true);
  const [dateRange, setDateRange] = reactExports.useState({
    startDate: parse("01-04-2025", "dd-MM-yyyy", /* @__PURE__ */ new Date()),
    endDate: parse("30-04-2025", "dd-MM-yyyy", /* @__PURE__ */ new Date())
  });
  const handleDateChange = (start, end) => {
    setDateRange({ startDate: start, endDate: end });
    const formattedStart = format(start, "dd-MM-yyyy");
    const formattedEnd = format(end, "dd-MM-yyyy");
    fetchReportData(formattedStart, formattedEnd);
  };
  const fetchReportData = reactExports.useCallback(async (startDate, endDate) => {
    try {
      setLoading(true);
      const requestData = {
        advertiser: selectedAdvertiser,
        start_date: startDate || "01-04-2025",
        end_date: endDate || "30-04-2025"
      };
      const response = await getReportData(requestData);
      setReportData(response);
      console.log(response);
      sessionStorage.setItem("dataCampaign", JSON.stringify(response));
    } catch (error) {
      Swal.fire({
        title: "Error",
        text: error instanceof Error ? error.message : "Error al obtener los datos",
        icon: "error"
      });
    } finally {
      setLoading(false);
    }
  }, [selectedAdvertiser, dateRange]);
  reactExports.useEffect(() => {
    const timeoutId = setTimeout(() => {
      fetchReportData();
    }, 300);
    return () => clearTimeout(timeoutId);
  }, [fetchReportData]);
  const renderDashboardContent = () => {
    if (loading) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center items-center h-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Cargando datos..." }) });
    }
    if (!reportData?.body) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center items-center h-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "No hay datos disponibles" }) });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gray-50 h-full flex", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col w-2/5", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-3/6 p-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            WN,
            {
              logo: "impresiones",
              number: reportData.body.impressions || 0,
              title: "IMPRESIONES",
              start: 0,
              end: reportData.body.impressions || 0,
              current: reportData.body.impressions || 0
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-3/6 p-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            WN,
            {
              logo: "conversiones",
              number: reportData.body.conversions || 0,
              title: "CONVERSIONES",
              start: 0,
              end: reportData.body.conversions || 0,
              current: reportData.body.conversions || 0
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-3/6 p-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            WN,
            {
              logo: "click",
              number: reportData.body.clicks || 0,
              title: "CLICS",
              start: 0,
              end: reportData.body.clicks || 0,
              current: reportData.body.clicks || 0
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-3/6 p-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            WN,
            {
              logo: "porcentaje",
              number: reportData.body.crt || 0,
              title: "CTR",
              start: 0,
              end: reportData.body.crt || 0,
              current: reportData.body.crt || 0
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-3/6 p-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            WN,
            {
              logo: "vistas",
              number: reportData.body.views || 0,
              title: "VIEWS",
              start: 0,
              end: reportData.body.views || 0,
              current: reportData.body.views || 0
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-3/6 p-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            WN,
            {
              logo: "porcentaje",
              number: reportData.body.vrt || 0,
              title: "VTR",
              start: 0,
              end: reportData.body.vrt || 0,
              current: reportData.body.vrt || 0
            }
          ) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col w-3/5", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-3/6 p-3", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border bg-white p-3 h-full flex flex-col", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "my-3 font-bold", children: "PRESUPUESTO" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 flex items-end w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(HN, {}) })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-3/6 p-3", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border bg-white p-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "my-3 font-bold", children: "RECOMENDACIONES" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "list", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
                "El presupuesto total planeado es de ",
                reportData.body.budget?.ordered_budget || 0,
                ", pero solo se ha ejecutado ",
                reportData.body.budget?.invested_budget || 0,
                ". Considera aumentar la inversión para alcanzar los objetivos de impresiones y conversiones."
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
                "Las campañas tienen un CTR (Click Through Rate) de ",
                reportData.body.crt || 0,
                "% y un VTR (View Through Rate) de ",
                reportData.body.vrt || 0,
                "%. Esto sugiere que hay margen de mejora en la segmentación y creatividad de los anuncios."
              ] })
            ] })
          ] }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full p-3", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border bg-white h-full p-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "my-3 font-bold", children: "RESUMEN DE CAMPAÑAS" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            YN,
            {
              columns: [
                {
                  header: "NOMBRE",
                  relation: "name"
                },
                {
                  header: "PLATAFORMA",
                  relation: "platform"
                },
                {
                  header: "OBJETIVO",
                  relation: "goal"
                },
                {
                  header: "PRESUPUESTO",
                  relation: "budget"
                },
                {
                  header: "FECHA INICIO",
                  relation: "start_date"
                },
                {
                  header: "FECHA FIN",
                  relation: "end_date"
                },
                {
                  header: "CUMPLIMIENTO",
                  relation: "compliance"
                }
              ],
              data: reportData.body.campaigns?.map((campaign) => ({
                ...campaign,
                id: campaign.name
                // Usando el nombre como id temporal
              })) || []
            }
          )
        ] }) }) })
      ] })
    ] });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-screen w-full flex", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SidebarMth, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-screen container-space w-full", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full justify-between items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "font-bold mb-3", children: "DASHBOARD" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Xy,
            {
              name: "advertiser",
              options: dataAdvertiser.getAdvertiser(),
              value: selectedAdvertiser,
              onChange: (e) => setSelectedAdvertiser(e.target.value)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            eI,
            {
              onChange: handleDateChange
            }
          )
        ] })
      ] }),
      renderDashboardContent()
    ] })
  ] });
};

const updateUserSchema = create$3().shape({
  name: create$6().required("El nombre es obligatorio").min(2, "El nombre debe tener al menos 2 caracteres"),
  firtsName: create$6().required("Los apellidos son obligatorios").min(2, "Los apellidos deben tener al menos 2 caracteres"),
  company: create$6().required("La empresa es obligatoria"),
  role: create$6().required("El rol es obligatorio"),
  phone: create$5().required("El número de celular es obligatorio").min(10, "El número debe tener al menos 10 dígitos")
  // .max(10, 'El número no debe exceder 10 dígitos'),
});

const updatePasswordSchema = create$3().shape({
  currentPassword: create$6().required("La contraseña actual es obligatoria"),
  password: create$6().required("La nueva contraseña es obligatoria").min(8, "Debe tener al menos 8 caracteres").matches(/\d/, "Debe contener al menos un número").matches(/[A-Z]/, "Debe contener al menos una mayúscula").matches(/[a-z]/, "Debe contener al menos una minúscula").matches(/[!@#$%^&*(),.?":{}|<>]/, "Debe contener al menos un carácter especial"),
  confirmPassword: create$6().required("Confirma tu contraseña").oneOf([create$9("password")], "Las contraseñas no coinciden")
});

const SettingsUser = () => {
  const { roles } = RegisterFormService;
  const [isEditing, setIsEditing] = reactExports.useState(false);
  const [isVisible, setIsVisible] = reactExports.useState(false);
  const [isUpdatePassword, setIsUpdatePassword] = reactExports.useState(false);
  const [formSetting, setformSetting] = reactExports.useState({
    name: "",
    firtsName: "",
    company: "",
    phone: "",
    role: "",
    email: ""
  });
  const { name, firtsName, company, phone, role, email } = formSetting;
  usePasswordValidation();
  const handleUserInfoSubmit = async (values) => {
    try {
      console.log("Valores del formulario de información:", values);
      setformSetting(values);
      setIsEditing(false);
    } catch (error) {
      console.error("Error al actualizar la información:", error);
    }
  };
  const handlePasswordSubmit = async (values) => {
    try {
      console.log("Valores del formulario de contraseña:", values);
      setIsVisible(false);
      setIsUpdatePassword(false);
    } catch (error) {
      console.error("Error al actualizar la contraseña:", error);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-screen w-full flex", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SidebarMth, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-screen w-full container-space", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "font-bold mb-3", children: "CONFIGURACIÓN" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col h-3/5", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("section", { id: "info-basic", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Formik,
          {
            enableReinitialize: true,
            initialValues: {
              name,
              firtsName,
              company,
              role,
              email,
              phone
            },
            validationSchema: updateUserSchema,
            onSubmit: handleUserInfoSubmit,
            children: (formik) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Form, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-5", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-1/5", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mt-6", children: "INFORMACIÓN BÁSICA" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Ny,
                    {
                      type: "text",
                      placeholder: "Nombres",
                      name: "name",
                      value: formik.values.name,
                      onChange: formik.handleChange,
                      onBlur: formik.handleBlur,
                      disabled: !isEditing
                    }
                  ),
                  formik.errors.name && formik.touched.name && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-500 text-sm my-2", children: formik.errors.name }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Ny,
                    {
                      type: "text",
                      placeholder: "Apellidos",
                      name: "firtsName",
                      value: formik.values.firtsName,
                      onChange: formik.handleChange,
                      onBlur: formik.handleBlur,
                      disabled: !isEditing
                    }
                  ),
                  formik.errors.firtsName && formik.touched.firtsName && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-500 text-sm my-2", children: formik.errors.firtsName }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Ny,
                    {
                      type: "text",
                      placeholder: "Empresa",
                      name: "company",
                      value: formik.values.company,
                      onChange: formik.handleChange,
                      onBlur: formik.handleBlur,
                      disabled: !isEditing
                    }
                  ),
                  formik.errors.company && formik.touched.company && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-500 text-sm my-2", children: formik.errors.company }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Xy,
                    {
                      options: roles,
                      value: formik.values.role,
                      onChange: (e) => formik.setFieldValue("role", e.target.value),
                      disabled: !isEditing
                    }
                  ),
                  formik.errors.role && formik.touched.role && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-500 text-sm my-2", children: formik.errors.role })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-1/5 flex flex-col justify-between", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mt-6", children: "INFORMACIÓN CUENTA" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Ny,
                    {
                      type: "email",
                      value: formik.values.email,
                      onChange: formik.handleChange,
                      onBlur: formik.handleBlur,
                      placeholder: "Correo electrónico",
                      disabled: true
                    }
                  ),
                  formik.errors.email && formik.touched.email && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-500 text-sm my-2", children: formik.errors.email }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mt-6", children: "INFORMACIÓN DE CONTACTO" }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Ny,
                    {
                      type: "number",
                      placeholder: "Celular",
                      name: "phone",
                      minLength: 10,
                      maxLength: 10,
                      value: formik.values.phone,
                      onChange: formik.handleChange,
                      onBlur: formik.handleBlur,
                      disabled: !isEditing
                    }
                  ),
                  formik.errors.phone && formik.touched.phone && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-500 text-sm my-2", children: formik.errors.phone })
                ] }) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-5", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-1/5" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-1/5", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-3 w-full items-center justify-end", children: isEditing ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    FN,
                    {
                      txtBtn: "Cancelar",
                      typeButton: "border",
                      full: false,
                      type: "button",
                      onClick: () => {
                        setIsEditing(false);
                        formik.resetForm();
                      }
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    FN,
                    {
                      txtBtn: "Guardar",
                      typeButton: "default",
                      full: false,
                      type: "submit",
                      disabled: !formik.isValid || formik.isSubmitting
                    }
                  )
                ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                  FN,
                  {
                    txtBtn: "Editar",
                    typeButton: "default",
                    full: false,
                    type: "button",
                    onClick: () => setIsEditing(true)
                  }
                ) }) })
              ] })
            ] })
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("section", { id: "update-password", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Formik,
          {
            initialValues: {
              currentPassword: "",
              password: "",
              confirmPassword: ""
            },
            validationSchema: updatePasswordSchema,
            onSubmit: handlePasswordSubmit,
            children: (formikProps) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Form, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "W-2/5", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mt-6", children: "ACTUALIZAR CONTRASEÑA" }) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-5", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-1/5", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    zd,
                    {
                      name: "currentPassword",
                      placeholder: "Contraseña actual",
                      disabled: !isUpdatePassword,
                      value: formikProps.values.currentPassword,
                      onChange: formikProps.handleChange,
                      onBlur: formikProps.handleBlur
                    }
                  ),
                  formikProps.errors.currentPassword && formikProps.touched.currentPassword && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-500 text-sm my-2", children: String(formikProps.errors.currentPassword) }),
                  !isVisible && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-3 w-full items-center justify-end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    FN,
                    {
                      txtBtn: "Actualizar",
                      typeButton: "default",
                      full: false,
                      type: "button",
                      onClick: () => {
                        setIsVisible(true);
                        setIsUpdatePassword(true);
                      }
                    }
                  ) })
                ] }),
                isVisible && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-1/5", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(UN, { formik: formikProps }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-3 w-full items-center justify-end", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      FN,
                      {
                        txtBtn: "Cancelar",
                        typeButton: "border",
                        full: false,
                        type: "button",
                        onClick: () => {
                          setIsVisible(false);
                          setIsUpdatePassword(false);
                          formikProps.resetForm();
                        }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      FN,
                      {
                        txtBtn: "Guardar",
                        typeButton: "default",
                        full: false,
                        type: "submit",
                        disabled: !formikProps.isValid || formikProps.isSubmitting
                      }
                    )
                  ] })
                ] })
              ] })
            ] })
          }
        ) })
      ] })
    ] })
  ] });
};

// THIS FILE IS AUTO GENERATED
function SiGoogleads (props) {
  return GenIcon({"attr":{"role":"img","viewBox":"0 0 24 24"},"child":[{"tag":"path","attr":{"d":"M3.9998 22.9291C1.7908 22.9291 0 21.1383 0 18.9293s1.7908-3.9998 3.9998-3.9998 3.9998 1.7908 3.9998 3.9998-1.7908 3.9998-3.9998 3.9998zm19.4643-6.0004L15.4632 3.072C14.3586 1.1587 11.9121.5028 9.9988 1.6074S7.4295 5.1585 8.5341 7.0718l8.0009 13.8567c1.1046 1.9133 3.5511 2.5679 5.4644 1.4646 1.9134-1.1046 2.568-3.5511 1.4647-5.4644zM7.5137 4.8438L1.5645 15.1484A4.5 4.5 0 0 1 4 14.4297c2.5597-.0075 4.6248 2.1585 4.4941 4.7148l3.2168-5.5723-3.6094-6.25c-.4499-.7793-.6322-1.6394-.5878-2.4784z"},"child":[]}]})(props);
}

// THIS FILE IS AUTO GENERATED
function BiSolidDashboard (props) {
  return GenIcon({"attr":{"viewBox":"0 0 24 24"},"child":[{"tag":"path","attr":{"d":"M4 13h6a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1zm-1 7a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1v-4a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v4zm10 0a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1v-7a1 1 0 0 0-1-1h-6a1 1 0 0 0-1 1v7zm1-10h6a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1h-6a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1z"},"child":[]}]})(props);
}

const dataThirdParty = {
  menuItems: [
    {
      id: "1",
      title: "NUEVA CAMPAÑA",
      href: "#nueva-campana",
      icon: IoMegaphone,
      subItems: [
        {
          id: "1.1",
          title: "CONJUNTOS DE ANUNCIOS 1",
          href: "#conjuntos-de-anuncios-1",
          icon: BiSolidDashboard,
          subItems: [
            {
              id: "1.1.1",
              title: "ANUNCIO 1",
              href: "#anuncio-1",
              icon: FaFacebook
            },
            {
              id: "1.1.2",
              title: "ANUNCIO 2",
              href: "#anuncio-2",
              icon: FaFacebook
            }
          ]
        },
        {
          id: "1.2",
          title: "CONJUNTOS DE ANUNCIOS 2",
          href: "#conjuntos-de-anuncios-2",
          icon: BiSolidDashboard,
          subItems: [
            {
              id: "1.1.1",
              title: "ANUNCIO 1",
              href: "#anuncio-1",
              icon: FaFacebook
            }
          ]
        }
      ]
    }
  ],
  getMenuItems() {
    return this.menuItems;
  }
};

const ThirdPartyCampaignForm = () => {
  const menuItems = dataThirdParty.getMenuItems();
  const { roles } = RegisterFormService;
  const [isEditing, setIsEditing] = reactExports.useState(false);
  const [formSetting, setformSetting] = reactExports.useState({
    name: "",
    firtsName: "",
    company: "",
    phone: "",
    role: "",
    email: ""
  });
  const [isChecked, setIsChecked] = reactExports.useState(false);
  const [isCheckedOrganizacion, setIsCheckedOrganizacion] = reactExports.useState(true);
  const [isCheckedLimiteGasto, setIsCheckedLimiteGasto] = reactExports.useState(true);
  const { name, firtsName, company, phone, role, email } = formSetting;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-screen w-full flex", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SidebarMth, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-screen w-full flex", style: { padding: "0px 20px 20px 120px" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-3/5 flex-col pr-5 container-space-top", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "font-bold", children: "CREACIÓN DE CAMPAÑAS" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mb-5", children: "MEDIOS PAGOS" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-1/2 mb-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mb-5 font-bold", children: "¿DÓNDE QUIERES PAUTAR?" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex rounded-md shadow-xs", role: "group", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", className: "px-4 py-2 text-sm font-medium text-gray-900 bg-white border border-gray-200 rounded-s-lg hover:bg-gray-100 hover:text-blue-700 focus:z-10 focus:ring-2 focus:ring-blue-700 focus:text-blue-700 dark:bg-gray-800 dark:border-gray-700 dark:text-white dark:hover:text-white dark:hover:bg-gray-700 dark:focus:ring-blue-500 dark:focus:text-white", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FaMeta, { className: "text-blue-700 text-2xl" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", className: "px-4 py-2 text-sm font-medium text-gray-900 bg-white border-t border-b border-gray-200 hover:bg-gray-100 hover:text-blue-700 focus:z-10 focus:ring-2 focus:ring-blue-700 focus:text-blue-700 dark:bg-gray-800 dark:border-gray-700 dark:text-white dark:hover:text-white dark:hover:bg-gray-700 dark:focus:ring-blue-500 dark:focus:text-white", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SiGoogleads, { className: "text-blue-700 text-2xl" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", className: "px-4 py-2 text-sm font-medium text-gray-900 bg-white border border-gray-200 rounded-e-lg hover:bg-gray-100 hover:text-blue-700 focus:z-10 focus:ring-2 focus:ring-blue-700 focus:text-blue-700 dark:bg-gray-800 dark:border-gray-700 dark:text-white dark:hover:text-white dark:hover:bg-gray-700 dark:focus:ring-blue-500 dark:focus:text-white", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FaTiktok, { className: "text-blue-700 text-2xl" }) })
          ] })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mb-4 font-bold", children: "INFORMACIÓN DE CAMPAÑAS" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "block", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Ny,
          {
            type: "text",
            placeholder: "Nombre de campaña",
            name: "name",
            value: name,
            onChange: (e) => setformSetting({ ...formSetting, name: e.target.value })
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full gap-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-2/5", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Xy,
            {
              name: "Estado Inicial",
              options: roles
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-3/5", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Xy,
            {
              name: "Awareness",
              options: roles
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full gap-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-1/2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Ny,
            {
              type: "text",
              placeholder: "Selecciona tu cuenta",
              name: "name",
              value: name,
              onChange: (e) => setformSetting({ ...formSetting, name: e.target.value })
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-1/2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Xy,
            {
              name: "Categoría de anuncio especial",
              options: roles
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-1/2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mb-4 font-bold", children: "OPTIMIZACIÓN DEL PRESUPUESTO DE CAMPAÑAS" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-1/2 flex justify-end", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "inline-flex items-center cursor-pointer", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "checkbox",
                className: "sr-only peer",
                checked: isCheckedOrganizacion,
                onChange: (e) => setIsCheckedOrganizacion(e.target.checked)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative w-11 h-6 bg-gray-200 rounded-full peer peer-focus:ring-4 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 dark:bg-gray-700 peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600 dark:peer-checked:bg-blue-600" })
          ] }) })
        ] }),
        isCheckedOrganizacion && /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { id: "organizacion", className: "w-full", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-1/2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "mb-4 font-bold", children: "TIPO DE PRESUPUESTO" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Xy,
                {
                  name: "Diario",
                  options: roles
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-1/2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "mb-4 font-bold", children: "ESTRATEGIA DE PUJA" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Xy,
                {
                  name: "Highest volume",
                  options: roles
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "block", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Ny,
            {
              type: "text",
              placeholder: "Presupuesto",
              name: "name",
              value: name,
              onChange: (e) => setformSetting({ ...formSetting, name: e.target.value })
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-1/2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mb-4 font-bold", children: "LIMITE DE GASTRO DE CAMPAÑA (OPCIONAL)" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-1/2 flex justify-end", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "inline-flex items-center cursor-pointer", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "checkbox",
                className: "sr-only peer",
                checked: isCheckedLimiteGasto,
                onChange: (e) => setIsCheckedLimiteGasto(e.target.checked)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative w-11 h-6 bg-gray-200 rounded-full peer peer-focus:ring-4 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 dark:bg-gray-700 peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600 dark:peer-checked:bg-blue-600" })
          ] }) })
        ] }),
        isCheckedLimiteGasto && /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "block", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "mb-4 font-bold", children: "CANTIDAD LIMITE" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Ny,
            {
              type: "text",
              placeholder: "Presupuesto",
              name: "name",
              value: name,
              onChange: (e) => setformSetting({ ...formSetting, name: e.target.value })
            }
          )
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "block", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "INFORMACIÓN CONJUNTO DE ANUNCIOS" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Ny,
            {
              type: "text",
              placeholder: "Nombre de conjunto de anuncios",
              name: "name",
              value: name,
              onChange: (e) => setformSetting({ ...formSetting, name: e.target.value })
            }
          )
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-1/2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "PRESUPUESTO DEL CONJUNTO DE ANUNCIOS" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-1/2 flex justify-end", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "inline-flex items-center cursor-pointer", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "checkbox",
                className: "sr-only peer",
                checked: isCheckedLimiteGasto,
                onChange: (e) => setIsCheckedLimiteGasto(e.target.checked)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative w-11 h-6 bg-gray-200 rounded-full peer peer-focus:ring-4 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 dark:bg-gray-700 peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600 dark:peer-checked:bg-blue-600" })
          ] }) })
        ] }),
        isCheckedLimiteGasto && /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "w-full", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full gap-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-1/2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "GASTO MÍNIMO" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Ny,
                {
                  type: "number",
                  placeholder: "0 COP",
                  name: "gastoMinimo"
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-1/2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "GASTO MÁXIMO" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Ny,
                {
                  type: "number",
                  placeholder: "0 COP",
                  name: "gastoMaximo"
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full gap-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-1/2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "FECHA INICIO" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-1/2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "FECHA FINAL" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Ny,
                {
                  type: "number",
                  placeholder: "0 COP",
                  name: "gastoMaximo"
                }
              )
            ] })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex w-2/5 flex-col pl-5 bg-gray-100 container-space-top", children: /* @__PURE__ */ jsxRuntimeExports.jsx(XN, { items: menuItems }) })
    ] })
  ] });
};

const tableColumns = [
  {
    header: "ESTADO",
    relation: "status",
    isToggle: true,
    toggleText: {
      active: "ACTIVA",
      inactive: "PAUSA"
    }
  },
  {
    header: "NOMBRE CAMPAÑAS",
    relation: "name"
  },
  {
    header: "PLATAFORMA",
    relation: "platform"
  },
  {
    header: "FECHA INICIAL",
    relation: "startDate"
  },
  {
    header: "FECHA FINAL",
    relation: "endDate"
  },
  {
    header: "PRESUPUESTO",
    relation: "budget"
  },
  {
    header: "GASTO",
    relation: "spent"
  },
  {
    header: "IMPRESIONES",
    relation: "impressions"
  },
  {
    header: "CPM",
    relation: "cpm"
  },
  {
    header: "CLICS URL",
    relation: "clicksUrl"
  },
  {
    header: "CTR",
    relation: "ctr"
  },
  {
    header: "CPC",
    relation: "cpc"
  }
];

const SummaryCampaign = () => {
  const location = useLocation();
  const [activeFilter, setActiveFilter] = reactExports.useState("all");
  const [currentPage, setCurrentPage] = reactExports.useState(1);
  const [isModalOpen, setIsModalOpen] = reactExports.useState(false);
  const [localData, setLocalData] = reactExports.useState([]);
  reactExports.useEffect(() => {
    let dataCampaign = sessionStorage.getItem("dataCampaign");
    const allTransformedCampaigns = [];
    function getRandomIntInRange(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    const transformMetaCampaign = (dataCampaign2) => ({
      status: true,
      name: dataCampaign2.name || "",
      platform: dataCampaign2.platform || "",
      startDate: dataCampaign2.start_date || "",
      endDate: dataCampaign2.end_date || "",
      budget: dataCampaign2.budget || "0",
      spent: getRandomIntInRange(1, 99999),
      impressions: getRandomIntInRange(1, 99999),
      cpm: getRandomIntInRange(1, 99999),
      clicksUrl: getRandomIntInRange(1, 99999),
      ctr: getRandomIntInRange(1, 99999),
      cpc: getRandomIntInRange(1, 99999)
    });
    if (dataCampaign) {
      const parsedData = JSON.parse(dataCampaign);
      const dataEnd = parsedData.body.campaigns;
      for (let i = 0; i < 6; i++) {
        allTransformedCampaigns.push(transformMetaCampaign(dataEnd[i]));
      }
    }
    let initialData = [];
    const locationData = location.state;
    if (locationData?.campaignData) {
      initialData = locationData.campaignData;
      sessionStorage.setItem("campaignDataResumen", JSON.stringify(initialData));
    } else {
      const stored = sessionStorage.getItem("campaignDataResumen");
      if (stored) {
        initialData = JSON.parse(stored);
      }
    }
    const combinedData = [...initialData, ...allTransformedCampaigns];
    const dataWithIds = combinedData.map((item, index) => ({
      ...item,
      id: `${item.name}-${item.platform}-${index}`
    }));
    setLocalData(dataWithIds);
  }, [location.state]);
  const toggleModal = () => setIsModalOpen((prev) => !prev);
  const getFilteredData = () => {
    if (activeFilter === "all") {
      return localData;
    }
    return localData.filter((item) => item.platform === activeFilter);
  };
  const handleFilterChange = (filter) => {
    setActiveFilter(filter);
    setCurrentPage(1);
  };
  const handleToggleChange = ({ rowId, checked, row, columnKey }) => {
    console.table({
      rowId,
      field: columnKey,
      oldValue: row[columnKey],
      newValue: checked
    });
    setLocalData((prev) => {
      const updated = prev.map(
        (item) => item.id === rowId ? { ...item, [columnKey]: checked } : item
      );
      sessionStorage.setItem("campaignDataResumen", JSON.stringify(updated));
      return updated;
    });
  };
  const formatUSD = (value) => {
    const num = Number(String(value).replace(/[^0-9]/g, ""));
    if (isNaN(num)) return value;
    return num.toLocaleString("en-US", { style: "currency", currency: "USD", minimumFractionDigits: 0 });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-screen w-full flex", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SidebarMth, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-screen w-full container-space", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-start", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "font-bold", style: { marginBottom: "0px !important" }, children: "CAMPAÑAS" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "MEDIOS PAGOS" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            FN,
            {
              txtBtn: "CREAR CAMPAÑA",
              typeButton: "default",
              full: false,
              type: "button",
              onClick: toggleModal
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex rounded-md shadow-xs", role: "group", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                className: `px-3 py-2 text-sm font-medium text-gray-900 bg-white border border-gray-200 rounded-s-lg hover:bg-gray-100 hover:text-blue-700 focus:z-10 focus:ring-2 focus:ring-blue-700 focus:text-blue-700 dark:bg-gray-800 dark:border-gray-700 dark:text-white dark:hover:text-white dark:hover:bg-gray-700 dark:focus:ring-blue-500 dark:focus:text-white ${activeFilter === "all" ? "bg-blue-50" : ""}`,
                onClick: () => handleFilterChange("all"),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(BsStack, { className: `text-2xl ${activeFilter === "all" ? "text-blue-700" : "text-gray-500"}` })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                className: `px-3 py-2 text-sm font-medium text-gray-900 bg-white border-r border-t border-b border-gray-200 hover:bg-gray-100 hover:text-blue-700 focus:z-10 focus:ring-2 focus:ring-blue-700 focus:text-blue-700 dark:bg-gray-800 dark:border-gray-700 dark:text-white dark:hover:text-white dark:hover:bg-gray-700 dark:focus:ring-blue-500 dark:focus:text-white ${activeFilter === "META" ? "bg-blue-50" : ""}`,
                onClick: () => handleFilterChange("META"),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(FaMeta, { className: `text-2xl ${activeFilter === "META" ? "text-blue-700" : "text-gray-500"}` })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                className: `px-3 py-2 text-sm font-medium text-gray-900 bg-white border-l border-t border-b border-gray-200 hover:bg-gray-100 hover:text-blue-700 focus:z-10 focus:ring-2 focus:ring-blue-700 focus:text-blue-700 dark:bg-gray-800 dark:border-gray-700 dark:text-white dark:hover:text-white dark:hover:bg-gray-700 dark:focus:ring-blue-500 dark:focus:text-white ${activeFilter === "GOOGLE" ? "bg-blue-50" : ""}`,
                onClick: () => handleFilterChange("GOOGLE"),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(SiGoogleads, { className: `text-2xl ${activeFilter === "GOOGLE" ? "text-blue-700" : "text-gray-500"}` })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                className: `px-3 py-2 text-sm font-medium text-gray-900 bg-white border border-gray-200 rounded-e-lg hover:bg-gray-100 hover:text-blue-700 focus:z-10 focus:ring-2 focus:ring-blue-700 focus:text-blue-700 dark:bg-gray-800 dark:border-gray-700 dark:text-white dark:hover:text-white dark:hover:bg-gray-700 dark:focus:ring-blue-500 dark:focus:text-white ${activeFilter === "TIKTOK" ? "bg-blue-50" : ""}`,
                onClick: () => handleFilterChange("TIKTOK"),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(FaTiktok, { className: `text-2xl ${activeFilter === "TIKTOK" ? "text-blue-700" : "text-gray-500"}` })
              }
            )
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        YN,
        {
          showSearch: true,
          itemsPerPage: 20,
          columns: tableColumns,
          data: getFilteredData().map((item) => ({
            ...item,
            budget: formatUSD(item.budget) + " USD"
          })),
          onToggleChange: handleToggleChange
        },
        `${activeFilter}-table`
      ) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(S1, { width: "40%", isOpen: isModalOpen, onClose: toggleModal, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col px-10 pb-5", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-center font-bold mb-3", children: "SELECCIONA UNA OPCIÓN PARA CREAR TU CAMPAÑA" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-3/6 p-2 flex", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/thirdPartyCampaign", children: /* @__PURE__ */ jsxRuntimeExports.jsx(u0, { imageUrl: "https://ftp.mathilde-ads.com/151-605f91d40859d5d52379b6753401b68f.svg", title: "Campañas manuales", description: "" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-3/6 p-2 flex", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/massiveCampaign", children: /* @__PURE__ */ jsxRuntimeExports.jsx(u0, { imageUrl: "https://ftp.mathilde-ads.com/151-d41c45a31a82b5e2519657b41a04ae94.svg", title: "Campañas masivas", description: "" }) }) })
      ] })
    ] }) })
  ] });
};

const MassiveCampaigns = () => {
  const [files, setFiles] = reactExports.useState([]);
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const [error, setError] = reactExports.useState(false);
  const [campaignData, setCampaignData] = reactExports.useState(null);
  const navigate = useNavigate();
  reactExports.useEffect(() => {
    const stored = sessionStorage.getItem("Campaign");
    if (stored) {
      setCampaignData(JSON.parse(stored));
    }
  }, []);
  const handleFileChange = (files2) => {
    setFiles((prevFiles) => [...prevFiles, ...files2]);
  };
  const handleDeleteFile = (fileToDelete) => {
    setFiles((prevFiles) => prevFiles.filter((file) => file !== fileToDelete));
  };
  const processCSVData = (csvContent) => {
    console.log("Procesando archivo CSV:", csvContent);
    const preprocessedContent = csvContent.replace(/;"[^"]*\n[^"]*"/g, (match) => match.replace(/\n/g, "||")).replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    const rows = preprocessedContent.split("\n").filter((row) => row.trim()).map((row) => {
      const fields2 = [];
      let field = "";
      let inQuotes = false;
      let expectedFields = 34;
      for (let i = 0; i < row.length; i++) {
        const char = row[i];
        if (char === '"') {
          if (inQuotes && (row[i + 1] === ";" || i === row.length - 1)) {
            fields2.push(field);
            field = "";
            inQuotes = false;
            if (row[i + 1] === ";") i++;
          } else {
            inQuotes = !inQuotes;
            if (!inQuotes && field) {
              fields2.push(field);
              field = "";
            }
          }
        } else if (char === ";" && !inQuotes) {
          fields2.push(field);
          field = "";
        } else {
          field += char;
        }
      }
      if (field || fields2.length < expectedFields) {
        fields2.push(field);
      }
      while (fields2.length < expectedFields) {
        fields2.push("");
      }
      return fields2.map((f) => {
        let cleaned = f.trim();
        if (cleaned.startsWith('"') && cleaned.endsWith('"')) {
          cleaned = cleaned.slice(1, -1);
        }
        return cleaned.replace(/\|\|/g, "\n");
      });
    });
    console.log("Número de filas:", rows.length);
    if (rows.length < 3) {
      console.warn("El archivo debe tener al menos 3 filas");
      throw new Error("El archivo debe contener al menos los tipos, campos y un registro de datos");
    }
    const types = rows[0].map((type) => type.trim().toLowerCase());
    const fields = rows[1].map((field) => field.trim().toLowerCase());
    console.log("Tipos:", types);
    console.log("Campos:", fields);
    if (types.length !== fields.length) {
      console.warn("El número de tipos no coincide con el número de campos");
      throw new Error("El formato del archivo no es válido");
    }
    const isGoogle = rows[2][0]?.toLowerCase().includes("google");
    if (isGoogle) {
      const googleCampaigns = [];
      const googleAdSets = [];
      const googleAds = [];
      for (let i = 2; i < rows.length; i++) {
        const values = rows[i];
        const campaignObj = {};
        const adSetObj = {};
        const adObj = {};
        fields.forEach((field, idx) => {
          const type = types[idx];
          const value = values[idx];
          if (!field) return;
          if (type === "campaign") {
            campaignObj[field] = value;
          } else if (type === "ad set") {
            adSetObj[field] = value;
          } else if (type === "ads") {
            adObj[field] = value;
          }
        });
        if (Object.keys(campaignObj).length > 0) googleCampaigns.push(campaignObj);
        if (Object.keys(adSetObj).length > 0) googleAdSets.push(adSetObj);
        if (Object.keys(adObj).length > 0) googleAds.push(adObj);
      }
      console.log("Datos procesados:", { campaignData: googleCampaigns, adSetData: googleAdSets, adData: googleAds });
      return { campaignData: googleCampaigns, adSetData: googleAdSets, adData: googleAds };
    }
    const campaignData2 = [];
    const adSetData = [];
    const adData = [];
    for (let i = 2; i < rows.length; i++) {
      const values = rows[i];
      const campaignObj = {};
      const adSetObj = {};
      const adObj = {};
      console.log(`Procesando fila ${i + 1}:`, values);
      if (values.length !== fields.length) {
        console.warn(`La fila ${i + 1} tiene ${values.length} valores, se esperaban ${fields.length}`);
        continue;
      }
      types.forEach((type, index) => {
        const field = fields[index];
        const value = values[index];
        if (!field || !value) return;
        try {
          const mappedField = field.replace(/\s+/g, "_").replace("bid_optimization_goal", "bid_optimization_goal").replace("bid_billing_event", "bid_optimization_event").replace("creative_media_url", "creative_media_url").replace("destination_url", "destination_url").replace("call_to__action", "call_to_action").replace("convesion_pixel", "conversion_pixel").replace("special_ad_category", "special_ad_category").replace("facebook_page_id", "facebook_page_id").replace("instagram_page_id", "instagram_page_id").replace("placements", "placement").replace("budget_type", "budget_type");
          console.log(`Procesando campo: ${field} -> ${mappedField} = ${value}`);
          const targetType = type.toLowerCase().trim();
          if (targetType === "campaign") {
            campaignObj[mappedField] = value;
          } else if (targetType === "ad set") {
            if (["start_time", "end_time"].includes(mappedField)) {
              adSetObj[mappedField + "_original"] = value;
            }
            if (["budget", "spend_limit_max", "spend_limit_min"].includes(mappedField)) {
              adSetObj[mappedField] = parseFloat(value.replace(/[^0-9.-]+/g, "")) || 0;
            } else if (["start_time", "end_time"].includes(mappedField)) {
              const [datePart, timePart] = value.split(" ");
              const [day, month, year] = datePart.split("/");
              adSetObj[mappedField] = `20${year}-${month.padStart(2, "0")}-${day.padStart(2, "0")}T${timePart}:00`;
            } else {
              adSetObj[mappedField] = value;
            }
          } else if (targetType === "ads") {
            adObj[mappedField] = value;
          }
        } catch (error2) {
          console.error(`Error procesando campo ${field} en fila ${i + 1}:`, error2);
        }
      });
      const hasRequiredCampaignFields = ["status", "name", "objective", "special_ad_category"].every((field) => {
        const hasField = campaignObj[field] !== void 0 && campaignObj[field] !== "";
        if (!hasField) console.warn(`Campo requerido faltante en Campaign: ${field}`);
        return hasField;
      });
      const hasRequiredAdSetFields = ["status", "name", "budget_type", "budget"].every((field) => {
        const hasField = adSetObj[field] !== void 0 && adSetObj[field] !== "";
        if (!hasField) console.warn(`Campo requerido faltante en AdSet: ${field}`);
        return hasField;
      });
      const hasRequiredAdFields = ["status", "name", "facebook_page_id", "creative_media_url"].every((field) => {
        const hasField = adObj[field] !== void 0 && adObj[field] !== "";
        if (!hasField) console.warn(`Campo requerido faltante en Ad: ${field}`);
        return hasField;
      });
      console.log("Campos de Campaign:", Object.keys(campaignObj), campaignObj);
      console.log("Campos de AdSet:", Object.keys(adSetObj), adSetObj);
      console.log("Campos de Ad:", Object.keys(adObj), adObj);
      console.log("¿Tiene campos requeridos?", {
        campaign: hasRequiredCampaignFields,
        adSet: hasRequiredAdSetFields,
        ad: hasRequiredAdFields
      });
      if (hasRequiredCampaignFields) {
        console.log("Agregando Campaign:", campaignObj);
        campaignData2.push(campaignObj);
      }
      if (hasRequiredAdSetFields) {
        console.log("Agregando AdSet:", adSetObj);
        adSetData.push(adSetObj);
      }
      if (hasRequiredAdFields) {
        console.log("Agregando Ad:", adObj);
        adData.push(adObj);
      }
    }
    console.log("Datos procesados:", { campaignData: campaignData2, adSetData, adData });
    const Campaign = { campaignData: campaignData2, adSetData, adData };
    setCampaignData(Campaign);
    return { campaignData: campaignData2, adSetData, adData };
  };
  const transformMetaCampaign = (campaign, adSet) => ({
    status: typeof campaign.status === "string" && campaign.status.trim().toUpperCase() === "ACTIVE" ? true : false,
    name: campaign.name,
    platform: "META",
    startDate: adSet?.start_time_original || adSet?.start_time || "",
    endDate: adSet?.end_time_original || adSet?.end_time || "",
    budget: adSet?.budget?.toString() || "0",
    spent: "0",
    impressions: "0",
    cpm: "0",
    clicksUrl: "0",
    ctr: "0",
    cpc: "0"
  });
  const transformGoogleCampaign = (row) => ({
    status: typeof row.status === "string" && row.status.trim().toUpperCase() === "ACTIVE" ? true : false,
    name: row.name || row.campaign_name || "",
    platform: "GOOGLE",
    startDate: row["start date"] || "",
    endDate: row["end date"] || "",
    budget: row["budget"]?.toString() || "0",
    spent: "0",
    impressions: "0",
    cpm: "0",
    clicksUrl: "0",
    ctr: "0",
    cpc: "0"
  });
  const handleSendFiles = async () => {
    if (files.length === 0) return;
    setIsLoading(true);
    setError(false);
    try {
      const allTransformedCampaigns = [];
      for (const file of files) {
        await new Promise((resolve) => setTimeout(resolve, 1e3));
        const text = await file.text();
        const { campaignData: campaigns, adSetData: adSets, adData: ads } = processCSVData(text);
        if (campaigns.length === 0 && adSets.length === 0 && ads.length === 0) {
          continue;
        }
        const platform = (campaigns[0] && (campaigns[0]["platform"] || campaigns[0]["Platform"]) || "").trim().toUpperCase();
        if (platform === "META") {
          for (let i = 0; i < campaigns.length; i++) {
            allTransformedCampaigns.push(transformMetaCampaign(campaigns[i], adSets[i]));
          }
        } else if (platform === "GOOGLE") {
          for (const campaign of campaigns) {
            allTransformedCampaigns.push(transformGoogleCampaign(campaign));
          }
        }
      }
      if (allTransformedCampaigns.length === 0) {
        throw new Error("No se encontraron datos válidos en los archivos");
      }
      sessionStorage.setItem("campaignDataResumen", JSON.stringify(allTransformedCampaigns));
      await new Promise((resolve) => setTimeout(resolve, 1e3));
      console.log("Datos transformados:", allTransformedCampaigns);
      navigate("/summaryCampaign", {
        state: { campaignData: allTransformedCampaigns }
      });
    } catch (error2) {
      console.error("Error completo:", error2);
      setError(true);
    } finally {
      setIsLoading(false);
    }
  };
  const handleDownloadTemplate = (platform) => {
    const fileUrl = platform === "meta" ? "https://d1h7f3ppz16fle.cloudfront.net/RecursosMathilde/Mathilde-web/files/meta_campaign_template.csv" : platform === "google" ? "https://d1h7f3ppz16fle.cloudfront.net/RecursosMathilde/Mathilde-web/files/google_campaign_template.csv" : "tiktok_campaign_template.csv";
    const link = document.createElement("a");
    link.href = fileUrl;
    link.download = fileUrl.split("/").pop() || "template.csv";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed inset-0 z-50 min-h-screen w-full flex items-center justify-center bg-white bg-opacity-75", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(QN, { description: "Estamos trabajando en la <br><strong>creación de tus campañas</strong>" }) }) }),
    error ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "min-h-screen w-full flex items-center justify-center bg-white", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center justify-center bg-white text-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl mb-4", children: "Error al procesar el archivo" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FN,
        {
          txtBtn: "Volver a intentar",
          typeButton: "default",
          full: false,
          type: "button",
          onClick: () => {
            setError(false);
            setFiles([]);
          }
        }
      )
    ] }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-screen w-full flex", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SidebarMth, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "min-h-screen w-full container-space", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "w-2/3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "block", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "font-bold", style: { marginBottom: "0px !important" }, children: "CREACIÓN DE CAMPAÑAS" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-normal mb-4", children: "MEDIOS PAGOS" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-bold mb-4", children: "CREAR CAMPAÑAS DE FORMA MASIVA EN LAS DIFERENTES PLATAFORMAS" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(GN, { accept: "text/csv", multiple: true, onChange: handleFileChange }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col mb-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mb-4", children: "DESCARGA LAS PLANTILLAS DEL FEED DE DATOS" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              FN,
              {
                txtBtn: "Plantilla Meta",
                leftIcon: FaMeta,
                typeButton: "border",
                full: false,
                type: "button",
                disabled: false,
                onClick: () => handleDownloadTemplate("meta")
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              FN,
              {
                txtBtn: "Plantilla Google",
                leftIcon: SiGoogleads,
                typeButton: "border",
                full: false,
                type: "button",
                disabled: false,
                onClick: () => handleDownloadTemplate("google")
              }
            )
          ] })
        ] }),
        files.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-3 w-full items-center justify-end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          FN,
          {
            txtBtn: "Regresar",
            typeButton: "border",
            full: false,
            type: "button",
            onClick: () => navigate("/summaryCampaign")
          }
        ) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "my-4 font-bold", children: "ARCHIVOS CARGADOS " }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(KN, { files, onDelete: handleDeleteFile }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-3 w-full items-center justify-end", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              FN,
              {
                txtBtn: "Cancelar",
                typeButton: "border",
                full: false,
                type: "button",
                onClick: () => setFiles([])
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              FN,
              {
                txtBtn: "Siguiente",
                typeButton: "default",
                full: false,
                type: "button",
                onClick: handleSendFiles
              }
            )
          ] })
        ] })
      ] }) })
    ] })
  ] });
};

const ATTRIBUTE_OPTIONS = [
  "Campaign",
  "Ip filter list",
  "Creative"
];
const METRIC_OPTIONS = [
  "Clicks",
  "Conversions",
  "Impressions",
  "CTR %"
];
const Report = () => {
  const [selectedAttributes, setSelectedAttributes] = reactExports.useState([]);
  const [dropdownOpen, setDropdownOpen] = reactExports.useState(false);
  const [selectedCampaigns, setSelectedCampaigns] = reactExports.useState([]);
  const [campaignSearch, setCampaignSearch] = reactExports.useState("");
  const [selectedMetrics, setSelectedMetrics] = reactExports.useState([]);
  const [metricsDropdownOpen, setMetricsDropdownOpen] = reactExports.useState(false);
  const [campaignsFromStorage, setCampaignsFromStorage] = reactExports.useState([]);
  const [selectedDate, setSelectedDate] = reactExports.useState("");
  const [reportData, setReportData] = reactExports.useState(null);
  const [isLoading, setIsLoading] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const stored = sessionStorage.getItem("campaignDataResumen");
    const dataCampaign = sessionStorage.getItem("dataCampaign");
    let combinedData = [];
    if (stored) {
      try {
        const parsed = JSON.parse(stored);
        if (Array.isArray(parsed)) {
          combinedData = [...combinedData, ...parsed];
        }
      } catch (e) {
        console.error("Error parsing stored data:", e);
      }
    }
    if (dataCampaign) {
      try {
        const parsedData = JSON.parse(dataCampaign);
        const dataEnd = parsedData.body.campaigns;
        if (Array.isArray(dataEnd)) {
          const transformedData = dataEnd.map((campaign) => ({
            name: campaign.name || "",
            platform: campaign.platform || "",
            startDate: campaign.start_date || "",
            endDate: campaign.end_date || "",
            budget: campaign.budget || "0"
          }));
          combinedData = [...combinedData, ...transformedData];
        }
      } catch (e) {
        console.error("Error parsing campaign data:", e);
      }
    }
    const uniqueCampaigns = Array.from(new Map(combinedData.map((item) => [item.name, item])).values());
    setCampaignsFromStorage(uniqueCampaigns);
  }, []);
  const handleSelect = (option) => {
    if (!selectedAttributes.includes(option)) {
      setSelectedAttributes([...selectedAttributes, option]);
    }
    setDropdownOpen(false);
  };
  const handleRemove = (option) => {
    setSelectedAttributes(selectedAttributes.filter((attr) => attr !== option));
  };
  const handleSelectMetric = (option) => {
    if (!selectedMetrics.includes(option)) {
      setSelectedMetrics([...selectedMetrics, option]);
    }
    setMetricsDropdownOpen(false);
  };
  const handleRemoveMetric = (option) => {
    setSelectedMetrics(selectedMetrics.filter((metric) => metric !== option));
  };
  const filteredCampaigns = campaignsFromStorage.filter(
    (c) => c.name.toLowerCase().includes(campaignSearch.toLowerCase()) && !selectedCampaigns.includes(c.name)
  );
  const handleSelectCampaign = (name) => {
    if (!selectedCampaigns.includes(name)) {
      setSelectedCampaigns([...selectedCampaigns, name]);
    }
    setCampaignSearch("");
  };
  const handleRemoveCampaign = (name) => {
    setSelectedCampaigns(selectedCampaigns.filter((c) => c !== name));
  };
  const availableOptions = ATTRIBUTE_OPTIONS.filter((opt) => !selectedAttributes.includes(opt) && (opt !== "Campaign" || selectedCampaigns.length === 0));
  const availableMetrics = METRIC_OPTIONS.filter((opt) => !selectedMetrics.includes(opt));
  const handleGenerateReport = async () => {
    setIsLoading(true);
    try {
      const requestData = {
        advertiser: "BANCODEBOGOTA",
        start_date: "01-04-2025",
        end_date: "30-04-2025"
      };
      const response = await getReportData(requestData);
      setReportData(response);
      console.log("Respuesta del servicio:", response);
    } catch (error) {
      Swal.fire({
        title: "Error",
        text: error instanceof Error ? error.message : "Error al obtener el reporte",
        icon: "error",
        confirmButtonText: "Aceptar"
      });
    } finally {
      setIsLoading(false);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-screen w-full flex", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SidebarMth, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "min-h-screen w-full bg-gray-100 container-space", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col h-full", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "font-bold mb-3", children: "REPORTES" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col bg-white p-5 rounded-md mb-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex mb-3 items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "mr-2", children: "Date Range: " }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(eI, {})
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("hr", {}),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex my-3 items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Attributes: " }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "span",
                {
                  className: "py-1 cursor-pointer text-sm text-indigo-500",
                  onClick: () => setDropdownOpen(!dropdownOpen),
                  children: "+ Add Attribute"
                }
              ),
              dropdownOpen && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute left-0 mt-1 w-48 bg-white border rounded shadow z-10", children: availableOptions.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-4 py-2 text-gray-400", children: "Sin opciones" }) : availableOptions.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: "px-4 py-2 hover:bg-blue-100 cursor-pointer",
                  onClick: () => handleSelect(option),
                  children: option
                },
                option
              )) })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-wrap gap-2 ml-4 items-center", children: selectedAttributes.map((attr) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "span",
            {
              className: "bg-blue-100 text-blue-700 pl-3 ml-3 flex items-center text-sm",
              style: {
                borderRadius: "1.30rem"
              },
              children: [
                attr,
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    className: "ml-2 text-blue-700 hover:text-blue-900 font-bold",
                    onClick: () => handleRemove(attr),
                    "aria-label": `Eliminar ${attr}`,
                    type: "button",
                    children: "×"
                  }
                ),
                attr === "Campaign" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative ml-4 w-80", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "div",
                    {
                      className: "flex flex-wrap items-center border rounded px-4 py-1 ml-2 bg-white min-h-[40px]",
                      style: {
                        borderTopRightRadius: "1.25rem",
                        borderBottomRightRadius: "1.25rem"
                      },
                      children: [
                        selectedCampaigns.map((name) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          "span",
                          {
                            className: "bg-purple-100 text-purple-700 px-2 py-1 rounded-full flex items-center text-xs mr-1 mb-1",
                            children: [
                              name,
                              /* @__PURE__ */ jsxRuntimeExports.jsx(
                                "button",
                                {
                                  className: "ml-1 text-purple-700 hover:text-purple-900 font-bold",
                                  onClick: () => handleRemoveCampaign(name),
                                  "aria-label": `Eliminar campaign ${name}`,
                                  type: "button",
                                  children: "×"
                                }
                              )
                            ]
                          },
                          name
                        )),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "input",
                          {
                            type: "text",
                            className: "flex-1 outline-none border-none px-2 py-1 min-w-[100px] text-gray-900 bg-white",
                            placeholder: "Buscar campaign...",
                            value: campaignSearch,
                            onChange: (e) => setCampaignSearch(e.target.value)
                          }
                        )
                      ]
                    }
                  ),
                  campaignSearch && filteredCampaigns.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      className: "absolute left-0 top-full mt-2 w-full bg-white border rounded shadow z-10 max-h-40 overflow-y-auto",
                      children: filteredCampaigns.map((c) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "div",
                        {
                          className: "px-4 py-2 hover:bg-blue-100 cursor-pointer",
                          onClick: () => handleSelectCampaign(c.name),
                          children: c.name
                        },
                        c.name
                      ))
                    }
                  ),
                  campaignSearch && filteredCampaigns.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      className: "absolute left-0 top-full mt-2 w-full bg-white border rounded shadow z-10",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-4 py-2 text-gray-400", children: "No hay coincidencias" })
                    }
                  )
                ] })
              ]
            },
            attr
          )) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("hr", {}),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex my-3 items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Metrics: " }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "span",
                {
                  className: "py-1 cursor-pointer text-sm text-indigo-500",
                  onClick: () => setMetricsDropdownOpen(!metricsDropdownOpen),
                  children: "+ Add Metric"
                }
              ),
              metricsDropdownOpen && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute left-0 mt-1 w-56 bg-white border rounded shadow z-10", children: availableMetrics.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-4 py-2 text-gray-400", children: "Sin opciones" }) : availableMetrics.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: "px-4 py-2 hover:bg-blue-100 cursor-pointer",
                  onClick: () => handleSelectMetric(option),
                  children: option
                },
                option
              )) })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-wrap gap-2 ml-4", children: selectedMetrics.map((metric) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "span",
            {
              className: "bg-green-100 text-green-700 px-3 py-1 rounded-full flex items-center text-sm",
              children: [
                metric,
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    className: "ml-2 text-green-700 hover:text-green-900 font-bold",
                    onClick: () => handleRemoveMetric(metric),
                    "aria-label": `Eliminar ${metric}`,
                    type: "button",
                    children: "×"
                  }
                )
              ]
            },
            metric
          )) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-3 w-full items-center justify-end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          FN,
          {
            txtBtn: isLoading ? "Cargando..." : "Generar Reporte",
            typeButton: "default",
            full: false,
            type: "button",
            onClick: handleGenerateReport,
            disabled: isLoading
          }
        ) })
      ] }),
      reportData && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col bg-white p-5 rounded-md mb-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "font-bold mb-2", children: "Resumen" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-3 gap-4 mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gray-50 p-4 rounded", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold", children: "Impresiones" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-2xl", children: reportData.body.impressions.toLocaleString() })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gray-50 p-4 rounded", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold", children: "Clics" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-2xl", children: reportData.body.clicks.toLocaleString() })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gray-50 p-4 rounded", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold", children: "Conversiones" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-2xl", children: reportData.body.conversions.toLocaleString() })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "font-bold mb-2", children: "Campañas" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "min-w-full border border-gray-300 rounded", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: "bg-gray-200", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "border px-4 py-2", children: "Campaña" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "border px-4 py-2", children: "Plataforma" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "border px-4 py-2", children: "Meta" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "border px-4 py-2", children: "Presupuesto" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "border px-4 py-2", children: "Cumplimiento" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: reportData.body.campaigns.map((campaign) => /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "border px-4 py-2", children: campaign.name }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "border px-4 py-2", children: campaign.platform }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "border px-4 py-2", children: campaign.goal }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "border px-4 py-2", children: campaign.budget.toLocaleString() }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "border px-4 py-2", children: campaign.compliance })
          ] }, campaign.name)) })
        ] })
      ] })
    ] }) })
  ] });
};

const App = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Provider_default, { store, children: /* @__PURE__ */ jsxRuntimeExports.jsx(AuthProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Loading..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/", element: /* @__PURE__ */ jsxRuntimeExports.jsx(LoginForm, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/register", element: /* @__PURE__ */ jsxRuntimeExports.jsx(RegisterForm, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/reset", element: /* @__PURE__ */ jsxRuntimeExports.jsx(ResetPass, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/validation", element: /* @__PURE__ */ jsxRuntimeExports.jsx(ValidationPass, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/dashboard", element: /* @__PURE__ */ jsxRuntimeExports.jsx(RouterLogueado, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Dashboard, {}) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/settings", element: /* @__PURE__ */ jsxRuntimeExports.jsx(RouterLogueado, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsUser, {}) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/thirdPartyCampaign", element: /* @__PURE__ */ jsxRuntimeExports.jsx(RouterLogueado, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ThirdPartyCampaignForm, {}) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/summaryCampaign", element: /* @__PURE__ */ jsxRuntimeExports.jsx(RouterLogueado, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SummaryCampaign, {}) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/massiveCampaign", element: /* @__PURE__ */ jsxRuntimeExports.jsx(RouterLogueado, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MassiveCampaigns, {}) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/report", element: /* @__PURE__ */ jsxRuntimeExports.jsx(RouterLogueado, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Report, {}) }) })
  ] }) }) }) });
};

client.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(React$1.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(BrowserRouter, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) }) })
);
